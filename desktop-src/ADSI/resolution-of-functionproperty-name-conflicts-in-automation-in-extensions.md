---
title: Résolution des conflits de nom de fonction/propriété dans l’automatisation dans les extensions
description: Dans cette rubrique, \ 0034 ; objet \ 0034 ; indique l’objet, dans son ensemble, comme un client ADSI l’affiche. C’est-à-dire, ADSI et toutes ses extensions.
ms.assetid: 76207326-879e-408b-8004-06d940401a41
ms.tgt_platform: multiple
keywords:
- Résolution des conflits de noms de fonctions et de propriétés dans l’automatisation dans les extensions
- extensions ADSI, résolution des conflits de noms de fonctions et de propriétés dans Automation
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d9a7ac99b99ecdf0ee1b940f066d9e8166a15542
ms.sourcegitcommit: b0ebdefc3dcd5c04bede94091833aa1015a2f95c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382848"
---
# <a name="resolution-of-functionproperty-name-conflicts-in-automation-in-extensions"></a><span data-ttu-id="8f183-106">Résolution des conflits de nom de fonction/propriété dans l’automatisation dans les extensions</span><span class="sxs-lookup"><span data-stu-id="8f183-106">Resolution of Function/Property Name Conflicts in Automation in Extensions</span></span>

<span data-ttu-id="8f183-107">Dans cette rubrique, « Object » indique l’objet, dans son ensemble, comme un client ADSI l’affiche.</span><span class="sxs-lookup"><span data-stu-id="8f183-107">In this topic, "object" indicates the object, as a whole, as an ADSI client views it.</span></span> <span data-ttu-id="8f183-108">C’est-à-dire, ADSI et toutes ses extensions.</span><span class="sxs-lookup"><span data-stu-id="8f183-108">That is, ADSI and all its extensions.</span></span>

## <a name="same-function-name-with-the-same-parameters"></a><span data-ttu-id="8f183-109">Même nom de fonction avec les mêmes paramètres</span><span class="sxs-lookup"><span data-stu-id="8f183-109">Same Function Name With the Same Parameters</span></span>

<span data-ttu-id="8f183-110">Si deux ou plusieurs interfaces [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) doubles dans un objet prennent en charge une propriété ou une méthode du même nom, par exemple, **func1**, l’appel est déterminé à l’aide des critères suivants.</span><span class="sxs-lookup"><span data-stu-id="8f183-110">If two or more dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in an object support a property or method of the same name, for example, **Func1**, invocation is determined using the following criteria.</span></span> <span data-ttu-id="8f183-111">Si le client a un pointeur vers l’une des interfaces doubles qui prennent en charge une méthode appelée **func1** et si l’environnement d’automatisation prend en charge l’accès vtable, **func1** est appelé directement par le biais de l’accès vtable ADSI.</span><span class="sxs-lookup"><span data-stu-id="8f183-111">If the client has a pointer to one of the dual interfaces that support a method called **Func1** and if the Automation environment supports vtable access, **Func1** is invoked directly through ADSI vtable access.</span></span>

<span data-ttu-id="8f183-112">Si l’une des conditions ci-dessus a la valeur false, [**IDispatch :: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) et [**IDispatch :: Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) sont appelés pour appeler **func1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-112">If either of the conditions above is false, [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) and [**IDispatch::Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke) are called to invoke **Func1**.</span></span>

<span data-ttu-id="8f183-113">Pour plus d’informations et pour obtenir une brève explication sur la façon dont un client peut ajouter un pointeur à une interface double, ainsi qu’une description des types d’environnements qui prennent en charge l’accès vtable, consultez [liaison tardive et accès à vtable dans le modèle d’extension ADSI](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).</span><span class="sxs-lookup"><span data-stu-id="8f183-113">For more information and a brief explanation about how a client can add a pointer to a dual interface, and a description of the types of environments that support vtable access, see [Late Binding versus Vtable Access in the ADSI Extension Model](late-binding-vs--vtable-access-in-the-adsi-extension-model.md).</span></span>

<span data-ttu-id="8f183-114">Étant donné que tous les objets d’extension redirigent les fonctions [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) vers l’agrégateur, l’agrégateur contrôle l’appel de **func1** .</span><span class="sxs-lookup"><span data-stu-id="8f183-114">Because all extension objects redirect the [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) functions back to the aggregator, the aggregator controls which **Func1** is invoked.</span></span> <span data-ttu-id="8f183-115">Les règles sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="8f183-115">The rules are:</span></span>

-   <span data-ttu-id="8f183-116">S’il n’existe aucune interface, et qu’il n’y aura qu’un seul, le cas échéant, dans l’agrégateur (ADSI) prend en charge une fonction appelée **func1**, l’agrégateur appelle son propre **func1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-116">If any interface, and there will be only one, if any, in the aggregator (ADSI) supports a function called **Func1**, the aggregator invokes its own **Func1**.</span></span>
-   <span data-ttu-id="8f183-117">Dans le cas contraire, l’agrégateur parcourt chacune de ses extensions, dans l’ordre indiqué dans le registre, et recherche la première extension qui implémente une fonction appelée **func1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-117">Otherwise, the aggregator goes through each of its extensions, in the order listed in the registry, and finds the first extension that implements a function called **Func1**.</span></span> <span data-ttu-id="8f183-118">Il est possible, mais improbable, que plusieurs interfaces [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) doubles dans cette première extension aient une fonction appelée **func1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-118">It is possible, but unlikely, that multiple dual [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interfaces in this first extension have a function called **Func1**.</span></span> <span data-ttu-id="8f183-119">L’extension doit déterminer quel **func1** doit toujours être appelé dans Automation.</span><span class="sxs-lookup"><span data-stu-id="8f183-119">The extension must determine which **Func1** should always be invoked in Automation.</span></span>

## <a name="same-function-name-with-different-parameters"></a><span data-ttu-id="8f183-120">Même nom de fonction avec des paramètres différents</span><span class="sxs-lookup"><span data-stu-id="8f183-120">Same Function Name With Different Parameters</span></span>

<span data-ttu-id="8f183-121">La section précédente a expliqué comment résoudre les conflits de nom de fonction, autrement dit, les noms de fonctions qui ont le même nom de fonction et la même liste de paramètres, tels que le nombre, le type et l’ordre, lorsqu’elle se produit dans Automation.</span><span class="sxs-lookup"><span data-stu-id="8f183-121">The previous section discussed how to resolve function name conflicts, that is, function names that have the same function name and same parameter list, such as number, type and order, when it occurs in Automation.</span></span> <span data-ttu-id="8f183-122">Que se passe-t-il si deux fonctions ont le même nom mais des paramètres différents ?</span><span class="sxs-lookup"><span data-stu-id="8f183-122">What if two functions have the same name but different parameters?</span></span> <span data-ttu-id="8f183-123">Si un client ADSI appelle la fonction à l’aide de [**IDispatch :: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) sans utiliser plusieurs noms pour spécifier les paramètres, le modèle d’extension ADSI ne peut pas lever l’ambiguïté des fonctions.</span><span class="sxs-lookup"><span data-stu-id="8f183-123">If an ADSI client invokes the function using [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) without using multiple names to specify the parameters, the ADSI extension model cannot disambiguate the functions.</span></span> <span data-ttu-id="8f183-124">En fonction du schéma de résolution abordé dans ci-dessus, la première extension du Registre qui prend en charge cette fonction par le biais de l’une de ses interfaces a sa version de cette fonction appelée, et l’appel peut échouer ou produire des résultats incorrects.</span><span class="sxs-lookup"><span data-stu-id="8f183-124">Based on the resolution scheme discussed in above, the first extension in the registry that supports this function through one of its interfaces has its version of this function invoked, and the call may fail or yield incorrect results.</span></span>

<span data-ttu-id="8f183-125">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="8f183-125">For example:</span></span>

-   <span data-ttu-id="8f183-126">Extn1 (premier dans le registre, sous la classe CA – priorité plus élevée) prend en charge **IInterface1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-126">Extn1 (first in the registry under class CA – higher priority) supports **IInterface1**.</span></span>
-   <span data-ttu-id="8f183-127">Extn2 (troisième dans le registre, sous la classe CA – priorité inférieure) prend en charge **IInterface2**.</span><span class="sxs-lookup"><span data-stu-id="8f183-127">Extn2 (third in the registry under class CA – lower priority) supports **IInterface2**.</span></span>
-   <span data-ttu-id="8f183-128">**IInterface1** prend en charge **Method1 (int param1, int param2)**.</span><span class="sxs-lookup"><span data-stu-id="8f183-128">**IInterface1** supports **Method1(int param1, int param2)**.</span></span>
-   <span data-ttu-id="8f183-129">**IInterface2** prend en charge **Method1 (int param1)**.</span><span class="sxs-lookup"><span data-stu-id="8f183-129">**IInterface2** supports **Method1(int param1)**.</span></span>

<span data-ttu-id="8f183-130">Un client ADSI possède un pointeur d’interface [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) vers un objet de classe ca.</span><span class="sxs-lookup"><span data-stu-id="8f183-130">An ADSI client has an [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch) interface pointer to an object of class CA.</span></span> <span data-ttu-id="8f183-131">Il souhaite appeler **IInterface2 :: méthode1**.</span><span class="sxs-lookup"><span data-stu-id="8f183-131">It wants to invoke **IInterface2::Method1**.</span></span> <span data-ttu-id="8f183-132">Si le client appelle « pDispatch->GetIDsOfNames (IID \_ null, rgszNames, 1, mon \_ LCID, rgDispId) » en stockant simplement le nom de fonction « méthode1 » dans *RgszNames \[ 0 \]*, **IInterface1 :: méthode1** au lieu de l' **IInterface2 souhaité :: méthode1** est appelé, et la fonction échoue car le nombre de paramètres est différent.</span><span class="sxs-lookup"><span data-stu-id="8f183-132">If the client calls "pDispatch->GetIDsOfNames(IID\_NULL, rgszNames, 1, MY\_LCID, rgDispId)" by just storing the function name "Method1" in *rgszNames\[0\]*, then **IInterface1::Method1** instead of the desired **IInterface2::Method1** is invoked, and the function fails because the number of parameters are different.</span></span>

<span data-ttu-id="8f183-133">Pour réduire ce problème, les développeurs d’extensions peuvent préfixer leurs noms de fonction avec leurs propres identificateurs spécifiques et éviter les conceptions d’interface qui utilisent des fonctions du même nom, mais des paramètres différents.</span><span class="sxs-lookup"><span data-stu-id="8f183-133">To minimize this problem, extension developers can prefix their function names with their own specific identifiers and avoid interface designs that use functions of the same name, but different parameters.</span></span>

<span data-ttu-id="8f183-134">En cas de conflit de noms, les clients ADSI peuvent éviter le problème par l’accès direct à la vtable si l’interface est une interface double.</span><span class="sxs-lookup"><span data-stu-id="8f183-134">If a name conflict does occur, ADSI clients can avoid the problem by direct vtable access if the interface is a dual interface.</span></span> <span data-ttu-id="8f183-135">Si l’accès direct à vtable n’est pas possible, les clients ADSI doivent appeler [**IDispatch :: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) avec plusieurs noms, en spécifiant les noms de fonction ainsi que les paramètres du tableau *rgszNames* décrits précédemment.</span><span class="sxs-lookup"><span data-stu-id="8f183-135">If direct vtable access is not possible, ADSI clients should call [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) with multiple names, specifying the function names as well as the parameters in the array *rgszNames* described previously.</span></span>

<span data-ttu-id="8f183-136">Visual Basic 5 n’appelle pas la fonction [**IDispatch :: GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) avec plusieurs noms.</span><span class="sxs-lookup"><span data-stu-id="8f183-136">Visual Basic 5 does not call the [**IDispatch::GetIDsOfNames**](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames) function with multiple names.</span></span> <span data-ttu-id="8f183-137">Autrement dit, il passe uniquement le nom de la fonction à **GetIDsOfNames**, mais pas aux arguments.</span><span class="sxs-lookup"><span data-stu-id="8f183-137">That is, it passes only the function name to **GetIDsOfNames**, but not arguments.</span></span> <span data-ttu-id="8f183-138">Toutefois, Visual Basic 5 permet aux utilisateurs d’appeler une fonction par l’accès direct à la vtable, au lieu d’appeler la fonction **IDispatch :: GetIDsOfNames** si l’interface est une interface double.</span><span class="sxs-lookup"><span data-stu-id="8f183-138">However, Visual Basic 5 allows users to invoke a function by direct vtable access, instead of invoking the **IDispatch::GetIDsOfNames** function if the interface is a dual interface.</span></span> <span data-ttu-id="8f183-139">Les développeurs doivent utiliser l’accès direct à la vtable, si possible.</span><span class="sxs-lookup"><span data-stu-id="8f183-139">Developers should use direct vtable access, if possible.</span></span>

<span data-ttu-id="8f183-140">Pour plus d’informations sur la résolution des conflits de noms, consultez l' [exemple relatif à la résolution des conflits de noms de fonctions](example-for-resolving-function-name-conflicts.md).</span><span class="sxs-lookup"><span data-stu-id="8f183-140">For more information about name conflict resolution, see [Example for Resolving Function Name Conflicts](example-for-resolving-function-name-conflicts.md).</span></span>

 

 