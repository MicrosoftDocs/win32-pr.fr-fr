---
description: Cet article fournit des détails supplémentaires sur les métadonnées de protection du workflow de contrôle dans les images PE.
title: Métadonnées PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106526988"
---
# <a name="pe-metadata"></a><span data-ttu-id="5391b-103">Métadonnées PE</span><span class="sxs-lookup"><span data-stu-id="5391b-103">PE metadata</span></span>

<span data-ttu-id="5391b-104">Cet article fournit des détails supplémentaires sur les métadonnées de protection du workflow (CFG) dans les images PE.</span><span class="sxs-lookup"><span data-stu-id="5391b-104">This article provides additional details for Control Flow Guard (CFG) metadata in PE images.</span></span> <span data-ttu-id="5391b-105">Il est supposé que vous êtes familiarisé avec la structure des métadonnées CFG dans les images PE.</span><span class="sxs-lookup"><span data-stu-id="5391b-105">Familiarity with the structure for CFG metadata in PE images is assumed.</span></span> <span data-ttu-id="5391b-106">Consultez la rubrique [format PE](../debug/pe-format.md) pour obtenir une documentation de haut niveau pour les métadonnées cfg dans les images PE.</span><span class="sxs-lookup"><span data-stu-id="5391b-106">See the [PE Format](../debug/pe-format.md) topic for high-level documentation for CFG metadata in PE images.</span></span>

- <span data-ttu-id="5391b-107">Les fonctions qui sont des cibles d’appel indirectes valides sont répertoriées dans le **GuardCFFunctionTable** attaché au répertoire de configuration de charge, parfois appelé table **GFIDS** à des fins de concision.</span><span class="sxs-lookup"><span data-stu-id="5391b-107">Functions that are valid indirect call targets are listed in the **GuardCFFunctionTable** attached to the load configuration directory, sometimes termed the **GFIDS** table for brevity.</span></span> <span data-ttu-id="5391b-108">Il s’agit d’une liste triée d’adresses virtuelles relatives (RVA) qui contiennent des informations sur les cibles d’appel CFG valides.</span><span class="sxs-lookup"><span data-stu-id="5391b-108">This is a sorted list of relative virtual addresses (RVA) that contain information about valid CFG call targets.</span></span> <span data-ttu-id="5391b-109">Il s’agit, en général, de symboles de fonction pris en considération.</span><span class="sxs-lookup"><span data-stu-id="5391b-109">These are, generally speaking, address taken function symbols.</span></span> <span data-ttu-id="5391b-110">Une image qui veut que la mise en œuvre de CFG doive énumérer tous les symboles de fonction adresse prise dans sa table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-110">An image that wants CFG enforcement must enumerate all address taken function symbols in its **GFIDS** table.</span></span> <span data-ttu-id="5391b-111">La liste des RVA dans la table **GFIDS** doit être triée correctement ou l’image ne sera pas chargée.</span><span class="sxs-lookup"><span data-stu-id="5391b-111">The RVA list in the **GFIDS** table must be sorted properly or the image will not be loaded.</span></span> <span data-ttu-id="5391b-112">La table **GFIDS** est un tableau de 4 + *n* octets, où *n* est donné par ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span><span class="sxs-lookup"><span data-stu-id="5391b-112">The **GFIDS** table is an array of 4 + *n* bytes, where *n* is given by ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT).</span></span> <span data-ttu-id="5391b-113">« GuardFlags » est le champ GuardFlags du répertoire de configuration de chargement.</span><span class="sxs-lookup"><span data-stu-id="5391b-113">“GuardFlags” is the GuardFlags field of the load configuration directory.</span></span> <span data-ttu-id="5391b-114">Cela permet d’associer des métadonnées supplémentaires à des cibles d’appel CFG à l’avenir.</span><span class="sxs-lookup"><span data-stu-id="5391b-114">This allows for extra metadata to be attached to CFG call targets in the future.</span></span> <span data-ttu-id="5391b-115">Les seules métadonnées actuellement définies sont un champ d’indicateurs supplémentaires de 1 octet facultatif (« indicateurs GFIDS ») qui est attaché à chaque entrée **GFIDS** si les cibles d’appel ont des métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5391b-115">The only currently defined metadata is an optional 1-byte extra flags field (“GFIDS flags”) that is attached to each **GFIDS** entry if any call targets have metadata.</span></span> <span data-ttu-id="5391b-116">Deux indicateurs **GFIDS** sont définis :</span><span class="sxs-lookup"><span data-stu-id="5391b-116">There are two **GFIDS** flags defined:</span></span>
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | <span data-ttu-id="5391b-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span><span class="sxs-lookup"><span data-stu-id="5391b-117">IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1</span></span> | <span data-ttu-id="5391b-118">La cible de l’appel est explicitement supprimée (ne la considérez pas comme valide à des fins de CFG)</span><span class="sxs-lookup"><span data-stu-id="5391b-118">Call target is explicitly suppressed (do not treat it as valid for purposes of CFG)</span></span> |
  | <span data-ttu-id="5391b-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0X2</span><span class="sxs-lookup"><span data-stu-id="5391b-119">IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2</span></span> | <span data-ttu-id="5391b-120">L’exportation de la cible de l’appel est supprimée.</span><span class="sxs-lookup"><span data-stu-id="5391b-120">Call target is export suppressed.</span></span> <span data-ttu-id="5391b-121">Pour plus d’informations, consultez Suppression de l' [exportation](#export-suppression)</span><span class="sxs-lookup"><span data-stu-id="5391b-121">See [Export suppression](#export-suppression) for more details</span></span> |
  
  <span data-ttu-id="5391b-122">Pour une compatibilité future, les outils ne doivent pas définir des indicateurs **GFIDS** qui n’ont pas encore été définis et ne doivent pas inclure d’octets de métadonnées supplémentaires **GFIDS** supplémentaires au-delà de la valeur 1 octet actuellement définie, car les significations pour d’autres indicateurs ou des métadonnées supplémentaires ne sont pas encore affectées.</span><span class="sxs-lookup"><span data-stu-id="5391b-122">For future compatibility, tools should not set **GFIDS** flags that have not yet been defined and should not include additional **GFIDS** extra metadata bytes beyond the 1-byte currently defined since the meanings for other flags or additional metadata are not yet assigned.</span></span> <span data-ttu-id="5391b-123">Vous trouverez des exemples d’images qui incluent des octets de métadonnées supplémentaires en vidant la table **GFIDS** de fichiers binaires, comme Ntdll.dll sur une version moderne du système d’exploitation Windows 10.</span><span class="sxs-lookup"><span data-stu-id="5391b-123">You can find examples of images that include extra metadata bytes by dumping the **GFIDS** table of binaries such as Ntdll.dll on a modern Windows 10 OS version.</span></span>

  <span data-ttu-id="5391b-124">Les outils doivent déclarer uniquement des symboles de fonction en tant que cibles d’appel valides, ce qui peut justifier une considération supplémentaire pour le code assembleur dans lequel les étiquettes peuvent être prises en compte.</span><span class="sxs-lookup"><span data-stu-id="5391b-124">Tools should only declare function symbols as valid call targets which may merit additional consideration for assembler code where labels might be address taken.</span></span> <span data-ttu-id="5391b-125">Pour des raisons historiques, le code assembleur peut s’appuyer sur des étiquettes de code autres que PROC ou. n’étant pas converties en cibles d’appel CFG par l’éditeur de liens.</span><span class="sxs-lookup"><span data-stu-id="5391b-125">For historical reasons, assembler code may rely on code labels other than PROC or .altentry as not being converted into CFG call targets by the linker.</span></span>

  <span data-ttu-id="5391b-126">En outre, pour des raisons historiques, le code peut délibérément déclarer du code en tant que données afin d’éviter l’inclusion dans la table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-126">Also for historical reasons, code may deliberately declare code as data to avoid inclusion in the **GFIDS** table.</span></span> <span data-ttu-id="5391b-127">Par exemple, un fichier objet peut implémenter un symbole comme code alors qu’un autre peut le déclarer comme données afin de prendre l’adresse du symbole sans générer un enregistrement cible CFG valide.</span><span class="sxs-lookup"><span data-stu-id="5391b-127">For example, one object file may implement a symbol as code while another may declare it as data in order to take the address of the symbol without generating a valid CFG target record.</span></span> <span data-ttu-id="5391b-128">Pour des raisons de compatibilité, il est recommandé que les ensembles d’outils prennent en charge cette pratique.</span><span class="sxs-lookup"><span data-stu-id="5391b-128">For compatibility, it is recommended that toolsets support this practice.</span></span>

- <span data-ttu-id="5391b-129">Les images qui prennent en charge CFG et qui souhaitent ou effectuent des vérifications de CFG doivent définir les IMAGE_GUARD_CF_INSTRUMENTED et IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bits GuardFlags, et doivent définir le bit IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics dans les en-têtes d’image.</span><span class="sxs-lookup"><span data-stu-id="5391b-129">Images that support CFG and that want or perform CFG checks should set the IMAGE_GUARD_CF_INSTRUMENTED and IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT GuardFlags bits, and should set the IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics bit in the image headers.</span></span>

- <span data-ttu-id="5391b-130">Le répertoire de configuration de charge publie deux pointeurs de fonction : GuardCFCheckFunctionPointer et GuardCFDispatchFunctionPointer (ce dernier est pris en charge uniquement pour certaines architectures telles que AMD64).</span><span class="sxs-lookup"><span data-stu-id="5391b-130">The load configuration directory advertises two function pointers: GuardCFCheckFunctionPointer and GuardCFDispatchFunctionPointer (the latter is only supported for certain architectures such as AMD64).</span></span> <span data-ttu-id="5391b-131">Ces pointeurs de fonction doivent pointer vers la mémoire en lecture seule pour que la sécurité CFG soit effective. le chargeur de DLL du système d’exploitation reprotégera la mémoire de façon transitoire pendant le chargement de l’image pour stocker les pointeurs de fonction.</span><span class="sxs-lookup"><span data-stu-id="5391b-131">These function pointers should point to read only memory for CFG security to be effective; the operating system’s DLL loader will reprotect the memory transiently during image loading to store the function pointers.</span></span> <span data-ttu-id="5391b-132">Il est généralement possible de les fusionner dans la section qui contient la table d’adresses d’importation (IAT).</span><span class="sxs-lookup"><span data-stu-id="5391b-132">Typical usage might be to merge these into the same section that contains the Import Address Table (IAT).</span></span> <span data-ttu-id="5391b-133">Le GuardCFCheckFunctionPointer fournit l’adresse d’un symbole de chargeur fourni par le système d’exploitation qui peut être appelé à l’aide d’un pointeur de fonction dans le premier registre des arguments entiers (ECX sur x86), qui retourne en cas de réussite ou abandonne le processus si la cible de l’appel n’est pas une cible CFG valide.</span><span class="sxs-lookup"><span data-stu-id="5391b-133">The GuardCFCheckFunctionPointer provides the address of an OS-loader provided symbol that can be called with a function pointer in the first integer argument register (ECX on x86) which will return on success or will abort the process if the call target is not a valid CFG target.</span></span> <span data-ttu-id="5391b-134">GuardCFDispatchFunctionPointer fournit l’adresse d’un symbole de chargeur fourni par le système d’exploitation qui prend une cible d’appel dans Register RAX et effectue un appel combiné de vérification CFG et de la branche tail à la cible de l’appel (les registres R10/R11 sont réservés pour une utilisation par le GuardCFDispatchFunctionPointer et les registres des arguments d’entier sont réservés pour une utilisation par la cible d’appel finale).</span><span class="sxs-lookup"><span data-stu-id="5391b-134">The GuardCFDispatchFunctionPointer provides the address of an OS-loader provided symbol that takes a call target in register RAX and performs a combined CFG check and tail branch optimized call to the call target (registers R10/R11 are reserved for use by the GuardCFDispatchFunctionPointer and integer argument registers are reserved for use by the ultimate call target).</span></span> <span data-ttu-id="5391b-135">L’adresse par défaut des symboles CFG dans une image doit pointer vers une fonction qui retourne simplement (GuardCFCheckFunctionPointer) ou qui retourne un symbole supprimé par Guard (ou qui est de préférence entièrement omis du symbole de la table **GFIDS** ) qui exécute une instruction « jmp Rax ».</span><span class="sxs-lookup"><span data-stu-id="5391b-135">The default address of the CFG symbols in an image should point to a function that just returns (GuardCFCheckFunctionPointer) or that returns a guard-suppressed symbol (or is preferably entirely omitted from the **GFIDS** table symbol) that executes a “jmp rax” instruction.</span></span> <span data-ttu-id="5391b-136">Pour les GuardCFDispatchFunctionPointer AMD64, quand une image est chargée sur un système d’exploitation prenant en charge CFG et que CFG est activé, le chargeur de DLL du système d’exploitation installe les pointeurs de fonction appropriés, ce qui permet une compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="5391b-136">For AMD64 GuardCFDispatchFunctionPointer, when an image is loaded on a CFG-aware operating system, and CFG is enabled, the OS DLL loader will install appropriate function pointers, which facilities backwards compatibility.</span></span> <span data-ttu-id="5391b-137">Une image peut fournir 0 pour le GuardCFDispatchFunctionPointer dans la configuration de chargement s’il n’a pas l’intention d’utiliser la fonction de répartition CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-137">An image can supply 0 for the GuardCFDispatchFunctionPointer in the load config if it does not intend to use the CFG dispatch facility.</span></span> <span data-ttu-id="5391b-138">Cela doit être fait pour les architectures non-AMD64 en vue d’une compatibilité future, au cas où ces architectures finiront par prendre en charge le mécanisme de distribution CFG sous une forme quelconque.</span><span class="sxs-lookup"><span data-stu-id="5391b-138">This should be done for non-AMD64 architectures for future compatibility, in case these architectures eventually support the CFG dispatch mechanism in some form.</span></span> <span data-ttu-id="5391b-139">Notez que Windows 8.1 AMD64 n’a pas pris en charge la distribution CFG et laissait le pointeur de fonction par défaut en place pour GuardCFDispatchFunctionPointer.</span><span class="sxs-lookup"><span data-stu-id="5391b-139">Note that Windows 8.1 AMD64 did not support CFG dispatch and would leave the default function pointer in place for GuardCFDispatchFunctionPointer.</span></span> <span data-ttu-id="5391b-140">La distribution CFG est uniquement prise en charge sur les systèmes d’exploitation Windows 10 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="5391b-140">CFG dispatch is only supported on Windows 10 and later operating systems.</span></span>

- <span data-ttu-id="5391b-141">Le système CFG en mode utilisateur ne peut être appliqué que pour les images marquées comme compatibles avec la randomisation du format d’espace d’adresse (ASLR) (spécifiée par l’option/DYNAMICBASE avec l’éditeur de liens Microsoft).</span><span class="sxs-lookup"><span data-stu-id="5391b-141">User mode CFG might only be enforced for images that are marked as address space layout randomization (ASLR) compatible (specified by the /DYNAMICBASE option with the Microsoft linker).</span></span> <span data-ttu-id="5391b-142">Cela est dû au fait que le système d’exploitation gère en interne CFG, où il est essentiellement connecté à l’infrastructure ASLR.</span><span class="sxs-lookup"><span data-stu-id="5391b-142">This is due to how the OS internally handles CFG where it is essentially wired in to the ASLR infrastructure.</span></span> <span data-ttu-id="5391b-143">En général, les utilisateurs de CFG doivent activer ASLR pour leurs images dans un premier temps.</span><span class="sxs-lookup"><span data-stu-id="5391b-143">In general, users of CFG should enable ASLR for their images as a first step.</span></span> <span data-ttu-id="5391b-144">Les outils ne doivent pas supposer que le système d’exploitation ignore toujours CFG sans ASLR défini, mais il doit généralement les définir tous les deux en même temps.</span><span class="sxs-lookup"><span data-stu-id="5391b-144">Tools should not assume that the OS will always ignore CFG without ASLR set but should generally set both at the same time.</span></span>

## <a name="compiler-directives"></a><span data-ttu-id="5391b-145">Directives de compilateur</span><span class="sxs-lookup"><span data-stu-id="5391b-145">Compiler directives</span></span>

- <span data-ttu-id="5391b-146">Les cibles d’appel peuvent être marquées comme explicitement supprimées avec le modificateur __declspec (Guard (Suppress)), ou avec la directive de l’éditeur de liens/guardsym : SymName, S (pour le code ASM, par exemple).</span><span class="sxs-lookup"><span data-stu-id="5391b-146">Call targets can be marked as explicitly suppressed with the __declspec(guard(suppress)) modifier, or with the /guardsym:symname,S linker directive (for asm code for example).</span></span> <span data-ttu-id="5391b-147">La cible d’appel est alors incluse dans la table **GFIDS** , mais marquée de sorte que le système d’exploitation traite la cible d’appel comme non valide.</span><span class="sxs-lookup"><span data-stu-id="5391b-147">This causes the call target to be included in the **GFIDS** table but marked in such a way that the OS will treat the call target as not valid.</span></span> <span data-ttu-id="5391b-148">Certains scénarios de non-production, tels que avec certaines instruments Application Verifier activés sur certains systèmes d’exploitation plus anciens, peuvent permettre de traiter les cibles d’appel supprimées comme valides, mais en général, ces scénarios ne sont pas censés être des scénarios de production.</span><span class="sxs-lookup"><span data-stu-id="5391b-148">Some non-production scenarios, such as with certain application verifier instrumentation enabled on some older operating systems, may enable suppressed call targets to be treated as valid, but in general these scenarios are not expected to be production scenarios.</span></span> <span data-ttu-id="5391b-149">Cette directive est utile pour annoter des fonctions « dangereuses » qui ne doivent pas être considérées comme cibles d’appel valides, même si la règle CFG normale les inclut.</span><span class="sxs-lookup"><span data-stu-id="5391b-149">This directive is useful for annotating “dangerous” functions that should not be considered as valid call targets, even though the normal CFG rule would include them.</span></span>

- <span data-ttu-id="5391b-150">Le code peut indiquer que les vérifications de CFG ne sont pas souhaitées avec le modificateur __declspec (Guard (nocf)).</span><span class="sxs-lookup"><span data-stu-id="5391b-150">Code can indicate CFG checks are not wanted with the __declspec(guard(nocf)) modifier.</span></span> <span data-ttu-id="5391b-151">Cela indique au compilateur de ne pas insérer de contrôles CFG pour la fonction entière.</span><span class="sxs-lookup"><span data-stu-id="5391b-151">This directs the compiler to not insert any CFG checks for the entire function.</span></span> <span data-ttu-id="5391b-152">Le compilateur doit s’occuper de propager cette directive dans tout code fourni par une fonction inline marquée comme ne souhaitant pas vérifier les contrôles CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-152">The compiler should take care to propagate this directive to any code contributed by an inlined function that is marked as not wanting CFG checks.</span></span> <span data-ttu-id="5391b-153">Cette approche est généralement utilisée uniquement avec modération dans des situations spécifiques où le programmeur a inséré manuellement une protection « équivalente CFG ».</span><span class="sxs-lookup"><span data-stu-id="5391b-153">This approach is typically used only sparingly in specific situations where the programmer has manually inserted “CFG-equivalent” protection.</span></span> <span data-ttu-id="5391b-154">Le programmeur sait qu’ils appellent via une table de fonctions en lecture seule dont l’adresse est obtenue via des références de mémoire en lecture seule et pour lesquelles l’index est masqué dans la limite de la table de fonctions.</span><span class="sxs-lookup"><span data-stu-id="5391b-154">The programmer knows that they are calling through some read only function table whose address is obtained through read only memory references and for which the index is masked to the function table limit.</span></span> <span data-ttu-id="5391b-155">Cette approche peut également être appliquée aux petites fonctions wrapper qui ne sont pas inline et qui n’effectuent rien de plus qu’un appel via un pointeur de fonction.</span><span class="sxs-lookup"><span data-stu-id="5391b-155">This approach may also be applied to small wrapper functions that are not inlined and that do nothing more than make a call through a function pointer.</span></span> <span data-ttu-id="5391b-156">Étant donné que l’utilisation incorrecte de cette directive peut compromettre la sécurité de CFG, le programmeur doit être très prudent en utilisant la directive.</span><span class="sxs-lookup"><span data-stu-id="5391b-156">Since incorrect usage of this directive can compromise the security of CFG, the programmer must be very careful using the directive.</span></span> <span data-ttu-id="5391b-157">En règle générale, cette utilisation est limitée aux très petites fonctions qui n’appellent qu’une seule fonction.</span><span class="sxs-lookup"><span data-stu-id="5391b-157">Typically, this usage is limited to very small functions that only call one function.</span></span>

## <a name="import-handling"></a><span data-ttu-id="5391b-158">Gestion des importations</span><span class="sxs-lookup"><span data-stu-id="5391b-158">Import handling</span></span>

- <span data-ttu-id="5391b-159">Les appels effectués via l’IAT ne doivent pas utiliser la protection CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-159">Calls through the IAT should not use CFG protection.</span></span> <span data-ttu-id="5391b-160">L’IAT est en lecture seule dans les images modernes (en supposant que la IAT est déclarée dans les en-têtes PE, auquel cas elle doit se trouver sur ses propres pages).</span><span class="sxs-lookup"><span data-stu-id="5391b-160">The IAT is read only in modern images (assuming that the IAT is declared in the PE headers in which case it must be on its own pages).</span></span> <span data-ttu-id="5391b-161">L’IAT peut être utilisé pour atteindre les fonctions qui sont supprimées, donc il s’agit d’une exigence d’exactitude.</span><span class="sxs-lookup"><span data-stu-id="5391b-161">The IAT can be used to reach functions that are guard suppressed, so this is a correctness requirement.</span></span> <span data-ttu-id="5391b-162">La protection en lecture seule de la mémoire via l’IAT remplace celle de CFG, car la liaison cible de l’appel est immuable une fois que les instantanés d’importation d’image sont résolus et que la résolution de liaison est fine.</span><span class="sxs-lookup"><span data-stu-id="5391b-162">Read only memory protection through the IAT supersedes that of CFG since the call target binding is immutable after the image import snaps are resolved, and the binding resolution is fine grained.</span></span>

- <span data-ttu-id="5391b-163">Chargement différé protégé : les appels via l’IAT de chargement différé ne doivent pas utiliser la protection CFG, pour les mêmes raisons que l’IAT standard.</span><span class="sxs-lookup"><span data-stu-id="5391b-163">Protected delay load: Calls through the delay load IAT should not use CFG protection, for the same reasons as the standard IAT.</span></span> <span data-ttu-id="5391b-164">L’IAT de chargement différé doit se trouver dans sa propre section et l’image doit définir le IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span><span class="sxs-lookup"><span data-stu-id="5391b-164">The delay load IAT should be in its own section and the image should set the IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit.</span></span> <span data-ttu-id="5391b-165">Cela indique que le chargeur de DLL du système d’exploitation doit modifier les protections du IAT de chargement différé lors de la résolution d’exportation si vous utilisez la prise en charge du chargement différé du système d’exploitation native sur les systèmes d’exploitation Windows 8 et versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="5391b-165">This indicates that the operating system’s DLL loader should change protections for the delay load IAT during export resolution if using the operating system’s delay load support native to Windows 8 and later operating systems.</span></span> <span data-ttu-id="5391b-166">La synchronisation de cette étape est gérée par le chargeur de DLL du système d’exploitation si la prise en charge du chargement différé du système d’exploitation est en cours d’utilisation (par exemple, ResolveDelayLoadedAPI), de sorte qu’aucun autre composant ne doit reprotéger les pages couvrant l’IAT du chargement différé déclaré.</span><span class="sxs-lookup"><span data-stu-id="5391b-166">The synchronization of this step is managed by the operating system DLL loader if native operating system delay load support is in use (e.g. ResolveDelayLoadedAPI) so no other component should reprotect the pages spanning the declared delay load IAT.</span></span> <span data-ttu-id="5391b-167">Pour la compatibilité descendante avec les anciens systèmes d’exploitation antérieurs à CFG, les outils peuvent permettre de déplacer l’IAT de chargement différé dans sa propre section (« . didat » par définition canonique), protégée en lecture/écriture dans les en-têtes d’image, et définir également l’indicateur IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION.</span><span class="sxs-lookup"><span data-stu-id="5391b-167">For backwards compatibility with older pre-CFG operating systems, tools may enable the option to move the delay load IAT into its own section (canonically “.didat”), protected as read/write in the image headers, and additionally set the IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION flag.</span></span> <span data-ttu-id="5391b-168">Ce paramètre fait en sorte que les chargeurs de DLL du système d’exploitation prenant en charge CFG reprotègent la section entière contenant la table IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT pour lire uniquement la mémoire pendant le chargement de l’image.</span><span class="sxs-lookup"><span data-stu-id="5391b-168">This setting will cause CFG-aware operating system DLL loaders to reprotect the entire section containing the IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT table to read only memory during image loading.</span></span> <span data-ttu-id="5391b-169">L’option permettant de placer l’IAT de chargement différé dans sa propre section peut ne pas être nécessaire si vous n’avez pas à exécuter une image sur les systèmes d’exploitation qui prennent en charge la préversion de CFG, mais les outils doivent prendre cette décision en fonction de la prise en charge minimale du système d’exploitation qu’une image a besoin.</span><span class="sxs-lookup"><span data-stu-id="5391b-169">The option to place the delay load IAT in its own section may not be required if you do not care about running an image on operating systems that predate CFG support, but tools should make that decision based on the minimum operating system support that an image needs.</span></span>

  <span data-ttu-id="5391b-170">Si une image n’utilise pas la prise en charge du chargement différé natif du système d’exploitation, elle peut toujours définir les bits GuardFlags associés au chargement différé.</span><span class="sxs-lookup"><span data-stu-id="5391b-170">If an image does not use the operating system’s native delay load support, it can still set the protected delay load related GuardFlags bits.</span></span> <span data-ttu-id="5391b-171">Dans cette configuration, le chargeur du système d’exploitation fournira simplement la prise en charge pour protéger l’IAT de chargement différé en lecture seule au moment de l’exécution, s’il est pris en charge par la plateforme, et il devient la responsabilité des stubs de résolution de chargement différé interne de l’image pour synchroniser et gérer la protection du IAT de chargement différé.</span><span class="sxs-lookup"><span data-stu-id="5391b-171">In this configuration, the operating system loader will just provide support to protect the delay load IAT as read only at runtime if supported by the platform, and it becomes the responsibility of the image’s internal delay load resolution stubs to synchronize and manage protection of the delay load IAT.</span></span> <span data-ttu-id="5391b-172">Étant donné que la table de configuration de charge est stockée en mémoire en lecture seule (ce qui est recommandé), la présence ou l’absence du bit de chargement de retard protégé dans le champ GuardFlags de l’image peut être utile comme indication interne des stubs de résolution de chargement différée de l’image pour indiquer si elle doit ou non protéger l’IAT de chargement différé.</span><span class="sxs-lookup"><span data-stu-id="5391b-172">Provided that the load configuration table is stored in read only memory (which is recommended), the presence or absence of the protected delay load IAT bit in the image’s GuardFlags field might be useful as an internal hint to the image’s internal delay load resolution stubs to indicate whether or not it should protect the delay load IAT.</span></span>

  <span data-ttu-id="5391b-173">Il est recommandé d’activer le chargement différé protégé par défaut si CFG est activé.</span><span class="sxs-lookup"><span data-stu-id="5391b-173">It is recommended that protected delay load be enabled by default if CFG is enabled.</span></span> <span data-ttu-id="5391b-174">Les images qui s’exécutent sur des versions de système d’exploitation plus anciennes et qui utilisent la prise en charge du chargement différé natif du système d’exploitation peuvent utiliser l’IAT de chargement différé dans sa propre section prise en charge de la compatibilité descendante.</span><span class="sxs-lookup"><span data-stu-id="5391b-174">Images that run on older operating system versions and that use the operating system’s native delay load support, as noted, may use the delay load IAT in its own section support for backwards compatibility.</span></span> <span data-ttu-id="5391b-175">Par opposition, il est recommandé de marquer le IAT de chargement différé comme en lecture seule et de le fusionner avec une autre section, ce qui s’interrompt sur les systèmes d’exploitation plus anciens qui ne comprennent pas les charges de retard protégées et qui assurent la prise en charge de la résolution de chargement en retard native.</span><span class="sxs-lookup"><span data-stu-id="5391b-175">This is opposed to marking the delay load IAT as read only and merging it with another section, which would break on older operating system’s that do not understand protected delay loads and which provide native delay load resolution support.</span></span> <span data-ttu-id="5391b-176">Toutes les versions de Windows 10 et la première Windows 8.1/Windows Server 2012 R2 génère ce CFG pris en charge (ce qui signifie que la mise à jour du 2014 du 1er novembre) introduit la prise en charge de la charge de délai protégée dans le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="5391b-176">All Windows 10 releases and the first Windows 8.1/Windows Server 2012 R2 builds that supported CFG (meaning the November 2014 update) introduce support for protected delay load in the operating system.</span></span>

## <a name="function-alignment"></a><span data-ttu-id="5391b-177">Alignement des fonctions</span><span class="sxs-lookup"><span data-stu-id="5391b-177">Function alignment</span></span>

- <span data-ttu-id="5391b-178">Les fonctions qui sont prises en considération et qui sont donc incluses dans la table **GFIDS** doivent être alignées sur 16 octets, si possible.</span><span class="sxs-lookup"><span data-stu-id="5391b-178">Functions that are address taken and are therefore included in the **GFIDS** table should be made 16-byte aligned, if possible.</span></span> <span data-ttu-id="5391b-179">Cela n’est peut-être pas toujours possible.</span><span class="sxs-lookup"><span data-stu-id="5391b-179">This may not always be possible.</span></span> <span data-ttu-id="5391b-180">Par exemple, pour les fonctions non-COMDAT qui font partie des fichiers objets assemblés ensemble comme une unité par les outils non compatibles avec CFG, que certains assembleurs peuvent produire, l’utilisateur de l’outil qui a produit les fichiers doit définir correctement l’alignement.</span><span class="sxs-lookup"><span data-stu-id="5391b-180">For example, for non-COMDAT functions that are a part of object files assembled together as one unit by non-CFG aware tools, which some assemblers may produce, the user of the tool that produced the files must appropriately set the alignment.</span></span> <span data-ttu-id="5391b-181">Les outils peuvent choisir d’émettre un avertissement de diagnostic dans cette situation pour permettre à l’utilisateur de prendre des mesures correctives appropriées.</span><span class="sxs-lookup"><span data-stu-id="5391b-181">Tools may elect to issue a diagnostic warning in this situation so that the user can take appropriate corrective action.</span></span> <span data-ttu-id="5391b-182">Cela est dû au fait que les marques de CFG appellent des cibles valides ou non valides sur des limites de 16 octets pour l’efficacité des contrôles CFG rapides.</span><span class="sxs-lookup"><span data-stu-id="5391b-182">The reason for this is that CFG marks call targets as valid or not valid on 16-byte boundaries for efficiency of fast CFG checks.</span></span> <span data-ttu-id="5391b-183">Si une fonction n’est pas alignée sur 16 octets, la totalité de l’emplacement de 16 octets doit être marqué comme étant valide, ce qui n’est pas aussi sécurisé car vous pouvez appeler mal aligné dans du code qui ne se trouve pas au début d’une fonction.</span><span class="sxs-lookup"><span data-stu-id="5391b-183">If a function is not 16-byte aligned, then the entire 16-byte slot must be marked as valid, which is not as secure since you can call misaligned into code that is not at the very start of a function.</span></span> <span data-ttu-id="5391b-184">Ce scénario est pris en charge pour faciliter l’interopérabilité lors de la première mise en place de CFG pour un projet.</span><span class="sxs-lookup"><span data-stu-id="5391b-184">This scenario is supported for ease of interoperability when first bringing CFG up for a project.</span></span> <span data-ttu-id="5391b-185">Les images compatibles avec le non-CFG sont marquées comme valides pour tout alignement de cible d’appel pour la compatibilité.</span><span class="sxs-lookup"><span data-stu-id="5391b-185">Non-CFG aware images are similarly marked as valid for any call target alignment for compatibility.</span></span> <span data-ttu-id="5391b-186">Comme précédemment, les cibles d’appel mal alignées réduisent les avantages en matière de sécurité de CFG. les outils doivent donc s’aligner automatiquement sur une limite de 16 octets pour tous les éléments de la table **GFIDS** quand cfg est souhaité pour une image.</span><span class="sxs-lookup"><span data-stu-id="5391b-186">As before, having misaligned call targets reduces the security benefits of CFG, so tools should automatically align to a 16-byte boundary for anything in the **GFIDS** table when CFG is desired for an image.</span></span> <span data-ttu-id="5391b-187">Les symboles qui ne figurent pas dans la table **GFIDS** n’ont pas besoin d’avoir des alignements particuliers pour cfg.</span><span class="sxs-lookup"><span data-stu-id="5391b-187">Symbols that are not in the **GFIDS** table do not need to have particular alignments for CFG.</span></span>

## <a name="export-suppression"></a><span data-ttu-id="5391b-188">Suppression de l’exportation</span><span class="sxs-lookup"><span data-stu-id="5391b-188">Export suppression</span></span>

- <span data-ttu-id="5391b-189">La suppression de l’exportation CFG (CFG ES) est un mode facultatif qui permet à un processus d’indiquer que les cibles d’appel qui étaient uniquement valides parce qu’il s’agissait de symboles dllexport et qui n’ont pas encore été résolus de manière dynamique par GetProcAddress, sont considérées comme non valides pour les besoins de CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-189">CFG export suppression (CFG ES) is an optional mode that enables a process to indicate that call targets which were only valid because they were dllexport symbols, and which have not yet been dynamically resolved by GetProcAddress, will be considered as not valid for purposes of CFG.</span></span> <span data-ttu-id="5391b-190">Cela réduit la surface d’exposition de CFG des exportations de DLL système.</span><span class="sxs-lookup"><span data-stu-id="5391b-190">This reduces the surface area of CFG from system DLL exports.</span></span> <span data-ttu-id="5391b-191">La suppression de l’exportation implique la communication des cibles d’appel « Export supprimées » admissibles en les marquant avec les indicateurs IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-191">Export suppression involves communicating eligible “export suppressed” dllexport call targets by marking them with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flags.</span></span> <span data-ttu-id="5391b-192">Les symboles dllexport et le point d’entrée de l’image PE doivent être implicitement considérés comme une adresse prise par des outils pour la génération de la table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-192">Dllexport symbols and the PE image entry point should be implicitly considered address taken by tools for purposes of generating the **GFIDS** table.</span></span>  <span data-ttu-id="5391b-193">Si un symbole d’exportation est aligné sur 16 octets et que l’adresse est prise pour aucune autre raison qu’un dllexport, il peut être marqué avec l’indicateur Export **GFIDS** supprimé dans la table de fonctions.</span><span class="sxs-lookup"><span data-stu-id="5391b-193">If an export symbol is 16-byte aligned and it is address taken for no other reason than being a dllexport, then it can be marked with the export suppressed **GFIDS** flag in the function table.</span></span> <span data-ttu-id="5391b-194">Les cibles d’appel qui ne sont pas alignées sur 16 octets ne **doivent pas** être marquées avec l’indicateur IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** et ne peuvent pas être restreintes uniquement comme cibles d’appel valides à l’heure GetProcAddress.</span><span class="sxs-lookup"><span data-stu-id="5391b-194">Call targets that are not 16-byte aligned **must not** be marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag and cannot be restricted to only being dynamically enabled as valid call targets at GetProcAddress time.</span></span>

  <span data-ttu-id="5391b-195">Une image qui prend en charge CFG ES comprend un GuardAddressTakenIatEntryTable dont le nombre est fourni par le GuardAddressTakenIatEntryCount dans le cadre de son répertoire de configuration de chargement.</span><span class="sxs-lookup"><span data-stu-id="5391b-195">An image that supports CFG ES includes a GuardAddressTakenIatEntryTable whose count is provided by the GuardAddressTakenIatEntryCount as part of its load configuration directory.</span></span> <span data-ttu-id="5391b-196">Le format de cette table est structuré de la même façon que la table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-196">This table is structurally formatted the same as the **GFIDS** table.</span></span> <span data-ttu-id="5391b-197">Elle utilise le même mécanisme de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags pour encoder les octets de métadonnées facultatifs supplémentaires dans la table Address prise IAT, bien que tous les octets de métadonnées doivent être nuls pour la table Address prise IAT et sont réservés.</span><span class="sxs-lookup"><span data-stu-id="5391b-197">It uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode extra optional metadata bytes in the address taken IAT table, though all metadata bytes must be zero for the address taken IAT table and are reserved.</span></span> <span data-ttu-id="5391b-198">La table Address comprise IAT indique un tableau trié de RVA de thunks d’importation qui ont la cible d’appel importée en tant qu’adresse de symbole.</span><span class="sxs-lookup"><span data-stu-id="5391b-198">The address taken IAT table indicates a sorted array of RVAs of import thunks which have the imported as a symbol address taken call target.</span></span> <span data-ttu-id="5391b-199">Cette construction prend en charge les symboles adresse prise qui existent dans un module distant, et qui sont dllexports, avec CFG ES en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="5391b-199">This construct supports address taken symbols that exist in a remote module, and which are dllexports, with CFG ES in use.</span></span> <span data-ttu-id="5391b-200">Voici un exemple de construction de code :</span><span class="sxs-lookup"><span data-stu-id="5391b-200">An example of such a code construct would be:</span></span>

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  <span data-ttu-id="5391b-201">Tous les thunks d’importation de ce type d’adresse doivent être énumérés afin que le chargeur du système d’exploitation puisse les trouver et que les cibles d’appel appropriées soient valides lors du chargement d’une image et de l’alignement de ses importations.</span><span class="sxs-lookup"><span data-stu-id="5391b-201">All such address taken import thunks must be enumerated so that the operating system loader can find them and make the appropriate call targets valid when loading an image and snapping its imports.</span></span> <span data-ttu-id="5391b-202">La table et le nombre peuvent être 0 s’il n’y a pas de thunks d’importation qui étaient pris en compte.</span><span class="sxs-lookup"><span data-stu-id="5391b-202">The table and count can be 0 if there are no import thunks that were address taken.</span></span>

  <span data-ttu-id="5391b-203">Un module définit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT le bit de GuardFlags pour indiquer qu’il a énuméré tous les thunks d’adresse pris dans sa table d’adresses IAT et que toutes les exportations qui correspondent à CFG ES sont marquées avec l’indicateur IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-203">A module sets the IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT GuardFlags bit to indicate that it has enumerated all address taken thunks in its address taken IAT table and that all exports that are CFG ES eligible are marked with the IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** flag.</span></span> <span data-ttu-id="5391b-204">Notez qu’il peut y avoir zéro de tels thunks et qu’il peut y avoir également zéro de tels symboles dllexport.</span><span class="sxs-lookup"><span data-stu-id="5391b-204">Note that there may be zero such thunks and that there may also be zero such dllexport symbols.</span></span> <span data-ttu-id="5391b-205">L’échec de la maintenance de la table IAT Address prise peut être un problème d’exactitude, car certaines cibles d’appel peuvent ne pas être rendues valides lorsque celles-ci doivent être au moment du chargement de la DLL.</span><span class="sxs-lookup"><span data-stu-id="5391b-205">Failure to maintain the address taken IAT table can be a correctness issue as some call targets might not be made valid when they should be at DLL load time.</span></span>

  <span data-ttu-id="5391b-206">Un module définit le bit de IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags pour indiquer qu’il veut activer CFG ES pour le processus.</span><span class="sxs-lookup"><span data-stu-id="5391b-206">A module sets the IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags bit to indicate that it wants to enable CFG ES for the process.</span></span> <span data-ttu-id="5391b-207">Dans la pratique, cette méthode est uniquement significative pour les fichiers exe.</span><span class="sxs-lookup"><span data-stu-id="5391b-207">In practice, this is only meaningful for EXEs today.</span></span> <span data-ttu-id="5391b-208">Un processus qui active CFG ES ne doit pas charger les dll qui ne sont pas générées avec CFG ES ou les échecs d’exécution peuvent se produire en raison d’adresses non désignées par les symboles IAT.</span><span class="sxs-lookup"><span data-stu-id="5391b-208">A process enabling CFG ES should not load DLLs not built with CFG ES or runtime failures may occur because of undesignated address taken IAT symbols.</span></span> <span data-ttu-id="5391b-209">La prise en charge de l’activation de CFG ES doit être une option d’abonnement distincte de l’activation de CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-209">Support for enabling CFG ES should be a separate opt-in option from enabling CFG.</span></span> <span data-ttu-id="5391b-210">Le fait de fournir des métadonnées CFG ES sécurisées et recommandé par défaut avec CFG, bien que les ensembles d’outils doivent veiller à ce qu’ils produisent des métadonnées correctes.</span><span class="sxs-lookup"><span data-stu-id="5391b-210">Providing CFG ES metadata is safe and recommended by default with CFG, though toolsets must take care to ensure they produce correct metadata.</span></span> <span data-ttu-id="5391b-211">Si ce n’est pas le cas, leurs images générées risquent de ne pas s’exécuter correctement dans un processus CFG ES.</span><span class="sxs-lookup"><span data-stu-id="5391b-211">If not, their generated images may not run properly in a CFG ES process.</span></span> <span data-ttu-id="5391b-212">Une telle prise en charge doit être testée minutieusement dans un processus de test qui applique CFG ES.</span><span class="sxs-lookup"><span data-stu-id="5391b-212">Such support should be thoroughly tested in a test process that enforces CFG ES.</span></span> <span data-ttu-id="5391b-213">Les DLL système intégrées du système d’exploitation prennent en charge les métadonnées CFG ES pour les versions modernes du système d’exploitation Windows 10 qui comprennent CFG ES.</span><span class="sxs-lookup"><span data-stu-id="5391b-213">The operating system built-in system DLLs support CFG ES metadata for modern Windows 10 operating system versions that understand CFG ES.</span></span> <span data-ttu-id="5391b-214">Les versions de système d’exploitation antérieures à cette prise en charge ne comprennent pas les CFG ES et ignorent toutes les directives CFG ES associées dans l’image.</span><span class="sxs-lookup"><span data-stu-id="5391b-214">Operating system versions prior to this support do not understand CFG ES at all and will ignore any CFG ES related directives in the image.</span></span> <span data-ttu-id="5391b-215">Ces images sont toujours compatibles avec les versions antérieures du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="5391b-215">Such images are still backwards compatible to older operating system versions.</span></span>

  <span data-ttu-id="5391b-216">La prise en charge de CFG ES est facultative du point de vue de l’ensemble d’outils, mais il est recommandé que les ensembles d’outils incluent au moins la prise en charge pour énumérer suffisamment d’informations pour que les images s’exécutent dans un processus qui souhaite CFG ES.</span><span class="sxs-lookup"><span data-stu-id="5391b-216">CFG ES support is optional from a toolset perspective, but it is recommended that toolsets at least include support to enumerate enough information for images to run in a process that desires CFG ES.</span></span> <span data-ttu-id="5391b-217">Comme nous l’avons vu précédemment, il est essentiel que la prise en charge des jeux d’outils soit minutieusement testée pour s’assurer qu’elle est compatible avec CFG ES, car la plupart des processus n’activent pas encore CFG ES.</span><span class="sxs-lookup"><span data-stu-id="5391b-217">As mentioned, it is critical that toolset support be thoroughly tested to ensure that it is compatible with CFG ES, as most processes don’t yet enable CFG ES.</span></span>

## <a name="exception-handling-and-unwinding"></a><span data-ttu-id="5391b-218">Traitement des exceptions et déroulement</span><span class="sxs-lookup"><span data-stu-id="5391b-218">Exception handling and unwinding</span></span>

- <span data-ttu-id="5391b-219">Les gestionnaires spécifiques au langage comme __C_specific_handler, comme indiqué par les informations du gestionnaire d’exceptions dans une inscription. pdata, ne doivent pas être marqués comme cibles d’appel valides dans la table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-219">Language specific handlers like __C_specific_handler, as designated by the exception handler information in a .pdata registration, should not be marked as valid call targets in the **GFIDS** table.</span></span> <span data-ttu-id="5391b-220">Ils sont recherchés en parcourant la mémoire en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5391b-220">They are instead looked up by traversing read only memory.</span></span> <span data-ttu-id="5391b-221">De même, le gestionnaire spécifique au langage C de Microsoft utilise des recherches en lecture seule de la mémoire pour localiser funclets pour les gestionnaires d’exceptions et ne déclare donc pas ses funclets en tant que cibles d’appel valides dans la table **GFIDS** .</span><span class="sxs-lookup"><span data-stu-id="5391b-221">Similarly, the Microsoft C language specific handler uses read only memory searches to locate funclets for exception handlers and thus does not declare its funclets as valid call targets in the **GFIDS** table.</span></span>

- <span data-ttu-id="5391b-222">Gestion des sauts longs (pour les cibles non-x86 comme AMD64) : les ensembles d’outils qui compilent avec CFG et prennent en charge setjmp ()/longjmp () doivent implémenter un saut long en tant que « saut long sécurisé » qui interagit avec la gestion structurée des exceptions (SEH).</span><span class="sxs-lookup"><span data-stu-id="5391b-222">Long jump handling (for non-x86 targets like AMD64):  Toolsets compiling with CFG and supporting setjmp()/longjmp() should implement long jump as “safe long jump” that interoperates with structured exception handling (SEH).</span></span> <span data-ttu-id="5391b-223">Cela signifie que le saut long est implémenté en tant qu’appel à RtlUnwindEx avec STATUS_LONGJUMP comme code d’État dans l’enregistrement d’exception fourni et un _JUMP_BUFFER standard pointé par ExceptionInformation [0].</span><span class="sxs-lookup"><span data-stu-id="5391b-223">This means long jump is implemented as a call to RtlUnwindEx with STATUS_LONGJUMP as the status code in the supplied exception record and a standard _JUMP_BUFFER pointed to by ExceptionInformation[0].</span></span> <span data-ttu-id="5391b-224">La cible de déroulement de saut doit être le TargetIp du déroulement.</span><span class="sxs-lookup"><span data-stu-id="5391b-224">The jump unwind target should be the TargetIp of the unwind.</span></span> <span data-ttu-id="5391b-225">La mémoire tampon de saut représente le contexte de Registre qui est restauré par le système d’exploitation après la fin du long saut.</span><span class="sxs-lookup"><span data-stu-id="5391b-225">The jump buffer represents the register context that is restored by the operating system after the long jump has completed.</span></span> <span data-ttu-id="5391b-226">RtlUnwind (ex) en cas d’appel avec STATUS_LONGJUMP a une signification spéciale propre à CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-226">RtlUnwind(Ex) when called with STATUS_LONGJUMP has special significance unique to CFG.</span></span> <span data-ttu-id="5391b-227">Cible de saut long (_JUMP_BUFFER. RIP ou _JUMP_BUFFER. LR sur ARM64) est recherché dans la liste des modules chargés gérée par le système d’exploitation en mémoire en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5391b-227">The long jump target (_JUMP_BUFFER.Rip or _JUMP_BUFFER.Lr on ARM64) is looked up in the loaded module list maintained by the operating system in read only memory.</span></span> <span data-ttu-id="5391b-228">Si le module conteneur pour la cible de saut (le « module cible ») a l’indicateur IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT défini dans son champ GuardFlags, le répertoire de configuration de chargement a un GuardLongJumpTargetTable avec un nombre d’éléments spécifié par le champ GuardLongJumpTargetCount de la configuration de charge.</span><span class="sxs-lookup"><span data-stu-id="5391b-228">If the containing module for the jump target (the “target module”) has the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag set in its GuardFlags field, then the load configuration directory has a GuardLongJumpTargetTable whith an element count specified by the load configuration GuardLongJumpTargetCount field.</span></span> <span data-ttu-id="5391b-229">Cette table est structurée de la même façon que la table **GFIDS** et utilise le même mécanisme de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags pour encoder les octets de métadonnées supplémentaires facultatifs dans la table de raccourcis longs.</span><span class="sxs-lookup"><span data-stu-id="5391b-229">This table is structurally formatted the same as the **GFIDS** table and uses the same GuardFlags IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK mechanism to encode optional extra metadata bytes in the long jump table.</span></span> <span data-ttu-id="5391b-230">Tous les octets de métadonnées doivent être nuls pour la table de sauts longue et sont réservés.</span><span class="sxs-lookup"><span data-stu-id="5391b-230">All metadata bytes must be zero for the long jump table and are reserved.</span></span>

  <span data-ttu-id="5391b-231">La table de saut long représente un tableau trié de RVA qui sont des cibles de saut longues valides.</span><span class="sxs-lookup"><span data-stu-id="5391b-231">The long jump table represents a sorted array of RVAs that are valid long jump targets.</span></span> <span data-ttu-id="5391b-232">Si un module cible de saut long définit IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT dans son champ GuardFlags, toutes les cibles de saut longues doivent être énumérées dans le LongJumpTargetTable.</span><span class="sxs-lookup"><span data-stu-id="5391b-232">If a long jump target module sets IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT in its GuardFlags field, then all long jump targets must be enumerated in the LongJumpTargetTable.</span></span> <span data-ttu-id="5391b-233">Même si un module n’a pas de cibles de saut longues, il doit toujours définir l’indicateur IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT si l’ensemble d’outils prend en charge le renforcement de saut long pour CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-233">Even if a module has zero long jump targets, it should still set the IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT flag if the toolset supports long jump hardening for CFG.</span></span> <span data-ttu-id="5391b-234">Cela signifie explicitement que l’image n’a pas de cibles de saut longues et qu’il ne s’agit pas d’une ancienne image que le système d’exploitation doit supposer peut avoir des cibles de saut longues valides à des emplacements non marqués pour lesquels il ne peut pas effectuer de vérification de cible de saut long.</span><span class="sxs-lookup"><span data-stu-id="5391b-234">This explicitly means that the image has no long jump targets and is not an old image that the operating system must assume could have valid long jump targets at unmarked locations for which it cannot perform long jump target checking.</span></span>

  <span data-ttu-id="5391b-235">Le renforcement des sauts longs est recommandé pour l’activation par défaut si CFG est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="5391b-235">Long jump hardening is recommended to be enabled by default if CFG is supported.</span></span> <span data-ttu-id="5391b-236">Il s’agit de la disposition des compilateurs Microsoft.</span><span class="sxs-lookup"><span data-stu-id="5391b-236">This is the disposition of Microsoft compilers.</span></span> <span data-ttu-id="5391b-237">Les systèmes d’exploitation qui ne comprennent pas le renforcement de la sécurité des sauts longs (versions antérieures à Windows 10 ou Windows 10 antérieures) n’effectuent pas de contrôles de renforcement de la sécurité de sauts longs et ignorent les longues métadonnées de sécurisation renforcée des sauts. par conséquent, le renforcement de la sécurité des sauts est à compatibilité descendante avec les anciennes versions</span><span class="sxs-lookup"><span data-stu-id="5391b-237">Operating systems that do not understand long jump hardening (pre-Windows 10 or older Windows 10 versions) will not perform long jump hardening checks and ignore any long jump hardening metadata, so long jump hardening is backwards compatible with older operating system releases.</span></span>

  <span data-ttu-id="5391b-238">Pour les images en mode noyau, la table cible de saut long de protection ne doit pas être incluse dans une section qui peut être ignorée.</span><span class="sxs-lookup"><span data-stu-id="5391b-238">For kernel mode images, the guard long jump target table should not be included in a discardable section.</span></span> <span data-ttu-id="5391b-239">La table cible de saut long de protection doit toujours être stockée en mémoire en lecture seule pour que ses propriétés de sécurité soient effectives.</span><span class="sxs-lookup"><span data-stu-id="5391b-239">The guard long jump target table should always be stored in read only memory for its security properties to be effective.</span></span>

## <a name="coff-information"></a><span data-ttu-id="5391b-240">Informations COFF</span><span class="sxs-lookup"><span data-stu-id="5391b-240">COFF information</span></span>

- <span data-ttu-id="5391b-241">Il existe des marquages de fichiers objet pour déclarer si un fichier objet est conforme à CFG ou non.</span><span class="sxs-lookup"><span data-stu-id="5391b-241">There are object file markings to declare whether an object file conforms to CFG or not.</span></span> <span data-ttu-id="5391b-242">Un fichier objet qui est conforme à CFG répertorie les cibles d’appel valides qu’il produit, de manière explicite, ainsi que toute adresse prise par les métadonnées IAT.</span><span class="sxs-lookup"><span data-stu-id="5391b-242">An object file that conforms to CFG will list the valid call targets that it produces, explicitly, as well as any address taken IAT metadata.</span></span> <span data-ttu-id="5391b-243">Un fichier objet qui n’est pas conforme à CFG doit avoir des cibles d’appel déduites en examinant les réadressages COFF du fichier OBJ pour rechercher les réadressages qui pointent vers le début d’un symbole de fonction.</span><span class="sxs-lookup"><span data-stu-id="5391b-243">An object file that does not conform to CFG must have call targets inferred by examining the COFF relocations of the obj file to find relocations that point to the start of a function symbol.</span></span> <span data-ttu-id="5391b-244">Cela peut s’avérer très approximatif pour les cibles d’appel CFG valides. il est donc souhaitable que les outils marquent leurs fichiers obj qui prennent en charge CFG et incluent les métadonnées du fichier obj. CFG en cas de compilation avec CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-244">This may overapproximate valid CFG call targets so it is desirable that tools mark their obj files that are CFG-aware and include the CFG obj file metadata if compiling with CFG.</span></span>

- <span data-ttu-id="5391b-245">Il existe des marquages de fichiers objet pour déclarer des cibles de saut longues pour le long saut long CFG renforcé qui doit être rempli pour le mode de compilation CFG.</span><span class="sxs-lookup"><span data-stu-id="5391b-245">There are object file markings to declare long jump targets for CFG hardened long jump which should be populated for CFG compilation mode.</span></span>
