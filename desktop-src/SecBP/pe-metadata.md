---
description: Cet article fournit des détails supplémentaires sur les métadonnées de protection du workflow de contrôle dans les images PE.
title: Métadonnées PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106526988"
---
# <a name="pe-metadata"></a>Métadonnées PE

Cet article fournit des détails supplémentaires sur les métadonnées de protection du workflow (CFG) dans les images PE. Il est supposé que vous êtes familiarisé avec la structure des métadonnées CFG dans les images PE. Consultez la rubrique [format PE](../debug/pe-format.md) pour obtenir une documentation de haut niveau pour les métadonnées cfg dans les images PE.

- Les fonctions qui sont des cibles d’appel indirectes valides sont répertoriées dans le **GuardCFFunctionTable** attaché au répertoire de configuration de charge, parfois appelé table **GFIDS** à des fins de concision. Il s’agit d’une liste triée d’adresses virtuelles relatives (RVA) qui contiennent des informations sur les cibles d’appel CFG valides. Il s’agit, en général, de symboles de fonction pris en considération. Une image qui veut que la mise en œuvre de CFG doive énumérer tous les symboles de fonction adresse prise dans sa table **GFIDS** . La liste des RVA dans la table **GFIDS** doit être triée correctement ou l’image ne sera pas chargée. La table **GFIDS** est un tableau de 4 + *n* octets, où *n* est donné par ((GuardFlags & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). « GuardFlags » est le champ GuardFlags du répertoire de configuration de chargement. Cela permet d’associer des métadonnées supplémentaires à des cibles d’appel CFG à l’avenir. Les seules métadonnées actuellement définies sont un champ d’indicateurs supplémentaires de 1 octet facultatif (« indicateurs GFIDS ») qui est attaché à chaque entrée **GFIDS** si les cibles d’appel ont des métadonnées. Deux indicateurs **GFIDS** sont définis :
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | La cible de l’appel est explicitement supprimée (ne la considérez pas comme valide à des fins de CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0X2 | L’exportation de la cible de l’appel est supprimée. Pour plus d’informations, consultez Suppression de l' [exportation](#export-suppression) |
  
  Pour une compatibilité future, les outils ne doivent pas définir des indicateurs **GFIDS** qui n’ont pas encore été définis et ne doivent pas inclure d’octets de métadonnées supplémentaires **GFIDS** supplémentaires au-delà de la valeur 1 octet actuellement définie, car les significations pour d’autres indicateurs ou des métadonnées supplémentaires ne sont pas encore affectées. Vous trouverez des exemples d’images qui incluent des octets de métadonnées supplémentaires en vidant la table **GFIDS** de fichiers binaires, comme Ntdll.dll sur une version moderne du système d’exploitation Windows 10.

  Les outils doivent déclarer uniquement des symboles de fonction en tant que cibles d’appel valides, ce qui peut justifier une considération supplémentaire pour le code assembleur dans lequel les étiquettes peuvent être prises en compte. Pour des raisons historiques, le code assembleur peut s’appuyer sur des étiquettes de code autres que PROC ou. n’étant pas converties en cibles d’appel CFG par l’éditeur de liens.

  En outre, pour des raisons historiques, le code peut délibérément déclarer du code en tant que données afin d’éviter l’inclusion dans la table **GFIDS** . Par exemple, un fichier objet peut implémenter un symbole comme code alors qu’un autre peut le déclarer comme données afin de prendre l’adresse du symbole sans générer un enregistrement cible CFG valide. Pour des raisons de compatibilité, il est recommandé que les ensembles d’outils prennent en charge cette pratique.

- Les images qui prennent en charge CFG et qui souhaitent ou effectuent des vérifications de CFG doivent définir les IMAGE_GUARD_CF_INSTRUMENTED et IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT bits GuardFlags, et doivent définir le bit IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics dans les en-têtes d’image.

- Le répertoire de configuration de charge publie deux pointeurs de fonction : GuardCFCheckFunctionPointer et GuardCFDispatchFunctionPointer (ce dernier est pris en charge uniquement pour certaines architectures telles que AMD64). Ces pointeurs de fonction doivent pointer vers la mémoire en lecture seule pour que la sécurité CFG soit effective. le chargeur de DLL du système d’exploitation reprotégera la mémoire de façon transitoire pendant le chargement de l’image pour stocker les pointeurs de fonction. Il est généralement possible de les fusionner dans la section qui contient la table d’adresses d’importation (IAT). Le GuardCFCheckFunctionPointer fournit l’adresse d’un symbole de chargeur fourni par le système d’exploitation qui peut être appelé à l’aide d’un pointeur de fonction dans le premier registre des arguments entiers (ECX sur x86), qui retourne en cas de réussite ou abandonne le processus si la cible de l’appel n’est pas une cible CFG valide. GuardCFDispatchFunctionPointer fournit l’adresse d’un symbole de chargeur fourni par le système d’exploitation qui prend une cible d’appel dans Register RAX et effectue un appel combiné de vérification CFG et de la branche tail à la cible de l’appel (les registres R10/R11 sont réservés pour une utilisation par le GuardCFDispatchFunctionPointer et les registres des arguments d’entier sont réservés pour une utilisation par la cible d’appel finale). L’adresse par défaut des symboles CFG dans une image doit pointer vers une fonction qui retourne simplement (GuardCFCheckFunctionPointer) ou qui retourne un symbole supprimé par Guard (ou qui est de préférence entièrement omis du symbole de la table **GFIDS** ) qui exécute une instruction « jmp Rax ». Pour les GuardCFDispatchFunctionPointer AMD64, quand une image est chargée sur un système d’exploitation prenant en charge CFG et que CFG est activé, le chargeur de DLL du système d’exploitation installe les pointeurs de fonction appropriés, ce qui permet une compatibilité descendante. Une image peut fournir 0 pour le GuardCFDispatchFunctionPointer dans la configuration de chargement s’il n’a pas l’intention d’utiliser la fonction de répartition CFG. Cela doit être fait pour les architectures non-AMD64 en vue d’une compatibilité future, au cas où ces architectures finiront par prendre en charge le mécanisme de distribution CFG sous une forme quelconque. Notez que Windows 8.1 AMD64 n’a pas pris en charge la distribution CFG et laissait le pointeur de fonction par défaut en place pour GuardCFDispatchFunctionPointer. La distribution CFG est uniquement prise en charge sur les systèmes d’exploitation Windows 10 et versions ultérieures.

- Le système CFG en mode utilisateur ne peut être appliqué que pour les images marquées comme compatibles avec la randomisation du format d’espace d’adresse (ASLR) (spécifiée par l’option/DYNAMICBASE avec l’éditeur de liens Microsoft). Cela est dû au fait que le système d’exploitation gère en interne CFG, où il est essentiellement connecté à l’infrastructure ASLR. En général, les utilisateurs de CFG doivent activer ASLR pour leurs images dans un premier temps. Les outils ne doivent pas supposer que le système d’exploitation ignore toujours CFG sans ASLR défini, mais il doit généralement les définir tous les deux en même temps.

## <a name="compiler-directives"></a>Directives de compilateur

- Les cibles d’appel peuvent être marquées comme explicitement supprimées avec le modificateur __declspec (Guard (Suppress)), ou avec la directive de l’éditeur de liens/guardsym : SymName, S (pour le code ASM, par exemple). La cible d’appel est alors incluse dans la table **GFIDS** , mais marquée de sorte que le système d’exploitation traite la cible d’appel comme non valide. Certains scénarios de non-production, tels que avec certaines instruments Application Verifier activés sur certains systèmes d’exploitation plus anciens, peuvent permettre de traiter les cibles d’appel supprimées comme valides, mais en général, ces scénarios ne sont pas censés être des scénarios de production. Cette directive est utile pour annoter des fonctions « dangereuses » qui ne doivent pas être considérées comme cibles d’appel valides, même si la règle CFG normale les inclut.

- Le code peut indiquer que les vérifications de CFG ne sont pas souhaitées avec le modificateur __declspec (Guard (nocf)). Cela indique au compilateur de ne pas insérer de contrôles CFG pour la fonction entière. Le compilateur doit s’occuper de propager cette directive dans tout code fourni par une fonction inline marquée comme ne souhaitant pas vérifier les contrôles CFG. Cette approche est généralement utilisée uniquement avec modération dans des situations spécifiques où le programmeur a inséré manuellement une protection « équivalente CFG ». Le programmeur sait qu’ils appellent via une table de fonctions en lecture seule dont l’adresse est obtenue via des références de mémoire en lecture seule et pour lesquelles l’index est masqué dans la limite de la table de fonctions. Cette approche peut également être appliquée aux petites fonctions wrapper qui ne sont pas inline et qui n’effectuent rien de plus qu’un appel via un pointeur de fonction. Étant donné que l’utilisation incorrecte de cette directive peut compromettre la sécurité de CFG, le programmeur doit être très prudent en utilisant la directive. En règle générale, cette utilisation est limitée aux très petites fonctions qui n’appellent qu’une seule fonction.

## <a name="import-handling"></a>Gestion des importations

- Les appels effectués via l’IAT ne doivent pas utiliser la protection CFG. L’IAT est en lecture seule dans les images modernes (en supposant que la IAT est déclarée dans les en-têtes PE, auquel cas elle doit se trouver sur ses propres pages). L’IAT peut être utilisé pour atteindre les fonctions qui sont supprimées, donc il s’agit d’une exigence d’exactitude. La protection en lecture seule de la mémoire via l’IAT remplace celle de CFG, car la liaison cible de l’appel est immuable une fois que les instantanés d’importation d’image sont résolus et que la résolution de liaison est fine.

- Chargement différé protégé : les appels via l’IAT de chargement différé ne doivent pas utiliser la protection CFG, pour les mêmes raisons que l’IAT standard. L’IAT de chargement différé doit se trouver dans sa propre section et l’image doit définir le IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT GuardFlags bit. Cela indique que le chargeur de DLL du système d’exploitation doit modifier les protections du IAT de chargement différé lors de la résolution d’exportation si vous utilisez la prise en charge du chargement différé du système d’exploitation native sur les systèmes d’exploitation Windows 8 et versions ultérieures. La synchronisation de cette étape est gérée par le chargeur de DLL du système d’exploitation si la prise en charge du chargement différé du système d’exploitation est en cours d’utilisation (par exemple, ResolveDelayLoadedAPI), de sorte qu’aucun autre composant ne doit reprotéger les pages couvrant l’IAT du chargement différé déclaré. Pour la compatibilité descendante avec les anciens systèmes d’exploitation antérieurs à CFG, les outils peuvent permettre de déplacer l’IAT de chargement différé dans sa propre section (« . didat » par définition canonique), protégée en lecture/écriture dans les en-têtes d’image, et définir également l’indicateur IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Ce paramètre fait en sorte que les chargeurs de DLL du système d’exploitation prenant en charge CFG reprotègent la section entière contenant la table IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT pour lire uniquement la mémoire pendant le chargement de l’image. L’option permettant de placer l’IAT de chargement différé dans sa propre section peut ne pas être nécessaire si vous n’avez pas à exécuter une image sur les systèmes d’exploitation qui prennent en charge la préversion de CFG, mais les outils doivent prendre cette décision en fonction de la prise en charge minimale du système d’exploitation qu’une image a besoin.

  Si une image n’utilise pas la prise en charge du chargement différé natif du système d’exploitation, elle peut toujours définir les bits GuardFlags associés au chargement différé. Dans cette configuration, le chargeur du système d’exploitation fournira simplement la prise en charge pour protéger l’IAT de chargement différé en lecture seule au moment de l’exécution, s’il est pris en charge par la plateforme, et il devient la responsabilité des stubs de résolution de chargement différé interne de l’image pour synchroniser et gérer la protection du IAT de chargement différé. Étant donné que la table de configuration de charge est stockée en mémoire en lecture seule (ce qui est recommandé), la présence ou l’absence du bit de chargement de retard protégé dans le champ GuardFlags de l’image peut être utile comme indication interne des stubs de résolution de chargement différée de l’image pour indiquer si elle doit ou non protéger l’IAT de chargement différé.

  Il est recommandé d’activer le chargement différé protégé par défaut si CFG est activé. Les images qui s’exécutent sur des versions de système d’exploitation plus anciennes et qui utilisent la prise en charge du chargement différé natif du système d’exploitation peuvent utiliser l’IAT de chargement différé dans sa propre section prise en charge de la compatibilité descendante. Par opposition, il est recommandé de marquer le IAT de chargement différé comme en lecture seule et de le fusionner avec une autre section, ce qui s’interrompt sur les systèmes d’exploitation plus anciens qui ne comprennent pas les charges de retard protégées et qui assurent la prise en charge de la résolution de chargement en retard native. Toutes les versions de Windows 10 et la première Windows 8.1/Windows Server 2012 R2 génère ce CFG pris en charge (ce qui signifie que la mise à jour du 2014 du 1er novembre) introduit la prise en charge de la charge de délai protégée dans le système d’exploitation.

## <a name="function-alignment"></a>Alignement des fonctions

- Les fonctions qui sont prises en considération et qui sont donc incluses dans la table **GFIDS** doivent être alignées sur 16 octets, si possible. Cela n’est peut-être pas toujours possible. Par exemple, pour les fonctions non-COMDAT qui font partie des fichiers objets assemblés ensemble comme une unité par les outils non compatibles avec CFG, que certains assembleurs peuvent produire, l’utilisateur de l’outil qui a produit les fichiers doit définir correctement l’alignement. Les outils peuvent choisir d’émettre un avertissement de diagnostic dans cette situation pour permettre à l’utilisateur de prendre des mesures correctives appropriées. Cela est dû au fait que les marques de CFG appellent des cibles valides ou non valides sur des limites de 16 octets pour l’efficacité des contrôles CFG rapides. Si une fonction n’est pas alignée sur 16 octets, la totalité de l’emplacement de 16 octets doit être marqué comme étant valide, ce qui n’est pas aussi sécurisé car vous pouvez appeler mal aligné dans du code qui ne se trouve pas au début d’une fonction. Ce scénario est pris en charge pour faciliter l’interopérabilité lors de la première mise en place de CFG pour un projet. Les images compatibles avec le non-CFG sont marquées comme valides pour tout alignement de cible d’appel pour la compatibilité. Comme précédemment, les cibles d’appel mal alignées réduisent les avantages en matière de sécurité de CFG. les outils doivent donc s’aligner automatiquement sur une limite de 16 octets pour tous les éléments de la table **GFIDS** quand cfg est souhaité pour une image. Les symboles qui ne figurent pas dans la table **GFIDS** n’ont pas besoin d’avoir des alignements particuliers pour cfg.

## <a name="export-suppression"></a>Suppression de l’exportation

- La suppression de l’exportation CFG (CFG ES) est un mode facultatif qui permet à un processus d’indiquer que les cibles d’appel qui étaient uniquement valides parce qu’il s’agissait de symboles dllexport et qui n’ont pas encore été résolus de manière dynamique par GetProcAddress, sont considérées comme non valides pour les besoins de CFG. Cela réduit la surface d’exposition de CFG des exportations de DLL système. La suppression de l’exportation implique la communication des cibles d’appel « Export supprimées » admissibles en les marquant avec les indicateurs IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** . Les symboles dllexport et le point d’entrée de l’image PE doivent être implicitement considérés comme une adresse prise par des outils pour la génération de la table **GFIDS** .  Si un symbole d’exportation est aligné sur 16 octets et que l’adresse est prise pour aucune autre raison qu’un dllexport, il peut être marqué avec l’indicateur Export **GFIDS** supprimé dans la table de fonctions. Les cibles d’appel qui ne sont pas alignées sur 16 octets ne **doivent pas** être marquées avec l’indicateur IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** et ne peuvent pas être restreintes uniquement comme cibles d’appel valides à l’heure GetProcAddress.

  Une image qui prend en charge CFG ES comprend un GuardAddressTakenIatEntryTable dont le nombre est fourni par le GuardAddressTakenIatEntryCount dans le cadre de son répertoire de configuration de chargement. Le format de cette table est structuré de la même façon que la table **GFIDS** . Elle utilise le même mécanisme de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags pour encoder les octets de métadonnées facultatifs supplémentaires dans la table Address prise IAT, bien que tous les octets de métadonnées doivent être nuls pour la table Address prise IAT et sont réservés. La table Address comprise IAT indique un tableau trié de RVA de thunks d’importation qui ont la cible d’appel importée en tant qu’adresse de symbole. Cette construction prend en charge les symboles adresse prise qui existent dans un module distant, et qui sont dllexports, avec CFG ES en cours d’utilisation. Voici un exemple de construction de code :

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Tous les thunks d’importation de ce type d’adresse doivent être énumérés afin que le chargeur du système d’exploitation puisse les trouver et que les cibles d’appel appropriées soient valides lors du chargement d’une image et de l’alignement de ses importations. La table et le nombre peuvent être 0 s’il n’y a pas de thunks d’importation qui étaient pris en compte.

  Un module définit IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT le bit de GuardFlags pour indiquer qu’il a énuméré tous les thunks d’adresse pris dans sa table d’adresses IAT et que toutes les exportations qui correspondent à CFG ES sont marquées avec l’indicateur IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **GFIDS** . Notez qu’il peut y avoir zéro de tels thunks et qu’il peut y avoir également zéro de tels symboles dllexport. L’échec de la maintenance de la table IAT Address prise peut être un problème d’exactitude, car certaines cibles d’appel peuvent ne pas être rendues valides lorsque celles-ci doivent être au moment du chargement de la DLL.

  Un module définit le bit de IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION GuardFlags pour indiquer qu’il veut activer CFG ES pour le processus. Dans la pratique, cette méthode est uniquement significative pour les fichiers exe. Un processus qui active CFG ES ne doit pas charger les dll qui ne sont pas générées avec CFG ES ou les échecs d’exécution peuvent se produire en raison d’adresses non désignées par les symboles IAT. La prise en charge de l’activation de CFG ES doit être une option d’abonnement distincte de l’activation de CFG. Le fait de fournir des métadonnées CFG ES sécurisées et recommandé par défaut avec CFG, bien que les ensembles d’outils doivent veiller à ce qu’ils produisent des métadonnées correctes. Si ce n’est pas le cas, leurs images générées risquent de ne pas s’exécuter correctement dans un processus CFG ES. Une telle prise en charge doit être testée minutieusement dans un processus de test qui applique CFG ES. Les DLL système intégrées du système d’exploitation prennent en charge les métadonnées CFG ES pour les versions modernes du système d’exploitation Windows 10 qui comprennent CFG ES. Les versions de système d’exploitation antérieures à cette prise en charge ne comprennent pas les CFG ES et ignorent toutes les directives CFG ES associées dans l’image. Ces images sont toujours compatibles avec les versions antérieures du système d’exploitation.

  La prise en charge de CFG ES est facultative du point de vue de l’ensemble d’outils, mais il est recommandé que les ensembles d’outils incluent au moins la prise en charge pour énumérer suffisamment d’informations pour que les images s’exécutent dans un processus qui souhaite CFG ES. Comme nous l’avons vu précédemment, il est essentiel que la prise en charge des jeux d’outils soit minutieusement testée pour s’assurer qu’elle est compatible avec CFG ES, car la plupart des processus n’activent pas encore CFG ES.

## <a name="exception-handling-and-unwinding"></a>Traitement des exceptions et déroulement

- Les gestionnaires spécifiques au langage comme __C_specific_handler, comme indiqué par les informations du gestionnaire d’exceptions dans une inscription. pdata, ne doivent pas être marqués comme cibles d’appel valides dans la table **GFIDS** . Ils sont recherchés en parcourant la mémoire en lecture seule. De même, le gestionnaire spécifique au langage C de Microsoft utilise des recherches en lecture seule de la mémoire pour localiser funclets pour les gestionnaires d’exceptions et ne déclare donc pas ses funclets en tant que cibles d’appel valides dans la table **GFIDS** .

- Gestion des sauts longs (pour les cibles non-x86 comme AMD64) : les ensembles d’outils qui compilent avec CFG et prennent en charge setjmp ()/longjmp () doivent implémenter un saut long en tant que « saut long sécurisé » qui interagit avec la gestion structurée des exceptions (SEH). Cela signifie que le saut long est implémenté en tant qu’appel à RtlUnwindEx avec STATUS_LONGJUMP comme code d’État dans l’enregistrement d’exception fourni et un _JUMP_BUFFER standard pointé par ExceptionInformation [0]. La cible de déroulement de saut doit être le TargetIp du déroulement. La mémoire tampon de saut représente le contexte de Registre qui est restauré par le système d’exploitation après la fin du long saut. RtlUnwind (ex) en cas d’appel avec STATUS_LONGJUMP a une signification spéciale propre à CFG. Cible de saut long (_JUMP_BUFFER. RIP ou _JUMP_BUFFER. LR sur ARM64) est recherché dans la liste des modules chargés gérée par le système d’exploitation en mémoire en lecture seule. Si le module conteneur pour la cible de saut (le « module cible ») a l’indicateur IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT défini dans son champ GuardFlags, le répertoire de configuration de chargement a un GuardLongJumpTargetTable avec un nombre d’éléments spécifié par le champ GuardLongJumpTargetCount de la configuration de charge. Cette table est structurée de la même façon que la table **GFIDS** et utilise le même mécanisme de IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK GuardFlags pour encoder les octets de métadonnées supplémentaires facultatifs dans la table de raccourcis longs. Tous les octets de métadonnées doivent être nuls pour la table de sauts longue et sont réservés.

  La table de saut long représente un tableau trié de RVA qui sont des cibles de saut longues valides. Si un module cible de saut long définit IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT dans son champ GuardFlags, toutes les cibles de saut longues doivent être énumérées dans le LongJumpTargetTable. Même si un module n’a pas de cibles de saut longues, il doit toujours définir l’indicateur IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT si l’ensemble d’outils prend en charge le renforcement de saut long pour CFG. Cela signifie explicitement que l’image n’a pas de cibles de saut longues et qu’il ne s’agit pas d’une ancienne image que le système d’exploitation doit supposer peut avoir des cibles de saut longues valides à des emplacements non marqués pour lesquels il ne peut pas effectuer de vérification de cible de saut long.

  Le renforcement des sauts longs est recommandé pour l’activation par défaut si CFG est pris en charge. Il s’agit de la disposition des compilateurs Microsoft. Les systèmes d’exploitation qui ne comprennent pas le renforcement de la sécurité des sauts longs (versions antérieures à Windows 10 ou Windows 10 antérieures) n’effectuent pas de contrôles de renforcement de la sécurité de sauts longs et ignorent les longues métadonnées de sécurisation renforcée des sauts. par conséquent, le renforcement de la sécurité des sauts est à compatibilité descendante avec les anciennes versions

  Pour les images en mode noyau, la table cible de saut long de protection ne doit pas être incluse dans une section qui peut être ignorée. La table cible de saut long de protection doit toujours être stockée en mémoire en lecture seule pour que ses propriétés de sécurité soient effectives.

## <a name="coff-information"></a>Informations COFF

- Il existe des marquages de fichiers objet pour déclarer si un fichier objet est conforme à CFG ou non. Un fichier objet qui est conforme à CFG répertorie les cibles d’appel valides qu’il produit, de manière explicite, ainsi que toute adresse prise par les métadonnées IAT. Un fichier objet qui n’est pas conforme à CFG doit avoir des cibles d’appel déduites en examinant les réadressages COFF du fichier OBJ pour rechercher les réadressages qui pointent vers le début d’un symbole de fonction. Cela peut s’avérer très approximatif pour les cibles d’appel CFG valides. il est donc souhaitable que les outils marquent leurs fichiers obj qui prennent en charge CFG et incluent les métadonnées du fichier obj. CFG en cas de compilation avec CFG.

- Il existe des marquages de fichiers objet pour déclarer des cibles de saut longues pour le long saut long CFG renforcé qui doit être rempli pour le mode de compilation CFG.
