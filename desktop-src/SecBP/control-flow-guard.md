---
description: La protection de workflow de contrôle (CFG) est une fonctionnalité de sécurité de plateforme hautement optimisée qui a été créée pour combattre les vulnérabilités d’altération de la mémoire.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Control Flow Guard
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104115907"
---
# <a name="control-flow-guard"></a><span data-ttu-id="296a1-103">Control Flow Guard</span><span class="sxs-lookup"><span data-stu-id="296a1-103">Control Flow Guard</span></span>

## <a name="what-is-control-flow-guard"></a><span data-ttu-id="296a1-104">Qu’est-ce que la protection de Flow Control ?</span><span class="sxs-lookup"><span data-stu-id="296a1-104">What is Control Flow Guard?</span></span>

<span data-ttu-id="296a1-105">La protection de workflow de contrôle (CFG) est une fonctionnalité de sécurité de plateforme hautement optimisée qui a été créée pour combattre les vulnérabilités d’altération de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="296a1-105">Control Flow Guard (CFG) is a highly-optimized platform security feature that was created to combat memory corruption vulnerabilities.</span></span> <span data-ttu-id="296a1-106">En plaçant des restrictions strictes sur l’emplacement à partir duquel une application peut exécuter du code, il est beaucoup plus difficile pour les attaques d’exécuter du code arbitraire par le biais de vulnérabilités telles que les débordements de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="296a1-106">By placing tight restrictions on where an application can execute code from, it makes it much harder for exploits to execute arbitrary code through vulnerabilities such as buffer overflows.</span></span> <span data-ttu-id="296a1-107">CFG étend les technologies d’atténuation des vulnérabilités précédentes telles que [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)et [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span><span class="sxs-lookup"><span data-stu-id="296a1-107">CFG extends previous exploit mitigation technologies such as [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md), and [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).</span></span>

<span data-ttu-id="296a1-108">Cette fonctionnalité est disponible dans Microsoft Visual Studio 2015 et s’exécute sur les versions « compatibles CFG » de Windows, les versions x86 et x64 pour les ordinateurs de bureau et les serveurs de mise à jour de Windows 10 et Windows 8.1 (KB3000850).</span><span class="sxs-lookup"><span data-stu-id="296a1-108">This feature is available in Microsoft Visual Studio 2015, and runs on "CFG-Aware" versions of Windows—the x86 and x64 releases for Desktop and Server of Windows 10 and Windows 8.1 Update (KB3000850).</span></span>

<span data-ttu-id="296a1-109">Nous encourageons vivement les développeurs à activer CFG pour leurs applications.</span><span class="sxs-lookup"><span data-stu-id="296a1-109">We strongly encourage developers to enable CFG for their applications.</span></span> <span data-ttu-id="296a1-110">Vous n’avez pas besoin d’activer CFG pour chaque partie de votre code, car une combinaison de CFG est activée et le code non activé par CFG s’exécute parfaitement.</span><span class="sxs-lookup"><span data-stu-id="296a1-110">You don't have to enable CFG for every part of your code, as a mixture of CFG enabled and non-CFG enabled code will execute fine.</span></span> <span data-ttu-id="296a1-111">Toutefois, l’activation de CFG pour l’ensemble du code peut entraîner des lacunes dans la protection.</span><span class="sxs-lookup"><span data-stu-id="296a1-111">But failing to enable CFG for all code can open gaps in the protection.</span></span> <span data-ttu-id="296a1-112">En outre, le code CFG activé fonctionne correctement sur les versions « ne connaissant pas CFG » de Windows et est donc entièrement compatible avec eux.</span><span class="sxs-lookup"><span data-stu-id="296a1-112">Furthermore, CFG enabled code works fine on "CFG-Unaware" versions of Windows and is therefore fully compatible with them.</span></span>

## <a name="how-can-i-enable-cfg"></a><span data-ttu-id="296a1-113">Comment activer CFG ?</span><span class="sxs-lookup"><span data-stu-id="296a1-113">How Can I Enable CFG?</span></span>

<span data-ttu-id="296a1-114">Dans la plupart des cas, il est inutile de modifier le code source.</span><span class="sxs-lookup"><span data-stu-id="296a1-114">In most cases, there is no need to change source code.</span></span> <span data-ttu-id="296a1-115">Il vous suffit d’ajouter une option à votre projet Visual Studio 2015, et le compilateur et l’éditeur de liens activent CFG.</span><span class="sxs-lookup"><span data-stu-id="296a1-115">All you have to do is add an option to your Visual Studio 2015 project, and the compiler and linker will enable CFG.</span></span>

<span data-ttu-id="296a1-116">La méthode la plus simple consiste à accéder aux propriétés de configuration propriétés de la **\| configuration du \| \| \| code C/C++** et à choisir **Oui (/Guard : CF)** pour la protection du workflow de contrôle.</span><span class="sxs-lookup"><span data-stu-id="296a1-116">The simplest method is to navigate to **Project \| Properties \| Configuration Properties \| C/C++ \| Code Generation** and choose **Yes (/guard:cf)** for Control Flow Guard.</span></span>

![propriété cfg dans Visual Studio](images/cfg-vs.png)

<span data-ttu-id="296a1-118">Vous pouvez également ajouter **/Guard : cf** aux propriétés de configuration propriétés de **\| \| configuration \| \| \| options supplémentaires de la ligne de commande c/C++** (pour le compilateur) et **/Guard : cf** vers propriétés de configuration propriétés de **\| \| configuration \| \| \| options supplémentaires** de la ligne de commande de l’éditeur de liens (pour l’éditeur de liens).</span><span class="sxs-lookup"><span data-stu-id="296a1-118">Alternatively, add **/guard:cf** to **Project \| Properties \| Configuration Properties \| C/C++ \| Command Line \| Additional Options** (for the compiler) and **/guard:cf** to **Project \| Properties \| Configuration Properties \| Linker \| Command Line \| Additional Options** (for the linker).</span></span>

![propriété cfg pour le compilateur](images/cfg-compiler.png)![propriété cfg pour l’éditeur de liens](images/cfg-linker.png)

<span data-ttu-id="296a1-121">Pour plus d’informations [, consultez/Guard (activer la protection du contrôle de Workflow)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .</span><span class="sxs-lookup"><span data-stu-id="296a1-121">See [/guard (Enable Control Flow Guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) for additional info.</span></span>

<span data-ttu-id="296a1-122">Si vous générez votre projet à partir de la ligne de commande, vous pouvez ajouter les mêmes options.</span><span class="sxs-lookup"><span data-stu-id="296a1-122">If you are building your project from the command line, you can add the same options.</span></span> <span data-ttu-id="296a1-123">Par exemple, si vous compilez un projet appelé test. cpp, utilisez **CL/Guard : cf test. cpp/Link/Guard : cf**.</span><span class="sxs-lookup"><span data-stu-id="296a1-123">For example, if you are compiling a project called test.cpp, use **cl /guard:cf test.cpp /link /guard:cf**.</span></span>

<span data-ttu-id="296a1-124">Vous avez également la possibilité de contrôler dynamiquement l’ensemble des adresses cibles iCal qui sont considérées comme valides par CFG à l’aide de [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) de l’API de gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="296a1-124">You also have the option of dynamically controlling the set of icall target addresses that are considered valid by CFG using the [**SetProcessValidCallTargets**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) from the Memory Management API.</span></span> <span data-ttu-id="296a1-125">La même API peut être utilisée pour spécifier si les pages sont des cibles non valides ou valides pour CFG.</span><span class="sxs-lookup"><span data-stu-id="296a1-125">The same API can be used to specify whether pages are invalid or valid targets for CFG.</span></span> <span data-ttu-id="296a1-126">Les fonctions [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) et [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) traitent par défaut une région spécifiée de pages exécutables et validées comme cibles d’appel indirect valides.</span><span class="sxs-lookup"><span data-stu-id="296a1-126">The [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) and [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) functions will by default treat a specified region of executable and committed pages as valid indirect call targets.</span></span> <span data-ttu-id="296a1-127">Il est possible de substituer ce comportement, par exemple lors de l’implémentation d’un compilateur juste-à-temps, en spécifiant des **cibles de page \_ \_ non valides** lors de l’appel de **VirtualAlloc** ou des **cibles de page \_ \_ aucune \_ mise à jour** lors de l’appel de **VirtualProtect** comme détaillé sous [**constantes de protection**](/windows/desktop/Memory/memory-protection-constants)de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="296a1-127">It is possible to override this behavior, such as when implementing a Just-in-Time compiler, by specifying **PAGE\_TARGETS\_INVALID** when calling **VirtualAlloc** or **PAGE\_TARGETS\_NO\_UPDATE** when calling **VirtualProtect** as detailed under [**Memory Protection Constants**](/windows/desktop/Memory/memory-protection-constants).</span></span>

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a><span data-ttu-id="296a1-128">Comment puis-je savoir qu’un fichier binaire est sous la protection du circuit de contrôle ?</span><span class="sxs-lookup"><span data-stu-id="296a1-128">How Do I Tell That a Binary is under Control Flow Guard?</span></span>

<span data-ttu-id="296a1-129">Exécutez l' [outil DUMPBIN](/cpp/build/reference/dumpbin-reference) (inclus dans l’installation de visual studio 2015) à partir de l’invite de commandes de Visual Studio avec les options */headers* et */loadconfig* : **dumpbin/headers/loadConfig test.exe**.</span><span class="sxs-lookup"><span data-stu-id="296a1-129">Run the [dumpbin tool](/cpp/build/reference/dumpbin-reference) (included in the Visual Studio 2015 installation) from the Visual Studio command prompt with the */headers* and */loadconfig* options: **dumpbin /headers /loadconfig test.exe**.</span></span> <span data-ttu-id="296a1-130">La sortie d’un binaire sous CFG doit indiquer que les valeurs d’en-tête incluent « Guard », et que les valeurs de la configuration de chargement incluent « instrumentation CF » et « table FID présente ».</span><span class="sxs-lookup"><span data-stu-id="296a1-130">The output for a binary under CFG should show that the header values include "Guard", and that the load config values include "CF Instrumented" and "FID table present".</span></span>

![sortie de dumpbin/headers](images/cfg-dumpbin-headers.png)

![sortie de DUMPBIN/loadConfig](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a><span data-ttu-id="296a1-133">Comment CFG fonctionne-t-il vraiment ?</span><span class="sxs-lookup"><span data-stu-id="296a1-133">How Does CFG Really Work?</span></span>

<span data-ttu-id="296a1-134">Les vulnérabilités logicielles sont souvent exploitées en fournissant des données peu probables, inhabituelles ou extrêmes à un programme en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="296a1-134">Software vulnerabilities are often exploited by providing unlikely, unusual, or extreme data to a running program.</span></span> <span data-ttu-id="296a1-135">Par exemple, une personne malveillante peut exploiter une vulnérabilité de débordement de mémoire tampon en fournissant plus d’entrées à un programme que prévu, ce qui a pour effet de surExécuter la zone réservée par le programme pour contenir une réponse.</span><span class="sxs-lookup"><span data-stu-id="296a1-135">For example, an attacker can exploit a buffer overflow vulnerability by providing more input to a program than expected, thereby over-running the area reserved by the program to hold a response.</span></span> <span data-ttu-id="296a1-136">Cela peut corrompre la mémoire adjacente qui peut contenir un pointeur de fonction.</span><span class="sxs-lookup"><span data-stu-id="296a1-136">This could corrupt adjacent memory that may hold a function pointer.</span></span> <span data-ttu-id="296a1-137">Quand le programme appelle par le biais de cette fonction, il peut alors accéder à un emplacement non souhaité spécifié par l’attaquant.</span><span class="sxs-lookup"><span data-stu-id="296a1-137">When the program calls through this function it may then jump to an unintended location specified by the attacker.</span></span>

<span data-ttu-id="296a1-138">Toutefois, une combinaison puissante de prise en charge de compilation et d’exécution à partir de CFG implémente l’intégrité du workflow de contrôle qui restreint étroitement les endroits où les instructions d’appel indirect peuvent s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="296a1-138">However, a potent combination of compile and run-time support from CFG implements control flow integrity that tightly restricts where indirect call instructions can execute.</span></span>

<span data-ttu-id="296a1-139">Le compilateur effectue les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="296a1-139">The compiler does the following:</span></span>

1.  <span data-ttu-id="296a1-140">Ajoute des vérifications de sécurité légères au code compilé.</span><span class="sxs-lookup"><span data-stu-id="296a1-140">Adds lightweight security checks to the compiled code.</span></span>
2.  <span data-ttu-id="296a1-141">Identifie l’ensemble des fonctions de l’application qui sont des cibles valides pour les appels indirects.</span><span class="sxs-lookup"><span data-stu-id="296a1-141">Identifies the set of functions in the application that are valid targets for indirect calls.</span></span>

<span data-ttu-id="296a1-142">Prise en charge du runtime, fournie par le noyau Windows :</span><span class="sxs-lookup"><span data-stu-id="296a1-142">The runtime support, provided by the Windows kernel:</span></span>

1.  <span data-ttu-id="296a1-143">Gère efficacement l’État qui identifie les cibles d’appel indirectes valides.</span><span class="sxs-lookup"><span data-stu-id="296a1-143">Efficiently maintains state that identifies valid indirect call targets.</span></span>
2.  <span data-ttu-id="296a1-144">Implémente la logique qui vérifie qu’une cible d’appel indirect est valide.</span><span class="sxs-lookup"><span data-stu-id="296a1-144">Implements the logic that verifies that an indirect call target is valid.</span></span>

<span data-ttu-id="296a1-145">Pour illustrer ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="296a1-145">To illustrate:</span></span>

![Pseudo-code cfg](images/cfg-pseudocode.jpg)

<span data-ttu-id="296a1-147">Lorsqu’une vérification de CFG échoue au moment de l’exécution, Windows met immédiatement fin au programme, ce qui rompt toute attaque qui tente d’appeler indirectement une adresse non valide.</span><span class="sxs-lookup"><span data-stu-id="296a1-147">When a CFG check fails at runtime, Windows immediately terminates the program, thus breaking any exploit that attempts to indirectly call an invalid address.</span></span>

 

 
