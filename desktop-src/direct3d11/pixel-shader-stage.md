---
title: Étape nuanceur de pixels
description: L’étape de nuanceur de pixels (PS) permet d’effectuer des techniques d’ombrage riches, telles que l’éclairage par pixel et le traitement des messages.
ms.assetid: 09831B10-4FD1-41E7-8D81-5AA63DC90020
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 57142e9c32919a6959a7fac14bf544cca1dacd79
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104102084"
---
# <a name="pixel-shader-stage"></a><span data-ttu-id="036e7-103">Étape nuanceur de pixels</span><span class="sxs-lookup"><span data-stu-id="036e7-103">Pixel Shader Stage</span></span>

<span data-ttu-id="036e7-104">L’étape de nuanceur de pixels (PS) permet d’effectuer des techniques d’ombrage riches, telles que l’éclairage par pixel et le traitement des messages.</span><span class="sxs-lookup"><span data-stu-id="036e7-104">The pixel-shader stage (PS) enables rich shading techniques such as per-pixel lighting and post-processing.</span></span> <span data-ttu-id="036e7-105">Un nuanceur de pixels est un programme qui combine des variables constantes, des données de texture, des valeurs interpolées par vertex et d’autres données pour produire des sorties par pixel.</span><span class="sxs-lookup"><span data-stu-id="036e7-105">A pixel shader is a program that combines constant variables, texture data, interpolated per-vertex values, and other data to produce per-pixel outputs.</span></span> <span data-ttu-id="036e7-106">L’étape de rastérisation appelle un nuanceur de pixels une fois pour chaque pixel couvert par une primitive. Toutefois, il est possible de spécifier un nuanceur **null** pour éviter d’exécuter un nuanceur.</span><span class="sxs-lookup"><span data-stu-id="036e7-106">The rasterizer stage invokes a pixel shader once for each pixel covered by a primitive, however, it is possible to specify a **NULL** shader to avoid running a shader.</span></span>

## <a name="the-pixel-shader"></a><span data-ttu-id="036e7-107">Nuanceur de pixels</span><span class="sxs-lookup"><span data-stu-id="036e7-107">The Pixel Shader</span></span>

<span data-ttu-id="036e7-108">Lors de l’échantillonnage multiple d’une texture, un nuanceur de pixels est appelé une fois par pixel couvert lorsqu’un test de profondeur/gabarit se produit pour chaque exemple multiple couvert.</span><span class="sxs-lookup"><span data-stu-id="036e7-108">When multisampling a texture, a pixel shader is invoked once per-covered pixel while a depth/stencil test occurs for each covered multisample.</span></span> <span data-ttu-id="036e7-109">Les exemples qui réussissent le test de profondeur/stencil sont mis à jour avec la couleur de sortie du nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="036e7-109">Samples that pass the depth/stencil test are updated with the pixel shader output color.</span></span>

<span data-ttu-id="036e7-110">Les fonctions intrinsèques de nuanceur de pixels produisent ou utilisent des dérivées de quantités par rapport à l’espace d’écran x et y.</span><span class="sxs-lookup"><span data-stu-id="036e7-110">The pixel shader intrinsic functions produce or use derivatives of quantities with respect to screen space x and y.</span></span> <span data-ttu-id="036e7-111">L’utilisation la plus courante pour les dérivés consiste à calculer les calculs de niveau de détail pour l’échantillonnage de texture et, dans le cas du filtrage anisotrope, à sélectionner des échantillons le long de l’axe de l’anisotropie.</span><span class="sxs-lookup"><span data-stu-id="036e7-111">The most common use for derivatives is to compute level-of-detail calculations for texture sampling and in the case of anisotropic filtering, selecting samples along the axis of anisotropy.</span></span> <span data-ttu-id="036e7-112">En règle générale, une implémentation matérielle exécute simultanément un nuanceur de pixels sur plusieurs pixels (par exemple une grille 2x2), de sorte que les dérivés des quantités calculées dans le nuanceur de pixels peuvent être raisonnablement approchées comme des deltas des valeurs au même point d’exécution en pixels adjacents.</span><span class="sxs-lookup"><span data-stu-id="036e7-112">Typically, a hardware implementation runs a pixel shader on multiple pixels (for example a 2x2 grid) simultaneously, so that derivatives of quantities computed in the pixel shader can be reasonably approximated as deltas of the values at the same point of execution in adjacent pixels.</span></span>

### <a name="inputs"></a><span data-ttu-id="036e7-113">Entrées</span><span class="sxs-lookup"><span data-stu-id="036e7-113">Inputs</span></span>

<span data-ttu-id="036e7-114">Lorsque le pipeline est configuré sans nuanceur Geometry, un nuanceur de pixels est limité à 16, 32 bits, 4 composants.</span><span class="sxs-lookup"><span data-stu-id="036e7-114">When the pipeline is configured without a geometry shader, a pixel shader is limited to 16, 32-bit, 4-component inputs.</span></span> <span data-ttu-id="036e7-115">Dans le cas contraire, un nuanceur de pixels peut prendre jusqu’à 32, 32 bits, 4 composants.</span><span class="sxs-lookup"><span data-stu-id="036e7-115">Otherwise, a pixel shader can take up to 32, 32-bit, 4-component inputs.</span></span>

<span data-ttu-id="036e7-116">Les données d’entrée de nuanceur de pixels incluent des attributs de vertex (qui peuvent être interpolés avec ou sans correction de perspective) ou peuvent être traités comme des constantes par Primitives.</span><span class="sxs-lookup"><span data-stu-id="036e7-116">Pixel shader input data includes vertex attributes (that can be interpolated with or without perspective correction) or can be treated as per-primitive constants.</span></span> <span data-ttu-id="036e7-117">Les entrées de nuanceur de pixels sont interpolées à partir des attributs de vertex de la primitive en cours de pixellisation, en fonction du mode d’interpolation déclaré.</span><span class="sxs-lookup"><span data-stu-id="036e7-117">Pixel shader inputs are interpolated from the vertex attributes of the primitive being rasterized, based on the interpolation mode declared.</span></span> <span data-ttu-id="036e7-118">Si une primitive est découpée avant pixellisation, le mode d’interpolation est également respecté au cours du processus de découpage.</span><span class="sxs-lookup"><span data-stu-id="036e7-118">If a primitive gets clipped before rasterization, the interpolation mode is honored during the clipping process as well.</span></span>

<span data-ttu-id="036e7-119">Les attributs de vertex sont interpolés (ou évalués) aux emplacements du centre du nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="036e7-119">Vertex attributes are interpolated (or evaluated) at pixel shader center locations.</span></span> <span data-ttu-id="036e7-120">Les modes d’interpolation d’attribut de nuanceur de pixels sont déclarés dans une déclaration de registre d’entrée, en fonction de chaque élément, dans un [argument](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) ou une [structure d’entrée](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span><span class="sxs-lookup"><span data-stu-id="036e7-120">Pixel shader attribute interpolation modes are declared in an input register declaration, on a per-element basis in either an [argument](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-function-parameters) or an [input structure](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-struct).</span></span> <span data-ttu-id="036e7-121">Les attributs peuvent être interpolés de manière linéaire ou avec un échantillonnage de centre de [gravité](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="036e7-121">Attributes can be interpolated linearly, or with [centroid sampling](https://msdn.microsoft.com/library/Ee415231(v=VS.85).aspx).</span></span> <span data-ttu-id="036e7-122">L’évaluation de l’un des centres de gravité s’applique uniquement au cours de l’échantillonnage multiple pour couvrir les cas où un pixel est couvert par une primitive mais un centre de pixels ne peut pas être. l’évaluation du centre de gravité se produit aussi près que possible du centre de pixels (non couvert).</span><span class="sxs-lookup"><span data-stu-id="036e7-122">Centroid evaluation is relevant only during multisampling to cover cases where a pixel is covered by a primitive but a pixel center may not be; centroid evaluation occurs as close as possible to the (non-covered) pixel center.</span></span>

<span data-ttu-id="036e7-123">Les entrées peuvent également être déclarées avec une [sémantique de valeur système](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), qui marque un paramètre consommé par d’autres étapes de pipeline.</span><span class="sxs-lookup"><span data-stu-id="036e7-123">Inputs may also be declared with a [system-value semantic](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-semantics), which marks a parameter that is consumed by other pipeline stages.</span></span> <span data-ttu-id="036e7-124">Par exemple, une position de pixel doit être marquée avec la \_ sémantique de position SV.</span><span class="sxs-lookup"><span data-stu-id="036e7-124">For instance, a pixel position should be marked with the SV\_Position semantic.</span></span> <span data-ttu-id="036e7-125">L’étape IA peut produire une scalaire pour un nuanceur de pixels (à l’aide de SV \_ PrimitiveID); la phase de rastérisation peut également générer une scalaire pour un nuanceur de pixels (à l’aide de SV \_ IsFrontFace).</span><span class="sxs-lookup"><span data-stu-id="036e7-125">The IA stage can produce one scalar for a pixel shader (using SV\_PrimitiveID); the rasterizer stage can also generate one scalar for a pixel shader (using SV\_IsFrontFace).</span></span>

### <a name="outputs"></a><span data-ttu-id="036e7-126">Sorties</span><span class="sxs-lookup"><span data-stu-id="036e7-126">Outputs</span></span>

<span data-ttu-id="036e7-127">Un nuanceur de pixels peut sortir jusqu’à 8, 32 bits, 4 couleurs de composant ou aucune couleur si le pixel est ignoré.</span><span class="sxs-lookup"><span data-stu-id="036e7-127">A pixel shader can output up to 8, 32-bit, 4-component colors, or no color if the pixel is discarded.</span></span> <span data-ttu-id="036e7-128">Les composants du registre de sortie du nuanceur de pixels doivent être déclarés avant de pouvoir être utilisés. un masque d’écriture de sortie distinct est autorisé pour chaque registre.</span><span class="sxs-lookup"><span data-stu-id="036e7-128">Pixel shader output register components must be declared before they can be used; each register is allowed a distinct output-write mask.</span></span>

<span data-ttu-id="036e7-129">Utilisez l’État profondeur-écriture-activer (dans l’étape de fusion de sortie) pour contrôler si les données de profondeur sont écrites dans une mémoire tampon de profondeur (ou utilisez l’instruction ignore pour ignorer les données de ce pixel).</span><span class="sxs-lookup"><span data-stu-id="036e7-129">Use the depth-write-enable state (in the output-merger stage) to control whether depth data gets written to a depth buffer (or use the discard instruction to discard data for that pixel).</span></span> <span data-ttu-id="036e7-130">Un nuanceur de pixels peut également générer une valeur facultative 32 bits, 1-composant, à virgule flottante, pour le test de profondeur (à l’aide de la \_ sémantique de profondeur SV).</span><span class="sxs-lookup"><span data-stu-id="036e7-130">A pixel shader can also output an optional 32-bit, 1-component, floating-point, depth value for depth testing (using the SV\_Depth semantic).</span></span> <span data-ttu-id="036e7-131">La valeur de profondeur est sortie dans le registre oDepth et remplace la valeur de profondeur interpolée pour le test de profondeur (en supposant que le test de profondeur est activé).</span><span class="sxs-lookup"><span data-stu-id="036e7-131">The depth value is output in the oDepth register, and replaces the interpolated depth value for depth testing (assuming depth testing is enabled).</span></span> <span data-ttu-id="036e7-132">Il n’existe aucun moyen de modifier dynamiquement l’utilisation de la profondeur de fonction fixe ou du nuanceur oDepth.</span><span class="sxs-lookup"><span data-stu-id="036e7-132">There is no way to dynamically change between using fixed-function depth or shader oDepth.</span></span>

<span data-ttu-id="036e7-133">Un nuanceur de pixels ne peut pas générer une valeur de stencil.</span><span class="sxs-lookup"><span data-stu-id="036e7-133">A pixel shader cannot output a stencil value.</span></span>

## <a name="related-topics"></a><span data-ttu-id="036e7-134">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="036e7-134">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="036e7-135">Pipeline graphique</span><span class="sxs-lookup"><span data-stu-id="036e7-135">Graphics Pipeline</span></span>](overviews-direct3d-11-graphics-pipeline.md)
</dt> <dt>

[<span data-ttu-id="036e7-136">Étapes de pipeline (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="036e7-136">Pipeline Stages (Direct3D 10)</span></span>](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 