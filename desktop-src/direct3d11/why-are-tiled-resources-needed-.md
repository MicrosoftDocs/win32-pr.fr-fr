---
title: Pourquoi les ressources en mosaïque sont-elles nécessaires ?
description: Les ressources en mosaïque sont nécessaires afin que la mémoire de l’unité de traitement graphique (GPU) soit gaspillée pour stocker des régions de surfaces inaccessibles par l’application, et le matériel peut comprendre comment filtrer sur des vignettes adjacentes.
ms.assetid: E2179D65-56D3-481F-A5F3-B9C45A11A179
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d42ccccf66a73d224d8bab9a9d10c87cc330be43
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104971699"
---
# <a name="why-are-tiled-resources-needed"></a><span data-ttu-id="d11a2-103">Pourquoi les ressources en mosaïque sont-elles nécessaires ?</span><span class="sxs-lookup"><span data-stu-id="d11a2-103">Why are tiled resources needed?</span></span>

<span data-ttu-id="d11a2-104">Les ressources en mosaïque sont nécessaires afin que la mémoire de l’unité de traitement graphique (GPU) soit gaspillée pour stocker des régions de surfaces inaccessibles par l’application, et le matériel peut comprendre comment filtrer sur des vignettes adjacentes.</span><span class="sxs-lookup"><span data-stu-id="d11a2-104">Tiled resources are needed so less graphics processing unit (GPU) memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles.</span></span>

<span data-ttu-id="d11a2-105">Dans un système graphique (autrement dit, le système d’exploitation, le pilote d’affichage et le matériel graphique) sans prise en charge des ressources en mosaïque, le système graphique gère toutes les allocations de mémoire Direct3D à la granularité des sous-ressources.</span><span class="sxs-lookup"><span data-stu-id="d11a2-105">In a graphics system (that is, the operating system, display driver, and graphics hardware) without tiled resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span> <span data-ttu-id="d11a2-106">Pour une [mémoire tampon](overviews-direct3d-11-resources-buffers.md), la mémoire tampon entière est la sous-ressource.</span><span class="sxs-lookup"><span data-stu-id="d11a2-106">For a [Buffer](overviews-direct3d-11-resources-buffers.md), the entire Buffer is the subresource.</span></span> <span data-ttu-id="d11a2-107">Pour une [texture](overviews-direct3d-11-resources-textures.md) (par exemple, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), chaque niveau MIP est une sous-ressource ; pour un tableau de textures (par exemple, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), chaque niveau MIP d’une tranche de tableau donnée est une sous-ressource.</span><span class="sxs-lookup"><span data-stu-id="d11a2-107">For a [Texture](overviews-direct3d-11-resources-textures.md) (for example, [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d)), each mip level is a subresource; for a texture array (for example, [**Texture2DArray**](/windows/desktop/direct3dhlsl/sm5-object-texture2darray)), each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="d11a2-108">Le système graphique expose uniquement la possibilité de gérer le mappage des allocations à cette granularité des sous-ressources.</span><span class="sxs-lookup"><span data-stu-id="d11a2-108">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="d11a2-109">Dans le contexte des ressources en mosaïque, le terme « mappage » fait référence à l’affichage des données dans le GPU.</span><span class="sxs-lookup"><span data-stu-id="d11a2-109">In the context of tiled resources, "mapping" refers to making data visible to the GPU.</span></span>

<span data-ttu-id="d11a2-110">Supposons qu’une application sait qu’une opération de rendu particulière a uniquement besoin d’accéder à une petite partie d’une chaîne mipmap d’image (peut-être pas même la zone complète d’un mipmap donné).</span><span class="sxs-lookup"><span data-stu-id="d11a2-110">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="d11a2-111">Dans l’idéal, l’application peut informer le système graphique de ce besoin.</span><span class="sxs-lookup"><span data-stu-id="d11a2-111">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="d11a2-112">Le système graphique se détournerait alors uniquement pour s’assurer que la mémoire nécessaire est mappée sur le GPU sans pagination dans une mémoire trop importante.</span><span class="sxs-lookup"><span data-stu-id="d11a2-112">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span> <span data-ttu-id="d11a2-113">En réalité, sans prise en charge des ressources en mosaïque, le système graphique ne peut être informé que de la mémoire qui doit être mappée sur le GPU à la granularité des sous-ressources (par exemple, une plage de niveaux de mipmap complets accessibles).</span><span class="sxs-lookup"><span data-stu-id="d11a2-113">In reality, without tiled resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="d11a2-114">Il n’existe aucune erreur de demande dans le système graphique. par conséquent, il est possible d’utiliser un grand nombre de mémoire GPU excédentaire pour mettre en correspondance des sous-ressources complètes avant qu’une commande de rendu faisant référence à une partie de la mémoire ne soit exécutée.</span><span class="sxs-lookup"><span data-stu-id="d11a2-114">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="d11a2-115">Il s’agit simplement d’un problème qui rend l’utilisation des allocations de mémoire volumineuses difficile dans Direct3D sans prise en charge des ressources en mosaïque.</span><span class="sxs-lookup"><span data-stu-id="d11a2-115">This is just one issue that makes the use of large memory allocations difficult in Direct3D without tiled resource support.</span></span>

<span data-ttu-id="d11a2-116">Direct3D 11 prend en charge les surfaces [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) avec jusqu’à 16384 pixels sur un côté donné.</span><span class="sxs-lookup"><span data-stu-id="d11a2-116">Direct3D 11 supports [**Texture2D**](/windows/desktop/direct3dhlsl/sm5-object-texture2d) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="d11a2-117">Une image de 16384 de largeur de 16384 de haut et de 4 octets par pixel consomme 1 Go de mémoire vidéo (et l’ajout de des mipmaps aurait doublé cette quantité).</span><span class="sxs-lookup"><span data-stu-id="d11a2-117">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="d11a2-118">Dans la pratique, il est rare que tous les Go soient référencés dans une seule opération de rendu.</span><span class="sxs-lookup"><span data-stu-id="d11a2-118">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="d11a2-119">Certains développeurs de jeux modélisent des surfaces de terrain aussi grandes que 128K de 128K.</span><span class="sxs-lookup"><span data-stu-id="d11a2-119">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="d11a2-120">La façon dont ils peuvent travailler sur les GPU existants consiste à scinder la surface en mosaïques suffisamment petites pour gérer le matériel.</span><span class="sxs-lookup"><span data-stu-id="d11a2-120">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="d11a2-121">L’application doit déterminer les vignettes qui peuvent être nécessaires et les charger dans un cache de textures sur le GPU-a Software Paging System.</span><span class="sxs-lookup"><span data-stu-id="d11a2-121">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span> <span data-ttu-id="d11a2-122">L’un des inconvénients majeurs de cette approche vient du fait que le matériel ne connaît rien sur la pagination qui se passe : quand une partie d’une image doit être affichée sur l’écran qui chevauche les vignettes, le matériel ne sait pas comment effectuer un filtrage de fonction fixe (c’est-à-dire efficace) sur les vignettes.</span><span class="sxs-lookup"><span data-stu-id="d11a2-122">A significant downside to this approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="d11a2-123">Cela signifie que l’application gérant sa propre mosaïque logicielle doit recourir à un filtrage manuel de la texture dans le code du nuanceur (ce qui devient très onéreux si un filtre anisotrope de bonne qualité est souhaité) et/ou gaspiller de la mémoire des marges autour des vignettes qui contiennent des données provenant de vignettes voisines afin que le filtrage matériel des fonctions fixes puisse continuer à fournir de l'</span><span class="sxs-lookup"><span data-stu-id="d11a2-123">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

<span data-ttu-id="d11a2-124">Si une représentation en mosaïque des allocations de surface peut être une fonctionnalité de première classe dans le système graphique, l’application peut indiquer au matériel les vignettes à rendre disponibles.</span><span class="sxs-lookup"><span data-stu-id="d11a2-124">If a tiled representation of surface allocations could be a first class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="d11a2-125">De cette façon, moins de mémoire GPU est gaspillée le stockage des régions de surfaces que l’application sait n’est pas accessible, et le matériel peut comprendre comment filtrer les vignettes adjacentes, en éliminant une partie des difficultés rencontrées par les développeurs qui effectuent des mosaïques de logiciels de manière autonome.</span><span class="sxs-lookup"><span data-stu-id="d11a2-125">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="d11a2-126">Mais pour fournir une solution complète, il est nécessaire de faire ce qu’il faut faire pour traiter le fait que, indépendamment de la prise en charge de l’affichage en mosaïque dans une surface, la dimension surface maximale est actuellement de 16384-nulle près du 128 Ko + que les applications souhaitent déjà.</span><span class="sxs-lookup"><span data-stu-id="d11a2-126">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="d11a2-127">Il suffit d’une approche qui nécessite le matériel pour prendre en charge des tailles de texture plus volumineuses. Toutefois, il existe des coûts et/ou des compromis significatifs pour passer à cet itinéraire.</span><span class="sxs-lookup"><span data-stu-id="d11a2-127">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span> <span data-ttu-id="d11a2-128">Le chemin de filtre de texture et le chemin d’accès de rendu de Direct3D 11 sont déjà saturés en termes de précision dans la prise en charge de 16 000 textures avec les autres exigences, telles que la prise en charge des étendues de Viewport en dehors de la surface pendant le rendu, ou la prise en charge de la texture de la surface pendant le filtrage.</span><span class="sxs-lookup"><span data-stu-id="d11a2-128">Direct3D 11's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="d11a2-129">Une possibilité consiste à définir un compromis de telle sorte que la taille de la texture augmente au-delà de 16 Ko, la fonctionnalité/précision est indiquée d’une certaine manière.</span><span class="sxs-lookup"><span data-stu-id="d11a2-129">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="d11a2-130">Toutefois, même avec cette concession, des coûts matériels supplémentaires peuvent être nécessaires en termes d’adressage dans l’ensemble du système matériel pour atteindre des tailles de texture plus volumineuses.</span><span class="sxs-lookup"><span data-stu-id="d11a2-130">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

<span data-ttu-id="d11a2-131">L’un des problèmes qui entrent dans la lecture des textures est très élevé, c’est que les coordonnées de la texture à virgule flottante simple précision (et les interpolateurs associés pour prendre en charge la pixellisation) sont à court de précision pour spécifier des emplacements sur la surface avec précision.</span><span class="sxs-lookup"><span data-stu-id="d11a2-131">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="d11a2-132">Le filtrage de texture instable s’ensuit.</span><span class="sxs-lookup"><span data-stu-id="d11a2-132">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="d11a2-133">Une option coûteuse serait d’exiger la prise en charge de l’interpolateur double précision, bien que cela puisse être excessif en raison d’une alternative raisonnable.</span><span class="sxs-lookup"><span data-stu-id="d11a2-133">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

<span data-ttu-id="d11a2-134">Un autre nom pour les ressources en mosaïque est « texture fragmentée ».</span><span class="sxs-lookup"><span data-stu-id="d11a2-134">An alternate name for tiled resources is "sparse texture."</span></span> <span data-ttu-id="d11a2-135">« Épars » véhicule à la fois la nature en mosaïque des ressources, et peut-être la raison principale de les faire apparaître en mosaïque, ce qui n’est pas censé tous être mappés à la fois.</span><span class="sxs-lookup"><span data-stu-id="d11a2-135">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="d11a2-136">En fait, une application peut créer de manière concevable une ressource en mosaïque dans laquelle aucune donnée n’est créée pour toutes les régions et les mips de la ressource, intentionnellement.</span><span class="sxs-lookup"><span data-stu-id="d11a2-136">In fact, an application could conceivably author a tiled resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="d11a2-137">Ainsi, le contenu lui-même peut être fragmenté, et le mappage du contenu dans la mémoire du GPU à un moment donné est un sous-ensemble de celui-ci (encore plus fragmenté).</span><span class="sxs-lookup"><span data-stu-id="d11a2-137">So, the content itself could be sparse, and the mapping of the content in GPU memory at a given time would be a subset of that (even more sparse).</span></span>

<span data-ttu-id="d11a2-138">Un autre scénario pouvant être fourni par des ressources en mosaïque permet à plusieurs ressources de différents formats/Dimensions de partager la même mémoire.</span><span class="sxs-lookup"><span data-stu-id="d11a2-138">Another scenario that could be served by tiled resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="d11a2-139">Parfois, les applications ont des ensembles exclusifs de ressources qui ne doivent pas être utilisés en même temps, ou des ressources qui sont créées uniquement pour une utilisation très courte, puis détruites, suivies de la création d’autres ressources.</span><span class="sxs-lookup"><span data-stu-id="d11a2-139">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="d11a2-140">Une forme de général qui peut se trouver sur des « ressources en mosaïque » est qu’il est possible d’autoriser l’utilisateur à pointer plusieurs ressources différentes au même (chevauchement) de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="d11a2-140">A form of generality that can fall out of "tiled resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="d11a2-141">En d’autres termes, la création et la destruction des « ressources » (qui définissent une dimension/format, etc.) peuvent être découplées à partir de la gestion de la mémoire sous-jacente des ressources du point de vue de l’application.</span><span class="sxs-lookup"><span data-stu-id="d11a2-141">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="related-topics"></a><span data-ttu-id="d11a2-142">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="d11a2-142">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d11a2-143">Ressources en mosaïque</span><span class="sxs-lookup"><span data-stu-id="d11a2-143">Tiled resources</span></span>](tiled-resources.md)
</dt> </dl>

 

 