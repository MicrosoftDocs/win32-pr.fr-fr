---
title: Règles à virgule flottante (Direct3D 11)
description: Direct3D 11 prend en charge plusieurs représentations à virgule flottante. Tous les calculs à virgule flottante fonctionnent sous un sous-ensemble défini des règles à virgule flottante simple précision IEEE 754 32 bits.
ms.assetid: 33F21BD0-FDF8-4D35-95C0-0A3920814CB6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d83c87db0daa69c0393d0399ece5bdb6cf01d519
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104382069"
---
# <a name="floating-point-rules-direct3d-11"></a><span data-ttu-id="700ad-104">Règles à virgule flottante (Direct3D 11)</span><span class="sxs-lookup"><span data-stu-id="700ad-104">Floating-point rules (Direct3D 11)</span></span>

<span data-ttu-id="700ad-105">Direct3D 11 prend en charge plusieurs représentations à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="700ad-105">Direct3D 11 supports several floating-point representations.</span></span> <span data-ttu-id="700ad-106">Tous les calculs à virgule flottante fonctionnent sous un sous-ensemble défini des règles à virgule flottante simple précision IEEE 754 32 bits.</span><span class="sxs-lookup"><span data-stu-id="700ad-106">All floating-point computations operate under a defined subset of the IEEE 754 32-bit single precision floating-point rules.</span></span>

-   [<span data-ttu-id="700ad-107">règles à virgule flottante 32 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-107">32-bit floating-point rules</span></span>](#32-bit-floating-point-rules)
    -   [<span data-ttu-id="700ad-108">Règles IEEE-754 honorées</span><span class="sxs-lookup"><span data-stu-id="700ad-108">Honored IEEE-754 rules</span></span>](#honored-ieee-754-rules)
    -   [<span data-ttu-id="700ad-109">Écarts ou exigences supplémentaires des règles IEEE-754</span><span class="sxs-lookup"><span data-stu-id="700ad-109">Deviations or additional requirements from IEEE-754 rules</span></span>](#deviations-or-additional-requirements-from-ieee-754-rules)
-   [<span data-ttu-id="700ad-110">règles à virgule flottante 64 bits (double précision)</span><span class="sxs-lookup"><span data-stu-id="700ad-110">64-bit (double precision) floating point rules</span></span>](#64-bit-double-precision-floating-point-rules)
-   [<span data-ttu-id="700ad-111">règles à virgule flottante 16 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-111">16-bit floating-point rules</span></span>](#16-bit-floating-point-rules)
-   [<span data-ttu-id="700ad-112">règles à virgule flottante 11 bits et 10 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-112">11-bit and 10-bit floating-point rules</span></span>](#11-bit-and-10-bit-floating-point-rules)
-   [<span data-ttu-id="700ad-113">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="700ad-113">Related topics</span></span>](#related-topics)

## <a name="32-bit-floating-point-rules"></a><span data-ttu-id="700ad-114">règles à virgule flottante 32 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-114">32-bit floating-point rules</span></span>

<span data-ttu-id="700ad-115">Il existe deux ensembles de règles : ceux qui se conforment à IEEE-754 et ceux qui s’écartent de la norme.</span><span class="sxs-lookup"><span data-stu-id="700ad-115">There are two sets of rules: those that conform to IEEE-754, and those that deviate from the standard.</span></span>

### <a name="honored-ieee-754-rules"></a><span data-ttu-id="700ad-116">Règles IEEE-754 honorées</span><span class="sxs-lookup"><span data-stu-id="700ad-116">Honored IEEE-754 rules</span></span>

<span data-ttu-id="700ad-117">Certaines de ces règles sont une option unique où IEEE-754 offre des choix.</span><span class="sxs-lookup"><span data-stu-id="700ad-117">Some of these rules are a single option where IEEE-754 offers choices.</span></span>

-   <span data-ttu-id="700ad-118">La division par 0 produit +/-INF, à l’exception de 0/0, ce qui donne NaN.</span><span class="sxs-lookup"><span data-stu-id="700ad-118">Divide by 0 produces +/- INF, except 0/0 which results in NaN.</span></span>
-   <span data-ttu-id="700ad-119">le journal de (+/-) 0 produit-INF.</span><span class="sxs-lookup"><span data-stu-id="700ad-119">log of (+/-) 0 produces -INF.</span></span> <span data-ttu-id="700ad-120">le journal d’une valeur négative (autre que-0) produit une valeur NaN.</span><span class="sxs-lookup"><span data-stu-id="700ad-120">log of a negative value (other than -0) produces NaN.</span></span>
-   <span data-ttu-id="700ad-121">La racine carrée réciproque (rsq) ou la racine carrée (sqrt) d’un nombre négatif produit une valeur NaN.</span><span class="sxs-lookup"><span data-stu-id="700ad-121">Reciprocal square root (rsq) or square root (sqrt) of a negative number produces NaN.</span></span> <span data-ttu-id="700ad-122">L’exception est-0 ; sqrt (-0) génère-0, et rsq (-0) produit-INF.</span><span class="sxs-lookup"><span data-stu-id="700ad-122">The exception is -0; sqrt(-0) produces -0, and rsq(-0) produces -INF.</span></span>
-   <span data-ttu-id="700ad-123">INF-INF = NaN</span><span class="sxs-lookup"><span data-stu-id="700ad-123">INF - INF = NaN</span></span>
-   <span data-ttu-id="700ad-124">(+/-) INF/(+/-) INF = NaN</span><span class="sxs-lookup"><span data-stu-id="700ad-124">(+/-)INF / (+/-)INF = NaN</span></span>
-   <span data-ttu-id="700ad-125">(+/-) INF \* 0 = Nan</span><span class="sxs-lookup"><span data-stu-id="700ad-125">(+/-)INF \* 0 = NaN</span></span>
-   <span data-ttu-id="700ad-126">NaN (any OP) any-value = NaN</span><span class="sxs-lookup"><span data-stu-id="700ad-126">NaN (any OP) any-value = NaN</span></span>
-   <span data-ttu-id="700ad-127">Les comparaisons EQ, GT, GE, LT et LE, lorsque l’un ou l’autre ou les deux opérandes sont NaN, retourne **false**.</span><span class="sxs-lookup"><span data-stu-id="700ad-127">The comparisons EQ, GT, GE, LT, and LE, when either or both operands is NaN returns **FALSE**.</span></span>
-   <span data-ttu-id="700ad-128">Les comparaisons ignorent le signe 0 (par conséquent + 0 est égal à-0).</span><span class="sxs-lookup"><span data-stu-id="700ad-128">Comparisons ignore the sign of 0 (so +0 equals -0).</span></span>
-   <span data-ttu-id="700ad-129">La comparaison ne, lorsque l’un des opérandes ou les deux, est NaN retourne la **valeur true**.</span><span class="sxs-lookup"><span data-stu-id="700ad-129">The comparison NE, when either or both operands is NaN returns **TRUE**.</span></span>
-   <span data-ttu-id="700ad-130">Les comparaisons de toute valeur non NaN par rapport à +/-INF renvoient le résultat correct.</span><span class="sxs-lookup"><span data-stu-id="700ad-130">Comparisons of any non-NaN value against +/- INF return the correct result.</span></span>

### <a name="deviations-or-additional-requirements-from-ieee-754-rules"></a><span data-ttu-id="700ad-131">Écarts ou exigences supplémentaires des règles IEEE-754</span><span class="sxs-lookup"><span data-stu-id="700ad-131">Deviations or additional requirements from IEEE-754 rules</span></span>

-   <span data-ttu-id="700ad-132">IEEE-754 nécessite des opérations à virgule flottante pour produire un résultat qui est la valeur représentable la plus proche d’un résultat à précision infinie, connu sous le nom d’arrondi à le plus proche, même.</span><span class="sxs-lookup"><span data-stu-id="700ad-132">IEEE-754 requires floating-point operations to produce a result that is the nearest representable value to an infinitely-precise result, known as round-to-nearest-even.</span></span> <span data-ttu-id="700ad-133">Direct3D 11 définit la même exigence : les opérations à virgule flottante 32 bits produisent un résultat qui se trouve dans 0,5 unité-Last-place (ULP) du résultat à précision infinie.</span><span class="sxs-lookup"><span data-stu-id="700ad-133">Direct3D 11 defines the same requirement: 32-bit floating-point operations produce a result that is within 0.5 unit-last-place (ULP) of the infinitely-precise result.</span></span> <span data-ttu-id="700ad-134">Cela signifie que, par exemple, le matériel est autorisé à tronquer les résultats à 32 bits plutôt qu’à effectuer un arrondi vers le plus proche, même si cela entraînerait une erreur d’au plus 0,5 ULP. Cette règle s’applique uniquement à l’addition, la soustraction et la multiplication.</span><span class="sxs-lookup"><span data-stu-id="700ad-134">This means that, for example, hardware is allowed to truncate results to 32-bit rather than perform round-to-nearest-even, as that would result in error of at most 0.5 ULP.This rule applies only to addition, subtraction, and multiplication.</span></span>
-   <span data-ttu-id="700ad-135">Il n’existe aucune prise en charge des exceptions à virgule flottante, des bits d’État ou des interruptions.</span><span class="sxs-lookup"><span data-stu-id="700ad-135">There is no support for floating-point exceptions, status bits or traps.</span></span>
-   <span data-ttu-id="700ad-136">Les dénormes sont vidées du zéro protégé contre la signature lors de l’entrée et de la sortie d’une opération mathématique à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="700ad-136">Denorms are flushed to sign-preserved zero on input and output of any floating-point mathematical operation.</span></span> <span data-ttu-id="700ad-137">Des exceptions sont faites pour toute opération de déplacement de données ou d’e/s qui ne manipule pas les données.</span><span class="sxs-lookup"><span data-stu-id="700ad-137">Exceptions are made for any I/O or data movement operation that doesn't manipulate the data.</span></span>
-   <span data-ttu-id="700ad-138">Les États qui contiennent des valeurs à virgule flottante, telles que Viewport MinDepth/MaxDepth, BorderColor Values, peuvent être fournis comme valeurs de dénorme et peuvent ou non être vidés avant que le matériel ne les utilise.</span><span class="sxs-lookup"><span data-stu-id="700ad-138">States that contain floating-point values, such as Viewport MinDepth/MaxDepth, BorderColor values, may be provided as denorm values and may or may not be flushed before the hardware uses them.</span></span>
-   <span data-ttu-id="700ad-139">Les opérations min ou Max vident les dénormes pour la comparaison, mais le résultat peut ou non être vidé de la norme.</span><span class="sxs-lookup"><span data-stu-id="700ad-139">Min or max operations flush denorms for comparison, but the result may or may not be denorm flushed.</span></span>
-   <span data-ttu-id="700ad-140">L’entrée NaN d’une opération produit toujours NaN à la sortie.</span><span class="sxs-lookup"><span data-stu-id="700ad-140">NaN input to an operation always produces NaN on output.</span></span> <span data-ttu-id="700ad-141">Toutefois, le modèle binaire exact de la valeur NaN n’est pas requis pour rester le même (sauf si l’opération est une instruction Move brute, qui ne modifie pas les données).</span><span class="sxs-lookup"><span data-stu-id="700ad-141">But the exact bit pattern of the NaN is not required to stay the same (unless the operation is a raw move instruction - which doesn't alter data.)</span></span>
-   <span data-ttu-id="700ad-142">Les opérations min ou Max pour lesquelles un seul opérande est NaN retournent l’autre opérande en tant que résultat (contrairement aux règles de comparaison que nous avons consultées précédemment).</span><span class="sxs-lookup"><span data-stu-id="700ad-142">Min or max operations for which only one operand is NaN return the other operand as the result (contrary to comparison rules we looked at earlier).</span></span> <span data-ttu-id="700ad-143">Il s’agit d’une règle IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="700ad-143">This is a IEEE 754R rule.</span></span>

    <span data-ttu-id="700ad-144">La spécification IEEE-754R pour les opérations min et Max à virgule flottante indique que si l’une des entrées de min ou Max est une valeur QNaN silencieuse, le résultat de l’opération est l’autre paramètre.</span><span class="sxs-lookup"><span data-stu-id="700ad-144">The IEEE-754R specification for floating point min and max operations states that if one of the inputs to min or max is a quiet QNaN value, the result of the operation is the other parameter.</span></span> <span data-ttu-id="700ad-145">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="700ad-145">For example:</span></span>

    ```C++
    min(x,QNaN) == min(QNaN,x) == x (same for max)
    ```

    

    <span data-ttu-id="700ad-146">Une révision de la spécification IEEE-754R a adopté un comportement différent pour min et Max lorsqu’une entrée est une valeur SNaN « signaling » et une valeur QNaN :</span><span class="sxs-lookup"><span data-stu-id="700ad-146">A revision of the IEEE-754R specification adopted a different behavior for min and max when one input is a "signaling" SNaN value versus a QNaN value:</span></span>

    ```C++
    min(x,SNaN) == min(SNaN,x) == QNaN (same for max)
     
    ```

    

    <span data-ttu-id="700ad-147">En règle générale, Direct3D suit les normes pour les opérations arithmétiques : IEEE-754 et IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="700ad-147">Generally, Direct3D follows the standards for arithmetic: IEEE-754 and IEEE-754R.</span></span> <span data-ttu-id="700ad-148">Mais dans ce cas, nous avons un écart.</span><span class="sxs-lookup"><span data-stu-id="700ad-148">But in this case, we have a deviation.</span></span>

    <span data-ttu-id="700ad-149">Les règles arithmétiques dans Direct3D 10 et les versions ultérieures ne font aucune distinction entre les valeurs NaN et les valeurs NaN de signalisation (QNaN contre SNaN).</span><span class="sxs-lookup"><span data-stu-id="700ad-149">The arithmetic rules in Direct3D 10 and later don't make any distinctions between quiet and signaling NaN values (QNaN versus SNaN).</span></span> <span data-ttu-id="700ad-150">Toutes les valeurs NaN sont gérées de la même façon.</span><span class="sxs-lookup"><span data-stu-id="700ad-150">All NaN values are handled the same way.</span></span> <span data-ttu-id="700ad-151">Dans le cas de min et Max, le comportement Direct3D pour toute valeur NaN est semblable à la façon dont QNaN est géré dans la définition IEEE-754R.</span><span class="sxs-lookup"><span data-stu-id="700ad-151">In the case of min and max, the Direct3D behavior for any NaN value is like how QNaN is handled in the IEEE-754R definition.</span></span> <span data-ttu-id="700ad-152">(Pour l’exhaustivité : si les deux entrées sont NaN, toute valeur NaN est retournée.)</span><span class="sxs-lookup"><span data-stu-id="700ad-152">(For completeness - if both inputs are NaN, any NaN value is returned.)</span></span>

-   <span data-ttu-id="700ad-153">Une autre règle IEEE 754R est que min (-0, + 0) = = min (+ 0,-0) = =-0 et Max (-0, + 0) = = max (+ 0,-0) = = + 0, qui honore le signe, contrairement aux règles de comparaison pour le zéro signé (comme nous l’avons vu précédemment).</span><span class="sxs-lookup"><span data-stu-id="700ad-153">Another IEEE 754R rule is that min(-0,+0) == min(+0,-0) == -0, and max(-0,+0) == max(+0,-0) == +0, which honors the sign, in contrast to the comparison rules for signed zero (as we saw earlier).</span></span> <span data-ttu-id="700ad-154">Direct3D recommande le comportement IEEE 754R ici, mais ne l’applique pas. Il est possible que le résultat de la comparaison des zéros dépende de l’ordre des paramètres, à l’aide d’une comparaison qui ignore les signes.</span><span class="sxs-lookup"><span data-stu-id="700ad-154">Direct3D recommends the IEEE 754R behavior here, but doesn't enforce it; it is permissible for the result of comparing zeros to be dependent on the order of parameters, using a comparison that ignores the signs.</span></span>
-   <span data-ttu-id="700ad-155">x \* 1.0 f aboutit toujours à x (sauf denorme Flush).</span><span class="sxs-lookup"><span data-stu-id="700ad-155">x\*1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="700ad-156">x/1.0 a toujours pour résultat x (à l’exception de la dénorme Flush).</span><span class="sxs-lookup"><span data-stu-id="700ad-156">x/1.0f always results in x (except denorm flushed).</span></span>
-   <span data-ttu-id="700ad-157">x +/-0.0 f produit toujours x (à l’exception de la dénorme Flush).</span><span class="sxs-lookup"><span data-stu-id="700ad-157">x +/- 0.0f always results in x (except denorm flushed).</span></span> <span data-ttu-id="700ad-158">Mais-0 + 0 = + 0.</span><span class="sxs-lookup"><span data-stu-id="700ad-158">But -0 + 0 = +0.</span></span>
-   <span data-ttu-id="700ad-159">Les opérations fusionnées (par exemple, Mad, DP3) produisent des résultats qui ne sont pas moins précis que le plus mauvais ordonnancement en série de l’évaluation de l’expansion déroutée de l’opération.</span><span class="sxs-lookup"><span data-stu-id="700ad-159">Fused operations (such as mad, dp3) produce results that are no less accurate than the worst possible serial ordering of evaluation of the unfused expansion of the operation.</span></span> <span data-ttu-id="700ad-160">La définition du pire classement possible, dans le but de la tolérance, n’est pas une définition fixe pour une opération fusionnée donnée. elle dépend des valeurs particulières des entrées.</span><span class="sxs-lookup"><span data-stu-id="700ad-160">The definition of the worst possible ordering, for the purpose of tolerance, is not a fixed definition for a given fused operation; it depends on the particular values of the inputs.</span></span> <span data-ttu-id="700ad-161">Les étapes individuelles de l’expansion sans fusible sont chacune autorisées 1 tolérance ULP (ou pour toutes les instructions Direct3D appelle avec une tolérance plus Lax que 1 ULP, la tolérance la plus LAX est autorisée).</span><span class="sxs-lookup"><span data-stu-id="700ad-161">The individual steps in the unfused expansion are each allowed 1 ULP tolerance (or for any instructions Direct3D calls out with a more lax tolerance than 1 ULP, the more lax tolerance is allowed).</span></span>
-   <span data-ttu-id="700ad-162">Les opérations fusionnées adhèrent aux mêmes règles NaN que les opérations non fusionnées.</span><span class="sxs-lookup"><span data-stu-id="700ad-162">Fused operations adhere to the same NaN rules as non-fused operations.</span></span>
-   <span data-ttu-id="700ad-163">sqrt et RCP ont 1 tolérance ULP.</span><span class="sxs-lookup"><span data-stu-id="700ad-163">sqrt and rcp have 1 ULP tolerance.</span></span> <span data-ttu-id="700ad-164">Les instructions de la racine carrée de nuanceur réciproque et réciproque, [**RCP**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) et [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), ont leur propre exigence de précision souple distincte.</span><span class="sxs-lookup"><span data-stu-id="700ad-164">The shader reciprocal and reciprocal square-root instructions, [**rcp**](/previous-versions/windows/desktop/legacy/hh447205(v=vs.85)) and [**rsq**](/windows/desktop/direct3dhlsl/rsq--sm4---asm-), have their own separate relaxed precision requirement.</span></span>
-   <span data-ttu-id="700ad-165">La multiplication et la Division de chacune fonctionnent au niveau de précision à virgule flottante 32 bits (précision à 0,5 ULP pour multiplier, 1,0 ULP pour réciproque).</span><span class="sxs-lookup"><span data-stu-id="700ad-165">Multiply and divide each operate at the 32-bit floating-point precision level (accuracy to 0.5 ULP for multiply, 1.0 ULP for reciprocal).</span></span> <span data-ttu-id="700ad-166">Si x/y est implémenté directement, les résultats doivent être d’une précision supérieure ou égale à celle d’une méthode en deux étapes.</span><span class="sxs-lookup"><span data-stu-id="700ad-166">If x/y is implemented directly, results must be of greater or equal accuracy than a two-step method.</span></span>

## <a name="64-bit-double-precision-floating-point-rules"></a><span data-ttu-id="700ad-167">règles à virgule flottante 64 bits (double précision)</span><span class="sxs-lookup"><span data-stu-id="700ad-167">64-bit (double precision) floating point rules</span></span>

<span data-ttu-id="700ad-168">Le matériel et les pilotes d’affichage prennent éventuellement en charge la virgule flottante double précision.</span><span class="sxs-lookup"><span data-stu-id="700ad-168">Hardware and display drivers optionally support double-precision floating-point.</span></span> <span data-ttu-id="700ad-169">Pour indiquer la prise en charge, quand vous appelez [**ID3D11Device :: CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) avec [**d3d11 \_ Feature \_ double**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), le pilote affecte la valeur true à **DoublePrecisionFloatShaderOps** de données de la [**\_ fonctionnalité \_ \_ d3d11**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) .</span><span class="sxs-lookup"><span data-stu-id="700ad-169">To indicate support, when you call [**ID3D11Device::CheckFeatureSupport**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-checkfeaturesupport) with [**D3D11\_FEATURE\_DOUBLES**](/windows/desktop/api/D3D11/ne-d3d11-d3d11_feature), the driver sets **DoublePrecisionFloatShaderOps** of [**D3D11\_FEATURE\_DATA\_DOUBLES**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_feature_data_doubles) to TRUE.</span></span> <span data-ttu-id="700ad-170">Le pilote et le matériel doivent ensuite prendre en charge toutes les instructions à virgule flottante double précision.</span><span class="sxs-lookup"><span data-stu-id="700ad-170">The driver and hardware must then support all double-precision floating-point instructions.</span></span>

<span data-ttu-id="700ad-171">Les instructions à double précision suivent les spécifications de comportement IEEE 754R.</span><span class="sxs-lookup"><span data-stu-id="700ad-171">Double-precision instructions follow IEEE 754R behavior requirements.</span></span>

<span data-ttu-id="700ad-172">La prise en charge de la génération de valeurs dénormalisées est requise pour les données à double précision (aucun comportement de vidage à zéro).</span><span class="sxs-lookup"><span data-stu-id="700ad-172">Support for generation of denormalized values is required for double-precision data (no flush-to-zero behavior).</span></span> <span data-ttu-id="700ad-173">De même, les instructions ne lisent pas les données dénormalisées comme un zéro signé, elles respectent la valeur de la norme.</span><span class="sxs-lookup"><span data-stu-id="700ad-173">Likewise, instructions don't read denormalized data as a signed zero, they honor the denorm value.</span></span>

## <a name="16-bit-floating-point-rules"></a><span data-ttu-id="700ad-174">règles à virgule flottante 16 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-174">16-bit floating-point rules</span></span>

<span data-ttu-id="700ad-175">Direct3D 11 prend également en charge les représentations 16 bits des nombres à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="700ad-175">Direct3D 11 also supports 16-bit representations of floating-point numbers.</span></span>

<span data-ttu-id="700ad-176">Format:</span><span class="sxs-lookup"><span data-stu-id="700ad-176">Format:</span></span>

-   <span data-ttu-id="700ad-177">1 bit (s) de signe dans la position de bit du MSB</span><span class="sxs-lookup"><span data-stu-id="700ad-177">1 sign bit (s)in the MSB bit position</span></span>
-   <span data-ttu-id="700ad-178">5 bits d’exposant biaisé (e)</span><span class="sxs-lookup"><span data-stu-id="700ad-178">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="700ad-179">10 bits de fraction (f), avec un bit masqué supplémentaire</span><span class="sxs-lookup"><span data-stu-id="700ad-179">10 bits of fraction (f), with an additional hidden bit</span></span>

<span data-ttu-id="700ad-180">Une valeur float16 (v) suit les règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="700ad-180">A float16 value (v) follows these rules:</span></span>

-   <span data-ttu-id="700ad-181">Si e = = 31 et f ! = 0, alors v est NaN indépendamment de s</span><span class="sxs-lookup"><span data-stu-id="700ad-181">if e == 31 and f != 0, then v is NaN regardless of s</span></span>
-   <span data-ttu-id="700ad-182">Si e = = 31 et f = = 0, v = (-1) s \* infini (infini signé)</span><span class="sxs-lookup"><span data-stu-id="700ad-182">if e == 31 and f == 0, then v = (-1)s\*infinity (signed infinity)</span></span>
-   <span data-ttu-id="700ad-183">Si e est compris entre 0 et 31, v = (-1) s \* 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="700ad-183">if e is between 0 and 31, then v = (-1)s\*2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="700ad-184">Si e = = 0 et f ! = 0, alors v = (-1) s \* 2 (e-14) \* (0. f) (nombres dénormalisés)</span><span class="sxs-lookup"><span data-stu-id="700ad-184">if e == 0 and f != 0, then v = (-1)s\*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="700ad-185">Si e = = 0 et f = = 0, v = (-1) s \* 0 (zéro signé)</span><span class="sxs-lookup"><span data-stu-id="700ad-185">if e == 0 and f == 0, then v = (-1)s\*0 (signed zero)</span></span>

<span data-ttu-id="700ad-186">les règles à virgule flottante 32 bits sont également conservées pour les nombres à virgule flottante 16 bits, ajustées pour la disposition en bits décrite précédemment.</span><span class="sxs-lookup"><span data-stu-id="700ad-186">32-bit floating-point rules also hold for 16-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="700ad-187">Les exceptions à cette règle sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="700ad-187">Exceptions to this include:</span></span>

-   <span data-ttu-id="700ad-188">Précision : les opérations non ancrées sur les nombres à virgule flottante 16 bits produisent un résultat qui est la valeur représentable la plus proche d’un résultat à précision infinie (arrondi au plus proche pair, par IEEE-754, appliqué aux valeurs 16 bits).</span><span class="sxs-lookup"><span data-stu-id="700ad-188">Precision: Unfused operations on 16-bit floating-point numbers produce a result that is the nearest representable value to an infinitely-precise result (round to nearest even, per IEEE-754, applied to 16-bit values).</span></span> <span data-ttu-id="700ad-189">les règles à virgule flottante 32 bits adhèrent à 1 tolérance ULP, les règles à virgule flottante de 16 bits adhèrent à 0,5 ULP pour les opérations non fusionnées et 0,6 ULP pour les opérations fusionnées.</span><span class="sxs-lookup"><span data-stu-id="700ad-189">32-bit floating-point rules adhere to 1 ULP tolerance, 16-bit floating-point rules adhere to 0.5 ULP for unfused operations, and 0.6 ULP for fused operations.</span></span>
-   <span data-ttu-id="700ad-190">les nombres à virgule flottante 16 bits préservent les dénormes.</span><span class="sxs-lookup"><span data-stu-id="700ad-190">16-bit floating-point numbers preserve denorms.</span></span>

## <a name="11-bit-and-10-bit-floating-point-rules"></a><span data-ttu-id="700ad-191">règles à virgule flottante 11 bits et 10 bits</span><span class="sxs-lookup"><span data-stu-id="700ad-191">11-bit and 10-bit floating-point rules</span></span>

<span data-ttu-id="700ad-192">Direct3D 11 prend également en charge les formats à virgule flottante 11 bits et 10 bits.</span><span class="sxs-lookup"><span data-stu-id="700ad-192">Direct3D 11 also supports 11-bit and 10-bit floating-point formats.</span></span>

<span data-ttu-id="700ad-193">Format:</span><span class="sxs-lookup"><span data-stu-id="700ad-193">Format:</span></span>

-   <span data-ttu-id="700ad-194">Aucun bit de signe</span><span class="sxs-lookup"><span data-stu-id="700ad-194">No sign bit</span></span>
-   <span data-ttu-id="700ad-195">5 bits d’exposant biaisé (e)</span><span class="sxs-lookup"><span data-stu-id="700ad-195">5 bits of biased exponent (e)</span></span>
-   <span data-ttu-id="700ad-196">6 bits de fraction (f) pour un format 11 bits, 5 bits de fraction (f) pour un format 10 bits, avec un bit masqué supplémentaire dans les deux cas.</span><span class="sxs-lookup"><span data-stu-id="700ad-196">6 bits of fraction (f) for an 11-bit format, 5 bits of fraction (f) for a 10-bit format, with an additional hidden bit in either case.</span></span>

<span data-ttu-id="700ad-197">Une valeur float11/float10 (v) respecte les règles suivantes :</span><span class="sxs-lookup"><span data-stu-id="700ad-197">A float11/float10 value (v) follows the following rules:</span></span>

-   <span data-ttu-id="700ad-198">Si e = = 31 et f ! = 0, alors v est NaN</span><span class="sxs-lookup"><span data-stu-id="700ad-198">if e == 31 and f != 0, then v is NaN</span></span>
-   <span data-ttu-id="700ad-199">Si e = = 31 et f = = 0, alors v = + Infinity</span><span class="sxs-lookup"><span data-stu-id="700ad-199">if e == 31 and f == 0, then v = +infinity</span></span>
-   <span data-ttu-id="700ad-200">Si e est compris entre 0 et 31, v = 2 (e-15) \* (1. f)</span><span class="sxs-lookup"><span data-stu-id="700ad-200">if e is between 0 and 31, then v = 2(e-15)\*(1.f)</span></span>
-   <span data-ttu-id="700ad-201">Si e = = 0 et f ! = 0, alors v = \* 2 (e-14) \* (0. f) (nombres dénormalisés)</span><span class="sxs-lookup"><span data-stu-id="700ad-201">if e == 0 and f != 0, then v = \*2(e-14)\*(0.f) (denormalized numbers)</span></span>
-   <span data-ttu-id="700ad-202">Si e = = 0 et f = = 0, alors v = 0 (zéro)</span><span class="sxs-lookup"><span data-stu-id="700ad-202">if e == 0 and f == 0, then v = 0 (zero)</span></span>

<span data-ttu-id="700ad-203">les règles à virgule flottante 32 bits contiennent également des nombres à virgule flottante de 11 et 10 bits, ajustés pour la disposition en bits décrite précédemment.</span><span class="sxs-lookup"><span data-stu-id="700ad-203">32-bit floating-point rules also hold for 11-bit and 10-bit floating-point numbers, adjusted for the bit layout described earlier.</span></span> <span data-ttu-id="700ad-204">Voici certaines exceptions :</span><span class="sxs-lookup"><span data-stu-id="700ad-204">Exceptions include:</span></span>

-   <span data-ttu-id="700ad-205">Précision : les règles à virgule flottante 32 bits adhèrent à 0,5 ULP.</span><span class="sxs-lookup"><span data-stu-id="700ad-205">Precision: 32-bit floating-point rules adhere to 0.5 ULP.</span></span>
-   <span data-ttu-id="700ad-206">les nombres à virgule flottante 10/11 bits préservent les dénormes.</span><span class="sxs-lookup"><span data-stu-id="700ad-206">10/11-bit floating-point numbers preserve denorms.</span></span>
-   <span data-ttu-id="700ad-207">Toute opération qui aboutirait à un nombre inférieur à zéro est ancrée à zéro.</span><span class="sxs-lookup"><span data-stu-id="700ad-207">Any operation that would result in a number less than zero is clamped to zero.</span></span>

## <a name="related-topics"></a><span data-ttu-id="700ad-208">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="700ad-208">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="700ad-209">Ressources</span><span class="sxs-lookup"><span data-stu-id="700ad-209">Resources</span></span>](overviews-direct3d-11-resources.md)
</dt> <dt>

[<span data-ttu-id="700ad-210">Textures</span><span class="sxs-lookup"><span data-stu-id="700ad-210">Textures</span></span>](overviews-direct3d-11-resources-textures.md)
</dt> </dl>

 

 