---
title: Modèle pour les systèmes distribués
description: Traditionnellement, le fait de disposer d’un système monolithique s’exécutant sur plusieurs ordinateurs signifiait le fractionnement du système en composants distincts du client et du serveur.
ms.assetid: 6055bcef-e34c-4f2d-92b9-9aec75cf3cec
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 82cd1ea3301d68e77562a63c542bc075692e5192
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103939792"
---
# <a name="the-model-for-distributed-systems"></a><span data-ttu-id="935be-103">Modèle pour les systèmes distribués</span><span class="sxs-lookup"><span data-stu-id="935be-103">The Model for Distributed Systems</span></span>

<span data-ttu-id="935be-104">Traditionnellement, le fait de disposer d’un système monolithique s’exécutant sur plusieurs ordinateurs signifiait le fractionnement du système en composants distincts du client et du serveur.</span><span class="sxs-lookup"><span data-stu-id="935be-104">Traditionally, having a monolithic system run across multiple computers meant splitting the system into separate client and server components.</span></span> <span data-ttu-id="935be-105">Dans ces systèmes, le composant client gérait l’interface utilisateur et le serveur a fourni le traitement principal, tel que l’accès à la base de données, l’impression, etc.</span><span class="sxs-lookup"><span data-stu-id="935be-105">In such systems, the client component handled the user interface and the server provided back-end processing, such as database access, printing, and so on.</span></span> <span data-ttu-id="935be-106">À mesure que les ordinateurs proliféraient, chutent et étaient connectés par des réseaux à bande passante jamais supérieure, le fractionnement des systèmes logiciels en plusieurs composants est devenu plus pratique, chaque composant s’exécutant sur un autre ordinateur et effectuant une fonction spécialisée.</span><span class="sxs-lookup"><span data-stu-id="935be-106">As computers proliferated, dropped in cost, and became connected by ever-higher bandwidth networks, splitting software systems into multiple components became more convenient, with each component running on a different computer and performing a specialized function.</span></span> <span data-ttu-id="935be-107">Cette approche simplifie le développement, la gestion, l’administration et améliore souvent les performances et la robustesse, car la défaillance d’un ordinateur n’a pas nécessairement désactivé l’ensemble du système.</span><span class="sxs-lookup"><span data-stu-id="935be-107">This approach simplified development, management, administration, and often improved performance and robustness, since failure in one computer did not necessarily disable the entire system.</span></span>

<span data-ttu-id="935be-108">Dans de nombreux cas, le système apparaît au client sous la forme d’un Cloud opaque qui effectue les opérations nécessaires, même si le système distribué est composé de nœuds individuels, comme illustré dans la figure suivante.</span><span class="sxs-lookup"><span data-stu-id="935be-108">In many cases the system appears to the client as an opaque cloud that performs the necessary operations, even though the distributed system is composed of individual nodes, as illustrated in the following figure.</span></span>

![les clients accèdent aux services d’un système de serveurs RPC qui apparaît comme Cloud opaque pour les clients externes](images/indy-nodes.png)

<span data-ttu-id="935be-110">L’opacité du Cloud est maintenue car les opérations informatiques sont appelées pour le compte du client.</span><span class="sxs-lookup"><span data-stu-id="935be-110">The opacity of the cloud is maintained because computing operations are invoked on behalf of the client.</span></span> <span data-ttu-id="935be-111">Ainsi, les clients peuvent localiser un ordinateur (un *nœud*) dans le Cloud et demander une opération donnée. lors de l’exécution de l’opération, cet ordinateur peut appeler des fonctionnalités sur d’autres ordinateurs dans le Cloud sans exposer les étapes supplémentaires, ou l’ordinateur sur lequel ils ont été exécutés, au client.</span><span class="sxs-lookup"><span data-stu-id="935be-111">As such, clients can locate a computer (a *node*) within the cloud and request a given operation; in performing the operation, that computer can invoke functionality on other computers within the cloud without exposing the additional steps, or the computer on which they were carried out, to the client.</span></span>

<span data-ttu-id="935be-112">Avec ce paradigme, les mécanismes d’un système distribué et similaire au Cloud peuvent être répartis en nombreux échanges de paquets individuels ou conversations entre les nœuds individuels.</span><span class="sxs-lookup"><span data-stu-id="935be-112">With this paradigm, the mechanics of a distributed, cloud-like system can be broken down into many individual packet exchanges, or conversations between individual nodes.</span></span>

<span data-ttu-id="935be-113">Les systèmes client-serveur traditionnels ont deux nœuds avec des rôles et des responsabilités fixes.</span><span class="sxs-lookup"><span data-stu-id="935be-113">Traditional client-server systems have two nodes with fixed roles and responsibilities.</span></span> <span data-ttu-id="935be-114">Les systèmes distribués modernes peuvent comporter plus de deux nœuds, et leurs rôles sont souvent dynamiques.</span><span class="sxs-lookup"><span data-stu-id="935be-114">Modern-distributed systems can have more than two nodes, and their roles are often dynamic.</span></span> <span data-ttu-id="935be-115">Dans une conversation, un nœud peut être un client, alors que dans une autre conversation, le nœud peut être le serveur.</span><span class="sxs-lookup"><span data-stu-id="935be-115">In one conversation a node can be a client, while in another conversation the node can be the server.</span></span> <span data-ttu-id="935be-116">Dans de nombreux cas, le consommateur ultime de la fonctionnalité exposée est un client avec un utilisateur assis dans un clavier, qui regarde la sortie.</span><span class="sxs-lookup"><span data-stu-id="935be-116">In many cases, the ultimate consumer of the exposed functionality is a client with a user sitting at a keyboard, watching the output.</span></span> <span data-ttu-id="935be-117">Dans d’autres cas, le système distribué fonctionne sans assistance, en effectuant des opérations en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="935be-117">In other cases the distributed system functions unattended, performing background operations.</span></span>

<span data-ttu-id="935be-118">Le système distribué ne dispose peut-être pas de clients et de serveurs dédiés pour chaque échange de paquets particulier, mais il est important de se souvenir qu’il existe un appelant, (ou initiateur, qui est souvent appelé client).</span><span class="sxs-lookup"><span data-stu-id="935be-118">The distributed system may not have dedicated clients and servers for each particular packet exchange, but it is important to remember there is a caller, (or initiator, either of which is often referred to as the client).</span></span> <span data-ttu-id="935be-119">Il y a également le destinataire de l’appel (souvent appelé serveur).</span><span class="sxs-lookup"><span data-stu-id="935be-119">There is also the recipient of the call (often referred to as the server).</span></span> <span data-ttu-id="935be-120">Il n’est pas nécessaire d’avoir des échanges de paquets bidirectionnels dans le format de demande-réponse d’un système distribué. souvent, les messages ne sont envoyés qu’une seule fois.</span><span class="sxs-lookup"><span data-stu-id="935be-120">It is not necessary to have two-way packet exchanges in the request-reply format of a distributed system; often messages are sent only one way.</span></span>

 

 




