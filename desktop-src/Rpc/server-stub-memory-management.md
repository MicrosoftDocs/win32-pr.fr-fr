---
title: Gestion de la mémoire stub serveur
description: Gestion de la mémoire stub serveur
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Gestion de la mémoire stub serveur
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6e052df6da999e5371ac498a1d39852b4be2b5e
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/08/2020
ms.locfileid: "103842826"
---
# <a name="server-stub-memory-management"></a><span data-ttu-id="69fb1-104">Gestion de la mémoire stub serveur</span><span class="sxs-lookup"><span data-stu-id="69fb1-104">Server Stub Memory Management</span></span>

## <a name="an-introduction-to-server-stub-memory-management"></a><span data-ttu-id="69fb1-105">Présentation de la gestion de la mémoire Server-Stub</span><span class="sxs-lookup"><span data-stu-id="69fb1-105">An Introduction to Server-Stub Memory Management</span></span>

<span data-ttu-id="69fb1-106">Les stubs générés par MIDL jouent le rôle d’interface entre un processus client et un processus serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-106">MIDL-generated stubs act as the interface between a client process and a server process.</span></span> <span data-ttu-id="69fb1-107">Un stub client marshale toutes les données passées aux paramètres marqués avec l’attribut [**\[ in \]**](../midl/in.md) , puis les envoie au stub serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-107">A client stub marshals all data passed to parameters marked with the [**\[in\]**](../midl/in.md) attribute, and sends it to the server stub.</span></span> <span data-ttu-id="69fb1-108">Le stub de serveur, lors de la réception de ces données, reconstruit la pile des appels, puis exécute la fonction de serveur implémentée par l’utilisateur correspondante.</span><span class="sxs-lookup"><span data-stu-id="69fb1-108">The server stub, upon receiving this data, reconstructs the call stack, and then executes the corresponding user-implemented server function.</span></span> <span data-ttu-id="69fb1-109">Le stub serveur marshale également les données de paramètre marquées avec l’attribut [**\[ out \]**](../midl/out-idl.md) et les retourne à l’application cliente.</span><span class="sxs-lookup"><span data-stu-id="69fb1-109">The server stub also marshals the parameter data marked with the [**\[out\]**](../midl/out-idl.md) attribute and returns it to the client application.</span></span>

<span data-ttu-id="69fb1-110">Le format de données marshalé 32 bits utilisé par MSRPC est une version conforme de la syntaxe de transfert de représentation de données réseau (NDR).</span><span class="sxs-lookup"><span data-stu-id="69fb1-110">The 32-bit marshaled data format used by MSRPC is a compliant version of the Network Data Representation (NDR) transfer syntax.</span></span> <span data-ttu-id="69fb1-111">Pour plus d’informations sur ce format, consultez [le site Web du groupe ouvert](https://www.opengroup.org/).</span><span class="sxs-lookup"><span data-stu-id="69fb1-111">For more information about this format, see [The Open Group website](https://www.opengroup.org/).</span></span> <span data-ttu-id="69fb1-112">Pour les plateformes 64 bits, une extension Microsoft 64 bits à la syntaxe de transfert NDR appelée NDR64 peut être utilisée pour de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="69fb1-112">For 64-bit platforms, a Microsoft 64-bit extension to NDR transfer syntax called NDR64 can be used for better performance.</span></span>

## <a name="unmarshaling-inbound-data"></a><span data-ttu-id="69fb1-113">Démarshaling de données entrantes</span><span class="sxs-lookup"><span data-stu-id="69fb1-113">Unmarshaling Inbound Data</span></span>

<span data-ttu-id="69fb1-114">Dans MSRPC, le stub client marshale toutes les données de paramètre marquées comme [**\[ dans \]**](../midl/in.md) dans une mémoire tampon continue pour la transmission au stub serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-114">In MSRPC, the client stub marshals all of the parameter data tagged as [**\[in\]**](../midl/in.md) in one continuous buffer for transmission to the server stub.</span></span> <span data-ttu-id="69fb1-115">De même, le stub serveur marshale toutes les données marquées avec l’attribut [**\[ out \]**](../midl/out-idl.md) dans une mémoire tampon continue pour revenir au stub client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-115">Likewise, the server stub marshals all data marked with the [**\[out\]**](../midl/out-idl.md) attribute in a continuous buffer for return to the client stub.</span></span> <span data-ttu-id="69fb1-116">Alors que la couche de protocole réseau sous RPC peut fragmenter et transmettre la mémoire tampon à la transmission, la fragmentation est transparente pour les stubs RPC.</span><span class="sxs-lookup"><span data-stu-id="69fb1-116">While the network protocol layer beneath RPC can fragment and packetize the buffer for transmission, the fragmentation is transparent to the RPC stubs.</span></span>

<span data-ttu-id="69fb1-117">L’allocation de mémoire pour la création de la trame d’appel du serveur peut être une opération coûteuse.</span><span class="sxs-lookup"><span data-stu-id="69fb1-117">Memory allocation for creating the server call frame can be an expensive operation.</span></span> <span data-ttu-id="69fb1-118">Le stub serveur tentera de réduire l’utilisation de mémoire inutile si possible, et il est supposé que la routine de serveur ne libérera pas ou ne réalloue pas de données marquées avec les attributs [**\[ in \]**](../midl/in.md) ou **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="69fb1-118">The server stub will attempt to minimize unnecessary memory usage when possible, and it is assumed that the server routine will not free or reallocate data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="69fb1-119">Chaque fois que cela est possible, le stub serveur tente de réutiliser les données dans la mémoire tampon afin d’éviter toute duplication inutile.</span><span class="sxs-lookup"><span data-stu-id="69fb1-119">The server stub attempts to reuse data in the buffer whenever possible to avoid unnecessary duplication.</span></span> <span data-ttu-id="69fb1-120">La règle générale est que si le format de données marshalé est le même que celui de la mémoire, RPC utilise des pointeurs vers les données regroupées au lieu d’allouer de la mémoire supplémentaire pour les données mises en forme de manière identique.</span><span class="sxs-lookup"><span data-stu-id="69fb1-120">The general rule is that if the marshaled data format is the same as the memory format, RPC will use pointers to the marshalled data instead of allocating additional memory for identically formatted data.</span></span>

<span data-ttu-id="69fb1-121">Par exemple, l’appel RPC suivant est défini avec une structure dont le format marshalé est identique à son format en mémoire.</span><span class="sxs-lookup"><span data-stu-id="69fb1-121">For example, the following RPC call is defined with a structure whose marshaled format is identical to its in-memory format.</span></span>

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

<span data-ttu-id="69fb1-122">Dans ce cas, RPC n’alloue pas de mémoire supplémentaire pour les données référencées par *plInStructure*; au lieu de cela, il passe simplement le pointeur vers les données marshalées à l’implémentation de fonction côté serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-122">In this case, RPC does not allocate additional memory for the data referenced by *plInStructure*; rather, it simply passes the pointer to the marshaled data to the server-side function implementation.</span></span> <span data-ttu-id="69fb1-123">Le stub du serveur RPC vérifie la mémoire tampon pendant le processus d’démarshaling si le stub est compilé à l’aide de l’indicateur « -Solid » (qui est un paramètre par défaut dans la version récente nmost du compilateur MIDL).</span><span class="sxs-lookup"><span data-stu-id="69fb1-123">The RPC server stub verifies the buffer during the unmarshaling process if the stub is compiled using the "-robust" flag (which is a default setting in the nmost recent version of the MIDL compiler).</span></span> <span data-ttu-id="69fb1-124">RPC garantit que les données passées à l’implémentation de la fonction côté serveur sont valides.</span><span class="sxs-lookup"><span data-stu-id="69fb1-124">RPC guarantees that the data passed to the server-side function implementation is valid.</span></span>

<span data-ttu-id="69fb1-125">N’oubliez pas que la mémoire est allouée à *plOutStructure*, car aucune donnée n’est transmise au serveur pour celle-ci.</span><span class="sxs-lookup"><span data-stu-id="69fb1-125">Be aware that memory is allocated for *plOutStructure*, since no data is passed to the server for it.</span></span>

## <a name="memory-allocation-for-inbound-data"></a><span data-ttu-id="69fb1-126">Allocation de mémoire pour les données entrantes</span><span class="sxs-lookup"><span data-stu-id="69fb1-126">Memory Allocation for Inbound Data</span></span>

<span data-ttu-id="69fb1-127">Des cas peuvent se produire lorsque le stub de serveur alloue de la mémoire pour les données de paramètre marquées avec les attributs [**\[ in \]**](../midl/in.md) ou **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="69fb1-127">Cases can arise where the server stub allocates memory for parameter data marked with the [**\[in\]**](../midl/in.md) or **\[in, out\]** attributes.</span></span> <span data-ttu-id="69fb1-128">Cela se produit lorsque le format de données marshalé diffère du format de mémoire, ou lorsque les structures qui composent les données marshalées sont suffisamment complexes et doivent être lues de manière atomique par le stub du serveur RPC.</span><span class="sxs-lookup"><span data-stu-id="69fb1-128">This occurs when the marshaled data format differs from the memory format, or when the structures that comprise the marshaled data are sufficient complex and must be read atomically by the RPC server stub.</span></span> <span data-ttu-id="69fb1-129">La liste ci-dessous présente plusieurs cas courants lorsque la mémoire doit être allouée pour les données reçues par le stub serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-129">Listed below are several common cases when memory must be allocated for data received by the server stub.</span></span>

-   <span data-ttu-id="69fb1-130">Les données sont un tableau variable ou un tableau variable conforme.</span><span class="sxs-lookup"><span data-stu-id="69fb1-130">The data is a varying array or a conformant varying array.</span></span> <span data-ttu-id="69fb1-131">Il s’agit de tableaux (ou de pointeurs vers des tableaux) dont la [**\[ longueur \_ est ( \] )**](../midl/length-is.md) ou le [**\[ premier attribut \_ est () \]**](../midl/first-is.md) défini sur ces derniers.</span><span class="sxs-lookup"><span data-stu-id="69fb1-131">These are arrays (or pointers to arrays) that have the [**\[length\_is()\]**](../midl/length-is.md) or [**\[first\_is()\]**](../midl/first-is.md) attribute set on them.</span></span> <span data-ttu-id="69fb1-132">Dans le rapport de non-remise, seul le premier élément de ces tableaux est marshalé et transmis.</span><span class="sxs-lookup"><span data-stu-id="69fb1-132">In NDR, only the first element of these arrays are marshaled and transmitted.</span></span> <span data-ttu-id="69fb1-133">Par exemple, dans l’extrait de code ci-dessous, les données passées dans le paramètre *PV* auront une mémoire allouée.</span><span class="sxs-lookup"><span data-stu-id="69fb1-133">For example, in the code snippet below, the data passed in the parameter *pv* will have memory allocated for it.</span></span>

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   <span data-ttu-id="69fb1-134">Les données sont une chaîne dimensionnée ou une chaîne non conforme.</span><span class="sxs-lookup"><span data-stu-id="69fb1-134">The data is a sized string or non-conformant string.</span></span> <span data-ttu-id="69fb1-135">Ces chaînes sont généralement des pointeurs vers des données de caractères marqués avec l’attribut [**\[ size \_ is () \]**](../midl/size-is.md) .</span><span class="sxs-lookup"><span data-stu-id="69fb1-135">These strings are usually pointers to character data tagged with the [**\[size\_is()\]**](../midl/size-is.md) attribute.</span></span> <span data-ttu-id="69fb1-136">Dans l’exemple ci-dessous, la chaîne transmise à la fonction côté serveur **SizedString** aura une mémoire allouée, alors que la chaîne transmise à la fonction **NormalString** sera réutilisée.</span><span class="sxs-lookup"><span data-stu-id="69fb1-136">In the example below, the string passed to the **SizedString** server-side function will have memory allocated, whereas the string passed to the **NormalString** function will be reused.</span></span>

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   <span data-ttu-id="69fb1-137">Les données sont un type simple dont la taille de la mémoire diffère de sa taille marshalée, par exemple **enum16** et **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-137">The data is a simple type whose memory size differs from its marshaled size, such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="69fb1-138">Les données sont définies par une structure dont l’alignement de la mémoire est plus petit que l’alignement naturel, contient l’un des types de données ci-dessus ou a des remplissages d’octets de fin.</span><span class="sxs-lookup"><span data-stu-id="69fb1-138">The data is defined by a structure whose memory alignment is smaller than the natural alignment, contains any of the above data types, or has trailing byte padding.</span></span> <span data-ttu-id="69fb1-139">Par exemple, la structure de données complexe suivante a forcé l’alignement sur 2 octets et a un remplissage à la fin.</span><span class="sxs-lookup"><span data-stu-id="69fb1-139">For example, the following complex data structure has forced 2-byte alignment and has padding at the end.</span></span>

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   <span data-ttu-id="69fb1-140">Les données contiennent une structure qui doit être marshalée champ par champ.</span><span class="sxs-lookup"><span data-stu-id="69fb1-140">The data contains a structure that must be marshaled field by field.</span></span> <span data-ttu-id="69fb1-141">Ces champs incluent des pointeurs d’interface définis dans les interfaces DCOM. pointeurs ignorés ; valeurs entières définies avec l’attribut de [**\[ plage \]**](../midl/range.md) ; éléments de tableaux définis avec les attributs de [**\[ \_ \] marshaling de câble**](../midl/wire-marshal.md), d' [**\[ utilisateur \_ Marshal \]**](../midl/user-marshal.md), de [**\[ transmission \_ en tant \]**](../midl/transmit-as.md) que et de [**\[ représentation \_ sous forme \]**](../midl/represent-as.md) de données et structures de données complexes incorporées.</span><span class="sxs-lookup"><span data-stu-id="69fb1-141">These fields include interface pointers defined in DCOM interfaces; ignored pointers; integer values set with the [**\[range\]**](../midl/range.md) attribute; elements of arrays defined with the [**\[wire\_marshal\]**](../midl/wire-marshal.md), [**\[user\_marshal\]**](../midl/user-marshal.md), [**\[transmit\_as\]**](../midl/transmit-as.md) and [**\[represent\_as\]**](../midl/represent-as.md) attributes; and embedded complex data structures.</span></span>
-   <span data-ttu-id="69fb1-142">Les données contiennent une Union, une structure contenant une Union ou un tableau d’unions.</span><span class="sxs-lookup"><span data-stu-id="69fb1-142">The data contains a union, a structure containing a union, or an array of unions.</span></span> <span data-ttu-id="69fb1-143">Seule la branche spécifique de l’Union est marshalée sur le câble.</span><span class="sxs-lookup"><span data-stu-id="69fb1-143">Only the specific branch of the union is marshaled on the wire.</span></span>
-   <span data-ttu-id="69fb1-144">Les données contiennent une structure avec un tableau de conformité multidimensionnelle qui possède au moins une dimension non fixe.</span><span class="sxs-lookup"><span data-stu-id="69fb1-144">The data contains a structure with a multidimensional conformant array that has at least one non-fixed dimension.</span></span>
-   <span data-ttu-id="69fb1-145">Les données contiennent un tableau de structures complexes.</span><span class="sxs-lookup"><span data-stu-id="69fb1-145">The data contains an array of complex structures.</span></span>
-   <span data-ttu-id="69fb1-146">Les données contiennent un tableau de types de données simples tels que **enum16** et **\_ \_ int3264**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-146">The data contains an array of simple data types such as **enum16** and **\_\_int3264**.</span></span>
-   <span data-ttu-id="69fb1-147">Les données contiennent un tableau de pointeurs REF et interface.</span><span class="sxs-lookup"><span data-stu-id="69fb1-147">The data contains an array of ref and interface pointers.</span></span>
-   <span data-ttu-id="69fb1-148">Les données ont un attribut [**\[ force \_ allocate \]**](../midl/force-allocate.md) appliqué à un pointeur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-148">The data has a [**\[force\_allocate\]**](../midl/force-allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="69fb1-149">Les données ont un attribut [**\[ allocate (tous les \_ nœuds) \]**](../midl/allocate.md) appliqué à un pointeur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-149">The data has a [**\[allocate(all\_nodes)\]**](../midl/allocate.md) attribute applied to a pointer.</span></span>
-   <span data-ttu-id="69fb1-150">Les données ont un attribut de [**\[ \_ nombre \] d’octets**](../midl/byte-count.md) appliqué à un pointeur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-150">The data has a [**\[byte\_count\]**](../midl/byte-count.md) attribute applied to a pointer.</span></span>

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a><span data-ttu-id="69fb1-151">64 bits et syntaxe de transfert NDR64</span><span class="sxs-lookup"><span data-stu-id="69fb1-151">64-bit Data and NDR64 Transfer Syntax</span></span>

<span data-ttu-id="69fb1-152">Comme mentionné précédemment, les données 64 bits sont marshalées à l’aide d’une syntaxe de transfert 64 bits spécifique appelée NDR64.</span><span class="sxs-lookup"><span data-stu-id="69fb1-152">As mentioned previously, 64-bit data is marshalled using a specific 64-bit transfer syntax called NDR64.</span></span> <span data-ttu-id="69fb1-153">Cette syntaxe de transfert a été développée pour résoudre le problème spécifique qui survient lorsque les pointeurs sont marshalés sous un rapport de non-résolution 32 bits et transmis à un stub serveur sur une plateforme 64 bits.</span><span class="sxs-lookup"><span data-stu-id="69fb1-153">This transfer syntax was developed to address the specific issue that arises when pointers are marshaled under 32-bit NDR and transmitted to a server-stub on a 64-bit platform.</span></span> <span data-ttu-id="69fb1-154">Dans ce cas, un pointeur de données 32 bits marshalé ne correspond pas à une unité de 64 bits, et l’allocation de mémoire se produira invariablement.</span><span class="sxs-lookup"><span data-stu-id="69fb1-154">In this case, a marshaled 32-bit data pointer does not match a 64-bit one, and memory allocation will invariably occur.</span></span> <span data-ttu-id="69fb1-155">Pour créer un comportement plus cohérent sur les plateformes 64 bits, Microsoft a développé une nouvelle syntaxe de transfert appelée NDR64.</span><span class="sxs-lookup"><span data-stu-id="69fb1-155">To create a more consistent behavior on 64-bit platforms, Microsoft developed a new transfer syntax called NDR64.</span></span>

<span data-ttu-id="69fb1-156">Voici un exemple illustrant ce problème :</span><span class="sxs-lookup"><span data-stu-id="69fb1-156">An example illustrating this problem is as follows:</span></span>


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



<span data-ttu-id="69fb1-157">Cette structure, quand elle est marshalée, est réutilisée par le stub serveur sur un système 32 bits.</span><span class="sxs-lookup"><span data-stu-id="69fb1-157">This structure, when marshaled, will be reused by the server stub on a 32-bit system.</span></span> <span data-ttu-id="69fb1-158">Toutefois, si le stub serveur réside sur un système 64 bits, les données marshalées par NDR ont une longueur de 4 octets, mais la taille de mémoire requise sera de 8.</span><span class="sxs-lookup"><span data-stu-id="69fb1-158">However, if the server stub resides on a 64-bit system, the NDR-marshaled data is 4 bytes in length, but the required memory size will be 8.</span></span> <span data-ttu-id="69fb1-159">Par conséquent, l’allocation de mémoire est forcée et la réutilisation de la mémoire tampon se produit rarement.</span><span class="sxs-lookup"><span data-stu-id="69fb1-159">As a result, memory allocation is forced, and buffer reuse will rarely occur.</span></span> <span data-ttu-id="69fb1-160">NDR64 résout ce problème en transformant la taille marshalée d’un pointeur 64 bits.</span><span class="sxs-lookup"><span data-stu-id="69fb1-160">NDR64 addresses this problem by making the marshaled size of a pointer 64-bit.</span></span>

<span data-ttu-id="69fb1-161">Contrairement au NDR 32 bits, les Tyes de données simples, comme **enum16** et **\_ \_ int3264** , ne rendent pas une structure ou un tableau complexe sous NDR64.</span><span class="sxs-lookup"><span data-stu-id="69fb1-161">In contrast with 32-bit NDR, simple data tyes such as **enum16** and **\_\_int3264** do not make a structure or array complex under NDR64.</span></span> <span data-ttu-id="69fb1-162">De même, les valeurs de remplissage de fin ne rendent pas une structure complexe.</span><span class="sxs-lookup"><span data-stu-id="69fb1-162">Likewise, trailing pad values do not make a structure complex.</span></span> <span data-ttu-id="69fb1-163">Les pointeurs d’interface sont traités comme des pointeurs uniques au niveau supérieur ; par conséquent, les structures et les tableaux contenant des pointeurs d’interface ne sont pas considérés comme complexes et ne nécessitent pas d’allocation de mémoire spécifique pour leur utilisation.</span><span class="sxs-lookup"><span data-stu-id="69fb1-163">Interface pointers are treated as unique pointers at the top level; as a result, structures and arrays containing interface pointers are not considered complex and will not require specific memory allocation for their use.</span></span>

## <a name="initializing-outbound-data"></a><span data-ttu-id="69fb1-164">Initialisation des données sortantes</span><span class="sxs-lookup"><span data-stu-id="69fb1-164">Initializing Outbound Data</span></span>

<span data-ttu-id="69fb1-165">Une fois que toutes les données entrantes n’ont pas été marshalées, le stub serveur doit initialiser les pointeurs sortants uniquement marqués avec l’attribut [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="69fb1-165">After all of the inbound data has been unmarshalled, the server stub needs to initialize the outbound-only pointers marked with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span>


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



<span data-ttu-id="69fb1-166">Dans l’appel ci-dessus, le stub serveur doit initialiser *plOutStructure* , car il n’était pas présent dans les données marshalées, et il s’agit d’un pointeur [**\[ Ref \]**](../midl/ref.md) implicite qui doit être mis à la disposition de l’implémentation de la fonction serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-166">In the above call, the server stub must initialize *plOutStructure* because it was not present in the marshaled data, and it is an implied [**\[ref\]**](../midl/ref.md) pointer that must be made available to the server function implementation.</span></span> <span data-ttu-id="69fb1-167">Le stub de serveur RPC initialise et zéro les pointeurs de référence uniquement de niveau supérieur avec l’attribut [**\[ out \]**](../midl/out-idl.md) .</span><span class="sxs-lookup"><span data-stu-id="69fb1-167">The RPC server stub initializes and zeroes out any top-level reference-only pointers with the [**\[out\]**](../midl/out-idl.md) attribute.</span></span> <span data-ttu-id="69fb1-168">Les pointeurs de référence **\[ out \]** situés sous celui-ci sont également initialisés de manière récursive.</span><span class="sxs-lookup"><span data-stu-id="69fb1-168">Any **\[out\]** reference pointers beneath it are recursively initialized as well.</span></span> <span data-ttu-id="69fb1-169">La récursivité s’arrête à tous les pointeurs avec les attributs [**\[ uniques \]**](../midl/unique.md) ou [**\[ ptr \]**](../midl/ptr.md) définis.</span><span class="sxs-lookup"><span data-stu-id="69fb1-169">The recursion stops at any pointers with the [**\[unique\]**](../midl/unique.md) or [**\[ptr\]**](../midl/ptr.md) attributes set on them.</span></span>

<span data-ttu-id="69fb1-170">L’implémentation de fonction serveur ne peut pas modifier directement les valeurs de pointeur de niveau supérieur et ne peut donc pas les réallouer.</span><span class="sxs-lookup"><span data-stu-id="69fb1-170">The server function implementation cannot directly alter top-level pointer values, and thus cannot reallocate them.</span></span> <span data-ttu-id="69fb1-171">Par exemple, dans l’implémentation de **ProcessRpcStructure** ci-dessus, le code suivant n’est pas valide :</span><span class="sxs-lookup"><span data-stu-id="69fb1-171">For example, in the implementation of **ProcessRpcStructure** above, the following code is invalid:</span></span>


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



<span data-ttu-id="69fb1-172">*plOutStructure* est une valeur de pile et sa modification n’est pas propagée vers RPC.</span><span class="sxs-lookup"><span data-stu-id="69fb1-172">*plOutStructure* is a stack value and its change is not propagated back to RPC.</span></span> <span data-ttu-id="69fb1-173">L’implémentation de la fonction serveur peut tenter d’éviter l’allocation en tentant de libérer des *plOutStructure*, ce qui peut entraîner une altération de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="69fb1-173">The server function implementation can attempt to avoid allocation by attempting to free *plOutStructure*, which may result in memory corruption.</span></span> <span data-ttu-id="69fb1-174">Le stub serveur allouera ensuite de l’espace pour le pointeur de niveau supérieur en mémoire (dans le cas pointeur vers pointeur) et une structure simple de niveau supérieur dont la taille sur la pile est plus petite que prévu.</span><span class="sxs-lookup"><span data-stu-id="69fb1-174">The server stub will then allocate space for the top-level pointer in memory (in the pointer-to-pointer case) and a top-level simple structure whose size on the stack is smaller than expected.</span></span>

<span data-ttu-id="69fb1-175">Dans certains cas, le client peut spécifier la taille d’allocation de mémoire du côté serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-175">The client can, under certain circumstances, specify the memory allocation size of the server side.</span></span> <span data-ttu-id="69fb1-176">Dans l’exemple suivant, le client spécifie la taille des données sortantes dans le paramètre de *taille* entrante.</span><span class="sxs-lookup"><span data-stu-id="69fb1-176">In the following example, the client specifies the size of the outbound data in the inbound *size* parameter.</span></span>

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

<span data-ttu-id="69fb1-177">Après avoir démarshalé les données entrantes, y compris la *taille*, le stub serveur alloue une mémoire tampon pour *PV* avec une taille de « sizeof (Char) \* Size ».</span><span class="sxs-lookup"><span data-stu-id="69fb1-177">After unmarshalling the inbound data, including *size*, the server stub allocates a buffer for *pv* with a size of "sizeof(char)\*size".</span></span> <span data-ttu-id="69fb1-178">Une fois que l’espace a été alloué, le stub de serveur met à zéro la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="69fb1-178">After the space has been allocated, the server stub zeroes out the buffer.</span></span> <span data-ttu-id="69fb1-179">Notez que dans ce cas particulier, le stub alloue la mémoire avec l' **\_ allocation d’utilisateur MIDL \_ ()**, car la taille de la mémoire tampon est déterminée au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="69fb1-179">Note that in this particular case, the stub allocates the memory with **MIDL\_user\_allocate()**, since the size of the buffer is determined at runtime.</span></span>

<span data-ttu-id="69fb1-180">Sachez que dans le cas des interfaces DCOM, les stubs générés par MIDL peuvent ne pas être impliqués du tout si le client et le serveur partagent le même cloisonnement COM, ou si **ICallFrame** est implémenté.</span><span class="sxs-lookup"><span data-stu-id="69fb1-180">Be aware that in the case of DCOM interfaces, MIDL-generated stubs may not be involved at all if the client and server share the same COM apartment, or if **ICallFrame** is implemented.</span></span> <span data-ttu-id="69fb1-181">Dans ce cas, le serveur ne peut pas dépendre du comportement d’allocation et doit vérifier indépendamment la mémoire dimensionnée par le client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-181">In this case, the server cannot depend on the allocation behavior, and needs to independently verify client-sized memory.</span></span>

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a><span data-ttu-id="69fb1-182">Implémentations de fonctions côté serveur et marshaling de données sortantes</span><span class="sxs-lookup"><span data-stu-id="69fb1-182">Server-side Function Implementations and Outbound Data Marshaling</span></span>

<span data-ttu-id="69fb1-183">Immédiatement après le démarshaling des données entrantes et l’initialisation de la mémoire allouée pour contenir des données sortantes, le stub de serveur RPC exécute l’implémentation côté serveur de la fonction appelée par le client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-183">Immediately subsequent to the unmarshalling on inbound data and the initialization of the memory allocated to contain outbound data, the RPC server stub executes the server-side implementation of the function called by the client.</span></span> <span data-ttu-id="69fb1-184">À ce stade, le serveur peut modifier les données spécifiquement marquées avec l’attribut **\[ in \] , out** , et il peut remplir la mémoire allouée pour les données sortantes uniquement (les données marquées avec [**\[ out \]**](../midl/out-idl.md)).</span><span class="sxs-lookup"><span data-stu-id="69fb1-184">At this time, the server can modify the data specifically marked with the **\[in, out\]** attribute, and it can populate the memory allocated for outbound-only data (the data tagged with [**\[out\]**](../midl/out-idl.md)).</span></span>

<span data-ttu-id="69fb1-185">Les règles générales de manipulation des données de paramètre marshalé sont simples : le serveur peut uniquement allouer de la mémoire ou modifier la mémoire allouée spécifiquement par le stub serveur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-185">The general rules for the manipulation of marshalled parameter data are simple: the server can only allocate new memory or modify the memory specifically allocated by the server stub.</span></span> <span data-ttu-id="69fb1-186">La réallocation ou la libération de la mémoire existante pour les données peut avoir un impact négatif sur les résultats et les performances de l’appel de fonction, et peut être très difficile à déboguer.</span><span class="sxs-lookup"><span data-stu-id="69fb1-186">Reallocating or releasing existing memory for data can have a negative impact on the results and performance of the function call, and can be very difficult to debug.</span></span>

<span data-ttu-id="69fb1-187">Logiquement, le serveur RPC réside dans un espace d’adressage différent du client, et il est généralement supposé qu’ils ne partagent pas de mémoire.</span><span class="sxs-lookup"><span data-stu-id="69fb1-187">Logically, the RPC server lives in a different address space than the client, and it can generally be assumed that they do not share memory.</span></span> <span data-ttu-id="69fb1-188">Par conséquent, il est possible que l’implémentation de fonction serveur utilise les données marquées avec l’attribut [**\[ in \]**](../midl/in.md) comme mémoire « Scratch » sans affecter les adresses mémoire du client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-188">As a result, it is safe for the server function implementation to use the data marked with the [**\[in\]**](../midl/in.md) attribute as "scratch" memory without affecting the client memory addresses.</span></span> <span data-ttu-id="69fb1-189">Cela dit, le serveur ne doit pas tenter de réallouer ou **\[ de \]** libérer des données, ce qui laisse le contrôle de ces espaces au stub du serveur RPC lui-même.</span><span class="sxs-lookup"><span data-stu-id="69fb1-189">That said, the server should not attempt to reallocate or release **\[in\]** data, leaving the control of those spaces to the RPC server stub itself.</span></span>

<span data-ttu-id="69fb1-190">En général, l’implémentation de fonction serveur n’a pas besoin de réallouer ou de libérer des données marquées avec l’attribut **\[ in, out \]** .</span><span class="sxs-lookup"><span data-stu-id="69fb1-190">Generally, the server function implementation does not need to reallocate or release data marked with the **\[in, out\]** attribute.</span></span> <span data-ttu-id="69fb1-191">Pour les données de taille fixe, la logique d’implémentation de la fonction peut modifier directement les données.</span><span class="sxs-lookup"><span data-stu-id="69fb1-191">For fixed size data, the function implementation logic can directly modify the data.</span></span> <span data-ttu-id="69fb1-192">De même, pour les données de taille variable, l’implémentation de fonction ne doit pas modifier la valeur de champ fournie à l’attribut [**\[ size \_ is () \]**](../midl/size-is.md) , soit.</span><span class="sxs-lookup"><span data-stu-id="69fb1-192">Likewise, for variable-sized data, the function implementation must not modify the field value supplied to the [**\[size\_is()\]**](../midl/size-is.md) attribute, either.</span></span> <span data-ttu-id="69fb1-193">Modifiez la valeur de champ utilisée pour dimensionner les données dans une mémoire tampon plus petite ou plus grande retournée au client, qui peut être mal équipée pour traiter la longueur anormale.</span><span class="sxs-lookup"><span data-stu-id="69fb1-193">Change the field value used to size the data results in a smaller or larger buffer returned to the client which may be ill-equipped to deal with the abnormal length.</span></span>

<span data-ttu-id="69fb1-194">Si des circonstances se produisent lorsque la routine du serveur doit réallouer la mémoire utilisée par les données marquées avec l’attribut **\[ in, out \]** , il est tout à fait possible que l’implémentation de la fonction côté serveur ne sache pas si le pointeur fourni par le stub est la mémoire allouée avec **MIDL \_ User \_ allocate ()** ou la mémoire tampon de câble marshalée.</span><span class="sxs-lookup"><span data-stu-id="69fb1-194">If circumstances occur where the server routine has to reallocate the memory used by data marked with the **\[in, out\]** attribute, it is entirely possible that the server-side function implementation will not know if the pointer provided by the stub is to memory allocated with **MIDL\_user\_allocate()** or the marshaled wire buffer.</span></span> <span data-ttu-id="69fb1-195">Pour contourner ce problème, MS RPC peut s’assurer qu’aucune fuite de mémoire ou altération n’a lieu si l’attribut [**\[ force \_ allocate \]**](../midl/force-allocate.md) est défini sur les données.</span><span class="sxs-lookup"><span data-stu-id="69fb1-195">To work around this problem, MS RPC can ensure that no memory leak or corruption occurs if the [**\[force\_allocate\]**](../midl/force-allocate.md) attribute is set on the data.</span></span> <span data-ttu-id="69fb1-196">Quand **\[ force \_ allocate \]** est définie, le stub serveur allouera toujours la mémoire pour le pointeur, bien que l’inconvénient est que les performances diminuent pour chaque utilisation.</span><span class="sxs-lookup"><span data-stu-id="69fb1-196">When **\[force\_allocate\]** is set, the server stub will always allocate memory for the pointer, although the caveat is that performance will decrease for every use of it.</span></span>

<span data-ttu-id="69fb1-197">Lorsque l’appel est retourné par l’implémentation de fonction côté serveur, le stub serveur marshale les données marquées avec l’attribut [**\[ out \]**](../midl/out-idl.md) et les envoie au client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-197">When the call returns from the server-side function implementation, the server stub marshals the data marked with the [**\[out\]**](../midl/out-idl.md) attribute and sends it to the client.</span></span> <span data-ttu-id="69fb1-198">N’oubliez pas que le stub ne marshale pas les données si l’implémentation de fonction côté serveur lève une exception.</span><span class="sxs-lookup"><span data-stu-id="69fb1-198">Be aware that the stub does not marshal the data if the server-side function implementation throws an exception.</span></span>

## <a name="releasing-allocated-memory"></a><span data-ttu-id="69fb1-199">Libérer de la mémoire allouée</span><span class="sxs-lookup"><span data-stu-id="69fb1-199">Releasing Allocated Memory</span></span>

<span data-ttu-id="69fb1-200">Le stub du serveur RPC libère la mémoire de la pile une fois que l’appel a été retourné par la fonction côté serveur, qu’une exception se produise ou non.</span><span class="sxs-lookup"><span data-stu-id="69fb1-200">The RPC server stub will release the stack memory after the call has returned from the server-side function, whether an exception occurs or not.</span></span> <span data-ttu-id="69fb1-201">Le stub serveur libère toute la mémoire allouée par le stub, ainsi que toute mémoire allouée avec l' **\_ allocation utilisateur MIDL \_ ()**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-201">The server stub frees all memory allocated by the stub as well as any memory allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="69fb1-202">L’implémentation de fonction côté serveur doit toujours donner à RPC un état cohérent, soit en levant une exception, soit en retournant un code d’erreur.</span><span class="sxs-lookup"><span data-stu-id="69fb1-202">The server-side function implementation must always give RPC a consistent state, either by throwing an exception or returning an error code.</span></span> <span data-ttu-id="69fb1-203">Si la fonction échoue pendant le remplissage de structures de données complexes, elle doit s’assurer que tous les pointeurs pointent vers des données valides ou ont la valeur **null**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-203">If the function fails during the population of complicated data structures, it must ensure that all pointers point to valid data or are set to **NULL**.</span></span>

<span data-ttu-id="69fb1-204">Pendant cette étape, le stub serveur libère toute la mémoire qui ne fait pas partie de la mémoire tampon marshalée contenant les données [**\[ dans \]**](../midl/in.md) .</span><span class="sxs-lookup"><span data-stu-id="69fb1-204">During this pass, the server stub frees all memory that is not part of the marshaled buffer containing the [**\[in\]**](../midl/in.md) data.</span></span> <span data-ttu-id="69fb1-205">Il existe une exception à ce comportement : les données avec l’attribut [**\[ allocate (ne pas \_ libérer) \]**](../midl/allocate.md) défini sur elles-le stub du serveur ne libère pas de mémoire associée à ces pointeurs.</span><span class="sxs-lookup"><span data-stu-id="69fb1-205">One exception to this behavior is data with the [**\[allocate(dont\_free)\]**](../midl/allocate.md) attribute set on them - the server stub does not free any memory associated with these pointers.</span></span>

<span data-ttu-id="69fb1-206">Une fois que le stub serveur libère la mémoire allouée par le stub et l’implémentation de la fonction, le stub appelle une fonction de notification spécifique si l’attribut [**\[ \_ indicateur \] Notify**](../midl/notify-flag.md) est spécifié pour des données particulières.</span><span class="sxs-lookup"><span data-stu-id="69fb1-206">After the server stub releases the memory allocated by the stub and the function implementation, the stub calls a specific notification function if the [**\[notify\_flag\]**](../midl/notify-flag.md) attribute is specified for particular data.</span></span>

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a><span data-ttu-id="69fb1-207">Marshaling d’une liste liée sur RPC--un exemple</span><span class="sxs-lookup"><span data-stu-id="69fb1-207">Marshalling a Linked List over RPC -- An Example</span></span>


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



<span data-ttu-id="69fb1-208">Dans l’exemple ci-dessus, le format de mémoire pour **LINKEDLIST** sera identique au format de câble marshalé.</span><span class="sxs-lookup"><span data-stu-id="69fb1-208">In the above example, the memory format for **LINKEDLIST** will be identical to the marshaled wire format.</span></span> <span data-ttu-id="69fb1-209">Par conséquent, le stub serveur n’alloue pas de mémoire pour la chaîne entière de pointeurs de données sous le *code confidentiel*.</span><span class="sxs-lookup"><span data-stu-id="69fb1-209">As a result, the server stub does not allocate memory for the entire chain of data pointers under *pIn*.</span></span> <span data-ttu-id="69fb1-210">Au lieu de cela, RPC réutilise la mémoire tampon de transmission pour l’ensemble de la liste liée.</span><span class="sxs-lookup"><span data-stu-id="69fb1-210">Rather, RPC reuses the wire buffer for the entire linked list.</span></span> <span data-ttu-id="69fb1-211">De même, le stub n’alloue pas de mémoire pour *pInOut*, mais réutilise à la place le tampon de transmission marshalé par le client.</span><span class="sxs-lookup"><span data-stu-id="69fb1-211">Similarly, the stub does not allocate memory for *pInOut*, but instead reuses the wire buffer marshaled by the client.</span></span>

<span data-ttu-id="69fb1-212">Étant donné que la signature de fonction contient un paramètre sortant, *moue*, le stub de serveur alloue de la mémoire pour contenir les données retournées.</span><span class="sxs-lookup"><span data-stu-id="69fb1-212">Because the function signature contains an outbound parameter, *pOut*, the server stub allocates memory to contain the returned data.</span></span> <span data-ttu-id="69fb1-213">La mémoire allouée est initialement zéro, avec **pNext** ayant la valeur **null**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-213">The allocated memory is initially zeroes out, with **pNext** set to **NULL**.</span></span> <span data-ttu-id="69fb1-214">L’application peut allouer la mémoire pour une nouvelle liste liée et un point *moue* -> **pNext** .</span><span class="sxs-lookup"><span data-stu-id="69fb1-214">The application can allocate the memory for a new linked list and point *pOut*->**pNext** to it.</span></span> <span data-ttu-id="69fb1-215">*pin* et la liste liée qu’il contient peuvent être utilisées comme un espace de travail, mais l’application ne doit pas modifier les pointeurs pNext.</span><span class="sxs-lookup"><span data-stu-id="69fb1-215">*pIn* and the linked list it contains can be used as a scratch area, but the application should not change any of the pNext pointers.</span></span>

<span data-ttu-id="69fb1-216">L’application peut modifier librement le contenu de la liste liée vers laquelle pointe *pInOut*, mais elle ne doit pas modifier les pointeurs **pNext** , sans parler du lien de niveau supérieur lui-même.</span><span class="sxs-lookup"><span data-stu-id="69fb1-216">The application can freely change the content of the linked list pointed to by *pInOut*, but it must not change any of the **pNext** pointers, let alone the top-level link itself.</span></span> <span data-ttu-id="69fb1-217">Si l’application décide de raccourcir la liste liée, elle ne peut pas savoir si un pointeur **pNext** donné lie pour une mémoire tampon interne RPC ou une mémoire tampon allouée spécifiquement avec l' **allocation d' \_ utilisateur MIDL \_ ()**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-217">If the application decides to shorten the linked list, it cannot know if any given **pNext** pointer links tto an RPC internal buffer or a buffer specifically allocated with **MIDL\_user\_allocate()**.</span></span> <span data-ttu-id="69fb1-218">Pour contourner ce problème, vous ajoutez une déclaration de type spécifique pour les pointeurs de liste liés qui forcent l’allocation des utilisateurs, comme indiqué dans le code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="69fb1-218">To work around this issue, you add a specific type declaration for linked list pointers that forces user allocation, as seen in the code below.</span></span>

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

<span data-ttu-id="69fb1-219">Cet attribut force le stub de serveur à allouer séparément chaque nœud de la liste liée, et l’application peut libérer la partie abrégée de la liste liée en appelant l' **\_ utilisateur \_ gratuit MIDL ()**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-219">This attribute forces the server stub to allocate each node of the linked list separately, and the application can free the shortened part of the linked list by calling **MIDL\_user\_free()**.</span></span> <span data-ttu-id="69fb1-220">L’application peut ensuite définir en toute sécurité le pointeur **pNext** à la fin de la liste liée récemment raccourcie sur **null**.</span><span class="sxs-lookup"><span data-stu-id="69fb1-220">The application can then safely set the **pNext** pointer at the end of the newly-shortened linked list to **NULL**.</span></span>

 

 