---
title: Instructions pour les applications de service de noms
description: Lorsque vous développez votre application distribuée, vous devez fournir aux utilisateurs de l’application une méthode pour spécifier le nom sous lequel ils peuvent inscrire l’application dans la base de données de service de noms.
ms.assetid: cda997b3-6031-4c0f-affc-c766ba4b7fd5
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c67af441da7a51917ae92751345e860e6b0fc92b
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103940148"
---
# <a name="name-service-application-guidelines"></a><span data-ttu-id="bcb8f-103">Instructions pour les applications de service de noms</span><span class="sxs-lookup"><span data-stu-id="bcb8f-103">Name Service Application Guidelines</span></span>

<span data-ttu-id="bcb8f-104">Lorsque vous développez votre application distribuée, vous devez fournir aux utilisateurs de l’application une méthode pour spécifier le nom sous lequel ils peuvent inscrire l’application dans la base de données de service de noms.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-104">When you develop your distributed application, you need to provide the application users with a method for specifying the name under which they can register the application in the name service database.</span></span> <span data-ttu-id="bcb8f-105">Cette méthode peut se composer d’un fichier de données, d’une entrée de ligne de commande ou d’une boîte de dialogue.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-105">This method can consist of a data file, command-line input, or dialog box.</span></span>

<span data-ttu-id="bcb8f-106">Bien que l’architecture du service de noms RPC prenne en charge différentes méthodes d’organisation des entrées de serveur d’une application, elle est optimisée pour les recherches.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-106">Although the RPC name service architecture supports various methods for organizing an application's server entries, it is optimized for lookups.</span></span> <span data-ttu-id="bcb8f-107">Par conséquent, des mises à jour fréquentes peuvent nuire aux performances du service de noms et de l’application.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-107">As a result, frequent updates can hinder the performance of both the name service and the application.</span></span> <span data-ttu-id="bcb8f-108">Pour éviter d’exporter les informations inutilement, choisissez une conception qui permet au serveur de déterminer si ses informations se trouvent dans la base de données du service de noms.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-108">To avoid exporting information unnecessarily, choose a design that lets the server determine whether its information is in the name service database.</span></span> <span data-ttu-id="bcb8f-109">En outre, chaque instance de serveur doit exporter vers son propre nom d’entrée.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-109">In addition, each server instance should export to its own entry name.</span></span> <span data-ttu-id="bcb8f-110">Dans le cas contraire, il sera difficile pour une instance de modifier ses UUID d’objets ou séquences de protocole pris en charge sans perturber les informations d’une autre instance.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-110">Otherwise, it will be difficult for an instance to change its supported object UUIDs or protocol sequences without disturbing another instance's information.</span></span>

<span data-ttu-id="bcb8f-111">La méthode suivante évite ces pièges et fournit de bonnes performances, quel que soit le service de noms utilisé par votre réseau.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-111">The following method avoids these pitfalls and provides good performance, no matter what name service your network uses.</span></span>

<span data-ttu-id="bcb8f-112">Pour commencer, concevez votre application de sorte que la première fois qu’une instance de serveur donnée démarre, qu’elle sélectionne un nom d’entrée de serveur unique et enregistre ce nom dans le Registre avec les autres informations de configuration de l’application.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-112">To begin with, design your application so that the first time a given server instance starts, it picks a unique server-entry name and saves this name in the registry along with the application's other configuration information.</span></span> <span data-ttu-id="bcb8f-113">Ensuite, il exporte ses descripteurs de liaison et les UUID d’objet, le cas échéant, vers son entrée de service de nom.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-113">Then, have it export its binding handles and object UUIDs, if any, to its name service entry.</span></span>

<span data-ttu-id="bcb8f-114">Les appels suivants de l’instance de serveur doivent vérifier que l’entrée de service de nom est présente et contient l’ensemble correct d’UUID d’objets et de handles de liaison.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-114">Subsequent invocations of the server instance should check that the name service entry is present and contains the correct set of object UUIDs and binding handles.</span></span> <span data-ttu-id="bcb8f-115">Une entrée manquante peut signifier qu’un administrateur l’a supprimée ou qu’une panne de courant a entraîné la perte des informations de service de nom.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-115">A missing entry may mean that an administrator removed it, or that a power outage caused the name service information to be lost.</span></span> <span data-ttu-id="bcb8f-116">Il est important de vérifier que les handles de liaison dans l’entrée sont corrects ; Si un administrateur ajoute la prise en charge TCP/IP à un ordinateur, par exemple, les serveurs RPC écoutent cette séquence de protocole lorsqu’ils appellent [**RpcServerUseAllProtseqs**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs).</span><span class="sxs-lookup"><span data-stu-id="bcb8f-116">It is important to verify that the binding handles in the entry are correct; if an administrator adds TCP/IP support to a computer, for example, RPC servers will listen on that protocol sequence when they call [**RpcServerUseAllProtseqs**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs).</span></span> <span data-ttu-id="bcb8f-117">Toutefois, si le serveur ne met pas à jour l’entrée de service de nom, les clients ne seront pas informés que TCP est pris en charge.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-117">However, if the server does not update the name service entry, clients will not be informed that TCP is supported.</span></span>

<span data-ttu-id="bcb8f-118">Lorsque le client importe, il doit spécifier **null** comme nom d’entrée.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-118">When the client imports, it should specify **NULL** as the entry name.</span></span> <span data-ttu-id="bcb8f-119">Si vous spécifiez la **valeur null** , les fonctions de la bibliothèque Microsoft RPC recherchent l’interface dans toutes les entrées de service de nom du domaine ou du groupe de travail de l’ordinateur client, ce qui recherche les informations pour chaque instance.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-119">Specifying **NULL** causes the Microsoft RPC library functions to search for the interface in all name service entries in the client computer's domain or workgroup, thus finding the information for every instance.</span></span>

<span data-ttu-id="bcb8f-120">Si vous utilisez des UUID d’objet pour représenter des objets connus tels que des imprimantes, vous pouvez utiliser une variante de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-120">If you use object UUIDs to represent well-known objects such as printers, you can use a variation of this method.</span></span> <span data-ttu-id="bcb8f-121">Au lieu d’exporter des liaisons vers une entrée, concevez votre application afin que chaque instance crée une entrée pour chaque objet pris en charge, par exemple «/.:/ Printers/Laser1 "et"/.:/ Printers/Laser2.»</span><span class="sxs-lookup"><span data-stu-id="bcb8f-121">Instead of exporting bindings to one entry, design your application so that each instance creates an entry for each supported object, such as "/.:/printers/Laser1" and "/.:/printers/Laser2."</span></span> <span data-ttu-id="bcb8f-122">Ensuite, le serveur doit exporter ses handles de liaison vers chaque entrée de serveur, ainsi que l’UUID d’objet correspondant à cette entrée.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-122">Then, have the server export its binding handles to each server entry, along with the object UUID relevant to that entry.</span></span>

<span data-ttu-id="bcb8f-123">Dans ce cas, un client peut rechercher une ressource par son nom en l’important à partir de l’entrée de serveur appropriée. elle ne requiert pas l’UUID de l’objet de la ressource.</span><span class="sxs-lookup"><span data-stu-id="bcb8f-123">In this case, a client can look up a resource by name by importing from the relevant server entry; it does not require the object UUID of the resource.</span></span> <span data-ttu-id="bcb8f-124">S’il a l’UUID de ressource, mais pas le nom, il peut importer à partir de l’entrée **null** .</span><span class="sxs-lookup"><span data-stu-id="bcb8f-124">If it has the resource UUID but not the name, it can import from the **null** entry.</span></span>

 

 




