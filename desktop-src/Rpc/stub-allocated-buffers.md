---
title: Mémoires tampons de Stub-Allocated
description: Plutôt que de forcer un appel distinct pour chaque nœud de l’arborescence ou du graphique, vous pouvez demander aux stubs de calculer la taille des données et d’allouer et libérer de la mémoire en faisant un appel unique à l' \_ allocation utilisateur MIDL ou à l' \_ \_ utilisateur MIDL \_ gratuit.
ms.assetid: 9911649d-00e8-47d8-b512-7d9b185d1e09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 956acf6452c1a4e7d04afcd1da263439436e3bad
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104031584"
---
# <a name="stub-allocated-buffers"></a><span data-ttu-id="9f4d9-103">Mémoires tampons de Stub-Allocated</span><span class="sxs-lookup"><span data-stu-id="9f4d9-103">Stub-Allocated Buffers</span></span>

<span data-ttu-id="9f4d9-104">Plutôt que de forcer un appel distinct pour chaque nœud de l’arborescence ou du graphique, vous pouvez demander aux stubs de calculer la taille des données et d’allouer et libérer de la mémoire en faisant un appel unique à l' [ \_ \_ allocation utilisateur MIDL](/windows/desktop/Midl/midl-user-allocate-1) ou à l' [ \_ utilisateur MIDL \_ gratuit](/windows/desktop/Midl/midl-user-free-1).</span><span class="sxs-lookup"><span data-stu-id="9f4d9-104">Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to [midl\_user\_allocate](/windows/desktop/Midl/midl-user-allocate-1) or [midl\_user\_free](/windows/desktop/Midl/midl-user-free-1).</span></span> <span data-ttu-id="9f4d9-105">L’attribut ACF **\[ allocate (tous les \_ nœuds) \]** indique aux stubs d’allouer ou de libérer tous les nœuds dans un appel unique aux fonctions de gestion de la mémoire fournies par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-105">The ACF attribute **\[allocate(all\_nodes)\]** directs the stubs to allocate or free all nodes in a single call to the user supplied–memory management functions.</span></span>

<span data-ttu-id="9f4d9-106">Par exemple, une application RPC peut utiliser la structure de données de l’arborescence binaire suivante :</span><span class="sxs-lookup"><span data-stu-id="9f4d9-106">For example, an RPC application might use the following binary tree data structure:</span></span>

``` syntax
/* IDL file fragment */
typedef struct _TREE_TYPE 
{
    short sNumber;
    struct _TREE_TYPE * pLeft;
    struct _TREE_TYPE * pRight;
} TREE_TYPE;

typedef TREE_TYPE * P_TREE_TYPE;
```

<span data-ttu-id="9f4d9-107">L’attribut ACF **\[ allocate (tous les \_ nœuds) \]** appliqué à ce type de données apparaît dans la Déclaration **typedef** dans le CCP en tant que :</span><span class="sxs-lookup"><span data-stu-id="9f4d9-107">The ACF attribute **\[allocate(all\_nodes)\]** applied to this data type appears in the **typedef** declaration in the ACF as:</span></span>

``` syntax
/* ACF file fragment */
typedef [allocate(all_nodes)] P_TREE_TYPE;
```

<span data-ttu-id="9f4d9-108">L’attribut **\[ allocate \]** peut uniquement être appliqué aux types pointeur.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-108">The **\[allocate\]** attribute can only be applied to pointer types.</span></span> <span data-ttu-id="9f4d9-109">L’attribut **\[ allocate \]** ACF est une extension Microsoft de l’IDL DCE et, par conséquent, n’est pas disponible si vous compilez avec le commutateur MIDL **/OSF** .</span><span class="sxs-lookup"><span data-stu-id="9f4d9-109">The **\[allocate\]** ACF attribute is a Microsoft extension to DCE IDL and, as such, is not available if you compile with the MIDL **/osf** switch.</span></span> <span data-ttu-id="9f4d9-110">Lorsque **\[ allocate (tous les \_ nœuds) \]** est appliqué à un type pointeur, les stubs générés par le compilateur MIDL traversent la structure de données spécifiée pour déterminer la taille d’allocation.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-110">When **\[allocate(all\_nodes)\]** is applied to a pointer type, the stubs generated by the MIDL compiler traverse the specified data structure to determine the allocation size.</span></span> <span data-ttu-id="9f4d9-111">Les stubs effectuent alors un appel unique pour allouer la quantité totale de mémoire requise par le graphique ou l’arborescence.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-111">The stubs then make a single call to allocate the entire amount of memory needed by the graph or tree.</span></span> <span data-ttu-id="9f4d9-112">Une application cliente peut libérer de la mémoire plus efficacement en effectuant un appel unique à l' **\_ utilisateur MIDL \_ gratuit**.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-112">A client application can free memory much more efficiently by making a single call to **midl\_user\_free**.</span></span> <span data-ttu-id="9f4d9-113">Toutefois, les performances du stub serveur sont généralement augmentées lors de l’utilisation de la mémoire nœud par nœud, car les stubs de serveur peuvent souvent utiliser la mémoire privée qui ne nécessite aucune allocation.</span><span class="sxs-lookup"><span data-stu-id="9f4d9-113">However, server-stub performance is generally increased when using node-by-node memory allocation because the server stubs can often use private memory that requires no allocations.</span></span>

<span data-ttu-id="9f4d9-114">Pour plus d’informations, consultez [allocation et désallocation de nœuds par nœud](node-by-node-allocation-and-deallocation.md).</span><span class="sxs-lookup"><span data-stu-id="9f4d9-114">For additional information, see [Node-by-Node Allocation and Deallocation](node-by-node-allocation-and-deallocation.md).</span></span>

 

 