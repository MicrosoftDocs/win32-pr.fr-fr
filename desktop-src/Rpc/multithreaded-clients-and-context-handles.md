---
title: Clients multithread et handles de contexte
description: Quand vous avez un client multithread où plusieurs threads utilisent la même instance de handle de contexte, l’accès à l’instance de handle de contexte est sérialisé par défaut sur le serveur.
ms.assetid: 192be467-b1e0-422b-878a-738cb7d72b5b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 67c621d75d8cc48ca1f71719066f455e0efce39f
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104031553"
---
# <a name="multithreaded-clients-and-context-handles"></a><span data-ttu-id="283dd-103">Clients multithread et handles de contexte</span><span class="sxs-lookup"><span data-stu-id="283dd-103">Multithreaded Clients and Context Handles</span></span>

<span data-ttu-id="283dd-104">Quand vous avez un client multithread où plusieurs threads utilisent la même instance de handle de contexte, l’accès à l’instance de handle de contexte est sérialisé par défaut sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="283dd-104">When you have a multithreaded client where multiple threads are using the same context handle instance, access to the context handle instance is serialized at the server by default.</span></span> <span data-ttu-id="283dd-105">Cela évite au gestionnaire de serveur d’avoir à se prémunir contre un autre thread du même client en modifiant le contexte ou le contexte qui s’est exécuté pendant la distribution d’un appel.</span><span class="sxs-lookup"><span data-stu-id="283dd-105">This saves the server manager from having to guard against another thread from the same client changing the context or the context running down while a call is dispatched.</span></span> <span data-ttu-id="283dd-106">Toutefois, dans certains cas, la sérialisation peut avoir un impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="283dd-106">However, in certain cases serialization may impact performance.</span></span>

<span data-ttu-id="283dd-107">Considérez les éléments suivants : deux threads clients appellent un appel de procédure distante qui ne modifie pas l’état du contexte (par exemple, l’appel obtient simplement des valeurs à partir de celui-ci).</span><span class="sxs-lookup"><span data-stu-id="283dd-107">Consider the following: two client threads invoke a remote procedure call that does not change the state of the context (for example, the call simply obtains some values from it).</span></span> <span data-ttu-id="283dd-108">De tels appels n’ont pas besoin d’être sérialisés.</span><span class="sxs-lookup"><span data-stu-id="283dd-108">Such calls do not need to be serialized.</span></span>

<span data-ttu-id="283dd-109">Dans ce cas, Windows XP offre un modèle de sérialisation en mode mixte, où chaque méthode peut être déclarée comme disposant d’un accès exclusif ou partagé à un handle de contexte.</span><span class="sxs-lookup"><span data-stu-id="283dd-109">For such situations, Windows XP offers a mixed mode serialization model, where each method may be declared to have exclusive or shared access to a context handle.</span></span> <span data-ttu-id="283dd-110">Pour plus d’informations, consultez [ \_ \_ sérialisation de handle de contexte](/windows/desktop/Midl/context-handle-serialize) et handle de [contexte \_ \_ noserialize](/windows/desktop/Midl/context-handle-noserialize) .</span><span class="sxs-lookup"><span data-stu-id="283dd-110">See [context\_handle\_serialize](/windows/desktop/Midl/context-handle-serialize) and [context\_handle\_noserialize](/windows/desktop/Midl/context-handle-noserialize) for details.</span></span>

<span data-ttu-id="283dd-111">Dans les versions de Windows antérieures à Windows XP, le seul moyen d’autoriser l’accès simultané à un handle de contexte consiste à appeler la fonction [**RpcSsDontSerializeContext**](/previous-versions/aa378473(v=vs.80)) pour permettre la distribution de plusieurs appels sur un seul handle de contexte.</span><span class="sxs-lookup"><span data-stu-id="283dd-111">In versions of Windows prior to Windows XP, the only means of allowing concurrent access to a context handle is to call the [**RpcSsDontSerializeContext**](/previous-versions/aa378473(v=vs.80)) function to allow multiple calls to be dispatched on a single context handle.</span></span> <span data-ttu-id="283dd-112">L’appel de la fonction **RpcSsDontSerializeContext** ne désactive pas entièrement la sérialisation ; Lorsqu’une exécution de contexte se produit, la routine d’exécution de contexte s’exécute uniquement lorsque toutes les demandes de client en suspens sont terminées.</span><span class="sxs-lookup"><span data-stu-id="283dd-112">Calling the **RpcSsDontSerializeContext** function does not disable serialization entirely; when a context run-down occurs, the context run-down routine runs only when all outstanding client requests have completed.</span></span> <span data-ttu-id="283dd-113">Un appel à **RpcScDontSerializeContext** affecte l’ensemble du processus et n’est pas réversible.</span><span class="sxs-lookup"><span data-stu-id="283dd-113">A call to **RpcScDontSerializeContext** affects the entire process, and is not revertible.</span></span> <span data-ttu-id="283dd-114">L’utilisation de **RpcScDontSerializeContext** dans Windows XP et les versions ultérieures n’est pas recommandée. Cela rend le code du serveur très compliqué lorsqu’il s’agit d’une gestion fiable des conditions de concurrence inhérentes à des environnements totalement non sérialisés.</span><span class="sxs-lookup"><span data-stu-id="283dd-114">Using **RpcScDontSerializeContext** in Windows XP and later versions is not recommended; it makes server code very complicated when dealing reliably with race conditions inherent in completely non-serialized environments.</span></span>

 

 