---
title: Gestion de la perte de connectivité
description: Gestion de la perte de connectivité
ms.assetid: a90fcb5a-773e-4c21-bf6c-c3519ec13a09
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: de8e7a8088cfe09a4c4026c16cc3dc5ea36b3430
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "103728868"
---
# <a name="dealing-with-loss-of-connectivity"></a><span data-ttu-id="689c7-103">Gestion de la perte de connectivité</span><span class="sxs-lookup"><span data-stu-id="689c7-103">Dealing with Loss of Connectivity</span></span>

<span data-ttu-id="689c7-104">Une fois qu’un appel RPC est terminé, la connexion n’est pas fermée. elle est marquée comme étant libre.</span><span class="sxs-lookup"><span data-stu-id="689c7-104">After an RPC call completes the connection is not closed; it is marked as free.</span></span> <span data-ttu-id="689c7-105">Par conséquent, le serveur peut descendre ou la connectivité réseau peut être perdue pendant ou entre les appels, tandis qu’une connexion est située dans le pool.</span><span class="sxs-lookup"><span data-stu-id="689c7-105">As such, the server can go down or network connectivity can be lost during or between calls, while a connection is sitting in the pool.</span></span> <span data-ttu-id="689c7-106">En matière de stratégie, le temps d’exécution RPC réessaye ces appels uniquement si les deux conditions suivantes sont remplies :</span><span class="sxs-lookup"><span data-stu-id="689c7-106">As a matter of policy, the RPC run time re-attempts those calls only if the following two conditions are met:</span></span>

-   <span data-ttu-id="689c7-107">Le serveur ne peut pas exécuter l’appel ou l’appel est idempotent.</span><span class="sxs-lookup"><span data-stu-id="689c7-107">The server cannot possibly execute the call, or the call is idempotent.</span></span>
-   <span data-ttu-id="689c7-108">Le client peut implémenter les nouvelles tentatives de manière efficace.</span><span class="sxs-lookup"><span data-stu-id="689c7-108">The client can implement retries in a performance-efficient manner.</span></span>

<span data-ttu-id="689c7-109">Les paragraphes suivants développent et clarifient les deux conditions.</span><span class="sxs-lookup"><span data-stu-id="689c7-109">The following paragraphs expand and clarify the two conditions.</span></span>

<span data-ttu-id="689c7-110">Un appel idempotent est un appel qui peut être exécuté plusieurs fois sur le serveur sans effets secondaires indésirables.</span><span class="sxs-lookup"><span data-stu-id="689c7-110">An idempotent call is a call that can be executed more than once on the server without undesirable side effects.</span></span> <span data-ttu-id="689c7-111">Par exemple, un appel RPC qui interroge le solde de la Banque pour un compte donné est idempotent.</span><span class="sxs-lookup"><span data-stu-id="689c7-111">For example, having an RPC call that queries the balance in the bank for a given account is idempotent.</span></span> <span data-ttu-id="689c7-112">Si cet appel est exécuté deux fois en raison d’une perte de connectivité, aucun dommage n’est fait.</span><span class="sxs-lookup"><span data-stu-id="689c7-112">If this call is executed twice due to loss of connectivity, no harm is done.</span></span> <span data-ttu-id="689c7-113">Un autre exemple d’appel idempotent est la modification de l’adresse d’un client dans une base de données.</span><span class="sxs-lookup"><span data-stu-id="689c7-113">Another example of an idempotent call is changing the address of a customer in a database.</span></span> <span data-ttu-id="689c7-114">L’exécution double est correcte, car la deuxième exécution remplace simplement l’adresse déjà actuelle par la même adresse.</span><span class="sxs-lookup"><span data-stu-id="689c7-114">Executing twice is fine, since the second execution simply replaces the already-current address with the same address.</span></span> <span data-ttu-id="689c7-115">Une opération telle que « soustraire 50 dollars du compte XYZ » n’est pas idempotent.</span><span class="sxs-lookup"><span data-stu-id="689c7-115">An operation like "subtract fifty dollars from account xyz" is not idempotent.</span></span> <span data-ttu-id="689c7-116">La perte de connectivité réseau ne doit pas aboutir à plusieurs exécutions d’un tel appel.</span><span class="sxs-lookup"><span data-stu-id="689c7-116">Loss of network connectivity should not result in multiple executions of such a call.</span></span>

<span data-ttu-id="689c7-117">Pour être sécurisé, le temps d’exécution RPC traite tous les appels comme non-idempotent.</span><span class="sxs-lookup"><span data-stu-id="689c7-117">To be safe, the RPC run time treats all calls as non-idempotent.</span></span> <span data-ttu-id="689c7-118">L' \[ \] attribut idempotent n’est pas pris en charge pour [**ncacn \_ IP \_ TCP**](/windows/desktop/Midl/ncacn-ip-tcp)et est ignoré.</span><span class="sxs-lookup"><span data-stu-id="689c7-118">The \[idempotent\] attribute is not supported for [**ncacn\_ip\_tcp**](/windows/desktop/Midl/ncacn-ip-tcp), and is ignored.</span></span> <span data-ttu-id="689c7-119">Par conséquent, la première condition de la liste précédente est réduite au *serveur qui ne peut pas exécuter l’appel*.</span><span class="sxs-lookup"><span data-stu-id="689c7-119">As such, the first condition in the preceding list is reduced to *the server that cannot possibly execute the call*.</span></span>

<span data-ttu-id="689c7-120">Dans de nombreux cas, le temps d’exécution RPC ne peut pas déterminer de façon concluant que l’appel n’a pas déjà été exécuté sur le serveur.</span><span class="sxs-lookup"><span data-stu-id="689c7-120">In many cases the RPC run time is unable to conclusively determine the call was not already executed on the server.</span></span> <span data-ttu-id="689c7-121">Dans ce cas, le client ne réessaiera pas d’exécuter l’appel.</span><span class="sxs-lookup"><span data-stu-id="689c7-121">In such cases, the client will not retry executing the call.</span></span>

<span data-ttu-id="689c7-122">Les exemples suivants illustrent le moment où la durée d’exécution RPC ne réessaye pas un appel :</span><span class="sxs-lookup"><span data-stu-id="689c7-122">The following examples illustrate when the RPC run time does or does not retry a call:</span></span>

-   <span data-ttu-id="689c7-123">Un serveur est redémarré.</span><span class="sxs-lookup"><span data-stu-id="689c7-123">A server is rebooted.</span></span>

    <span data-ttu-id="689c7-124">Un simple appel RPC non sécurisé est effectué sur une interface sur laquelle aucun appel précédent n’a été effectué après le redémarrage.</span><span class="sxs-lookup"><span data-stu-id="689c7-124">A simple, no-security RPC call is made on an interface on which no previous call has been made after the reboot.</span></span> <span data-ttu-id="689c7-125">Dans la mesure où aucun appel n’a été effectué sur cette interface, le temps d’exécution RPC tente d’abord de négocier l’utilisation de l’interface.</span><span class="sxs-lookup"><span data-stu-id="689c7-125">Since no calls were made on this interface, the RPC run time first attempts to negotiate use of the interface.</span></span> <span data-ttu-id="689c7-126">Il envoie un paquet à l’aide d’une connexion dans le pool.</span><span class="sxs-lookup"><span data-stu-id="689c7-126">It sends a packet using a connection in the pool.</span></span> <span data-ttu-id="689c7-127">Étant donné que le serveur a été redémarré et que la connexion n’est plus valide, une erreur est retournée.</span><span class="sxs-lookup"><span data-stu-id="689c7-127">Since the server was rebooted, and the connection is no longer valid, it returns an error.</span></span> <span data-ttu-id="689c7-128">Étant donné que l’exécution RPC côté client n’a pas encore commencé à envoyer les données pour l’appel réel, le client détermine que le serveur n’a peut-être pas pu être exécuté sur ces données.</span><span class="sxs-lookup"><span data-stu-id="689c7-128">Since the client side RPC run time has not yet started sending the data for the actual call, the client determines that the server could not possibly have executed on those data.</span></span> <span data-ttu-id="689c7-129">Par conséquent, il ferme la connexion et recherche une autre connexion dans le pool.</span><span class="sxs-lookup"><span data-stu-id="689c7-129">Therefore, it closes the connection and looks for another connection in the pool.</span></span> <span data-ttu-id="689c7-130">S’il ne trouve pas de connexion, il ouvre une nouvelle connexion et tente à nouveau de négocier l’utilisation de l’interface.</span><span class="sxs-lookup"><span data-stu-id="689c7-130">If it cannot find a connection, it opens a new connection and tries to negotiate use of the interface again.</span></span> <span data-ttu-id="689c7-131">Si cela se déroule correctement, l’appel est effectué (c’est-à-dire, une nouvelle tentative est effectuée, car l’échec a été détecté avant le démarrage de l’appel).</span><span class="sxs-lookup"><span data-stu-id="689c7-131">If this succeeds, the call is made (that is, a retry is made, because the failure was detected before the call was started).</span></span>

-   <span data-ttu-id="689c7-132">Un appel RPC avec la sécurité au niveau de la confidentialité (chiffrement) est établi sur une connexion avec un contexte de sécurité déjà négocié.</span><span class="sxs-lookup"><span data-stu-id="689c7-132">An RPC call with privacy-level security (encryption) is made on a connection with an already-negotiated security context.</span></span>

    <span data-ttu-id="689c7-133">Pour garantir des performances optimales, le temps d’exécution RPC chiffre le paquet marshalé en ligne (sur les données de texte en clair).</span><span class="sxs-lookup"><span data-stu-id="689c7-133">To ensure efficient performance, the RPC run time encrypts the marshaled packet inline (over the clear text data).</span></span> <span data-ttu-id="689c7-134">Si la tentative d’envoi des données échoue, l’exécution RPC ne peut pas réessayer l’appel, car les données de texte en clair ont été remplacées par les données chiffrées et ne peuvent pas rechiffrer les données avec un nouveau contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="689c7-134">If the attempt to send the data fails, the RPC run time cannot retry the call, since the clear text data have been overwritten with the encrypted data, and it cannot re-encrypt the data with a new security context.</span></span> <span data-ttu-id="689c7-135">Par conséquent, aucune nouvelle tentative n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="689c7-135">Therefore, no retry is made.</span></span>

-   <span data-ttu-id="689c7-136">L’envoi d’un fragment non-premier échoue.</span><span class="sxs-lookup"><span data-stu-id="689c7-136">The sending of a non-first fragment fails.</span></span>

    <span data-ttu-id="689c7-137">Aucune nouvelle tentative n’est effectuée, car le temps d’exécution RPC peut choisir d’ignorer le contenu du premier fragment une fois qu’il est terminé et n’a aucun moyen de réessayer d’envoyer le premier fragment.</span><span class="sxs-lookup"><span data-stu-id="689c7-137">Retry is not made, since the RPC run time may choose to discard the contents of the first fragment once it is complete, and has no way to retry sending the first fragment.</span></span>

-   <span data-ttu-id="689c7-138">La demande RPC est envoyée.</span><span class="sxs-lookup"><span data-stu-id="689c7-138">The RPC request is sent.</span></span>

    <span data-ttu-id="689c7-139">Le serveur abandonne la connexion.</span><span class="sxs-lookup"><span data-stu-id="689c7-139">The server aborts the connection.</span></span> <span data-ttu-id="689c7-140">Aucune nouvelle tentative n’est effectuée, car RPC ne peut pas déterminer si le serveur a reçu l’appel et a démarré son exécution.</span><span class="sxs-lookup"><span data-stu-id="689c7-140">No retry is attempted, since RPC cannot discern whether the server received the call and started executing it.</span></span>

<span data-ttu-id="689c7-141">Si le serveur utilise un point de terminaison dynamique, RPC ne résoudra pas le point de terminaison pendant les nouvelles tentatives.</span><span class="sxs-lookup"><span data-stu-id="689c7-141">If the server uses a dynamic endpoint, RPC will not re-resolve the endpoint during retries.</span></span> <span data-ttu-id="689c7-142">Cela signifie que si un serveur est arrêté et remis en service, il peut résider sur un point de terminaison différent, et RPC ne résoudra pas en toute transparence le point de terminaison lorsqu’un appel est retenté.</span><span class="sxs-lookup"><span data-stu-id="689c7-142">This means that if a server is brought down and comes back up, it may reside on a different endpoint, and RPC will not transparently re-resolve the endpoint when a call is retried.</span></span> <span data-ttu-id="689c7-143">Pour forcer la rérésolution du point de terminaison, le client RPC doit appeler [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) avant de réessayer un appel.</span><span class="sxs-lookup"><span data-stu-id="689c7-143">To force re-resolving of the endpoint, the RPC client should calling [**RpcBindingReset**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingreset) before it retries a call.</span></span>

<span data-ttu-id="689c7-144">Dans la plupart des cas, si un client RPC peut déterminer si un appel est idempotent ou s’il conserve les données que RPC rejette, il peut choisir de générer un mécanisme de nouvelle tentative sur RPC.</span><span class="sxs-lookup"><span data-stu-id="689c7-144">In many of these cases, if an RPC client can determine whether a call is idempotent, or if it keeps data that RPC discards, it may choose to build a retry mechanism on top of RPC.</span></span>

> [!Note]  
> <span data-ttu-id="689c7-145">Si le serveur est un cluster et que les différents nœuds du cluster exécutent des versions différentes du logiciel serveur, une nouvelle tentative RPC peut débarquer l’appel sur un autre nœud du cluster en cas de basculement, et éventuellement sur une autre version du serveur.</span><span class="sxs-lookup"><span data-stu-id="689c7-145">If the server is a cluster, and the different nodes of the cluster run different versions of the server software, an RPC retry may land the call on a different node of the cluster in the case of failover, and potentially on a different version of the server.</span></span> <span data-ttu-id="689c7-146">Dans de tels scénarios de déploiement, assurez-vous que le client ne s’appuie pas sur une version particulière du logiciel serveur pour exécuter un appel donné.</span><span class="sxs-lookup"><span data-stu-id="689c7-146">In such deployment scenarios, make sure the client does not rely on a particular version of the server software to execute a given call.</span></span> <span data-ttu-id="689c7-147">Si c’est le cas, le client doit créer un mécanisme par-dessus RPC qui détecte et gère ces conditions.</span><span class="sxs-lookup"><span data-stu-id="689c7-147">If it does, the client should build a mechanism on top of RPC that detects and handles such conditions.</span></span>

 

 

 