---
description: Programmation de DirectX avec COM.
title: Programmation de DirectX avec COM
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 67fc7a35f42439e1a9eeef1b2895d88dc0dbf5d4
ms.sourcegitcommit: f712e5fed19d6afe2762a77ffcdf8b5977f85901
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/26/2021
ms.locfileid: "103953285"
---
# <a name="programming-directx-with-com"></a><span data-ttu-id="dd193-103">Programmation de DirectX avec COM</span><span class="sxs-lookup"><span data-stu-id="dd193-103">Programming DirectX with COM</span></span>

<span data-ttu-id="dd193-104">Le modèle COM (Component Object Model) Microsoft est un modèle de programmation orienté objet utilisé par plusieurs technologies, y compris l’essentiel de la surface de l’API DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-104">The Microsoft Component Object Model (COM) is an object-oriented programming model used by several technologies, including the bulk of the DirectX API surface.</span></span> <span data-ttu-id="dd193-105">C’est pourquoi, en tant que développeur DirectX, vous utilisez inévitablement COM lorsque vous programmez DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-105">For that reason, you (as a DirectX developer) inevitably use COM when you program DirectX.</span></span>

> [!NOTE]
> <span data-ttu-id="dd193-106">La rubrique [consommer des composants COM avec c++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) montre comment utiliser des API DirectX (et toute API com, pour cette question) à l’aide de [c++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span><span class="sxs-lookup"><span data-stu-id="dd193-106">The topic [Consume COM components with C++/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) shows how to consume DirectX APIs (and any COM API, for that matter) by using [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).</span></span> <span data-ttu-id="dd193-107">C’est de loin la technologie la plus pratique et recommandée à utiliser.</span><span class="sxs-lookup"><span data-stu-id="dd193-107">That's by far the most convenient and recommended technology to use.</span></span>

<span data-ttu-id="dd193-108">Vous pouvez également utiliser le modèle COM brut et c’est ce que cette rubrique concerne.</span><span class="sxs-lookup"><span data-stu-id="dd193-108">Alternatively, you can use raw COM, and that's what this topic is about.</span></span> <span data-ttu-id="dd193-109">Vous aurez besoin d’une compréhension de base des principes et des techniques de programmation impliqués dans l’utilisation des API COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-109">You'll need a basic understanding of the principles and programming techniques involved in consuming COM APIs.</span></span> <span data-ttu-id="dd193-110">Bien que COM offre une réputation difficile et complexe, la programmation COM requise par la plupart des applications DirectX est simple.</span><span class="sxs-lookup"><span data-stu-id="dd193-110">Although COM has a reputation for being difficult and complex, the COM programming required by most DirectX applications is straightforward.</span></span> <span data-ttu-id="dd193-111">En partie, cela est dû au fait que vous allez consommer les objets COM fournis par DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-111">In part, this is because you'll be consuming the COM objects provided by DirectX.</span></span> <span data-ttu-id="dd193-112">Vous n’avez pas besoin de créer vos propres objets COM, ce qui est généralement là où la complexité se produit.</span><span class="sxs-lookup"><span data-stu-id="dd193-112">There's no need for you to author your own COM objects, which is typically where the complexity arises.</span></span>

## <a name="com-component-overview"></a><span data-ttu-id="dd193-113">Vue d’ensemble du composant COM</span><span class="sxs-lookup"><span data-stu-id="dd193-113">COM component overview</span></span>

<span data-ttu-id="dd193-114">Un objet COM est essentiellement un composant encapsulé de fonctionnalités qui peuvent être utilisées par les applications pour effectuer une ou plusieurs tâches.</span><span class="sxs-lookup"><span data-stu-id="dd193-114">A COM object is essentially an encapsulated component of functionality that can be used by applications to perform one or more tasks.</span></span> <span data-ttu-id="dd193-115">Pour le déploiement, un ou plusieurs composants COM sont empaquetés dans un fichier binaire appelé serveur COM. plus souvent qu’une DLL.</span><span class="sxs-lookup"><span data-stu-id="dd193-115">For deployment, one or more COM components are packaged into a binary called a COM server; more often than not a DLL.</span></span>

<span data-ttu-id="dd193-116">Une DLL traditionnelle exporte des fonctions gratuites.</span><span class="sxs-lookup"><span data-stu-id="dd193-116">A traditional DLL exports free functions.</span></span> <span data-ttu-id="dd193-117">Un serveur COM peut faire de même.</span><span class="sxs-lookup"><span data-stu-id="dd193-117">A COM server can do the same.</span></span> <span data-ttu-id="dd193-118">Toutefois, les composants COM au sein du serveur COM exposent des interfaces COM et des méthodes membres appartenant à ces interfaces.</span><span class="sxs-lookup"><span data-stu-id="dd193-118">But the COM components inside the COM server expose COM interfaces and member methods belonging to those interfaces.</span></span> <span data-ttu-id="dd193-119">Votre application crée des instances de composants COM, récupère des interfaces à partir de celles-ci et appelle des méthodes sur ces interfaces afin de tirer parti des fonctionnalités implémentées dans les composants COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-119">Your application creates instances of COM components, retrieves interfaces from them, and calls methods on those interfaces in order to benefit from the features implemented in the COM components.</span></span>

<span data-ttu-id="dd193-120">Dans la pratique, cela ressemble à l’appel de méthodes sur un objet C++ normal.</span><span class="sxs-lookup"><span data-stu-id="dd193-120">In practice, this feels similar to calling methods on a regular C++ object.</span></span> <span data-ttu-id="dd193-121">Toutefois, il existe quelques différences.</span><span class="sxs-lookup"><span data-stu-id="dd193-121">But there are some differences.</span></span>

- <span data-ttu-id="dd193-122">Un objet COM applique l’encapsulation plus stricte qu’un objet C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-122">A COM object enforces stricter encapsulation than a C++ object does.</span></span> <span data-ttu-id="dd193-123">Vous ne pouvez pas simplement créer l’objet, puis appeler une méthode publique.</span><span class="sxs-lookup"><span data-stu-id="dd193-123">You can't just create the object, and then call any public method.</span></span> <span data-ttu-id="dd193-124">Au lieu de cela, les méthodes publiques d’un composant COM sont regroupées dans une ou plusieurs interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-124">Instead, a COM component's public methods are grouped into one or more COM interfaces.</span></span> <span data-ttu-id="dd193-125">Pour appeler une méthode, vous devez créer l’objet et récupérer à partir de l’objet l’interface qui implémente la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-125">To call a method, you create the object and retrieve from the object the interface that implements the method.</span></span> <span data-ttu-id="dd193-126">Une interface implémente généralement un ensemble de méthodes associées qui fournissent l’accès à une fonctionnalité particulière de l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-126">An interface typically implements a related set of methods that provide access to a particular feature of the object.</span></span> <span data-ttu-id="dd193-127">Par exemple, l’interface [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) représente une carte graphique virtuelle et contient des méthodes qui vous permettent de créer des ressources, par exemple, et de nombreuses autres tâches liées à l’adaptateur.</span><span class="sxs-lookup"><span data-stu-id="dd193-127">For example, the [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) interface represents a virtual graphics adapter, and it contains methods that enable you create resources, for example, and many other adapter-related tasks.</span></span>
- <span data-ttu-id="dd193-128">Un objet COM n’est pas créé de la même façon qu’un objet C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-128">A COM object is not created in the same way as a C++ object.</span></span> <span data-ttu-id="dd193-129">Il existe plusieurs façons de créer un objet COM, mais elles impliquent toutes des techniques spécifiques à COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-129">There are several ways to create a COM object, but all involve COM-specific techniques.</span></span> <span data-ttu-id="dd193-130">L’API DirectX comprend une variété de fonctions et de méthodes d’assistance qui simplifient la création de la plupart des objets COM DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-130">The DirectX API includes a variety of helper functions and methods that simplify creating most of the DirectX COM objects.</span></span>
- <span data-ttu-id="dd193-131">Vous devez utiliser des techniques spécifiques à COM pour contrôler la durée de vie d’un objet COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-131">You must use COM-specific techniques to control the lifetime of a COM object.</span></span>
- <span data-ttu-id="dd193-132">Le serveur COM (généralement une DLL) n’a pas besoin d’être chargé explicitement.</span><span class="sxs-lookup"><span data-stu-id="dd193-132">The COM server (typically a DLL) doesn't need to be explicitly loaded.</span></span> <span data-ttu-id="dd193-133">Vous n’êtes pas non plus lié à une bibliothèque statique pour pouvoir utiliser un composant COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-133">Nor do you link to a static library in order to use a COM component.</span></span> <span data-ttu-id="dd193-134">Chaque composant COM possède un identificateur unique inscrit (identificateur global unique, ou GUID), que votre application utilise pour identifier l’objet COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-134">Each COM component has a unique registered identifier (a globally-unique identifier, or GUID), which your application uses to identify the COM object.</span></span> <span data-ttu-id="dd193-135">Votre application identifie le composant, et le runtime COM charge automatiquement la DLL de serveur COM correcte.</span><span class="sxs-lookup"><span data-stu-id="dd193-135">Your application identifies the component, and the COM runtime automatically loads the correct COM server DLL.</span></span>
- <span data-ttu-id="dd193-136">COM est une spécification binaire.</span><span class="sxs-lookup"><span data-stu-id="dd193-136">COM is a binary specification.</span></span> <span data-ttu-id="dd193-137">Les objets COM peuvent être écrits et accessibles à partir d’un large éventail de langages.</span><span class="sxs-lookup"><span data-stu-id="dd193-137">COM objects can be written in and accessed from a variety of languages.</span></span> <span data-ttu-id="dd193-138">Vous n’avez rien à savoir sur le code source de l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-138">You don't need to know anything about the object's source code.</span></span> <span data-ttu-id="dd193-139">Par exemple, Visual Basic applications utilisent régulièrement des objets COM qui ont été écrits en C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-139">For example, Visual Basic applications routinely use COM objects that were written in C++.</span></span>

## <a name="component-object-and-interface"></a><span data-ttu-id="dd193-140">Composant, objet et interface</span><span class="sxs-lookup"><span data-stu-id="dd193-140">Component, object, and interface</span></span>

<span data-ttu-id="dd193-141">Il est important de comprendre la distinction entre les composants, les objets et les interfaces.</span><span class="sxs-lookup"><span data-stu-id="dd193-141">It's important to understand the distinction between components, objects, and interfaces.</span></span> <span data-ttu-id="dd193-142">En cas d’utilisation occasionnelle, vous pouvez entendre un composant ou un objet référencé par le nom de son interface principale.</span><span class="sxs-lookup"><span data-stu-id="dd193-142">In casual usage, you may hear a component or object referred to by the name of its principal interface.</span></span> <span data-ttu-id="dd193-143">Mais les termes ne sont pas interchangeables.</span><span class="sxs-lookup"><span data-stu-id="dd193-143">But the terms are not interchangeable.</span></span> <span data-ttu-id="dd193-144">Un composant peut implémenter n’importe quel nombre d’interfaces ; et un objet est une instance d’un composant.</span><span class="sxs-lookup"><span data-stu-id="dd193-144">A component can implement any number of interfaces; and an object is an instance of a component.</span></span> <span data-ttu-id="dd193-145">Par exemple, bien que tous les composants doivent implémenter l' [**interface IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), ils implémentent généralement au moins une interface supplémentaire, et ils peuvent implémenter beaucoup.</span><span class="sxs-lookup"><span data-stu-id="dd193-145">For example, while all components must implement the [**IUnknown interface**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), they normally implement at least one additional interface, and they might implement many.</span></span>

<span data-ttu-id="dd193-146">Pour utiliser une méthode d’interface particulière, vous ne devez pas instancier un objet, vous devez également obtenir l’interface appropriée.</span><span class="sxs-lookup"><span data-stu-id="dd193-146">To use a particular interface method, you must not only instantiate an object, you must also obtain the correct interface from it.</span></span>

<span data-ttu-id="dd193-147">En outre, plusieurs composants peuvent implémenter la même interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-147">In addition, more than one component might implement the same interface.</span></span> <span data-ttu-id="dd193-148">Une interface est un groupe de méthodes qui effectuent un ensemble d’opérations liées de manière logique.</span><span class="sxs-lookup"><span data-stu-id="dd193-148">An interface is a group of methods that perform a logically-related set of operations.</span></span> <span data-ttu-id="dd193-149">La définition d’interface spécifie uniquement la syntaxe des méthodes et leurs fonctionnalités générales.</span><span class="sxs-lookup"><span data-stu-id="dd193-149">The interface definition specifies only the syntax of the methods and their general functionality.</span></span> <span data-ttu-id="dd193-150">Tout composant COM qui doit prendre en charge un ensemble d’opérations particulier peut le faire en implémentant une interface appropriée.</span><span class="sxs-lookup"><span data-stu-id="dd193-150">Any COM component that needs to support a particular set of operations can do so by implementing a suitable interface.</span></span> <span data-ttu-id="dd193-151">Certaines interfaces sont hautement spécialisées et sont implémentées uniquement par un seul composant ; d’autres sont utiles dans de nombreuses circonstances et sont implémentées par de nombreux composants.</span><span class="sxs-lookup"><span data-stu-id="dd193-151">Some interfaces are highly specialized, and are implemented only by a single component; others are useful in a variety of circumstances, and are implemented by many components.</span></span>

<span data-ttu-id="dd193-152">Si un composant implémente une interface, il doit prendre en charge chaque méthode dans la définition de l’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-152">If a component implements an interface, it must support every method in the interface definition.</span></span> <span data-ttu-id="dd193-153">En d’autres termes, vous devez être en mesure d’appeler n’importe quelle méthode et de vous assurer qu’elle existe.</span><span class="sxs-lookup"><span data-stu-id="dd193-153">In other words, you must be able to call any method and be confident that it exists.</span></span> <span data-ttu-id="dd193-154">Toutefois, les détails de la façon dont une méthode particulière est implémentée peuvent varier d’un composant à un autre.</span><span class="sxs-lookup"><span data-stu-id="dd193-154">However, the details of how a particular method is implemented may vary from one component to another.</span></span> <span data-ttu-id="dd193-155">Par exemple, différents composants peuvent utiliser des algorithmes différents pour arriver au résultat final.</span><span class="sxs-lookup"><span data-stu-id="dd193-155">For example, different components may use different algorithms to arrive at the final result.</span></span> <span data-ttu-id="dd193-156">Il n’y a pas non plus de garantie qu’une méthode ne sera pas prise en charge d’une façon non évidente.</span><span class="sxs-lookup"><span data-stu-id="dd193-156">There is also no guarantee that a method will be supported in a nontrivial way.</span></span> <span data-ttu-id="dd193-157">Parfois, un composant implémente une interface couramment utilisée, mais il ne doit prendre en charge qu’un sous-ensemble des méthodes.</span><span class="sxs-lookup"><span data-stu-id="dd193-157">Sometimes, a component implements a commonly-used interface, but it needs to support only a subset of the methods.</span></span> <span data-ttu-id="dd193-158">Vous serez toujours en mesure d’appeler correctement les méthodes restantes, mais elles retournent un [**HRESULT**](#hresult-values) (qui est un type com standard représentant un code de résultat) contenant la valeur **E_NOTIMPL**.</span><span class="sxs-lookup"><span data-stu-id="dd193-158">You will still be able to call the remaining methods successfully, but they will return an [**HRESULT**](#hresult-values) (which is a standard COM type representing a result code) containing the value **E_NOTIMPL**.</span></span> <span data-ttu-id="dd193-159">Vous devez faire référence à sa documentation pour voir comment une interface est implémentée par un composant particulier.</span><span class="sxs-lookup"><span data-stu-id="dd193-159">You should refer to its documentation to see how an interface is implemented by any particular component.</span></span>

<span data-ttu-id="dd193-160">La norme COM exige qu’une définition d’interface ne soit pas modifiée une fois qu’elle a été publiée.</span><span class="sxs-lookup"><span data-stu-id="dd193-160">The COM standard requires that an interface definition must not change once it has been published.</span></span> <span data-ttu-id="dd193-161">L’auteur ne peut pas, par exemple, ajouter une nouvelle méthode à une interface existante.</span><span class="sxs-lookup"><span data-stu-id="dd193-161">The author cannot, for example, add a new method to an existing interface.</span></span> <span data-ttu-id="dd193-162">L’auteur doit à la place créer une nouvelle interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-162">The author must instead create a new interface.</span></span> <span data-ttu-id="dd193-163">Bien qu’il n’existe aucune restriction sur les méthodes qui doivent être dans cette interface, il est courant de faire en sorte que l’interface de nouvelle génération comprenne toutes les méthodes de l’ancienne interface, ainsi que toutes les nouvelles méthodes.</span><span class="sxs-lookup"><span data-stu-id="dd193-163">While there are no restrictions on what methods must be in that interface, a common practice is to have the next-generation interface include all the of the old interface's methods, plus any new methods.</span></span>

<span data-ttu-id="dd193-164">Il n’est pas rare qu’une interface ait plusieurs générations.</span><span class="sxs-lookup"><span data-stu-id="dd193-164">It's not unusual for an interface to have several generations.</span></span> <span data-ttu-id="dd193-165">En règle générale, toutes les générations effectuent essentiellement la même tâche globale, mais elles sont différentes dans les détails.</span><span class="sxs-lookup"><span data-stu-id="dd193-165">Typically, all generations perform essentially the same overall task, but they're different in specifics.</span></span> <span data-ttu-id="dd193-166">Souvent, un composant COM implémente chaque génération actuelle et précédente du lignage d’une interface donnée.</span><span class="sxs-lookup"><span data-stu-id="dd193-166">Often, a COM component implements every current and prior generation of a given interface's lineage.</span></span> <span data-ttu-id="dd193-167">Cela permet aux anciennes applications de continuer à utiliser les interfaces plus anciennes de l’objet, tandis que les applications plus récentes peuvent tirer parti des fonctionnalités des interfaces les plus récentes.</span><span class="sxs-lookup"><span data-stu-id="dd193-167">Doing so allows older applications to continue using the object's older interfaces, while newer applications can take advantage of the features of the newer interfaces.</span></span> <span data-ttu-id="dd193-168">En règle générale, un groupe descendant d’interfaces ont le même nom, plus un entier qui indique la génération.</span><span class="sxs-lookup"><span data-stu-id="dd193-168">Typically, a descent group of interfaces all have the same name, plus an integer that indicates the generation.</span></span> <span data-ttu-id="dd193-169">Par exemple, si l’interface d’origine était nommée **IMyInterface** (impliquant la génération 1), les deux générations suivantes seraient appelées **IMyInterface2** et **IMyInterface3**.</span><span class="sxs-lookup"><span data-stu-id="dd193-169">For example, if the original interface were named **IMyInterface** (implying generation 1), then the next two generations would be called **IMyInterface2** and **IMyInterface3**.</span></span> <span data-ttu-id="dd193-170">Dans le cas des interfaces DirectX, les générations successives sont généralement nommées pour le numéro de version de DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-170">In the case of DirectX interfaces, successive generations are typically named for the version number of DirectX.</span></span>

## <a name="guids"></a><span data-ttu-id="dd193-171">GUID</span><span class="sxs-lookup"><span data-stu-id="dd193-171">GUIDs</span></span>

<span data-ttu-id="dd193-172">Les GUID sont un élément clé du modèle de programmation COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-172">GUIDs are a key part of the COM programming model.</span></span> <span data-ttu-id="dd193-173">Au plus basique, un GUID est une structure 128 bits.</span><span class="sxs-lookup"><span data-stu-id="dd193-173">At its most basic, a GUID is a 128-bit structure.</span></span> <span data-ttu-id="dd193-174">Toutefois, les GUID sont créés de manière à garantir que deux GUID ne sont pas identiques.</span><span class="sxs-lookup"><span data-stu-id="dd193-174">However, GUIDs are created in such a way as to guarantee that no two GUIDs are the same.</span></span> <span data-ttu-id="dd193-175">COM utilise largement des GUID pour deux raisons principales.</span><span class="sxs-lookup"><span data-stu-id="dd193-175">COM uses GUIDs extensively for two primary purposes.</span></span>

- <span data-ttu-id="dd193-176">Pour identifier de façon unique un composant COM particulier.</span><span class="sxs-lookup"><span data-stu-id="dd193-176">To uniquely identify a particular COM component.</span></span> <span data-ttu-id="dd193-177">Un GUID qui est assigné pour identifier un composant COM est appelé identificateur de classe (CLSID) et vous utilisez un CLSID lorsque vous souhaitez créer une instance du composant COM associé.</span><span class="sxs-lookup"><span data-stu-id="dd193-177">A GUID that is assigned to identify a COM component is called a class identifier (CLSID), and you use a CLSID when you want to create an instance of the associated COM component.</span></span>
- <span data-ttu-id="dd193-178">Pour identifier de façon unique une interface COM particulière.</span><span class="sxs-lookup"><span data-stu-id="dd193-178">To uniquely identify a particular COM interface.</span></span> <span data-ttu-id="dd193-179">Un GUID qui est assigné pour identifier une interface COM est appelé un identificateur d’interface (IID) et vous utilisez un IID quand vous demandez une interface particulière à partir d’une instance d’un composant (un objet).</span><span class="sxs-lookup"><span data-stu-id="dd193-179">A GUID that is assigned to identify a COM interface is called an interface identifier (IID), and you use an IID when you request a particular interface from an instance of a component (an object).</span></span> <span data-ttu-id="dd193-180">L’IID d’une interface sera le même, quel que soit le composant qui implémente l’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-180">An interface's IID will be the same, regardless of which component implements the interface.</span></span>

<span data-ttu-id="dd193-181">Pour plus de commodité, la documentation DirectX fait normalement référence aux composants et aux interfaces par leurs noms descriptifs (par exemple, **ID3D12Device**) plutôt que par leurs GUID.</span><span class="sxs-lookup"><span data-stu-id="dd193-181">For convenience, the DirectX documentation normally refers to components and interfaces by their descriptive names (for example, **ID3D12Device**) rather than by their GUIDs.</span></span> <span data-ttu-id="dd193-182">Dans le contexte de la documentation DirectX, il n’y a aucune ambiguïté.</span><span class="sxs-lookup"><span data-stu-id="dd193-182">Within the context of the DirectX documentation, there is no ambiguity.</span></span> <span data-ttu-id="dd193-183">Il est techniquement possible pour un tiers de créer une interface avec le nom descriptif **ID3D12Device** (il doit avoir un IID différent pour être valide).</span><span class="sxs-lookup"><span data-stu-id="dd193-183">It's technically possible for a third-party to author an interface with the descriptive name **ID3D12Device** (it would need to have a different IID in order to be valid).</span></span> <span data-ttu-id="dd193-184">Dans un souci de clarté, toutefois, nous ne vous recommandons pas.</span><span class="sxs-lookup"><span data-stu-id="dd193-184">In the interest of clarity, though, we don't recommend that.</span></span>

<span data-ttu-id="dd193-185">Ainsi, la seule manière non ambiguë de faire référence à un objet ou une interface particulier est par son GUID.</span><span class="sxs-lookup"><span data-stu-id="dd193-185">So, the only unambiguous way to refer to a particular object or interface is by its GUID.</span></span>

<span data-ttu-id="dd193-186">Bien qu’un GUID soit une structure, un GUID est souvent exprimé sous la forme d’une chaîne équivalente.</span><span class="sxs-lookup"><span data-stu-id="dd193-186">Although a GUID is a structure, a GUID is often expressed in equivalent string form.</span></span> <span data-ttu-id="dd193-187">Le format général de la forme de chaîne d’un GUID est 32 chiffres hexadécimaux, au format 8-4-4-4-12.</span><span class="sxs-lookup"><span data-stu-id="dd193-187">The general format of the string form of a GUID is 32 hexadecimal digits, in the format 8-4-4-4-12.</span></span> <span data-ttu-id="dd193-188">Autrement dit, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, où chaque x correspond à un chiffre hexadécimal.</span><span class="sxs-lookup"><span data-stu-id="dd193-188">That is, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}, where each x corresponds to a hexadecimal digit.</span></span> <span data-ttu-id="dd193-189">Par exemple, la chaîne de l’IID de l’interface **ID3D12Device** est {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span><span class="sxs-lookup"><span data-stu-id="dd193-189">For example, the string form of the IID for the **ID3D12Device** interface is {189819F1-1DB6-4B57-BE54-1821339B85F7}.</span></span>

<span data-ttu-id="dd193-190">Étant donné que le GUID réel est quelque peu encombrant et facile à utiliser, un nom équivalent est également fourni.</span><span class="sxs-lookup"><span data-stu-id="dd193-190">Because the actual GUID is somewhat clumsy to use and easy to mistype, an equivalent name is usually provided as well.</span></span> <span data-ttu-id="dd193-191">Dans votre code, vous pouvez utiliser ce nom au lieu de la structure réelle quand vous appelez des fonctions, par exemple quand vous transmettez un argument pour le `riid` paramètre à [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span><span class="sxs-lookup"><span data-stu-id="dd193-191">In your code, you can use this name instead of the actual structure when you call functions, for example when you pass an argument for the `riid` parameter to [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice).</span></span> <span data-ttu-id="dd193-192">La Convention d’affectation de noms personnalisée consiste à ajouter IID_ ou CLSID_ au nom descriptif de l’interface ou de l’objet, respectivement.</span><span class="sxs-lookup"><span data-stu-id="dd193-192">The customary naming convention is to prepend either IID_ or CLSID_ to the descriptive name of the interface or object, respectively.</span></span> <span data-ttu-id="dd193-193">Par exemple, le nom de l’IID de l’interface **ID3D12Device** est IID_ID3D12Device.</span><span class="sxs-lookup"><span data-stu-id="dd193-193">For example, the name of the **ID3D12Device** interface's IID is IID_ID3D12Device.</span></span>

> [!NOTE]
> <span data-ttu-id="dd193-194">Les applications DirectX doivent établir une liaison avec ``dxguid.lib`` et ``uuid.lib`` pour fournir des définitions pour les différents GUID d’interface et de classe.</span><span class="sxs-lookup"><span data-stu-id="dd193-194">DirectX applications should link with ``dxguid.lib`` and ``uuid.lib`` to provide definitions for the various interface and class GUIDs.</span></span> <span data-ttu-id="dd193-195">Visual C++ et d’autres compilateurs prennent en charge l’extension de langage d’opérateur **__uuidof** , mais la liaison de style C explicite avec ces bibliothèques de liens est également prise en charge et entièrement portable.</span><span class="sxs-lookup"><span data-stu-id="dd193-195">Visual C++ and other compilers support the **__uuidof** operator language extension, but explicit C-style linkage with these link libraries is also supported and fully portable.</span></span>

## <a name="hresult-values"></a><span data-ttu-id="dd193-196">Valeurs HRESULT</span><span class="sxs-lookup"><span data-stu-id="dd193-196">HRESULT values</span></span>

<span data-ttu-id="dd193-197">La plupart des méthodes COM retournent un entier 32 bits appelé **HRESULT**.</span><span class="sxs-lookup"><span data-stu-id="dd193-197">Most COM methods return a 32-bit integer called an **HRESULT**.</span></span> <span data-ttu-id="dd193-198">Avec la plupart des méthodes, HRESULT est essentiellement une structure qui contient deux informations principales.</span><span class="sxs-lookup"><span data-stu-id="dd193-198">With most methods, the HRESULT is essentially a structure that contains two primary pieces of information.</span></span>
- <span data-ttu-id="dd193-199">Indique si la méthode a réussi ou échoué.</span><span class="sxs-lookup"><span data-stu-id="dd193-199">Whether the method succeeded or failed.</span></span>
- <span data-ttu-id="dd193-200">Informations plus détaillées sur le résultat de l’opération effectuée par la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-200">More detailed information about the outcome of the operation performed by the method.</span></span>

<span data-ttu-id="dd193-201">Certaines méthodes retournent une valeur **HRESULT** à partir de l’ensemble standard défini dans `Winerror.h` .</span><span class="sxs-lookup"><span data-stu-id="dd193-201">Some methods return a **HRESULT** value from the standard set defined in `Winerror.h`.</span></span> <span data-ttu-id="dd193-202">Toutefois, une méthode est libre de retourner une valeur **HRESULT** personnalisée avec des informations plus spécialisées.</span><span class="sxs-lookup"><span data-stu-id="dd193-202">However, a method is free to return a custom **HRESULT** value with more specialized information.</span></span> <span data-ttu-id="dd193-203">Ces valeurs sont généralement documentées sur la page de référence de la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-203">These values are normally documented on the method's reference page.</span></span>

<span data-ttu-id="dd193-204">La liste des valeurs **HRESULT** que vous trouvez dans la page de référence d’une méthode est souvent uniquement un sous-ensemble des valeurs possibles qui peuvent être retournées.</span><span class="sxs-lookup"><span data-stu-id="dd193-204">The list of **HRESULT** values that you find on a method's reference page is often only a subset of the possible values that may be returned.</span></span> <span data-ttu-id="dd193-205">En général, la liste couvre uniquement les valeurs qui sont spécifiques à la méthode, ainsi que les valeurs standard qui ont une signification spécifique à la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-205">The list typically covers only those values that are specific to the method, as well as those standard values that have some method-specific meaning.</span></span> <span data-ttu-id="dd193-206">Vous devez supposer qu’une méthode peut retourner une variété de valeurs **HRESULT** standard, même si elles ne sont pas explicitement documentées.</span><span class="sxs-lookup"><span data-stu-id="dd193-206">You should assume that a method may return a variety of standard **HRESULT** values, even if they're not explicitly documented.</span></span>

<span data-ttu-id="dd193-207">Alors que les valeurs **HRESULT** sont souvent utilisées pour retourner les informations d’erreur, vous ne devez pas les considérer comme des codes d’erreur.</span><span class="sxs-lookup"><span data-stu-id="dd193-207">While **HRESULT** values are often used to return error information, you should not think of them as error codes.</span></span> <span data-ttu-id="dd193-208">Le fait que le bit qui indique la réussite ou l’échec est stocké séparément des bits qui contiennent les informations détaillées permet aux valeurs **HRESULT** d’avoir un nombre quelconque de codes de réussite et d’échec.</span><span class="sxs-lookup"><span data-stu-id="dd193-208">The fact that the bit that indicates success or failure is stored separately from the bits that contain the detailed information allows **HRESULT** values to have any number of success and failure codes.</span></span> <span data-ttu-id="dd193-209">Par Convention, les noms des codes de réussite sont préfixés par les codes d’S_ et d’échec en E_.</span><span class="sxs-lookup"><span data-stu-id="dd193-209">By convention, the names of success codes are prefixed by S_ and failure codes by E_.</span></span> <span data-ttu-id="dd193-210">Par exemple, les deux codes les plus couramment utilisés sont S_OK et E_FAIL, qui indiquent respectivement une réussite ou un échec simple.</span><span class="sxs-lookup"><span data-stu-id="dd193-210">For example, the two most commonly used codes are S_OK and E_FAIL, which indicate simple success or failure, respectively.</span></span>

<span data-ttu-id="dd193-211">Le fait que les méthodes COM puissent retourner une variété de codes de réussite ou d’échec signifie que vous devez faire attention à la façon dont vous testez la valeur **HRESULT** .</span><span class="sxs-lookup"><span data-stu-id="dd193-211">The fact that COM methods may return a variety of success or failure codes means that you have to be careful how you test the **HRESULT** value.</span></span> <span data-ttu-id="dd193-212">Par exemple, considérez une méthode hypothétique avec des valeurs de retour documentées de S_OK en cas de réussite et E_FAIL dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="dd193-212">For example, consider a hypothetical method with documented return values of S_OK if successful and E_FAIL if not.</span></span> <span data-ttu-id="dd193-213">Toutefois, n’oubliez pas que la méthode peut également retourner d’autres codes d’échec ou de réussite.</span><span class="sxs-lookup"><span data-stu-id="dd193-213">However, remember that the method may also return other failure or success codes.</span></span> <span data-ttu-id="dd193-214">Le fragment de code suivant illustre le risque d’utiliser un test simple, où `hr` contient la valeur **HRESULT** retournée par la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-214">The following code fragment illustrates the danger of using a simple test, where `hr` contains the **HRESULT** value returned by the method.</span></span>

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="dd193-215">Tant que, en cas d’échec, cette méthode ne retourne jamais E_FAIL (et pas un autre code d’échec), alors ce test fonctionne.</span><span class="sxs-lookup"><span data-stu-id="dd193-215">As long as, in the failure case, this method only ever return E_FAIL (and not some other failure code), then this test works.</span></span> <span data-ttu-id="dd193-216">Toutefois, il est plus réaliste qu’une méthode donnée soit implémentée pour retourner un ensemble de codes d’erreur spécifiques, peut-être E_NOTIMPL ou E_INVALIDARG.</span><span class="sxs-lookup"><span data-stu-id="dd193-216">However, it's more realistic that a given method is implemented to return a set of specific failure codes, perhaps E_NOTIMPL or E_INVALIDARG.</span></span> <span data-ttu-id="dd193-217">Avec le code ci-dessus, ces valeurs ne sont pas interprétées correctement comme un succès.</span><span class="sxs-lookup"><span data-stu-id="dd193-217">With the code above, those values would be incorrectly interpreted as a success.</span></span>

<span data-ttu-id="dd193-218">Si vous avez besoin d’informations détaillées sur le résultat de l’appel de la méthode, vous devez tester chaque valeur **HRESULT** pertinente.</span><span class="sxs-lookup"><span data-stu-id="dd193-218">If you need detailed information about the outcome of the method call, you need to test each relevant **HRESULT** value.</span></span> <span data-ttu-id="dd193-219">Toutefois, vous pouvez être intéressé uniquement par le fait que la méthode a réussi ou échoué.</span><span class="sxs-lookup"><span data-stu-id="dd193-219">However, you may be interested only in whether the method succeeded or failed.</span></span> <span data-ttu-id="dd193-220">Un moyen fiable de tester si une valeur **HRESULT** indique la réussite ou l’échec consiste à passer la valeur à l’une des macros suivantes, définie dans Winerror. h.</span><span class="sxs-lookup"><span data-stu-id="dd193-220">A robust way to test whether an **HRESULT** value indicates success or failure is to pass the value to the one of the following macros, defined in Winerror.h.</span></span>

- <span data-ttu-id="dd193-221">La `SUCCEEDED` macro retourne la valeur true pour un code de réussite et la valeur false pour un code d’échec.</span><span class="sxs-lookup"><span data-stu-id="dd193-221">The `SUCCEEDED` macro returns TRUE for a success code, and FALSE for a failure code.</span></span>
- <span data-ttu-id="dd193-222">La `FAILED` macro retourne la valeur true pour un code d’échec et la valeur false pour un code de réussite.</span><span class="sxs-lookup"><span data-stu-id="dd193-222">The `FAILED` macro returns TRUE for a failure code, and FALSE for a success code.</span></span>

<span data-ttu-id="dd193-223">Par conséquent, vous pouvez corriger le fragment de code précédent à l’aide de la `FAILED` macro, comme indiqué dans le code suivant.</span><span class="sxs-lookup"><span data-stu-id="dd193-223">So, you can fix the preceding code fragment by using the `FAILED` macro, as shown in the following code.</span></span>

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

<span data-ttu-id="dd193-224">Ce fragment de code corrigé traite correctement les E_NOTIMPL et les E_INVALIDARG comme des échecs.</span><span class="sxs-lookup"><span data-stu-id="dd193-224">This corrected code fragment properly treats E_NOTIMPL and E_INVALIDARG as failures.</span></span>

<span data-ttu-id="dd193-225">Bien que la plupart des méthodes COM retournent des valeurs **HRESULT** structurées, un petit nombre utilise la valeur **HRESULT** pour retourner un entier simple.</span><span class="sxs-lookup"><span data-stu-id="dd193-225">Although most COM methods return structured **HRESULT** values, a small number use the **HRESULT** to return a simple integer.</span></span> <span data-ttu-id="dd193-226">Implicitement, ces méthodes aboutissent toujours.</span><span class="sxs-lookup"><span data-stu-id="dd193-226">Implicitly, these methods are always successful.</span></span> <span data-ttu-id="dd193-227">Si vous transmettez un **HRESULT** de ce tri à la macro SUCCEEDED, la macro retourne toujours true.</span><span class="sxs-lookup"><span data-stu-id="dd193-227">If you pass an **HRESULT** of this sort to the SUCCEEDED macro, then the macro always returns TRUE.</span></span> <span data-ttu-id="dd193-228">Un exemple de méthode communément appelée qui ne retourne pas de valeur **HRESULT** est la méthode **IUnknown :: Release** , qui retourne un ulong.</span><span class="sxs-lookup"><span data-stu-id="dd193-228">An example of a commonly-called method that doesn't return an **HRESULT** is the **IUnknown::Release** method, which returns a ULONG.</span></span> <span data-ttu-id="dd193-229">Cette méthode décrémente le décompte de références d’un objet et retourne le décompte de références actuel.</span><span class="sxs-lookup"><span data-stu-id="dd193-229">This method decrements an object's reference count by one and returns the current reference count.</span></span> <span data-ttu-id="dd193-230">Consultez Gestion de la durée de vie d’un [objet com](#managing-a-com-objects-lifetime) pour une discussion sur le décompte de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-230">See [Managing a COM object's lifetime](#managing-a-com-objects-lifetime) for a discussion of reference counting.</span></span>

## <a name="the-address-of-a-pointer"></a><span data-ttu-id="dd193-231">Adresse d’un pointeur</span><span class="sxs-lookup"><span data-stu-id="dd193-231">The address of a pointer</span></span>

<span data-ttu-id="dd193-232">Si vous affichez quelques pages de référence de méthode COM, vous risquez de rencontrer ce qui suit.</span><span class="sxs-lookup"><span data-stu-id="dd193-232">If you view a few COM method reference pages, you'll probably run across something like the following.</span></span>

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

<span data-ttu-id="dd193-233">Bien qu’un pointeur normal soit tout à fait familier à un développeur C/C++, COM utilise souvent un niveau supplémentaire d’indirection.</span><span class="sxs-lookup"><span data-stu-id="dd193-233">While a normal pointer is quite familiar to any C/C++ developer, COM often uses an additional level of indirection.</span></span> <span data-ttu-id="dd193-234">Ce deuxième niveau d’indirection est indiqué par deux astérisques, `**` , à la suite de la déclaration de type, et le nom de la variable a généralement un préfixe `pp` .</span><span class="sxs-lookup"><span data-stu-id="dd193-234">This second level of indirection is indicated by two asterisks, `**`, following the type declaration, and the variable name typically has a prefix of `pp`.</span></span> <span data-ttu-id="dd193-235">Pour la fonction ci-dessus, le `ppDevice` paramètre est généralement désigné comme l’adresse d’un pointeur vers un void.</span><span class="sxs-lookup"><span data-stu-id="dd193-235">For the function above, the `ppDevice` parameter is typically referred to as the address of a pointer to a void.</span></span> <span data-ttu-id="dd193-236">Dans la pratique, dans cet exemple, `ppDevice` est l’adresse d’un pointeur vers une interface **ID3D12Device** .</span><span class="sxs-lookup"><span data-stu-id="dd193-236">In practice, in this example, `ppDevice` is the address of a pointer to an **ID3D12Device** interface.</span></span>

<span data-ttu-id="dd193-237">Contrairement à un objet C++, vous n’accédez pas directement aux méthodes d’un objet COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-237">Unlike a C++ object, you don't access a COM object's methods directly.</span></span> <span data-ttu-id="dd193-238">Au lieu de cela, vous devez obtenir un pointeur vers une interface qui expose la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-238">Instead, you must obtain a pointer to an interface that exposes the method.</span></span> <span data-ttu-id="dd193-239">Pour appeler la méthode, vous utilisez essentiellement la même syntaxe que pour appeler un pointeur vers une méthode C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-239">To invoke the method, you use essentially the same syntax as you would to invoke a pointer to a C++ method.</span></span> <span data-ttu-id="dd193-240">Par exemple, pour appeler la méthode **IMyInterface ::D osomething** , vous devez utiliser la syntaxe suivante.</span><span class="sxs-lookup"><span data-stu-id="dd193-240">For example, to invoke the **IMyInterface::DoSomething** method, you would use the following syntax.</span></span>

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

<span data-ttu-id="dd193-241">Le besoin d’un deuxième niveau d’indirection provient du fait que vous ne créez pas directement de pointeurs d’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-241">The need for a second level of indirection comes from the fact that you don't create interface pointers directly.</span></span> <span data-ttu-id="dd193-242">Vous devez appeler l’une des différentes méthodes, telles que la méthode **D3D12CreateDevice** indiquée ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="dd193-242">You must call one of a variety of methods, such as the **D3D12CreateDevice** method shown above.</span></span> <span data-ttu-id="dd193-243">Pour utiliser une telle méthode pour obtenir un pointeur d’interface, vous déclarez une variable en tant que pointeur vers l’interface souhaitée, puis vous transmettez l’adresse de cette variable à la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-243">To use such a method to obtain an interface pointer, you declare a variable as a pointer to the desired interface, and then you pass the address of that variable to the method.</span></span> <span data-ttu-id="dd193-244">En d’autres termes, vous transmettez l’adresse d’un pointeur vers la méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-244">In other words, you pass the address of a pointer to the method.</span></span> <span data-ttu-id="dd193-245">Lorsque la méthode est retournée, la variable pointe vers l’interface demandée et vous pouvez utiliser ce pointeur pour appeler l’une des méthodes de l’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-245">When the method returns, the variable points to the requested interface, and you can use that pointer to call any of the interface's methods.</span></span>

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a><span data-ttu-id="dd193-246">Création d’un objet COM</span><span class="sxs-lookup"><span data-stu-id="dd193-246">Creating a COM object</span></span>

<span data-ttu-id="dd193-247">Il existe plusieurs façons de créer un objet COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-247">There are several ways to create a COM object.</span></span> <span data-ttu-id="dd193-248">Ce sont les deux les plus couramment utilisés dans la programmation DirectX.</span><span class="sxs-lookup"><span data-stu-id="dd193-248">These are the two most commonly used in DirectX programming.</span></span>

- <span data-ttu-id="dd193-249">Indirectement, en appelant une méthode ou une fonction DirectX qui crée l’objet pour vous.</span><span class="sxs-lookup"><span data-stu-id="dd193-249">Indirectly, by calling a DirectX method or function that creates the object for you.</span></span> <span data-ttu-id="dd193-250">La méthode crée l’objet et retourne une interface sur l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-250">The method creates the object, and returns an interface on the object.</span></span> <span data-ttu-id="dd193-251">Lorsque vous créez un objet de cette manière, vous pouvez parfois spécifier l’interface qui doit être retournée, d’autres fois que l’interface est impliquée.</span><span class="sxs-lookup"><span data-stu-id="dd193-251">When you create an object this way, sometimes you can specify which interface should be returned, other times the interface is implied.</span></span> <span data-ttu-id="dd193-252">L’exemple de code ci-dessus montre comment créer indirectement un objet COM d’appareil Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="dd193-252">The code example above shows how to indirectly create a Direct3D 12 device COM object.</span></span>
- <span data-ttu-id="dd193-253">Directement, en passant le CLSID de l’objet à la [**fonction CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="dd193-253">Directly, by passing the object's CLSID to the [**CoCreateInstance function**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span> <span data-ttu-id="dd193-254">La fonction crée une instance de l’objet et retourne un pointeur vers une interface que vous spécifiez.</span><span class="sxs-lookup"><span data-stu-id="dd193-254">The function creates an instance of the object, and it returns a pointer to an interface that you specify.</span></span>

<span data-ttu-id="dd193-255">Une fois, avant de créer des objets COM, vous devez initialiser COM en appelant la [**fonction CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="dd193-255">One time, before you create any COM objects, you must initialize COM by calling the [**CoInitializeEx function**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="dd193-256">Si vous créez des objets indirectement, la méthode de création d’objet gère cette tâche.</span><span class="sxs-lookup"><span data-stu-id="dd193-256">If you're creating objects indirectly, then the object creation method handles this task.</span></span> <span data-ttu-id="dd193-257">Toutefois, si vous devez créer un objet avec **CoCreateInstance**, vous devez appeler **CoInitializeEx** explicitement.</span><span class="sxs-lookup"><span data-stu-id="dd193-257">But, if you need to create an object with **CoCreateInstance**, then you must call **CoInitializeEx** explicitly.</span></span> <span data-ttu-id="dd193-258">Lorsque vous avez terminé, COM doit être non initialisé en appelant [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span><span class="sxs-lookup"><span data-stu-id="dd193-258">When you're finished, COM must be uninitialized by calling [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize).</span></span> <span data-ttu-id="dd193-259">Si vous effectuez un appel à **CoInitializeEx** , vous devez le faire correspondre avec un appel à **CoUninitialize**.</span><span class="sxs-lookup"><span data-stu-id="dd193-259">If you make a call to **CoInitializeEx** then you must match it with a call to **CoUninitialize**.</span></span> <span data-ttu-id="dd193-260">En règle générale, les applications qui doivent initialiser explicitement COM le font dans leur routine de démarrage, et elles n’initialisent pas COM dans leur routine de nettoyage.</span><span class="sxs-lookup"><span data-stu-id="dd193-260">Typically, applications that need to explicitly initialize COM do so in their startup routine, and they uninitialize COM in their cleanup routine.</span></span>

<span data-ttu-id="dd193-261">Pour créer une nouvelle instance d’un objet COM avec **CoCreateInstance**, vous devez avoir le CLSID de l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-261">To create a new instance of a COM object with **CoCreateInstance**, you must have the object's CLSID.</span></span> <span data-ttu-id="dd193-262">Si ce CLSID est disponible publiquement, vous le trouverez dans la documentation de référence ou dans le fichier d’en-tête approprié.</span><span class="sxs-lookup"><span data-stu-id="dd193-262">If this CLSID is publicly available, you will find it in the reference documentation or the appropriate header file.</span></span> <span data-ttu-id="dd193-263">Si le CLSID n’est pas disponible publiquement, vous ne pouvez pas créer l’objet directement.</span><span class="sxs-lookup"><span data-stu-id="dd193-263">If the CLSID is not publicly available, then you can't create the object directly.</span></span>

<span data-ttu-id="dd193-264">La fonction **CoCreateInstance** a cinq paramètres.</span><span class="sxs-lookup"><span data-stu-id="dd193-264">The **CoCreateInstance** function has five parameters.</span></span> <span data-ttu-id="dd193-265">Pour les objets COM que vous allez utiliser avec DirectX, vous pouvez normalement définir les paramètres comme suit.</span><span class="sxs-lookup"><span data-stu-id="dd193-265">For the COM objects you will be using with DirectX, you can normally set the parameters as follows.</span></span>

<span data-ttu-id="dd193-266">*rclsid* Définissez cette valeur sur le CLSID de l’objet que vous souhaitez créer.</span><span class="sxs-lookup"><span data-stu-id="dd193-266">*rclsid* Set this to the CLSID of the object that you want to create.</span></span>

<span data-ttu-id="dd193-267">*pUnkOuter* Affectez à la valeur `nullptr` .</span><span class="sxs-lookup"><span data-stu-id="dd193-267">*pUnkOuter* Set to `nullptr`.</span></span> <span data-ttu-id="dd193-268">Ce paramètre est utilisé uniquement si vous regroupez des objets.</span><span class="sxs-lookup"><span data-stu-id="dd193-268">This parameter is used only if you are aggregating objects.</span></span> <span data-ttu-id="dd193-269">La description de l’agrégation COM n’entre pas dans le cadre de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="dd193-269">A discussion of COM aggregation is outside the scope of this topic.</span></span>

<span data-ttu-id="dd193-270">*dwClsContext* Définissez sur CLSCTX_INPROC_SERVER.</span><span class="sxs-lookup"><span data-stu-id="dd193-270">*dwClsContext* Set to CLSCTX_INPROC_SERVER.</span></span> <span data-ttu-id="dd193-271">Ce paramètre indique que l’objet est implémenté en tant que DLL et s’exécute dans le cadre du processus de votre application.</span><span class="sxs-lookup"><span data-stu-id="dd193-271">This setting indicates that the object is implemented as a DLL and runs as part of your application's process.</span></span>

<span data-ttu-id="dd193-272">*riid* Définissez sur l’IID de l’interface que vous souhaitez retourner.</span><span class="sxs-lookup"><span data-stu-id="dd193-272">*riid* Set to the IID of the interface that you would like to have returned.</span></span> <span data-ttu-id="dd193-273">La fonction crée l’objet et retourne le pointeur d’interface demandé dans le paramètre PPV.</span><span class="sxs-lookup"><span data-stu-id="dd193-273">The function will create the object and return the requested interface pointer in the ppv parameter.</span></span>

<span data-ttu-id="dd193-274">*PPV* Affectez-lui l’adresse d’un pointeur qui sera défini sur l’interface spécifiée par `riid` lorsque la fonction retourne.</span><span class="sxs-lookup"><span data-stu-id="dd193-274">*ppv* Set this to the address of a pointer that will be set to the interface specified by `riid` when the function returns.</span></span> <span data-ttu-id="dd193-275">Cette variable doit être déclarée comme un pointeur vers l’interface demandée, et la référence au pointeur dans la liste de paramètres doit être castée en (LPVOID \*).</span><span class="sxs-lookup"><span data-stu-id="dd193-275">This variable should be declared as a pointer to the requested interface, and the reference to the pointer in the parameter list should be cast as (LPVOID \*).</span></span>

<span data-ttu-id="dd193-276">La création d’un objet indirectement est généralement nettement plus simple, comme nous l’avons vu dans l’exemple de code ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="dd193-276">Creating an object indirectly is usually much simpler, as we saw in the code example above.</span></span> <span data-ttu-id="dd193-277">Vous transmettez à la méthode de création d’objet l’adresse d’un pointeur d’interface, et la méthode crée ensuite l’objet et retourne un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-277">You pass the object creation method the address of an interface pointer, and the method then creates the object and returns an interface pointer.</span></span> <span data-ttu-id="dd193-278">Lorsque vous créez un objet indirectement, même si vous ne pouvez pas choisir l’interface retournée par la méthode, vous pouvez souvent spécifier un certain nombre de choses sur la façon dont l’objet doit être créé.</span><span class="sxs-lookup"><span data-stu-id="dd193-278">When you create an object indirectly, even if you can't choose which interface the method returns, often you can still specify a variety of things about how the object should be created.</span></span>

<span data-ttu-id="dd193-279">Par exemple, vous pouvez passer à **D3D12CreateDevice** une valeur spécifiant le niveau de fonctionnalité D3D minimal que l’appareil retourné doit prendre en charge, comme indiqué dans l’exemple de code ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="dd193-279">For example, you can pass to **D3D12CreateDevice** a value specifying the minimum D3D feature level that the returned device should support, as shown in the code example above.</span></span>

## <a name="using-com-interfaces"></a><span data-ttu-id="dd193-280">Utilisation des interfaces COM</span><span class="sxs-lookup"><span data-stu-id="dd193-280">Using COM interfaces</span></span>

<span data-ttu-id="dd193-281">Lorsque vous créez un objet COM, la méthode de création retourne un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-281">When you create a COM object, the creation method returns an interface pointer.</span></span> <span data-ttu-id="dd193-282">Vous pouvez ensuite utiliser ce pointeur pour accéder à n’importe quelle méthode de l’interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-282">You can then use that pointer to access any of the interface's methods.</span></span> <span data-ttu-id="dd193-283">La syntaxe est identique à celle utilisée avec un pointeur vers une méthode C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-283">The syntax is identical to that used with a pointer to a C++ method.</span></span>

## <a name="requesting-additional-interfaces"></a><span data-ttu-id="dd193-284">Demande d’interfaces supplémentaires</span><span class="sxs-lookup"><span data-stu-id="dd193-284">Requesting Additional Interfaces</span></span>

<span data-ttu-id="dd193-285">Dans de nombreux cas, le pointeur d’interface que vous recevez de la méthode de création peut être le seul dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="dd193-285">In many cases, the interface pointer that you receive from the creation method may be the only one that you need.</span></span> <span data-ttu-id="dd193-286">En fait, il est relativement courant pour un objet d’exporter une seule interface autre que **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="dd193-286">In fact, it's relatively common for an object to export only one interface other than **IUnknown**.</span></span> <span data-ttu-id="dd193-287">Toutefois, de nombreux objets exportent plusieurs interfaces et vous pouvez avoir besoin de pointeurs vers plusieurs d’entre eux.</span><span class="sxs-lookup"><span data-stu-id="dd193-287">However, many objects export multiple interfaces, and you may need pointers to several of them.</span></span> <span data-ttu-id="dd193-288">Si vous avez besoin de davantage d’interfaces que celles retournées par la méthode de création, il n’est pas nécessaire de créer un nouvel objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-288">If you need more interfaces than the one returned by the creation method, there's no need to create a new object.</span></span> <span data-ttu-id="dd193-289">Au lieu de cela, demandez un autre pointeur d’interface à l’aide de la [**méthode IUnknown :: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))de l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-289">Instead, request another interface pointer by using the object's [**IUnknown::QueryInterface method**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)).</span></span>

<span data-ttu-id="dd193-290">Si vous créez votre objet avec **CoCreateInstance**, vous pouvez demander un pointeur d’interface **IUnknown** , puis appeler **IUnknown :: QueryInterface** pour demander chaque interface dont vous avez besoin.</span><span class="sxs-lookup"><span data-stu-id="dd193-290">If you create your object with **CoCreateInstance**, then you can request an **IUnknown** interface pointer and then call **IUnknown::QueryInterface** to request every interface you need.</span></span> <span data-ttu-id="dd193-291">Toutefois, cette approche est peu commode si vous n’avez besoin que d’une seule interface et qu’elle ne fonctionne pas du tout si vous utilisez une méthode de création d’objet qui ne vous permet pas de spécifier le pointeur d’interface qui doit être retourné.</span><span class="sxs-lookup"><span data-stu-id="dd193-291">However, this approach is inconvenient if you need only a single interface, and it doesn't work at all if you use an object creation method that doesn't allow you to specify which interface pointer should be returned.</span></span> <span data-ttu-id="dd193-292">Dans la pratique, vous n’avez généralement pas besoin d’obtenir un pointeur **IUnknown** explicite, car toutes les interfaces com étendent l’interface **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="dd193-292">In practice, you usually don't need to obtain an explicit **IUnknown** pointer, because all COM interfaces extend the **IUnknown** interface.</span></span>

<span data-ttu-id="dd193-293">L’extension d’une interface est conceptuellement similaire à l’héritage d’une classe C++.</span><span class="sxs-lookup"><span data-stu-id="dd193-293">Extending an interface is conceptually similar to inheriting from a C++ class.</span></span> <span data-ttu-id="dd193-294">L’interface enfant expose toutes les méthodes de l’interface parent, ainsi qu’une ou plusieurs de ses propres méthodes.</span><span class="sxs-lookup"><span data-stu-id="dd193-294">The child interface exposes all of the parent interface's methods, plus one or more of its own.</span></span> <span data-ttu-id="dd193-295">En fait, vous verrez souvent « Inherits from » utilisé à la place de « extends ».</span><span class="sxs-lookup"><span data-stu-id="dd193-295">In fact, you will often see "inherits from" used instead of "extends".</span></span> <span data-ttu-id="dd193-296">Vous devez vous souvenir que l’héritage est interne à l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-296">What you need to remember is that the inheritance is internal to the object.</span></span> <span data-ttu-id="dd193-297">Votre application ne peut pas hériter de l’interface d’un objet ou l’étendre.</span><span class="sxs-lookup"><span data-stu-id="dd193-297">Your application can't inherit from or extend an object's interface.</span></span> <span data-ttu-id="dd193-298">Toutefois, vous pouvez utiliser l’interface enfant pour appeler l’une des méthodes de l’enfant ou du parent.</span><span class="sxs-lookup"><span data-stu-id="dd193-298">However, you can use the child interface to call any of the methods of the child or parent.</span></span>

<span data-ttu-id="dd193-299">Étant donné que toutes les interfaces sont des enfants de **IUnknown**, vous pouvez appeler **QueryInterface** sur l’un des pointeurs d’interface que vous avez déjà pour l’objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-299">Because all interfaces are children of **IUnknown**, you can call **QueryInterface** on any of the interface pointers that you already have for the object.</span></span> <span data-ttu-id="dd193-300">Dans ce cas, vous devez fournir l’IID de l’interface que vous demandez et l’adresse d’un pointeur qui contiendra le pointeur d’interface lorsque la méthode est retournée.</span><span class="sxs-lookup"><span data-stu-id="dd193-300">When you do so, you must provide the IID of the interface that you're requesting and the address of a pointer that will contain the interface pointer when the method returns.</span></span>

<span data-ttu-id="dd193-301">Par exemple, le fragment de code suivant appelle **IDXGIFactory2 :: CreateSwapChainForHwnd** pour créer un objet de chaîne de permutation principale.</span><span class="sxs-lookup"><span data-stu-id="dd193-301">For example, the following code fragment calls **IDXGIFactory2::CreateSwapChainForHwnd** to create a primary swap chain object.</span></span> <span data-ttu-id="dd193-302">Cet objet expose plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="dd193-302">This object exposes several interfaces.</span></span> <span data-ttu-id="dd193-303">La méthode **CreateSwapChainForHwnd** retourne une interface **IDXGISwapChain1** .</span><span class="sxs-lookup"><span data-stu-id="dd193-303">The **CreateSwapChainForHwnd** method returns an **IDXGISwapChain1** interface.</span></span> <span data-ttu-id="dd193-304">Le code suivant utilise ensuite l’interface **IDXGISwapChain1** pour appeler **QueryInterface** afin de demander une interface **IDXGISwapChain3** .</span><span class="sxs-lookup"><span data-stu-id="dd193-304">The subsequent code then uses the **IDXGISwapChain1** interface to call **QueryInterface** to request an **IDXGISwapChain3** interface.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> <span data-ttu-id="dd193-305">En C++, vous pouvez utiliser la ``IID_PPV_ARGS`` macro plutôt que l’IID explicite et le pointeur Cast : ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .</span><span class="sxs-lookup"><span data-stu-id="dd193-305">In C++ you can make use of the ``IID_PPV_ARGS`` macro rather than the explicit IID and cast pointer: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));``.</span></span>
> <span data-ttu-id="dd193-306">Cela est souvent utilisé pour les méthodes de création, ainsi que pour **QueryInterface**.</span><span class="sxs-lookup"><span data-stu-id="dd193-306">This is often used for creation methods as well as **QueryInterface**.</span></span> <span data-ttu-id="dd193-307">Pour plus d’informations, consultez [combaseapi. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) .</span><span class="sxs-lookup"><span data-stu-id="dd193-307">See [combaseapi.h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) for more information.</span></span>

## <a name="managing-a-com-objects-lifetime"></a><span data-ttu-id="dd193-308">Gestion de la durée de vie d’un objet COM</span><span class="sxs-lookup"><span data-stu-id="dd193-308">Managing a COM object's lifetime</span></span>

<span data-ttu-id="dd193-309">Lorsqu’un objet est créé, le système alloue les ressources mémoire nécessaires.</span><span class="sxs-lookup"><span data-stu-id="dd193-309">When an object is created, the system allocates the necessary memory resources.</span></span> <span data-ttu-id="dd193-310">Lorsqu’un objet n’est plus nécessaire, il doit être détruit.</span><span class="sxs-lookup"><span data-stu-id="dd193-310">When an object is no longer needed, it should be destroyed.</span></span> <span data-ttu-id="dd193-311">Le système peut utiliser cette mémoire à d’autres fins.</span><span class="sxs-lookup"><span data-stu-id="dd193-311">The system can use that memory for other purposes.</span></span> <span data-ttu-id="dd193-312">Avec les objets C++, vous pouvez contrôler la durée de vie de l’objet directement avec les `new` `delete` opérateurs et dans les cas où vous travaillez à ce niveau, ou simplement à l’aide de la pile et de la durée de vie de la portée.</span><span class="sxs-lookup"><span data-stu-id="dd193-312">With C++ objects, you can control the object's lifetime directly with the `new` and `delete` operators in cases where you're operating at that level, or just by using the stack and scope lifetime.</span></span> <span data-ttu-id="dd193-313">COM ne vous permet pas de créer ou de détruire directement des objets.</span><span class="sxs-lookup"><span data-stu-id="dd193-313">COM doesn't enable you to directly create or destroy objects.</span></span> <span data-ttu-id="dd193-314">La raison de cette conception est que le même objet peut être utilisé par plusieurs parties de votre application ou, dans certains cas, par plusieurs applications.</span><span class="sxs-lookup"><span data-stu-id="dd193-314">The reason for this design is that the same object may be used by more than one part of your application or, in some cases, by more than one application.</span></span> <span data-ttu-id="dd193-315">Si l’une de ces références était de détruire l’objet, les autres références deviendront non valides.</span><span class="sxs-lookup"><span data-stu-id="dd193-315">If one of those references were to destroy the object, then the other references would become invalid.</span></span> <span data-ttu-id="dd193-316">Au lieu de cela, COM utilise un système de décompte de références pour contrôler la durée de vie d’un objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-316">Instead, COM uses a system of reference counting to control an object's lifetime.</span></span>

<span data-ttu-id="dd193-317">Le nombre de références d’un objet est le nombre de fois que l’une de ses interfaces a été demandée.</span><span class="sxs-lookup"><span data-stu-id="dd193-317">An object's reference count is the number of times one of its interfaces has been requested.</span></span> <span data-ttu-id="dd193-318">Chaque fois qu’une interface est demandée, le nombre de références est incrémenté.</span><span class="sxs-lookup"><span data-stu-id="dd193-318">Each time that an interface is requested, the reference count is incremented.</span></span> <span data-ttu-id="dd193-319">Une application libère une interface lorsque cette interface n’est plus nécessaire, ce qui décrémente le nombre de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-319">An application releases an interface when that interface is no longer needed, decrementing the reference count.</span></span> <span data-ttu-id="dd193-320">Tant que le nombre de références est supérieur à zéro, l’objet reste en mémoire.</span><span class="sxs-lookup"><span data-stu-id="dd193-320">As long as the reference count is greater than zero, the object remains in memory.</span></span> <span data-ttu-id="dd193-321">Lorsque le nombre de références atteint zéro, l’objet se détruit lui-même.</span><span class="sxs-lookup"><span data-stu-id="dd193-321">When the reference count reaches zero, the object destroys itself.</span></span> <span data-ttu-id="dd193-322">Vous n’avez rien à savoir sur le décompte de références d’un objet.</span><span class="sxs-lookup"><span data-stu-id="dd193-322">You don't need to know anything about the reference count of an object.</span></span> <span data-ttu-id="dd193-323">À condition que vous obteniez et libériez correctement les interfaces d’un objet, l’objet aura la durée de vie appropriée.</span><span class="sxs-lookup"><span data-stu-id="dd193-323">As long as you obtain and release an object's interfaces properly, the object will have the appropriate lifetime.</span></span>

<span data-ttu-id="dd193-324">La gestion correcte du décompte de références est un élément essentiel de la programmation COM.</span><span class="sxs-lookup"><span data-stu-id="dd193-324">Properly handling reference counting is a crucial part of COM programming.</span></span> <span data-ttu-id="dd193-325">Dans le cas contraire, vous risquez de créer facilement une fuite de mémoire ou un incident.</span><span class="sxs-lookup"><span data-stu-id="dd193-325">Failure to do so can easily create a memory leak or a crash.</span></span> <span data-ttu-id="dd193-326">L’une des erreurs les plus courantes effectuées par les programmeurs COM est l’échec de la libération d’une interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-326">One of the most common mistakes that COM programmers make is failing to release an interface.</span></span> <span data-ttu-id="dd193-327">Dans ce cas, le nombre de références n’atteint jamais la valeur zéro et l’objet reste en mémoire indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="dd193-327">When this happens, the reference count never reaches zero, and the object remains in memory indefinitely.</span></span>

> [!NOTE]
> <span data-ttu-id="dd193-328">Direct3D 10 ou une version ultérieure a des règles de durée de vie légèrement modifiées pour les objets.</span><span class="sxs-lookup"><span data-stu-id="dd193-328">Direct3D 10 or later has slightly modified lifetime rules for objects.</span></span> <span data-ttu-id="dd193-329">En particulier, les objets dérivés de **ID3DxxDeviceChild** ne survivent jamais leur appareil parent (autrement dit, si le **ID3DxxDevice** propriétaire atteint un refcount 0, tous les objets enfants sont également immédiatement non valides).</span><span class="sxs-lookup"><span data-stu-id="dd193-329">In particular, objects that are derived from **ID3DxxDeviceChild** never outlive their parent device (that is, if the owning **ID3DxxDevice** hits a 0 refcount, then all child objects are immediately invalid as well).</span></span> <span data-ttu-id="dd193-330">En outre, lorsque vous utilisez des méthodes **Set** pour lier des objets au pipeline de rendu, ces références n’augmentent pas le nombre de références (autrement dit, il s’agit de références faibles).</span><span class="sxs-lookup"><span data-stu-id="dd193-330">Also, when you use **Set** methods to bind objects to the render pipeline, these references don't increase the reference count (that is, they are weak references).</span></span> <span data-ttu-id="dd193-331">Dans la pratique, cette méthode est mieux gérée en vous assurant que vous libérez entièrement tous les objets enfants de l’appareil avant de libérer l’appareil.</span><span class="sxs-lookup"><span data-stu-id="dd193-331">In practice, this is best handled by ensuring that you release all device child objects fully before you release the device.</span></span>

## <a name="incrementing-and-decrementing-the-reference-count"></a><span data-ttu-id="dd193-332">Incrémentation et décrémentation du décompte de références</span><span class="sxs-lookup"><span data-stu-id="dd193-332">Incrementing and decrementing the reference count</span></span>

<span data-ttu-id="dd193-333">Chaque fois que vous obtenez un nouveau pointeur d’interface, le décompte de références doit être incrémenté par un appel à [**IUnknown :: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span><span class="sxs-lookup"><span data-stu-id="dd193-333">Whenever you obtain a new interface pointer, the reference count must be incremented by a call to [**IUnknown::AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref).</span></span> <span data-ttu-id="dd193-334">Toutefois, votre application n’a généralement pas besoin d’appeler cette méthode.</span><span class="sxs-lookup"><span data-stu-id="dd193-334">However, your application doesn't usually need to call this method.</span></span> <span data-ttu-id="dd193-335">Si vous obtenez un pointeur d’interface en appelant une méthode de création d’objet, ou en appelant **IUnknown :: QueryInterface**, l’objet incrémente automatiquement le nombre de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-335">If you obtain an interface pointer by calling an object creation method, or by calling **IUnknown::QueryInterface**, then the object automatically increments the reference count.</span></span> <span data-ttu-id="dd193-336">Toutefois, si vous créez un pointeur d’interface d’une autre façon, telle que la copie d’un pointeur existant, vous devez appeler explicitement **IUnknown :: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="dd193-336">However, if you create an interface pointer in some other way, such as copying an existing pointer, then you must explicitly call **IUnknown::AddRef**.</span></span> <span data-ttu-id="dd193-337">Dans le cas contraire, quand vous relâchez le pointeur d’interface d’origine, l’objet peut être détruit même si vous devez toujours utiliser la copie du pointeur.</span><span class="sxs-lookup"><span data-stu-id="dd193-337">Otherwise, when you release the original interface pointer, the object may be destroyed even though you may still need to use the copy of the pointer.</span></span>

<span data-ttu-id="dd193-338">Vous devez libérer tous les pointeurs d’interface, que vous ou l’objet incrémentiez ou non le nombre de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-338">You must release all interface pointers, regardless of whether you or the object incremented the reference count.</span></span> <span data-ttu-id="dd193-339">Quand vous n’avez plus besoin d’un pointeur d’interface, appelez [**IUnknown :: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) pour décrémenter le décompte de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-339">When you no longer need an interface pointer, call [**IUnknown::Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) to decrement the reference count.</span></span> <span data-ttu-id="dd193-340">Une pratique courante consiste à initialiser tous les pointeurs d’interface à `nullptr` , puis à les rétablir `nullptr` lorsqu’ils sont libérés.</span><span class="sxs-lookup"><span data-stu-id="dd193-340">A common practice is to initialize all interface pointers to `nullptr`, and then to set them back to `nullptr` when they are released.</span></span> <span data-ttu-id="dd193-341">Cette Convention vous permet de tester tous les pointeurs d’interface dans votre code de nettoyage.</span><span class="sxs-lookup"><span data-stu-id="dd193-341">That convention allows you to test all interface pointers in your cleanup code.</span></span> <span data-ttu-id="dd193-342">Ceux qui ne sont pas `nullptr` toujours actifs et vous devez les libérer avant de mettre fin à l’application.</span><span class="sxs-lookup"><span data-stu-id="dd193-342">Those that are not `nullptr` are still active, and you need to release them before you terminate the application.</span></span>

<span data-ttu-id="dd193-343">Le fragment de code suivant étend l’exemple indiqué plus haut pour illustrer comment gérer le décompte de références.</span><span class="sxs-lookup"><span data-stu-id="dd193-343">The following code fragment extends the sample shown earlier to illustrate how to handle reference counting.</span></span>

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a><span data-ttu-id="dd193-344">Pointeurs intelligents COM</span><span class="sxs-lookup"><span data-stu-id="dd193-344">COM Smart Pointers</span></span>

<span data-ttu-id="dd193-345">Le code jusqu’à présent a explicitement appelé ``Release`` et ``AddRef`` à conserver les décomptes de références à l’aide de méthodes **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="dd193-345">The code so far has explicitly called ``Release`` and ``AddRef`` to maintain the reference counts using **IUnknown** methods.</span></span> <span data-ttu-id="dd193-346">Ce modèle nécessite que le programmeur soit à l’œuvre d’une mise à jour correcte pour gérer correctement le nombre dans tous les chemins possibles.</span><span class="sxs-lookup"><span data-stu-id="dd193-346">This pattern requires the programmer to be diligent in remembering to properly maintain the count in all possible codepaths.</span></span> <span data-ttu-id="dd193-347">Cela peut entraîner une gestion complexe des erreurs, et la gestion des exceptions C++ activée peut être particulièrement difficile à implémenter.</span><span class="sxs-lookup"><span data-stu-id="dd193-347">This can result in complicated error-handling, and with C++ exception handling enabled can be particularly difficult to implement.</span></span> <span data-ttu-id="dd193-348">Une meilleure solution avec C++ consiste à utiliser un [pointeur intelligent](/cpp/cpp/smart-pointers-modern-cpp).</span><span class="sxs-lookup"><span data-stu-id="dd193-348">A better solution with C++ is to make use of a [smart pointer](/cpp/cpp/smart-pointers-modern-cpp).</span></span>

* <span data-ttu-id="dd193-349">**WinRT :: com_ptr** est un pointeur intelligent fourni par les [projections de langage C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr).</span><span class="sxs-lookup"><span data-stu-id="dd193-349">**winrt::com_ptr** is a smart pointer provided by the [C++/WinRT language projections](/uwp/cpp-ref-for-winrt/com-ptr).</span></span> <span data-ttu-id="dd193-350">Il s’agit du pointeur intelligent COM recommandé à utiliser pour les applications UWP.</span><span class="sxs-lookup"><span data-stu-id="dd193-350">This is the recommended COM smart pointer to use for UWP apps.</span></span> <span data-ttu-id="dd193-351">Notez que C++/WinRT requiert C++ 17.</span><span class="sxs-lookup"><span data-stu-id="dd193-351">Note that C++/WinRT requires C++17.</span></span>

* <span data-ttu-id="dd193-352">**Microsoft :: WRL :: ComPtr** est un pointeur intelligent fourni par le [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span><span class="sxs-lookup"><span data-stu-id="dd193-352">**Microsoft::WRL::ComPtr** is a smart pointer provided by the [Windows Runtime C++ Template Library (WRL)](/cpp/cppcx/wrl/comptr-class).</span></span> <span data-ttu-id="dd193-353">Cette bibliothèque est « pure » C++ et peut donc être utilisée pour les applications Windows Runtime (via C++/CX ou C++/WinRT), ainsi que pour les applications de bureau Win32 classiques.</span><span class="sxs-lookup"><span data-stu-id="dd193-353">This library is "pure" C++ so it can be utilized for Windows Runtime applications (via C++/CX or C++/WinRT) as well as classic Win32 desktop applications.</span></span> <span data-ttu-id="dd193-354">Ce pointeur intelligent fonctionne également sur les versions antérieures de Windows qui ne prennent pas en charge les API Windows Runtime.</span><span class="sxs-lookup"><span data-stu-id="dd193-354">This smart pointer also works on older versions of Windows that do not support the Windows Runtime APIs.</span></span> <span data-ttu-id="dd193-355">Pour les applications de bureau Win32, vous pouvez utiliser ``#include <wrl/client.h>`` pour inclure uniquement cette classe et éventuellement définir également le symbole de préprocesseur ``__WRL_CLASSIC_COM_STRICT__`` .</span><span class="sxs-lookup"><span data-stu-id="dd193-355">For Win32 desktop applications, you can use ``#include <wrl/client.h>`` to only include this class and optionally define the preprocessor symbol ``__WRL_CLASSIC_COM_STRICT__`` as well.</span></span> <span data-ttu-id="dd193-356">Pour plus d’informations, consultez [pointeurs intelligents com revisités](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span><span class="sxs-lookup"><span data-stu-id="dd193-356">For more information, see [COM smart pointers revisited](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited).</span></span>

* <span data-ttu-id="dd193-357">**CComPtr** est un pointeur intelligent fourni par le [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span><span class="sxs-lookup"><span data-stu-id="dd193-357">**CComPtr** is a smart pointer provided by the [Active Template Library (ATL)](/cpp/atl/reference/ccomptr-class).</span></span> <span data-ttu-id="dd193-358">**Microsoft :: WRL :: ComPtr** est une version plus récente de cette implémentation qui résout plusieurs problèmes d’utilisation subtils. l’utilisation de ce pointeur intelligent n’est donc pas recommandée pour les nouveaux projets.</span><span class="sxs-lookup"><span data-stu-id="dd193-358">The **Microsoft::WRL::ComPtr** is a newer version of this implementation that addresses a number of subtle usage issues, so use of this smart pointer is not recommended for new projects.</span></span> <span data-ttu-id="dd193-359">Pour plus d’informations, consultez [How to Create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span><span class="sxs-lookup"><span data-stu-id="dd193-359">For more information, see [How to create and use CComPtr and CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).</span></span>


## <a name="using-atl-with-directx-9"></a><span data-ttu-id="dd193-360">Utilisation d’ATL avec DirectX 9</span><span class="sxs-lookup"><span data-stu-id="dd193-360">Using ATL with DirectX 9</span></span>

<span data-ttu-id="dd193-361">Pour utiliser la Active Template Library (ATL) avec DirectX 9, vous devez redéfinir les interfaces pour la compatibilité ATL.</span><span class="sxs-lookup"><span data-stu-id="dd193-361">To use the Active Template Library (ATL) with DirectX 9, you must redefine the interfaces for ATL compatibility.</span></span> <span data-ttu-id="dd193-362">Cela vous permet d’utiliser correctement la classe **CComQIPtr** pour obtenir un pointeur vers une interface.</span><span class="sxs-lookup"><span data-stu-id="dd193-362">This allows you to properly use the **CComQIPtr** class to obtain a pointer to an interface.</span></span>

<span data-ttu-id="dd193-363">Vous saurez si vous ne redéfinissez pas les interfaces pour ATL, car le message d’erreur suivant s’affiche.</span><span class="sxs-lookup"><span data-stu-id="dd193-363">You'll know if you don't redefine the interfaces for ATL, because you'll see the following error message.</span></span>

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

<span data-ttu-id="dd193-364">L’exemple de code suivant montre comment définir l’interface IDirectXFileData.</span><span class="sxs-lookup"><span data-stu-id="dd193-364">The following code sample shows how to define the IDirectXFileData interface.</span></span>

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

<span data-ttu-id="dd193-365">Après avoir redéfini l’interface, vous devez utiliser la méthode **Attach** pour attacher l’interface au pointeur d’interface retourné par **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="dd193-365">After redefining the interface, you must use the **Attach** method to attach the interface to the interface pointer returned by **::Direct3DCreate9**.</span></span> <span data-ttu-id="dd193-366">Si ce n’est pas le cas, l’interface **IDirect3D9** ne sera pas correctement libérée par la classe de pointeur intelligent.</span><span class="sxs-lookup"><span data-stu-id="dd193-366">If you don't, then the **IDirect3D9** interface won't be properly released by the smart pointer class.</span></span>

<span data-ttu-id="dd193-367">La classe **CComPtr** appelle en interne **IUnknown :: AddRef** sur le pointeur d’interface lorsque l’objet est créé et lorsqu’une interface est assignée à la classe **CComPtr** .</span><span class="sxs-lookup"><span data-stu-id="dd193-367">The **CComPtr** class internally calls **IUnknown::AddRef** on the interface pointer when the object is created and when an interface is assigned to the **CComPtr** class.</span></span> <span data-ttu-id="dd193-368">Pour éviter la fuite du pointeur d’interface, n’appelez pas \* \* IUnknown :: AddRef sur l’interface retournée à partir de **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="dd193-368">To avoid leaking the interface pointer, don't call \*\*IUnknown::AddRef on the interface returned from **::Direct3DCreate9**.</span></span>

<span data-ttu-id="dd193-369">Le code suivant libère correctement l’interface sans appeler **IUnknown :: AddRef**.</span><span class="sxs-lookup"><span data-stu-id="dd193-369">The following code properly releases the interface without calling **IUnknown::AddRef**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

<span data-ttu-id="dd193-370">Utilisez le code précédent.</span><span class="sxs-lookup"><span data-stu-id="dd193-370">Use the previous code.</span></span> <span data-ttu-id="dd193-371">N’utilisez pas le code suivant, qui appelle **IUnknown :: AddRef** suivi de **IUnknown :: Release**, et qui ne libère pas la référence ajoutée par **::D irect3dcreate9**.</span><span class="sxs-lookup"><span data-stu-id="dd193-371">Don't use the following code, which calls **IUnknown::AddRef** followed by **IUnknown::Release**, and doesn't release the reference added by **::Direct3DCreate9**.</span></span>

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

<span data-ttu-id="dd193-372">Notez qu’il s’agit du seul emplacement dans Direct3D 9 où vous devrez utiliser la méthode **Attach** de cette manière.</span><span class="sxs-lookup"><span data-stu-id="dd193-372">Note that this is the only place in Direct3D 9 where you'll have to use the **Attach** method in this manner.</span></span>

<span data-ttu-id="dd193-373">Pour plus d’informations sur les classes **CComPTR** et **CComQIPtr** , consultez leurs définitions dans le `Atlbase.h` fichier d’en-tête.</span><span class="sxs-lookup"><span data-stu-id="dd193-373">For more information about the **CComPTR** and **CComQIPtr** classes, see their definitions in the `Atlbase.h` header file.</span></span>
