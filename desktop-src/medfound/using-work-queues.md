---
description: Cette rubrique explique comment utiliser les files d’attente de travail dans Microsoft Media Foundation.
ms.assetid: 6be05df7-e8ff-4110-8f73-a62eb31fd414
title: Utilisation des files d’attente de travail
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d7bb41b830742ca871d44cadac9bd26a9967aa1
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "104201841"
---
# <a name="using-work-queues"></a><span data-ttu-id="0f115-103">Utilisation des files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-103">Using Work Queues</span></span>

<span data-ttu-id="0f115-104">Cette rubrique explique comment utiliser les files d’attente de travail dans Microsoft Media Foundation.</span><span class="sxs-lookup"><span data-stu-id="0f115-104">This topic describes how to use work queues in Microsoft Media Foundation.</span></span>

-   [<span data-ttu-id="0f115-105">Utilisation des files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-105">Using Work Queues</span></span>](#using-work-queues)
-   [<span data-ttu-id="0f115-106">Arrêt des files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-106">Shutting Down Work Queues</span></span>](#shutting-down-work-queues)
-   [<span data-ttu-id="0f115-107">Utilisation d’éléments de travail planifiés</span><span class="sxs-lookup"><span data-stu-id="0f115-107">Using Scheduled Work Items</span></span>](#using-scheduled-work-items)
-   [<span data-ttu-id="0f115-108">Utilisation de rappels périodiques</span><span class="sxs-lookup"><span data-stu-id="0f115-108">Using Periodic Callbacks</span></span>](#using-periodic-callbacks)
-   [<span data-ttu-id="0f115-109">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="0f115-109">Related topics</span></span>](#related-topics)

## <a name="using-work-queues"></a><span data-ttu-id="0f115-110">Utilisation des files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-110">Using Work Queues</span></span>

<span data-ttu-id="0f115-111">Une file d’attente de travail est un moyen efficace d’effectuer des opérations asynchrones sur un autre thread.</span><span class="sxs-lookup"><span data-stu-id="0f115-111">A work queue is an efficient way to perform asynchronous operations on another thread.</span></span> <span data-ttu-id="0f115-112">D’un point de vue conceptuel, vous placez des éléments de travail dans la file d’attente et la file d’attente dispose d’un thread qui extrait chaque élément de la file d’attente et le distribue.</span><span class="sxs-lookup"><span data-stu-id="0f115-112">Conceptually, you put work items in the queue, and the queue has a thread that pulls each item from the queue and dispatches it.</span></span> <span data-ttu-id="0f115-113">Les éléments de travail sont implémentés en tant que rappels à l’aide de l’interface [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) .</span><span class="sxs-lookup"><span data-stu-id="0f115-113">Work items are implemented as callbacks by using the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span>

<span data-ttu-id="0f115-114">Media Foundation crée plusieurs files d’attente de travail standard, appelées *files d’attente de travail de plateforme*.</span><span class="sxs-lookup"><span data-stu-id="0f115-114">Media Foundation creates several standard work queues, called *platform work queues*.</span></span> <span data-ttu-id="0f115-115">Les applications peuvent également créer leurs propres files d’attente de travail, appelées *files d’attente de travail privées*.</span><span class="sxs-lookup"><span data-stu-id="0f115-115">Applications can also create their own work queues, called *private work queues*.</span></span> <span data-ttu-id="0f115-116">Pour obtenir la liste des files d’attente de travail de plateforme, consultez [identificateurs de file d’attente de travail](work-queue-identifiers.md).</span><span class="sxs-lookup"><span data-stu-id="0f115-116">For a list of the platform work queues, see [Work Queue Identifiers](work-queue-identifiers.md).</span></span> <span data-ttu-id="0f115-117">Pour créer une file d’attente de travail privée, appelez [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue).</span><span class="sxs-lookup"><span data-stu-id="0f115-117">To create a private work queue, call [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue).</span></span> <span data-ttu-id="0f115-118">Cette fonction retourne un identificateur pour la nouvelle file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-118">This function returns an identifier for the new work queue.</span></span> <span data-ttu-id="0f115-119">Pour placer un élément dans la file d’attente, appelez [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) ou [**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex).</span><span class="sxs-lookup"><span data-stu-id="0f115-119">To put an item in the queue, call [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) or [**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex).</span></span> <span data-ttu-id="0f115-120">Dans les deux cas, vous devez spécifier une interface de rappel.</span><span class="sxs-lookup"><span data-stu-id="0f115-120">In both cases, you must specify a callback interface.</span></span>

-   <span data-ttu-id="0f115-121">[**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) prend un pointeur vers l’interface [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) , plus un objet d’État facultatif qui implémente **IUnknown**.</span><span class="sxs-lookup"><span data-stu-id="0f115-121">[**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) takes a pointer to the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface, plus an optional state object that implements **IUnknown**.</span></span> <span data-ttu-id="0f115-122">Ce sont les mêmes paramètres que ceux utilisés dans les méthodes asynchrones, comme décrit dans la rubrique [méthodes de rappel asynchrones](asynchronous-callback-methods.md).</span><span class="sxs-lookup"><span data-stu-id="0f115-122">These are the same parameters used in asynchronous methods, as described in the topic [Asynchronous Callback Methods](asynchronous-callback-methods.md).</span></span> <span data-ttu-id="0f115-123">En interne, cette fonction crée un objet de résultat asynchrone, qui est passé à la méthode [**Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) du rappel.</span><span class="sxs-lookup"><span data-stu-id="0f115-123">Internally, this function creates an asynchronous result object, which is passed to the callback's [**Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) method.</span></span>
-   <span data-ttu-id="0f115-124">[**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex) prend un pointeur vers l’interface [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) .</span><span class="sxs-lookup"><span data-stu-id="0f115-124">[**MFPutWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitemex) takes a pointer to the [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) interface.</span></span> <span data-ttu-id="0f115-125">Cette interface représente un objet de résultat asynchrone.</span><span class="sxs-lookup"><span data-stu-id="0f115-125">This interface represents an asynchronous result object.</span></span> <span data-ttu-id="0f115-126">Créez cet objet en appelant [**MFCreateAsyncResult**](/windows/desktop/api/mfapi/nf-mfapi-mfcreateasyncresult) et en spécifiant votre interface de rappel et, éventuellement, un objet d’État.</span><span class="sxs-lookup"><span data-stu-id="0f115-126">Create this object by calling [**MFCreateAsyncResult**](/windows/desktop/api/mfapi/nf-mfapi-mfcreateasyncresult) and specifying your callback interface and, optionally, a state object.</span></span>

<span data-ttu-id="0f115-127">Dans les deux cas, le thread de file d’attente de travail appelle votre méthode [**IMFAsyncCallback :: Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) .</span><span class="sxs-lookup"><span data-stu-id="0f115-127">In both cases, the work queue thread calls your [**IMFAsyncCallback::Invoke**](/windows/desktop/api/mfobjects/nf-mfobjects-imfasynccallback-invoke) method.</span></span> <span data-ttu-id="0f115-128">Utilisez la méthode **Invoke** pour exécuter l’élément de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-128">Use the **Invoke** method to perform the work item.</span></span>

<span data-ttu-id="0f115-129">Si plusieurs threads ou composants partagent la même file d’attente de travail, vous pouvez appeler [**MFLockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mflockworkqueue) pour verrouiller la file d’attente de travail, ce qui empêche la plateforme de la libérer.</span><span class="sxs-lookup"><span data-stu-id="0f115-129">If more than one thread or component shares the same work queue, you can call [**MFLockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mflockworkqueue) to lock the work queue, which prevents the platform from releasing it.</span></span> <span data-ttu-id="0f115-130">Pour chaque appel à [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue) ou **MFLockWorkQueue**, vous devez appeler [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue) une fois pour libérer la file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-130">For each call to [**MFAllocateWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfallocateworkqueue) or **MFLockWorkQueue**, you must call [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue) once to release the work queue.</span></span> <span data-ttu-id="0f115-131">Par exemple, si vous créez une file d’attente de travail et que vous la verrouillez une fois, vous devez appeler **MFUnlockWorkQueue** deux fois, une fois pour l’appel à **MFAllocateWorkQueue** et une fois pour l’appel à **MFLockWorkQueue**.</span><span class="sxs-lookup"><span data-stu-id="0f115-131">For example, if you create a new work queue and then lock it once, you must call **MFUnlockWorkQueue** twice, once for the call to **MFAllocateWorkQueue** and once for the call to **MFLockWorkQueue**.</span></span>

<span data-ttu-id="0f115-132">Le code suivant montre comment créer une nouvelle file d’attente de travail, placer un élément de travail dans la file d’attente et libérer la file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-132">The following code shows how to create a new work queue, put a work item in the queue, and release the work queue.</span></span>

<span data-ttu-id="0f115-133">Pour plus d’informations sur les files d’attente de travail dans Windows 8, consultez [files d’attente de travail et améliorations des threads](media-foundation-work-queue-and-threading-improvements.md) .</span><span class="sxs-lookup"><span data-stu-id="0f115-133">See [Work Queue and Threading Improvements](media-foundation-work-queue-and-threading-improvements.md) for additional information on work queues in Windows 8.</span></span>


```C++
DWORD idWorkQueue = 0;
HRESULT hr = S_OK;

// Create a new work queue.
hr = MFAllocateWorkQueue(&idWorkQueue);

// Put an item on the queue.
if (SUCCEEDED(hr))
{
    hr = MFPutWorkItem(idWorkQueue, pCallback, NULL);
}

// Wait for the callback to be invoked.
if (SUCCEEDED(hr))
{
    WaitForSingleObject(hEvent, INFINITE);
}

// Release the work queue.
if (SUCCEEDED(hr))
{
    hr = MFUnlockWorkQueue(idWorkQueue);
}
```



<span data-ttu-id="0f115-134">Cet exemple suppose que *pCallback* est un pointeur vers l’interface [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) de l’application.</span><span class="sxs-lookup"><span data-stu-id="0f115-134">This example assumes that *pCallback* is a pointer to the application's [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span> <span data-ttu-id="0f115-135">Il suppose également que le rappel définit le descripteur d’événement *hEvent* .</span><span class="sxs-lookup"><span data-stu-id="0f115-135">It also assumes that the callback sets the *hEvent* event handle.</span></span> <span data-ttu-id="0f115-136">Le code attend que cet événement soit défini avant d’appeler [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue).</span><span class="sxs-lookup"><span data-stu-id="0f115-136">The code waits for this event to be set before calling [**MFUnlockWorkQueue**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockworkqueue).</span></span>

<span data-ttu-id="0f115-137">Les threads de file d’attente de travail sont toujours créés dans le processus de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="0f115-137">Work queue threads are always created in the caller's process.</span></span> <span data-ttu-id="0f115-138">Dans chaque file d’attente de travail, les rappels sont sérialisés.</span><span class="sxs-lookup"><span data-stu-id="0f115-138">Within each work queue, the callbacks are serialized.</span></span> <span data-ttu-id="0f115-139">Si vous appelez [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) deux fois avec la même file d’attente de travail, le deuxième rappel n’est pas appelé tant que le premier rappel n’a pas été retourné.</span><span class="sxs-lookup"><span data-stu-id="0f115-139">If you call [**MFPutWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfputworkitem) twice with the same work queue, the second callback is not invoked until the first callback has returned.</span></span>

## <a name="shutting-down-work-queues"></a><span data-ttu-id="0f115-140">Arrêt des files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-140">Shutting Down Work Queues</span></span>

<span data-ttu-id="0f115-141">Avant d’appeler [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), libérez toutes les ressources utilisées par les threads de file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-141">Before calling [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), release any resources that are being used by work queue threads.</span></span> <span data-ttu-id="0f115-142">Pour synchroniser ce processus, vous pouvez verrouiller la plateforme Media Foundation, ce qui empêche la fonction **MFShutdown** de fermer les threads de file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-142">To synchronize this process, you can lock the Media Foundation platform, which prevents the **MFShutdown** function from closing any work queue threads.</span></span> <span data-ttu-id="0f115-143">Si **MFShutdown** est appelé alors que la plateforme est verrouillée, **MFShutdown** attend quelques centaines de millisecondes pour que la plateforme soit déverrouillée.</span><span class="sxs-lookup"><span data-stu-id="0f115-143">If **MFShutdown** is called while the platform is locked, **MFShutdown** waits a few hundred milliseconds for the platform to be unlocked.</span></span> <span data-ttu-id="0f115-144">S’il n’est pas déverrouillé dans ce délai, **MFShutdown** ferme les threads de file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="0f115-144">If it is not unlocked within that time, **MFShutdown** closes the work queue threads.</span></span>

<span data-ttu-id="0f115-145">L’implémentation par défaut de [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) verrouille automatiquement la plateforme Media Foundation lors de la création de l’objet de résultat.</span><span class="sxs-lookup"><span data-stu-id="0f115-145">The default implementation of [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) automatically locks the Media Foundation platform when the result object is created.</span></span> <span data-ttu-id="0f115-146">La libération de l’interface déverrouille la plateforme.</span><span class="sxs-lookup"><span data-stu-id="0f115-146">Releasing the interface unlocks the platform.</span></span> <span data-ttu-id="0f115-147">Par conséquent, vous n’avez presque jamais besoin de verrouiller la plateforme directement.</span><span class="sxs-lookup"><span data-stu-id="0f115-147">Therefore, you will almost never need to lock the platform directly.</span></span> <span data-ttu-id="0f115-148">Toutefois, si vous écrivez votre propre implémentation personnalisée de **IMFAsyncResult**, vous devez verrouiller et déverrouiller manuellement la plateforme.</span><span class="sxs-lookup"><span data-stu-id="0f115-148">But if you write your own custom implementation of **IMFAsyncResult**, then you should manually lock and unlock the platform.</span></span> <span data-ttu-id="0f115-149">Pour verrouiller la plateforme, appelez [**MFLockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mflockplatform).</span><span class="sxs-lookup"><span data-stu-id="0f115-149">To lock the platform, call [**MFLockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mflockplatform).</span></span> <span data-ttu-id="0f115-150">Pour déverrouiller la plateforme, appelez [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform).</span><span class="sxs-lookup"><span data-stu-id="0f115-150">To unlock the platform, call [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform).</span></span> <span data-ttu-id="0f115-151">Pour obtenir un exemple, consultez [objets de résultats asynchrones personnalisés](custom-asynchronous-result-objects.md).</span><span class="sxs-lookup"><span data-stu-id="0f115-151">For an example, see [Custom Asynchronous Result Objects](custom-asynchronous-result-objects.md).</span></span>

<span data-ttu-id="0f115-152">Après avoir appelé [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), vous devez vous assurer que la plateforme est déverrouillée dans le délai de 5 secondes.</span><span class="sxs-lookup"><span data-stu-id="0f115-152">After you call [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), you need to ensure that the platform is unlocked within the 5-second time-out period.</span></span> <span data-ttu-id="0f115-153">Pour ce faire, vous devez libérer tous les pointeurs [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) et appeler [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform) si vous avez verrouillé la plateforme manuellement.</span><span class="sxs-lookup"><span data-stu-id="0f115-153">Do this by releasing all [**IMFAsyncResult**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasyncresult) pointers, and by calling [**MFUnlockPlatform**](/windows/desktop/api/mfapi/nf-mfapi-mfunlockplatform) if you locked the platform manually.</span></span> <span data-ttu-id="0f115-154">Veillez à libérer toutes les ressources utilisées par les threads de file d’attente de travail, sans quoi votre application peut présenter une fuite de mémoire.</span><span class="sxs-lookup"><span data-stu-id="0f115-154">Make sure to release any resources that are being used by work queue threads, or your application might leak memory.</span></span>

<span data-ttu-id="0f115-155">En règle générale, si votre application s’arrête et libère tous les objets Media Foundation avant d’appeler [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), vous n’avez pas à vous soucier du verrouillage.</span><span class="sxs-lookup"><span data-stu-id="0f115-155">Typically, if your application shuts down and releases every Media Foundation object before calling [**MFShutdown**](/windows/desktop/api/mfapi/nf-mfapi-mfshutdown), you do not have to worry about locking.</span></span> <span data-ttu-id="0f115-156">Le mécanisme de verrouillage permet simplement aux threads de file d’attente de travail de se fermer correctement après l’appel de **MFShutdown**.</span><span class="sxs-lookup"><span data-stu-id="0f115-156">The locking mechanism simply allows work queue threads to exit gracefully after you call **MFShutdown**.</span></span>

## <a name="using-scheduled-work-items"></a><span data-ttu-id="0f115-157">Utilisation d’éléments de travail planifiés</span><span class="sxs-lookup"><span data-stu-id="0f115-157">Using Scheduled Work Items</span></span>

<span data-ttu-id="0f115-158">Vous pouvez planifier un rappel au bout d’un laps de temps défini en appelant [**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) ou [**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex).</span><span class="sxs-lookup"><span data-stu-id="0f115-158">You can schedule a callback to occur after a set period of time by calling [**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) or [**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex).</span></span>

-   <span data-ttu-id="0f115-159">[**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) prend un pointeur vers votre rappel, un objet d’État facultatif et un intervalle de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="0f115-159">[**MFScheduleWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitem) takes a pointer to your callback, an optional state object, and a time-out interval.</span></span>
-   <span data-ttu-id="0f115-160">[**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex) prend un pointeur vers un objet de résultat asynchrone et une valeur de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="0f115-160">[**MFScheduleWorkItemEx**](/windows/desktop/api/mfapi/nf-mfapi-mfscheduleworkitemex) takes a pointer to an asynchronous result object and a time-out value.</span></span>

<span data-ttu-id="0f115-161">Spécifiez le délai d’expiration sous la forme d’une valeur négative en millisecondes.</span><span class="sxs-lookup"><span data-stu-id="0f115-161">Specify the time-out as a negative value in milliseconds.</span></span> <span data-ttu-id="0f115-162">Par exemple, pour planifier l’appel d’un rappel en 5 secondes, utilisez la valeur − 5000.</span><span class="sxs-lookup"><span data-stu-id="0f115-162">For example, to schedule a callback to be invoked in 5 seconds, use the value −5000.</span></span> <span data-ttu-id="0f115-163">Les deux fonctions retournent une valeur de **\_ clé MFWORKITEM** , que vous pouvez utiliser pour annuler le rappel en le passant à la fonction [**MFCancelWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfcancelworkitem) .</span><span class="sxs-lookup"><span data-stu-id="0f115-163">Both functions return an **MFWORKITEM\_KEY** value, which you can use to cancel the callback by passing it to the [**MFCancelWorkItem**](/windows/desktop/api/mfapi/nf-mfapi-mfcancelworkitem) function.</span></span>

<span data-ttu-id="0f115-164">Les éléments de travail planifiés utilisent toujours la \_ \_ \_ file d’attente de travail de la plateforme de minuteur de rappel MFASYNC.</span><span class="sxs-lookup"><span data-stu-id="0f115-164">Scheduled work items always use the MFASYNC\_CALLBACK\_QUEUE\_TIMER platform work queue.</span></span>

## <a name="using-periodic-callbacks"></a><span data-ttu-id="0f115-165">Utilisation de rappels périodiques</span><span class="sxs-lookup"><span data-stu-id="0f115-165">Using Periodic Callbacks</span></span>

<span data-ttu-id="0f115-166">La fonction [**MFAddPeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfaddperiodiccallback) planifie un rappel à appeler régulièrement jusqu’à ce que vous l’annuliez.</span><span class="sxs-lookup"><span data-stu-id="0f115-166">The [**MFAddPeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfaddperiodiccallback) function schedules a callback to be invoked periodically until you cancel it.</span></span> <span data-ttu-id="0f115-167">L’intervalle de rappel est fixe ; les applications ne peuvent pas la modifier.</span><span class="sxs-lookup"><span data-stu-id="0f115-167">The callback interval is fixed; applications cannot change it.</span></span> <span data-ttu-id="0f115-168">Pour déterminer l’intervalle exact, appelez [**MFGetTimerPeriodicity**](/windows/desktop/api/mfapi/nf-mfapi-mfgettimerperiodicity).</span><span class="sxs-lookup"><span data-stu-id="0f115-168">To find out the exact interval, call [**MFGetTimerPeriodicity**](/windows/desktop/api/mfapi/nf-mfapi-mfgettimerperiodicity).</span></span> <span data-ttu-id="0f115-169">L’intervalle est de l’ordre de 10 millisecondes. cette fonction est donc conçue pour les situations où vous avez besoin d’un « battement » fréquent, par exemple l’implémentation d’une horloge de présentation.</span><span class="sxs-lookup"><span data-stu-id="0f115-169">The interval is on the order of 10 milliseconds, so this function is meant for situations where you need a frequent "tick," such as implementing a presentation clock.</span></span> <span data-ttu-id="0f115-170">Si vous souhaitez planifier une opération moins fréquemment, utilisez un élément de travail planifié, comme décrit précédemment.</span><span class="sxs-lookup"><span data-stu-id="0f115-170">If you want to schedule an operation to occur less frequently, use a scheduled work item, as described previously.</span></span>

<span data-ttu-id="0f115-171">Contrairement aux autres rappels décrits dans cette rubrique, le rappel périodique n’utilise pas l’interface [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) .</span><span class="sxs-lookup"><span data-stu-id="0f115-171">Unlike the other callbacks described in this topic, the periodic callback does not use the [**IMFAsyncCallback**](/windows/desktop/api/mfobjects/nn-mfobjects-imfasynccallback) interface.</span></span> <span data-ttu-id="0f115-172">Au lieu de cela, il utilise un pointeur de fonction.</span><span class="sxs-lookup"><span data-stu-id="0f115-172">Instead, it uses a function pointer.</span></span> <span data-ttu-id="0f115-173">Pour plus d’informations, consultez [**rappel MFPERIODICCALLBACK**](/windows/win32/api/mfapi/nc-mfapi-mfperiodiccallback).</span><span class="sxs-lookup"><span data-stu-id="0f115-173">For more information, see [**MFPERIODICCALLBACK Callback**](/windows/win32/api/mfapi/nc-mfapi-mfperiodiccallback).</span></span>

<span data-ttu-id="0f115-174">Pour annuler le rappel périodique, appelez [**MFRemovePeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfremoveperiodiccallback).</span><span class="sxs-lookup"><span data-stu-id="0f115-174">To cancel the periodic callback, call [**MFRemovePeriodicCallback**](/windows/desktop/api/mfapi/nf-mfapi-mfremoveperiodiccallback).</span></span>

<span data-ttu-id="0f115-175">Les rappels périodiques utilisent \_ la \_ \_ file d’attente de travail du minuteur de file d’attente de rappel MFASYNC.</span><span class="sxs-lookup"><span data-stu-id="0f115-175">Periodic callbacks use the MFASYNC\_CALLBACK\_QUEUE\_TIMER platform work queue.</span></span>

## <a name="related-topics"></a><span data-ttu-id="0f115-176">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="0f115-176">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="0f115-177">Files d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="0f115-177">Work Queues</span></span>](work-queues.md)
</dt> <dt>

[<span data-ttu-id="0f115-178">**MFASYNCRESULT**</span><span class="sxs-lookup"><span data-stu-id="0f115-178">**MFASYNCRESULT**</span></span>](/windows/win32/api/mfapi/ns-mfapi-mfasyncresult)
</dt> <dt>

[<span data-ttu-id="0f115-179">Améliorations de la file d’attente de travail et du thread</span><span class="sxs-lookup"><span data-stu-id="0f115-179">Work Queue and Threading Improvements</span></span>](media-foundation-work-queue-and-threading-improvements.md)
</dt> </dl>

 

 
