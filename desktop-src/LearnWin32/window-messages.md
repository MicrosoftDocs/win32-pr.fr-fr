---
title: Messages de fenêtre (prise en main de Win32 et C++)
description: .
ms.assetid: 90c20456-44ed-4f0f-a6d3-b6c5660f0bc7
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0e7ea533a89cb0ccf7053945cd693cc6e1ef5c28
ms.sourcegitcommit: 35bb565804eaeed7ac5503595753f59d120076dd
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/09/2021
ms.locfileid: "106535092"
---
# <a name="window-messages-get-started-with-win32-and-c"></a><span data-ttu-id="27559-103">Messages de fenêtre (prise en main de Win32 et C++)</span><span class="sxs-lookup"><span data-stu-id="27559-103">Window Messages (Get Started with Win32 and C++)</span></span>

<span data-ttu-id="27559-104">Une application GUI doit répondre aux événements de l’utilisateur et du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="27559-104">A GUI application must respond to events from the user and from the operating system.</span></span>

- <span data-ttu-id="27559-105">Les **événements de l’utilisateur** incluent toutes les façons dont quelqu’un peut interagir avec votre programme : les clics de souris, les frappes de touche, les gestes à écran tactile, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="27559-105">**Events from the user** include all the ways that someone can interact with your program: mouse clicks, key strokes, touch-screen gestures, and so on.</span></span>
- <span data-ttu-id="27559-106">Les **événements du système d’exploitation** incluent tout ce qui est « en dehors » du programme qui peut affecter le comportement du programme.</span><span class="sxs-lookup"><span data-stu-id="27559-106">**Events from the operating system** include anything "outside" of the program that can affect how the program behaves.</span></span> <span data-ttu-id="27559-107">Par exemple, l’utilisateur peut brancher un nouveau périphérique matériel, ou Windows peut passer à un état d’alimentation faible (veille ou veille prolongée).</span><span class="sxs-lookup"><span data-stu-id="27559-107">For example, the user might plug in a new hardware device, or Windows might enter a lower-power state (sleep or hibernate).</span></span>

<span data-ttu-id="27559-108">Ces événements peuvent se produire à tout moment pendant l’exécution du programme, dans presque n’importe quel ordre.</span><span class="sxs-lookup"><span data-stu-id="27559-108">These events can occur at any time while the program is running, in almost any order.</span></span> <span data-ttu-id="27559-109">Comment structurer un programme dont le déroulement de l’exécution ne peut pas être prédit à l’avance ?</span><span class="sxs-lookup"><span data-stu-id="27559-109">How do you structure a program whose flow of execution cannot be predicted in advance?</span></span>

<span data-ttu-id="27559-110">Pour résoudre ce problème, Windows utilise un modèle de transmission de messages.</span><span class="sxs-lookup"><span data-stu-id="27559-110">To solve this problem, Windows uses a message-passing model.</span></span> <span data-ttu-id="27559-111">Le système d’exploitation communique avec la fenêtre de votre application en lui transmettant des messages.</span><span class="sxs-lookup"><span data-stu-id="27559-111">The operating system communicates with your application window by passing messages to it.</span></span> <span data-ttu-id="27559-112">Un message est simplement un code numérique qui désigne un événement particulier.</span><span class="sxs-lookup"><span data-stu-id="27559-112">A message is simply a numeric code that designates a particular event.</span></span> <span data-ttu-id="27559-113">Par exemple, si l’utilisateur appuie sur le bouton gauche de la souris, la fenêtre reçoit un message avec le code de message suivant.</span><span class="sxs-lookup"><span data-stu-id="27559-113">For example, if the user presses the left mouse button, the window receives a message that has the following message code.</span></span>

```C++
#define WM_LBUTTONDOWN    0x0201
```

<span data-ttu-id="27559-114">Certains messages sont associés à des données.</span><span class="sxs-lookup"><span data-stu-id="27559-114">Some messages have data associated with them.</span></span> <span data-ttu-id="27559-115">Par exemple, le message [**WM \_ LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) comprend la coordonnée x et la coordonnée y du curseur de la souris.</span><span class="sxs-lookup"><span data-stu-id="27559-115">For example, the [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message includes the x-coordinate and y-coordinate of the mouse cursor.</span></span>

<span data-ttu-id="27559-116">Pour transmettre un message à une fenêtre, le système d’exploitation appelle la procédure de fenêtre inscrite pour cette fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-116">To pass a message to a window, the operating system calls the window procedure registered for that window.</span></span> <span data-ttu-id="27559-117">(Et maintenant vous savez à quoi sert la procédure de fenêtre.)</span><span class="sxs-lookup"><span data-stu-id="27559-117">(And now you know what the window procedure is for.)</span></span>

## <a name="the-message-loop"></a><span data-ttu-id="27559-118">Boucle de messages</span><span class="sxs-lookup"><span data-stu-id="27559-118">The Message Loop</span></span>

<span data-ttu-id="27559-119">Une application recevra des milliers de messages pendant son exécution.</span><span class="sxs-lookup"><span data-stu-id="27559-119">An application will receive thousands of messages while it runs.</span></span> <span data-ttu-id="27559-120">(Considérez que chaque clic de souris et bouton de souris génère un message.) En outre, une application peut avoir plusieurs fenêtres, chacune avec sa propre procédure de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-120">(Consider that every keystroke and mouse-button click generates a message.) Additionally, an application can have several windows, each with its own window procedure.</span></span> <span data-ttu-id="27559-121">Comment le programme reçoit-il tous ces messages et les remet à la procédure de fenêtre appropriée ?</span><span class="sxs-lookup"><span data-stu-id="27559-121">How does the program receive all these messages and deliver them to the correct window procedure?</span></span> <span data-ttu-id="27559-122">L’application a besoin d’une boucle pour récupérer les messages et les distribuer aux fenêtres appropriées.</span><span class="sxs-lookup"><span data-stu-id="27559-122">The application needs a loop to retrieve the messages and dispatch them to the correct windows.</span></span>

<span data-ttu-id="27559-123">Pour chaque thread qui crée une fenêtre, le système d’exploitation crée une file d’attente pour les messages de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-123">For each thread that creates a window, the operating system creates a queue for window messages.</span></span> <span data-ttu-id="27559-124">Cette file d’attente contient les messages de toutes les fenêtres créées sur ce thread.</span><span class="sxs-lookup"><span data-stu-id="27559-124">This queue holds messages for all the windows that are created on that thread.</span></span> <span data-ttu-id="27559-125">La file d’attente elle-même est masquée dans votre programme.</span><span class="sxs-lookup"><span data-stu-id="27559-125">The queue itself is hidden from your program.</span></span> <span data-ttu-id="27559-126">Vous ne pouvez pas manipuler la file d’attente directement.</span><span class="sxs-lookup"><span data-stu-id="27559-126">You cannot manipulate the queue directly.</span></span> <span data-ttu-id="27559-127">Toutefois, vous pouvez extraire un message de la file d’attente en appelant la fonction [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) .</span><span class="sxs-lookup"><span data-stu-id="27559-127">However, you can pull a message from the queue by calling the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function.</span></span>

```C++
MSG msg;
GetMessage(&msg, NULL, 0, 0);
```

<span data-ttu-id="27559-128">Cette fonction supprime le premier message du début de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-128">This function removes the first message from the head of the queue.</span></span> <span data-ttu-id="27559-129">Si la file d’attente est vide, la fonction se bloque jusqu’à ce qu’un autre message soit mis en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-129">If the queue is empty, the function blocks until another message is queued.</span></span> <span data-ttu-id="27559-130">Le fait que les blocs [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) ne permettront pas à votre programme de ne pas répondre.</span><span class="sxs-lookup"><span data-stu-id="27559-130">The fact that [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) blocks will not make your program unresponsive.</span></span> <span data-ttu-id="27559-131">S’il n’y a aucun message, il n’y a rien à faire pour le programme.</span><span class="sxs-lookup"><span data-stu-id="27559-131">If there are no messages, there is nothing for the program to do.</span></span> <span data-ttu-id="27559-132">Si vous devez effectuer un traitement en arrière-plan, vous pouvez créer des threads supplémentaires qui continuent à s’exécuter lorsque **GetMessage** attend un autre message.</span><span class="sxs-lookup"><span data-stu-id="27559-132">If you have to perform background processing, you can create additional threads that continue to run while **GetMessage** waits for another message.</span></span> <span data-ttu-id="27559-133">(Voir [éviter les goulots d’étranglement dans votre procédure de fenêtre](writing-the-window-procedure.md).)</span><span class="sxs-lookup"><span data-stu-id="27559-133">(See [Avoiding Bottlenecks in Your Window Procedure](writing-the-window-procedure.md).)</span></span>

<span data-ttu-id="27559-134">Le premier paramètre de [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) est l’adresse d’une structure [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) .</span><span class="sxs-lookup"><span data-stu-id="27559-134">The first parameter of [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) is the address of a [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure.</span></span> <span data-ttu-id="27559-135">Si la fonction aboutit, elle remplit la structure **MSG** avec des informations sur le message.</span><span class="sxs-lookup"><span data-stu-id="27559-135">If the function succeeds, it fills in the **MSG** structure with information about the message.</span></span> <span data-ttu-id="27559-136">Cela comprend la fenêtre cible et le code du message.</span><span class="sxs-lookup"><span data-stu-id="27559-136">This includes the target window and the message code.</span></span> <span data-ttu-id="27559-137">Les trois autres paramètres vous permettent de filtrer les messages que vous recevez de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-137">The other three parameters let you filter which messages you get from the queue.</span></span> <span data-ttu-id="27559-138">Dans presque tous les cas, vous allez définir ces paramètres sur zéro.</span><span class="sxs-lookup"><span data-stu-id="27559-138">In almost all cases, you will set these parameters to zero.</span></span>

<span data-ttu-id="27559-139">Même si la structure [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) contient des informations sur le message, vous n’examinerez presque jamais cette structure directement.</span><span class="sxs-lookup"><span data-stu-id="27559-139">Although the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure contains information about the message, you will almost never examine this structure directly.</span></span> <span data-ttu-id="27559-140">Au lieu de cela, vous le transmettez directement à deux autres fonctions.</span><span class="sxs-lookup"><span data-stu-id="27559-140">Instead, you will pass it directly to two other functions.</span></span>

```C++
TranslateMessage(&msg); 
DispatchMessage(&msg);
```

<span data-ttu-id="27559-141">La fonction [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) est liée à l’entrée au clavier.</span><span class="sxs-lookup"><span data-stu-id="27559-141">The [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) function is related to keyboard input.</span></span> <span data-ttu-id="27559-142">Il traduit les séquences de touches (touche enfoncée, touche précédente) en caractères.</span><span class="sxs-lookup"><span data-stu-id="27559-142">It translates keystrokes (key down, key up) into characters.</span></span> <span data-ttu-id="27559-143">Vous n’avez pas vraiment besoin de savoir comment cette fonction fonctionne ; n’oubliez pas de l’appeler avant [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span><span class="sxs-lookup"><span data-stu-id="27559-143">You do not really have to know how this function works; just remember to call it before [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span></span> <span data-ttu-id="27559-144">Le lien vers la documentation MSDN vous donne plus d’informations, si vous êtes curieux.</span><span class="sxs-lookup"><span data-stu-id="27559-144">The link to the MSDN documentation will give you more information, if you are curious.</span></span>

<span data-ttu-id="27559-145">La fonction [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) indique au système d’exploitation d’appeler la procédure de fenêtre de la fenêtre qui est la cible du message.</span><span class="sxs-lookup"><span data-stu-id="27559-145">The [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) function tells the operating system to call the window procedure of the window that is the target of the message.</span></span> <span data-ttu-id="27559-146">En d’autres termes, le système d’exploitation recherche le handle de fenêtre dans son tableau de fenêtres, recherche le pointeur de fonction associé à la fenêtre et appelle la fonction.</span><span class="sxs-lookup"><span data-stu-id="27559-146">In other words, the operating system looks up the window handle in its table of windows, finds the function pointer associated with the window, and invokes the function.</span></span>

<span data-ttu-id="27559-147">Par exemple, supposons que l’utilisateur appuie sur le bouton gauche de la souris.</span><span class="sxs-lookup"><span data-stu-id="27559-147">For example, suppose that the user presses the left mouse button.</span></span> <span data-ttu-id="27559-148">Cela provoque une chaîne d’événements :</span><span class="sxs-lookup"><span data-stu-id="27559-148">This causes a chain of events:</span></span>

1. <span data-ttu-id="27559-149">Le système d’exploitation place un message [**WM \_ LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) dans la file d’attente de messages.</span><span class="sxs-lookup"><span data-stu-id="27559-149">The operating system puts a [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message on the message queue.</span></span>
2. <span data-ttu-id="27559-150">Votre programme appelle la fonction [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) .</span><span class="sxs-lookup"><span data-stu-id="27559-150">Your program calls the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function.</span></span>
3. <span data-ttu-id="27559-151">[**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) extrait le message [**WM \_ LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) à partir de la file d’attente et remplit la structure [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) .</span><span class="sxs-lookup"><span data-stu-id="27559-151">[**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) pulls the [**WM\_LBUTTONDOWN**](/windows/desktop/inputdev/wm-lbuttondown) message from the queue and fills in the [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) structure.</span></span>
4. <span data-ttu-id="27559-152">Votre programme appelle les fonctions [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) et [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) .</span><span class="sxs-lookup"><span data-stu-id="27559-152">Your program calls the [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) and [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) functions.</span></span>
5. <span data-ttu-id="27559-153">À l’intérieur de [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage), le système d’exploitation appelle votre procédure de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-153">Inside [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage), the operating system calls your window procedure.</span></span>
6. <span data-ttu-id="27559-154">Votre procédure de fenêtre peut soit répondre au message, soit l’ignorer.</span><span class="sxs-lookup"><span data-stu-id="27559-154">Your window procedure can either respond to the message or ignore it.</span></span>

<span data-ttu-id="27559-155">Lorsque la procédure de fenêtre retourne, elle retourne à [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span><span class="sxs-lookup"><span data-stu-id="27559-155">When the window procedure returns, it returns back to [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage).</span></span> <span data-ttu-id="27559-156">Cela revient à la boucle de message pour le message suivant.</span><span class="sxs-lookup"><span data-stu-id="27559-156">This returns to the message loop for the next message.</span></span> <span data-ttu-id="27559-157">Tant que votre programme est en cours d’exécution, les messages continuent d’arriver dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-157">As long as your program is running, messages will continue to arrive on the queue.</span></span> <span data-ttu-id="27559-158">Par conséquent, vous devez disposer d’une boucle qui extrait continuellement des messages de la file d’attente et les distribue.</span><span class="sxs-lookup"><span data-stu-id="27559-158">Therefore, you must have a loop that continually pulls messages from the queue and dispatches them.</span></span> <span data-ttu-id="27559-159">Vous pouvez considérer la boucle comme suit :</span><span class="sxs-lookup"><span data-stu-id="27559-159">You can think of the loop as doing the following:</span></span>

```C++
// WARNING: Don't actually write your loop this way.

while (1)      
{
    GetMessage(&msg, NULL, 0,  0);
    TranslateMessage(&msg); 
    DispatchMessage(&msg);
}
```

<span data-ttu-id="27559-160">Comme écrit, bien sûr, cette boucle ne se terminerait jamais.</span><span class="sxs-lookup"><span data-stu-id="27559-160">As written, of course, this loop would never end.</span></span> <span data-ttu-id="27559-161">C’est là qu’intervient la valeur de retour de la fonction [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) .</span><span class="sxs-lookup"><span data-stu-id="27559-161">That is where the return value for the [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) function comes in.</span></span> <span data-ttu-id="27559-162">Normalement, **GetMessage** retourne une valeur différente de zéro.</span><span class="sxs-lookup"><span data-stu-id="27559-162">Normally, **GetMessage** returns a nonzero value.</span></span> <span data-ttu-id="27559-163">Lorsque vous souhaitez quitter l’application et sortir de la boucle de message, appelez la fonction [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) .</span><span class="sxs-lookup"><span data-stu-id="27559-163">When you want to exit the application and break out of the message loop, call the [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) function.</span></span>

```C++
        PostQuitMessage(0);
```

<span data-ttu-id="27559-164">La fonction [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) place un message [**WM \_ Quit**](/windows/desktop/winmsg/wm-quit) dans la file d’attente de messages.</span><span class="sxs-lookup"><span data-stu-id="27559-164">The [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) function puts a [**WM\_QUIT**](/windows/desktop/winmsg/wm-quit) message on the message queue.</span></span> <span data-ttu-id="27559-165">**WM \_ QUIT** est un message spécial : il fait en sorte que [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) retourne zéro et signale la fin de la boucle de message.</span><span class="sxs-lookup"><span data-stu-id="27559-165">**WM\_QUIT** is a special message: It causes [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) to return zero, signaling the end of the message loop.</span></span> <span data-ttu-id="27559-166">Voici la boucle de message révisée.</span><span class="sxs-lookup"><span data-stu-id="27559-166">Here is the revised message loop.</span></span>

```C++
// Correct.

MSG msg = { };
while (GetMessage(&msg, NULL, 0, 0) > 0)
{
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}
```

<span data-ttu-id="27559-167">Tant que la fonction [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) retourne une valeur différente de zéro, l’expression de la boucle **while** prend la valeur true.</span><span class="sxs-lookup"><span data-stu-id="27559-167">As long as [**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) returns a nonzero value, the expression in the **while** loop evaluates to true.</span></span> <span data-ttu-id="27559-168">Une fois que vous avez appelé [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage), l’expression devient false et le programme s’arrête hors de la boucle.</span><span class="sxs-lookup"><span data-stu-id="27559-168">After you call [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage), the expression becomes false and the program breaks out of the loop.</span></span> <span data-ttu-id="27559-169">(L’un des résultats intéressants de ce comportement est que votre procédure de fenêtre ne reçoit jamais de message [**WM \_ Quit**](/windows/desktop/winmsg/wm-quit) .</span><span class="sxs-lookup"><span data-stu-id="27559-169">(One interesting result of this behavior is that your window procedure never receives a [**WM\_QUIT**](/windows/desktop/winmsg/wm-quit) message.</span></span> <span data-ttu-id="27559-170">Par conséquent, il n’est pas nécessaire d’avoir une instruction case pour ce message dans votre procédure de fenêtre.)</span><span class="sxs-lookup"><span data-stu-id="27559-170">Therefore, you do not have to have a case statement for this message in your window procedure.)</span></span>

<span data-ttu-id="27559-171">La prochaine question évidente est l’appel de [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage).</span><span class="sxs-lookup"><span data-stu-id="27559-171">The next obvious question is when to call [**PostQuitMessage**](/windows/desktop/api/winuser/nf-winuser-postquitmessage).</span></span> <span data-ttu-id="27559-172">Nous reviendrons à cette question dans la rubrique [fermeture de la fenêtre](closing-the-window.md), mais nous devons d’abord écrire notre procédure de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-172">We'll return to this question in the topic [Closing the Window](closing-the-window.md), but first we have to write our window procedure.</span></span>

## <a name="posted-messages-versus-sent-messages"></a><span data-ttu-id="27559-173">Messages publiés et messages envoyés</span><span class="sxs-lookup"><span data-stu-id="27559-173">Posted Messages versus Sent Messages</span></span>

<span data-ttu-id="27559-174">La section précédente a abordé les messages qui passent dans une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-174">The previous section talked about messages going onto a queue.</span></span> <span data-ttu-id="27559-175">Parfois, le système d’exploitation appellera directement une procédure de fenêtre, en ignorant la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="27559-175">Sometimes, the operating system will call a window procedure directly, bypassing the queue.</span></span>

<span data-ttu-id="27559-176">La terminologie de cette distinction peut prêter à confusion :</span><span class="sxs-lookup"><span data-stu-id="27559-176">The terminology for this distinction can be confusing:</span></span>

-   <span data-ttu-id="27559-177">La *publication* d’un message signifie que le message est placé dans la file d’attente de messages et est distribué via la boucle de message ([**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) et [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)).</span><span class="sxs-lookup"><span data-stu-id="27559-177">*Posting* a message means the message goes on the message queue, and is dispatched through the message loop ([**GetMessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) and [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)).</span></span>
-   <span data-ttu-id="27559-178">L' *envoi* d’un message signifie que le message ignore la file d’attente et que le système d’exploitation appelle directement la procédure de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-178">*Sending* a message means the message skips the queue, and the operating system calls the window procedure directly.</span></span>

<span data-ttu-id="27559-179">Pour le moment, la différence n’est pas très importante.</span><span class="sxs-lookup"><span data-stu-id="27559-179">For now, the difference is not very important.</span></span> <span data-ttu-id="27559-180">La procédure de fenêtre gère tous les messages.</span><span class="sxs-lookup"><span data-stu-id="27559-180">The window procedure handles all messages.</span></span> <span data-ttu-id="27559-181">Toutefois, certains messages contournent la file d’attente et accèdent directement à votre procédure de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="27559-181">However, some messages bypass the queue and go directly to your window procedure.</span></span> <span data-ttu-id="27559-182">Toutefois, il peut faire la différence si votre application communique entre Windows.</span><span class="sxs-lookup"><span data-stu-id="27559-182">However, it can make a difference if your application communicates between windows.</span></span> <span data-ttu-id="27559-183">Pour plus d’informations sur ce problème, consultez la rubrique [à propos des messages et des files d’attente de messages](/windows/desktop/winmsg/about-messages-and-message-queues).</span><span class="sxs-lookup"><span data-stu-id="27559-183">You can find a more thorough discussion of this issue in the topic [About Messages and Message Queues](/windows/desktop/winmsg/about-messages-and-message-queues).</span></span>

## <a name="next"></a><span data-ttu-id="27559-184">Suivant</span><span class="sxs-lookup"><span data-stu-id="27559-184">Next</span></span>

[<span data-ttu-id="27559-185">Écriture de la procédure de fenêtre</span><span class="sxs-lookup"><span data-stu-id="27559-185">Writing the Window Procedure</span></span>](writing-the-window-procedure.md)
