---
description: Découvrez comment empêcher les blocages dans les applications Windows pour les plateformes Windows 7 et Windows Server 2008 R2.
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: Prévention des blocages dans les applications Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35a2d8fac95039f20c8c684c50138933c54750c3
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/06/2021
ms.locfileid: "104042904"
---
# <a name="preventing-hangs-in-windows-applications"></a><span data-ttu-id="ef8ee-103">Prévention des blocages dans les applications Windows</span><span class="sxs-lookup"><span data-stu-id="ef8ee-103">Preventing Hangs in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="ef8ee-104">Plateformes affectées</span><span class="sxs-lookup"><span data-stu-id="ef8ee-104">Affected Platforms</span></span>

<span data-ttu-id="ef8ee-105">**Clients** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="ef8ee-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="ef8ee-106">**Serveurs** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="ef8ee-106">**Servers** - Windows Server 2008 R2</span></span>  









## <a name="description"></a><span data-ttu-id="ef8ee-107">Description</span><span class="sxs-lookup"><span data-stu-id="ef8ee-107">Description</span></span>

<span data-ttu-id="ef8ee-108">**Blocages-perspective de l’utilisateur**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-108">**Hangs - User Perspective**</span></span>

<span data-ttu-id="ef8ee-109">Les utilisateurs comme les applications réactives.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-109">Users like responsive applications.</span></span> <span data-ttu-id="ef8ee-110">Lorsqu’il clique sur un menu, il souhaite que l’application réagisse instantanément, même si elle est en train d’imprimer son travail.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-110">When they click a menu, they want the application to react instantly, even if it is currently printing their work.</span></span> <span data-ttu-id="ef8ee-111">Lorsqu’ils enregistrent un long document dans leur traitement de texte préféré, ils souhaitent continuer à taper alors que le disque est toujours en cours de rotation.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-111">When they save a lengthy document in their favorite word processor, they want to continue typing while the disk is still spinning.</span></span> <span data-ttu-id="ef8ee-112">Les utilisateurs sont impatients plutôt rapidement lorsque l’application ne réagit pas en temps utile à leur entrée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-112">Users get impatient rather quickly when the application does not react in a timely fashion to their input.</span></span>

<span data-ttu-id="ef8ee-113">Un programmeur peut reconnaître de nombreuses raisons légitimes pour qu’une application ne puisse pas répondre instantanément aux entrées d’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-113">A programmer might recognize many legitimate reasons for an application not to instantly respond to user input.</span></span> <span data-ttu-id="ef8ee-114">L’application peut être chargée de recalculer certaines données ou d’attendre la fin de l’exécution de l’e/s disque.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-114">The application might be busy recalculating some data, or simply waiting for its disk I/O to complete.</span></span> <span data-ttu-id="ef8ee-115">Toutefois, à partir de la recherche des utilisateurs, nous savons que les utilisateurs sont mécontents et frustrés après quelques secondes d’inactivité.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-115">However, from user research, we know that users get annoyed and frustrated after just a couple of seconds of unresponsiveness.</span></span> <span data-ttu-id="ef8ee-116">Après 5 secondes, ils tenteront de mettre fin à une application bloquée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-116">After 5 seconds, they will try to terminate a hung application.</span></span> <span data-ttu-id="ef8ee-117">À la suite des blocages, les blocages d’applications sont la source la plus courante de perturbation de l’utilisateur lors de l’utilisation d’applications Win32.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-117">Next to crashes, application hangs are the most common source of user disruption when working with Win32 applications.</span></span>

<span data-ttu-id="ef8ee-118">Il existe de nombreuses causes racines pour les blocages des applications, et non pas toutes les manifestes dans une interface utilisateur qui ne répond pas.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-118">There are many different root causes for application hangs, and not all of them manifest themselves in an unresponsive UI.</span></span> <span data-ttu-id="ef8ee-119">Toutefois, une interface utilisateur qui ne répond pas est l’une des expériences de blocage les plus courantes, et ce scénario reçoit actuellement la prise en charge de système d’exploitation la plus courante pour la détection et la récupération.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-119">However, an unresponsive UI is one of the most common hang experiences, and this scenario currently receives the most operating system support for both detection as well as recovery.</span></span> <span data-ttu-id="ef8ee-120">Windows détecte automatiquement, collecte les informations de débogage et éventuellement arrête ou redémarre les applications bloquées.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-120">Windows automatically detects, collects debug information, and optionally terminates or restarts hung applications.</span></span> <span data-ttu-id="ef8ee-121">Dans le cas contraire, l’utilisateur devra peut-être redémarrer l’ordinateur pour pouvoir récupérer une application bloquée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-121">Otherwise, the user might have to restart the machine in order to recover a hung application.</span></span>

<span data-ttu-id="ef8ee-122">**Blocages-perspective du système d’exploitation**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-122">**Hangs - Operating System Perspective**</span></span>

<span data-ttu-id="ef8ee-123">Quand une application (ou plus précisément, un thread) crée une fenêtre sur le bureau, elle entre dans un contrat implicite avec le Gestionnaire de fenêtrage (DWM) pour traiter les messages de fenêtre en temps opportun.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-123">When an application (or more accurately, a thread) creates a window on the desktop, it enters into an implicit contract with the Desktop Window Manager (DWM) to process window messages in a timely fashion.</span></span> <span data-ttu-id="ef8ee-124">Le DWM publie des messages (entrée clavier/souris et messages provenant d’autres fenêtres, ainsi que lui-même) dans la file d’attente de messages spécifique au thread.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-124">The DWM posts messages (keyboard/mouse input and messages from other windows, as well as itself) into the thread-specific message queue.</span></span> <span data-ttu-id="ef8ee-125">Le thread récupère et distribue ces messages par le biais de sa file d’attente de messages.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-125">The thread retrieves and dispatches those messages via its message queue.</span></span> <span data-ttu-id="ef8ee-126">Si le thread ne traite pas la file d’attente en appelant GetMessage (), les messages ne sont pas traités et la fenêtre se bloque : il ne peut ni redessiner, ni accepter d’entrée de la part de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-126">If the thread does not service the queue by calling GetMessage(), messages are not processed, and the window hangs: it can neither redraw nor can it accept input from the user.</span></span> <span data-ttu-id="ef8ee-127">Le système d’exploitation détecte cet État en joignant un minuteur aux messages en attente dans la file d’attente de messages.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-127">The operating system detects this state by attaching a timer to pending messages in the message queue.</span></span> <span data-ttu-id="ef8ee-128">Si un message n’a pas été récupéré dans un délai de 5 secondes, le DWM déclare que la fenêtre est bloquée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-128">If a message has not been retrieved within 5 seconds, the DWM declares the window to be hung.</span></span> <span data-ttu-id="ef8ee-129">Vous pouvez interroger cet état de fenêtre particulier à l’aide de l’API IsHungAppWindow ().</span><span class="sxs-lookup"><span data-stu-id="ef8ee-129">You can query this particular window state via the IsHungAppWindow() API.</span></span>

<span data-ttu-id="ef8ee-130">La détection n’est que la première étape.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-130">Detection is only the first step.</span></span> <span data-ttu-id="ef8ee-131">À ce stade, l’utilisateur ne peut toujours pas mettre fin à l’application. le fait de cliquer sur le bouton X (fermer) se traduirait par un \_ message de fermeture WM, qui serait bloqué dans la file d’attente de messages comme n’importe quel autre message.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-131">At this point, the user still cannot even terminate the application - clicking the X (Close) button would result in a WM\_CLOSE message, which would be stuck in the message queue just like any other message.</span></span> <span data-ttu-id="ef8ee-132">Le Gestionnaire de fenêtrage aide à masquer et à remplacer en toute transparence la fenêtre bloquée par une copie « fantôme » affichant une image bitmap de la zone cliente précédente de la fenêtre d’origine (et ajoutant « ne pas répondre » à la barre de titre).</span><span class="sxs-lookup"><span data-stu-id="ef8ee-132">The Desktop Window Manager assists by seamlessly hiding and then replacing the hung window with a 'ghost' copy displaying a bitmap of the original window's previous client area (and adding "Not Responding" to the title bar).</span></span> <span data-ttu-id="ef8ee-133">Tant que le thread de la fenêtre d’origine ne récupère pas les messages, le DWM gère simultanément les deux fenêtres, mais permet à l’utilisateur d’interagir uniquement avec la copie fantôme.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-133">As long as the original window's thread does not retrieve messages, the DWM manages both windows simultaneously, but allows the user to interact only with the ghost copy.</span></span> <span data-ttu-id="ef8ee-134">À l’aide de cette fenêtre fantôme, l’utilisateur peut uniquement déplacer, réduire et, plus important encore, fermer l’application qui ne répond pas, mais ne modifie pas son état interne.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-134">Using this ghost window, the user can only move, minimize, and - most importantly - close the unresponsive application, but not change its internal state.</span></span>

<span data-ttu-id="ef8ee-135">L’expérience fantôme complète ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="ef8ee-135">The whole ghost experience looks like this:</span></span>

![Capture d’écran montrant la boîte de dialogue « le bloc-notes ne répond pas ».](images/preventinghangs-ghostwindow.gif)

<span data-ttu-id="ef8ee-137">La Gestionnaire de fenêtrage effectue une dernière chose ; Il s’intègre à Rapport d’erreurs Windows, permettant à l’utilisateur de fermer et éventuellement de redémarrer l’application, mais également de renvoyer des données de débogage précieuses à Microsoft.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-137">The Desktop Window Manager does one last thing; it integrates with Windows Error Reporting, allowing the user to not only close and optionally restart the application, but also send valuable debugging data back to Microsoft.</span></span> <span data-ttu-id="ef8ee-138">Vous pouvez obtenir ces données de blocage pour vos propres applications en vous inscrivant sur le site Web winqual.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-138">You can get this hang data for your own applications by signing up at the Winqual website.</span></span>

<span data-ttu-id="ef8ee-139">Windows 7 a ajouté une nouvelle fonctionnalité à cette expérience.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-139">Windows 7 added one new feature to this experience.</span></span> <span data-ttu-id="ef8ee-140">Le système d’exploitation analyse l’application bloquée et, dans certaines circonstances, donne à l’utilisateur la possibilité d’annuler une opération de blocage et de rendre l’application réactive.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-140">The operating system analyzes the hung application and, under certain circumstances, gives the user the option to cancel a blocking operation and make the application responsive again.</span></span> <span data-ttu-id="ef8ee-141">L’implémentation actuelle prend en charge l’annulation des appels de socket bloquants ; d’autres opérations seront annulées par l’utilisateur dans les versions ultérieures.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-141">The current implementation supports cancellation of blocking Socket calls; more operations will be user-cancelable in future releases.</span></span>

<span data-ttu-id="ef8ee-142">Pour intégrer votre application à l’expérience de récupération des blocages et tirer le meilleur parti des données disponibles, procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="ef8ee-142">To integrate your application with the hang recovery experience and to make the most out of the available data, follow these steps:</span></span>

-   <span data-ttu-id="ef8ee-143">Assurez-vous que votre application s’inscrit au redémarrage et à la récupération, ce qui rend le blocage aussi simple que possible pour l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-143">Ensure that your application registers for restart and recovery, making a hang as pain-free as possible to the user.</span></span> <span data-ttu-id="ef8ee-144">Une application correctement inscrite peut redémarrer automatiquement avec la plupart de ses données non enregistrées intactes.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-144">A properly registered application can automatically restart with most of its unsaved data intact.</span></span> <span data-ttu-id="ef8ee-145">Cela fonctionne pour les blocages d’application et les blocages.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-145">This works for both application hangs and crashes.</span></span>
-   <span data-ttu-id="ef8ee-146">Obtenir des informations sur la fréquence, ainsi que des données de débogage pour vos applications bloquées et bloquées à partir du site Web winqual.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-146">Get frequency information as well as debugging data for your hung and crashed applications from the Winqual website.</span></span> <span data-ttu-id="ef8ee-147">Vous pouvez utiliser ces informations même pendant votre version bêta pour améliorer votre code.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-147">You can use this information even during your Beta to improve your code.</span></span> <span data-ttu-id="ef8ee-148">Pour obtenir une vue d’ensemble, consultez « Présentation de Rapport d’erreurs Windows ».</span><span class="sxs-lookup"><span data-stu-id="ef8ee-148">See "Introducing Windows Error Reporting" for a brief overview.</span></span>
-   <span data-ttu-id="ef8ee-149">Vous pouvez désactiver la fonctionnalité de ghosting dans votre application via un appel à DisableProcessWindowsGhosting ().</span><span class="sxs-lookup"><span data-stu-id="ef8ee-149">You can disable the ghosting feature in your application via a call to DisableProcessWindowsGhosting ().</span></span> <span data-ttu-id="ef8ee-150">Toutefois, cela empêche l’utilisateur moyen de fermer et redémarrer une application bloquée et se termine souvent par un redémarrage.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-150">However, this prevents the average user from closing and restarting a hung application and often ends in a reboot.</span></span>

<span data-ttu-id="ef8ee-151">**Blocages-perspective développeur**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-151">**Hangs - Developer Perspective**</span></span>

<span data-ttu-id="ef8ee-152">Le système d’exploitation définit le blocage d’une application en tant que thread d’interface utilisateur qui n’a pas traité de messages pendant au moins 5 secondes.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-152">The operating system defines an application hang as a UI thread that has not processed messages for at least 5 seconds.</span></span> <span data-ttu-id="ef8ee-153">Des bogues évidents provoquent des blocages, par exemple, un thread qui attend un événement qui n’est jamais signalé, et deux threads contenant chacun un verrou et tentant d’acquérir les autres.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-153">Obvious bugs cause some hangs, for example, a thread waiting for an event that is never signaled, and two threads each holding a lock and trying to acquire the others.</span></span> <span data-ttu-id="ef8ee-154">Vous pouvez corriger ces bogues sans trop d’efforts.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-154">You can fix those bugs without too much effort.</span></span> <span data-ttu-id="ef8ee-155">Toutefois, de nombreux blocages ne sont pas si clairs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-155">However, many hangs are not so clear.</span></span> <span data-ttu-id="ef8ee-156">Oui, le thread d’interface utilisateur ne récupère pas les messages, mais il est également occupé à effectuer un autre travail « important », puis à revenir au traitement des messages.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-156">Yes, the UI thread is not retrieving messages - but it is equally busy doing other 'important' work and will eventually come back to processing messages.</span></span>

<span data-ttu-id="ef8ee-157">Toutefois, l’utilisateur perçoit cela comme un bogue.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-157">However, the user perceives this as a bug.</span></span> <span data-ttu-id="ef8ee-158">La conception doit correspondre aux attentes de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-158">The design should match the user's expectations.</span></span> <span data-ttu-id="ef8ee-159">Si la conception de l’application entraîne une application qui ne répond pas, la conception devra changer.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-159">If the application's design leads to an unresponsive application, the design will have to change.</span></span> <span data-ttu-id="ef8ee-160">Enfin, ce qui est important, l’absence de réponse ne peut pas être corrigée comme un bogue de code. elle nécessite un travail initial au cours de la phase de conception.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-160">Finally, and this is important, unresponsiveness cannot be fixed like a code bug; it requires upfront work during the design phase.</span></span> <span data-ttu-id="ef8ee-161">Essayer de répartir la base de code existante d’une application pour améliorer la réactivité de l’interface utilisateur est souvent trop cher.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-161">Trying to retrofit an application's existing code base to make the UI more responsive is often too expensive.</span></span> <span data-ttu-id="ef8ee-162">Les instructions de conception suivantes peuvent vous aider.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-162">The following design guidelines might help.</span></span>

-   <span data-ttu-id="ef8ee-163">Faire de la réactivité de l’interface utilisateur une exigence de niveau supérieur ; l’utilisateur doit toujours maîtriser votre application</span><span class="sxs-lookup"><span data-stu-id="ef8ee-163">Make UI responsiveness a top-level requirement; the user should always feel in control of your application</span></span>
-   <span data-ttu-id="ef8ee-164">Assurez-vous que les utilisateurs peuvent annuler des opérations qui prennent plus d’une seconde à se terminer et/ou que les opérations peuvent se terminer en arrière-plan. fournir une interface utilisateur de progression appropriée, si nécessaire</span><span class="sxs-lookup"><span data-stu-id="ef8ee-164">Ensure that users can cancel operations that take longer than one second to complete and/or that operations can complete in the background; provide appropriate progress UI if necessary</span></span>

![Capture d’écran montrant la boîte de dialogue « copie d’éléments ».](images/preventinghangs-progressbar.gif)

-   <span data-ttu-id="ef8ee-166">Met en file d’attente les opérations de longue durée ou de blocage en tant que tâches en arrière-plan (cela nécessite un mécanisme de messagerie bien pensé pour informer le thread d’interface utilisateur lorsque le travail est terminé)</span><span class="sxs-lookup"><span data-stu-id="ef8ee-166">Queue long-running or blocking operations as background tasks (this requires a well-thought out messaging mechanism to inform the UI thread when work has been completed)</span></span>
-   <span data-ttu-id="ef8ee-167">Gardez le code pour les threads de l’interface utilisateur simple ; supprimer autant d’appels d’API bloquant que possible</span><span class="sxs-lookup"><span data-stu-id="ef8ee-167">Keep the code for UI threads simple; remove as many blocking API calls as possible</span></span>
-   <span data-ttu-id="ef8ee-168">Affiche les fenêtres et les boîtes de dialogue uniquement lorsqu’elles sont prêtes et entièrement opérationnelles.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-168">Show windows and dialogs only when they are ready and fully operational.</span></span> <span data-ttu-id="ef8ee-169">Si la boîte de dialogue doit afficher des informations qui nécessitent trop de ressources pour être calculées, affichez d’abord des informations génériques et mettez-les à jour à la volée lorsque davantage de données sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-169">If the dialog needs to display information that is too resource-intensive to calculate, show some generic information first and update it on the fly when more data becomes available.</span></span> <span data-ttu-id="ef8ee-170">La boîte de dialogue Propriétés du dossier de l’Explorateur Windows en est un bon exemple.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-170">A good example is the folder properties dialog from Windows Explorer.</span></span> <span data-ttu-id="ef8ee-171">Il doit afficher la taille totale du dossier, les informations qui ne sont pas immédiatement disponibles à partir du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-171">It needs to display the folder's total size, information that is not readily available from the file system.</span></span> <span data-ttu-id="ef8ee-172">La boîte de dialogue s’affiche immédiatement et le champ « taille » est mis à jour à partir d’un thread de travail :</span><span class="sxs-lookup"><span data-stu-id="ef8ee-172">The dialog shows up right away and the "size" field is updated from a worker thread:</span></span>

![Capture d’écran montrant la page « général » des propriétés de Windows avec le texte « taille », « taille sur le disque » et « contient ».](images/preventinghangs-updatingdialog.gif)

<span data-ttu-id="ef8ee-174">Malheureusement, il n’existe aucun moyen simple de concevoir et d’écrire une application réactive.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-174">Unfortunately, there is no simple way to design and write a responsive application.</span></span> <span data-ttu-id="ef8ee-175">Windows ne fournit pas d’infrastructure asynchrone simple qui permet une planification aisée des opérations de blocage ou de longue durée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-175">Windows does not provide a simple asynchronous framework that would allow for easy scheduling of blocking or long-running operations.</span></span> <span data-ttu-id="ef8ee-176">Les sections suivantes présentent quelques-unes des meilleures pratiques pour empêcher les blocages et mettre en évidence certains des pièges les plus courants.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-176">The following sections introduce some of the best practices in preventing hangs and highlight some of the common pitfalls.</span></span>

## <a name="best-practices"></a><span data-ttu-id="ef8ee-177">Bonnes pratiques</span><span class="sxs-lookup"><span data-stu-id="ef8ee-177">Best Practices</span></span>

<span data-ttu-id="ef8ee-178">**Garder le thread d’interface utilisateur simple**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-178">**Keep the UI Thread Simple**</span></span>

<span data-ttu-id="ef8ee-179">La responsabilité principale du thread d’interface utilisateur est de récupérer et de distribuer les messages.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-179">The UI thread's primary responsibility is to retrieve and dispatch messages.</span></span> <span data-ttu-id="ef8ee-180">Tout autre type de travail présente le risque de suspendre les fenêtres détenues par ce thread.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-180">Any other kind of work introduces the risk of hanging the windows owned by this thread.</span></span>

<span data-ttu-id="ef8ee-181">**Ne**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-181">**Do:**</span></span>

-   <span data-ttu-id="ef8ee-182">Déplacer des algorithmes gourmands en ressources ou non liés qui entraînent des opérations de longue durée vers les threads de travail</span><span class="sxs-lookup"><span data-stu-id="ef8ee-182">Move resource-intensive or unbounded algorithms that result in long-running operations to worker threads</span></span>
-   <span data-ttu-id="ef8ee-183">Identifiez autant que possible les appels de fonctions bloquantes et essayez de les déplacer vers les threads de travail. toute fonction appelant dans une autre DLL doit être suspecte</span><span class="sxs-lookup"><span data-stu-id="ef8ee-183">Identify as many blocking function calls as possible and try to move them to worker threads; any function calling into another DLL should be suspicious</span></span>
-   <span data-ttu-id="ef8ee-184">Faites un effort supplémentaire pour supprimer toutes les e/s de fichier et les appels d’API réseau de votre thread de travail.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-184">Make an extra effort to remove all file I/O and networking API calls from your worker thread.</span></span> <span data-ttu-id="ef8ee-185">Ces fonctions peuvent se bloquer pendant de nombreuses secondes si elles ne sont pas des minutes.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-185">These functions can block for many seconds if not minutes.</span></span> <span data-ttu-id="ef8ee-186">Si vous devez effectuer n’importe quel type d’e/s dans le thread d’interface utilisateur, envisagez d’utiliser des e/s asynchrones</span><span class="sxs-lookup"><span data-stu-id="ef8ee-186">If you need to do any kind of I/O in the UI thread, consider using asynchronous I/O</span></span>
-   <span data-ttu-id="ef8ee-187">N’oubliez pas que votre thread d’interface utilisateur traite également tous les serveurs COM STA (Single-Threaded Apartment) hébergés par votre processus. Si vous effectuez un appel bloquant, ces serveurs COM ne répondront pas tant que vous n’aurez pas reservi la file d’attente de messages</span><span class="sxs-lookup"><span data-stu-id="ef8ee-187">Be aware that your UI thread is also servicing all single-threaded apartment (STA) COM servers hosted by your process; if you make a blocking call, these COM servers will be unresponsive until you service the message queue again</span></span>

<span data-ttu-id="ef8ee-188">**Ne pas :**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-188">**Do not:**</span></span>

-   <span data-ttu-id="ef8ee-189">Attendre un objet de noyau (comme un événement ou un mutex) pendant plus d’un laps de temps. Si vous devez attendre, envisagez d’utiliser MsgWaitForMultipleObjects (), qui se débloquera à l’arrivée d’un nouveau message</span><span class="sxs-lookup"><span data-stu-id="ef8ee-189">Wait on any kernel object (like Event or Mutex) for more than a very short amount of time; if you have to wait at all, consider using MsgWaitForMultipleObjects(), which will unblock when a new message arrives</span></span>
-   <span data-ttu-id="ef8ee-190">Partagez la file d’attente de messages de fenêtre d’un thread avec un autre thread à l’aide de la fonction AttachThreadInput ().</span><span class="sxs-lookup"><span data-stu-id="ef8ee-190">Share a thread's window message queue with another thread by using the AttachThreadInput() function.</span></span> <span data-ttu-id="ef8ee-191">Il est non seulement extrêmement difficile de synchroniser correctement l’accès à la file d’attente, mais aussi d’empêcher le système d’exploitation Windows de détecter correctement une fenêtre bloquée</span><span class="sxs-lookup"><span data-stu-id="ef8ee-191">It is not only extremely difficult to properly synchronize access to the queue, it also can prevent the Windows operating system from properly detecting a hung window</span></span>
-   <span data-ttu-id="ef8ee-192">Utilisez TerminateThread () sur l’un de vos threads de travail.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-192">Use TerminateThread() on any of your worker threads.</span></span> <span data-ttu-id="ef8ee-193">L’arrêt d’un thread de cette manière ne lui permet pas de libérer des verrous ou des événements de signal et peut facilement entraîner des objets de synchronisation orphelins</span><span class="sxs-lookup"><span data-stu-id="ef8ee-193">Terminating a thread in this way will not allow it to release locks or signal events and can easily result in orphaned synchronization objects</span></span>
-   <span data-ttu-id="ef8ee-194">Appelez un code inconnu de votre thread d’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-194">Call into any 'unknown' code from your UI thread.</span></span> <span data-ttu-id="ef8ee-195">Cela est particulièrement vrai si votre application a un modèle d’extensibilité ; Il n’y a aucune garantie que le code tiers respecte vos instructions de réactivité</span><span class="sxs-lookup"><span data-stu-id="ef8ee-195">This is especially true if your application has an extensibility model; there is no guarantee that 3rd-party code follows your responsiveness guidelines</span></span>
-   <span data-ttu-id="ef8ee-196">Effectuer tout type d’appel de diffusion en blocage ; SendMessage ( \_ diffusion HWND) vous place à la merci de chaque application mal écrite en cours d’exécution</span><span class="sxs-lookup"><span data-stu-id="ef8ee-196">Make any kind of blocking broadcast call; SendMessage(HWND\_BROADCAST) puts you at the mercy of every ill-written application currently running</span></span>

<span data-ttu-id="ef8ee-197">**Implémenter des modèles asynchrones**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-197">**Implement Asynchronous Patterns**</span></span>

<span data-ttu-id="ef8ee-198">La suppression d’opérations de longue durée ou de blocage à partir du thread d’interface utilisateur requiert l’implémentation d’une infrastructure asynchrone qui permet de décharger ces opérations sur les threads de travail.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-198">Removing long-running or blocking operations from the UI thread requires implementing an asynchronous framework that allows offloading those operations to worker threads.</span></span>

<span data-ttu-id="ef8ee-199">**Ne**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-199">**Do:**</span></span>

-   <span data-ttu-id="ef8ee-200">Utilisez des API de message de fenêtre asynchrones dans votre thread d’interface utilisateur, notamment en remplaçant SendMessage par l’un de ses homologues non bloquant : PostMessage, SendNotifyMessage ou SendMessageCallback</span><span class="sxs-lookup"><span data-stu-id="ef8ee-200">Use asynchronous window message APIs in your UI thread, especially by replacing SendMessage with one of its non-blocking peers: PostMessage, SendNotifyMessage, or SendMessageCallback</span></span>
-   <span data-ttu-id="ef8ee-201">Utilisez les threads d’arrière-plan pour exécuter des tâches de longue durée ou de blocage.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-201">Use background threads to execute long-running or blocking tasks.</span></span> <span data-ttu-id="ef8ee-202">Utiliser la nouvelle API de pool de threads pour implémenter vos threads de travail</span><span class="sxs-lookup"><span data-stu-id="ef8ee-202">Use the new thread pool API to implement your worker threads</span></span>
-   <span data-ttu-id="ef8ee-203">Assurez la prise en charge de l’annulation des tâches en arrière-plan de longue durée.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-203">Provide cancellation support for long-running background tasks.</span></span> <span data-ttu-id="ef8ee-204">Pour les opérations d’e/s bloquantes, utilisez l’annulation d’e/s, mais uniquement en dernier recours. Il n’est pas facile d’annuler l’opération « Right ».</span><span class="sxs-lookup"><span data-stu-id="ef8ee-204">For blocking I/O operations, use I/O cancellation, but only as a last resort; it's not easy to cancel the 'right' operation</span></span>
-   <span data-ttu-id="ef8ee-205">Implémenter une conception asynchrone pour du code managé à l’aide du modèle IAsyncResult ou à l’aide d’événements</span><span class="sxs-lookup"><span data-stu-id="ef8ee-205">Implement an asynchronous design for managed code by using the IAsyncResult pattern or by using Events</span></span>

<span data-ttu-id="ef8ee-206">**Utiliser les verrous avec prudence**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-206">**Use Locks Wisely**</span></span>

<span data-ttu-id="ef8ee-207">Votre application ou DLL nécessite des verrous pour synchroniser l’accès à ses structures de données internes.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-207">Your application or DLL needs locks to synchronize access to its internal data structures.</span></span> <span data-ttu-id="ef8ee-208">L’utilisation de plusieurs verrous augmente le parallélisme et rend votre application plus réactive.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-208">Using multiple locks increases parallelism and makes your application more responsive.</span></span> <span data-ttu-id="ef8ee-209">Toutefois, l’utilisation de plusieurs verrous augmente également la possibilité d’acquérir ces verrous dans des ordres différents et de provoquer un blocage des threads.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-209">However, using multiple locks also increases the chance of acquiring those locks in different orders and causing your threads to deadlock.</span></span> <span data-ttu-id="ef8ee-210">Si deux threads maintiennent chacun un verrou, puis essaient d’acquérir le verrou de l’autre thread, leurs opérations forment une attente circulaire qui bloque toute progression vers l’avant pour ces threads.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-210">If two threads each hold a lock and then try to acquire the other thread's lock, their operations will form a circular wait that blocks any forward progress for these threads.</span></span> <span data-ttu-id="ef8ee-211">Vous pouvez éviter ce blocage uniquement en vous assurant que tous les threads de l’application acquièrent toujours tous les verrous dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-211">You can avoid this deadlock only by ensuring that all threads in the application always acquire all locks in the same order.</span></span> <span data-ttu-id="ef8ee-212">Toutefois, il n’est pas toujours facile d’acquérir des verrous dans l’ordre « Right ».</span><span class="sxs-lookup"><span data-stu-id="ef8ee-212">However, it isn't always easy to acquire locks in the 'right' order.</span></span> <span data-ttu-id="ef8ee-213">Les composants logiciels peuvent être composés, mais les acquisitions de verrous ne le peuvent pas.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-213">Software components can be composed, but lock acquisitions cannot.</span></span> <span data-ttu-id="ef8ee-214">Si votre code appelle un autre composant, les verrous de ce composant deviennent désormais partie intégrante de votre ordre de verrouillage implicite, même si vous n’avez aucune visibilité sur ces verrous.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-214">If your code calls some other component, that component's locks now become part of your implicit lock order - even if you have no visibility into those locks.</span></span>

<span data-ttu-id="ef8ee-215">Les choses sont encore plus difficiles, car les opérations de verrouillage incluent bien plus que les fonctions habituelles pour les sections critiques, les mutex et les autres verrous traditionnels.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-215">Things get even harder because locking operations include far more than the usual functions for Critical Sections, Mutexes, and other traditional locks.</span></span> <span data-ttu-id="ef8ee-216">Tout appel bloquant qui traverse les limites de thread a des propriétés de synchronisation qui peuvent provoquer un interblocage.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-216">Any blocking call that crosses thread boundaries has synchronization properties that can result in a deadlock.</span></span> <span data-ttu-id="ef8ee-217">Le thread appelant effectue une opération avec la sémantique « Acquire » et ne peut pas se débloquer tant que le thread cible n’est pas appelé.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-217">The calling thread performs an operation with 'acquire' semantics and cannot unblock until the target thread 'releases' that call.</span></span> <span data-ttu-id="ef8ee-218">Certaines fonctions User32 (par exemple, SendMessage), ainsi que de nombreux appels COM bloquants, appartiennent à cette catégorie.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-218">Quite a few User32 functions (for example SendMessage), as well as many blocking COM calls fall into this category.</span></span>

<span data-ttu-id="ef8ee-219">Pire encore, le système d’exploitation a son propre verrou interne propre au processus qui est parfois conservé pendant l’exécution de votre code.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-219">Worse yet, the operating system has its own internal process-specific lock that sometimes is held while your code executes.</span></span> <span data-ttu-id="ef8ee-220">Ce verrou est acquis lorsque les dll sont chargées dans le processus et est donc appelé « verrouillage du chargeur ».</span><span class="sxs-lookup"><span data-stu-id="ef8ee-220">This lock is acquired when DLLs are loaded into the process, and is therefore called the 'loader lock.'</span></span> <span data-ttu-id="ef8ee-221">La fonction DllMain s’exécute toujours sous le verrou du chargeur. Si vous acquérez des verrous dans DllMain (et que vous ne le faites pas), vous devez faire en sorte que le chargeur verrouille la partie de votre ordre de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-221">The DllMain function always executes under the loader lock; if you acquire any locks in DllMain (and you should not), you need to make the loader lock part of your lock order.</span></span> <span data-ttu-id="ef8ee-222">L’appel de certaines API Win32 peut également acquérir le verrou du chargeur sur vos fonctions, telles que LoadLibraryEx, GetModuleHandle, et en particulier CoCreateInstance.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-222">Calling certain Win32 APIs might also acquire the loader lock on your behalf - functions like LoadLibraryEx, GetModuleHandle, and especially CoCreateInstance.</span></span>

<span data-ttu-id="ef8ee-223">Pour regrouper tout cela, examinez l’exemple de code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-223">To tie all of this together, look at the sample code below.</span></span> <span data-ttu-id="ef8ee-224">Cette fonction acquiert plusieurs objets de synchronisation et définit implicitement un ordre de verrouillage, ce qui n’est pas nécessairement évident sur l’inspection des curseurs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-224">This function acquires multiple synchronization objects and implicitly defines a lock order, something that is not necessarily obvious on cursory inspection.</span></span> <span data-ttu-id="ef8ee-225">Dans l’entrée de la fonction, le code acquiert une section critique et ne le libère pas jusqu’à la sortie de la fonction, ce qui en fait le nœud supérieur dans la hiérarchie des verrous.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-225">On function entry, the code acquires a Critical Section and does not release it until function exit, thereby making it the top node in our lock hierarchy.</span></span> <span data-ttu-id="ef8ee-226">Le code appelle ensuite la fonction Win32 LoadIcon (), qui sous les couvertures peut appeler le chargeur du système d’exploitation pour charger ce fichier binaire.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-226">The code then calls the Win32 function LoadIcon(), which under the covers might call into the Operating System Loader to load this binary.</span></span> <span data-ttu-id="ef8ee-227">Cette opération permet d’acquérir le verrou du chargeur, qui devient également une partie de cette hiérarchie de verrous (Assurez-vous que la fonction DllMain n’acquiert pas le \_ verrou g cs).</span><span class="sxs-lookup"><span data-stu-id="ef8ee-227">This operation would acquire the loader lock, which now also becomes part of this lock hierarchy (make sure the DllMain function does not acquire the g\_cs lock).</span></span> <span data-ttu-id="ef8ee-228">Le code appelle ensuite SendMessage (), une opération de blocage inter-threads, qui n’est pas retournée, sauf si le thread d’interface utilisateur répond.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-228">Next the code calls SendMessage(), a blocking cross-thread operation, which will not return unless the UI thread responds.</span></span> <span data-ttu-id="ef8ee-229">Encore une fois, assurez-vous que le thread d’interface utilisateur n’acquiert jamais g \_ cs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-229">Again, make sure that the UI thread never acquires g\_cs.</span></span>

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

<span data-ttu-id="ef8ee-230">En examinant ce code, il est évident que nous avons implicitement établi g \_ cs le verrou de niveau supérieur dans notre hiérarchie de verrous, même si nous voulions uniquement synchroniser l’accès aux variables de membre de classe.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-230">Looking at this code it seems clear that we implicitly made g\_cs the top-level lock in our lock hierarchy, even if we only wanted to synchronize access to the class member variables.</span></span>

<span data-ttu-id="ef8ee-231">**Ne**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-231">**Do:**</span></span>

-   <span data-ttu-id="ef8ee-232">Concevoir une hiérarchie de verrous et la respecter.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-232">Design a lock hierarchy and obey it.</span></span> <span data-ttu-id="ef8ee-233">Ajoutez tous les verrous nécessaires.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-233">Add all the necessary locks.</span></span> <span data-ttu-id="ef8ee-234">Il existe beaucoup plus de primitives de synchronisation que simplement mutex et CriticalSections ; ils doivent tous être inclus.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-234">There are many more synchronization primitives than just Mutex and CriticalSections; they all need to be included.</span></span> <span data-ttu-id="ef8ee-235">Inclure le verrou du chargeur dans votre hiérarchie si vous prenez des verrous dans DllMain ()</span><span class="sxs-lookup"><span data-stu-id="ef8ee-235">Include the loader lock in your hierarchy if you take any locks in DllMain()</span></span>
-   <span data-ttu-id="ef8ee-236">Acceptez le protocole de verrouillage avec vos dépendances.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-236">Agree on locking protocol with your dependencies.</span></span> <span data-ttu-id="ef8ee-237">Tout code que votre application appelle ou qui peut appeler votre application doit partager la même hiérarchie de verrouillage</span><span class="sxs-lookup"><span data-stu-id="ef8ee-237">Any code your application calls or that might call your application needs to share the same lock hierarchy</span></span>
-   <span data-ttu-id="ef8ee-238">Les structures de données de verrouillage ne fonctionnent pas.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-238">Lock data structures not functions.</span></span> <span data-ttu-id="ef8ee-239">Déplacez les acquisitions de verrous hors des points d’entrée de fonction et protégez uniquement l’accès aux données avec des verrous.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-239">Move lock acquisitions away from function entry points and guard only data access with locks.</span></span> <span data-ttu-id="ef8ee-240">Si moins de code fonctionne sous un verrou, il y a moins de risques de blocages</span><span class="sxs-lookup"><span data-stu-id="ef8ee-240">If less code operates under a lock, there is less of a chance for deadlocks</span></span>
-   <span data-ttu-id="ef8ee-241">Analyser les acquisitions et les libérations de verrous dans votre code de gestion des erreurs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-241">Analyze lock acquisitions and releases in your error handling code.</span></span> <span data-ttu-id="ef8ee-242">Souvent la hiérarchie de verrous si elle est oubliée lors d’une tentative de récupération après une condition d’erreur</span><span class="sxs-lookup"><span data-stu-id="ef8ee-242">Often the lock hierarchy if forgotten when trying to recover from an error condition</span></span>
-   <span data-ttu-id="ef8ee-243">Remplacer les verrous imbriqués par des compteurs de référence : ils ne peuvent pas se bloquer.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-243">Replace nested locks with reference counters - they cannot deadlock.</span></span> <span data-ttu-id="ef8ee-244">Les éléments verrouillés individuellement dans les listes et les tables sont de bons candidats</span><span class="sxs-lookup"><span data-stu-id="ef8ee-244">Individually locked elements in lists and tables are good candidates</span></span>
-   <span data-ttu-id="ef8ee-245">Soyez prudent lors de l’attente d’un handle de thread à partir d’une DLL.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-245">Be careful when waiting on a thread handle from a DLL.</span></span> <span data-ttu-id="ef8ee-246">Supposez toujours que votre code peut être appelé sous le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-246">Always assume that your code could be called under the loader lock.</span></span> <span data-ttu-id="ef8ee-247">Il est préférable de faire référence à vos ressources et de laisser le thread de travail effectuer son propre nettoyage (puis utiliser FreeLibraryAndExitThread pour s’arrêter correctement)</span><span class="sxs-lookup"><span data-stu-id="ef8ee-247">It's better to reference-count your resources and let the worker thread do its own cleanup (and then use FreeLibraryAndExitThread to terminate cleanly)</span></span>
-   <span data-ttu-id="ef8ee-248">Utiliser l’API traversée de chaîne d’attente si vous souhaitez diagnostiquer vos propres blocages</span><span class="sxs-lookup"><span data-stu-id="ef8ee-248">Use the Wait Chain Traversal API if you want to diagnose your own deadlocks</span></span>

<span data-ttu-id="ef8ee-249">**Ne pas :**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-249">**Do not:**</span></span>

-   <span data-ttu-id="ef8ee-250">Effectuez tout autre opération d’initialisation très simple dans votre fonction DllMain ().</span><span class="sxs-lookup"><span data-stu-id="ef8ee-250">Do anything other than very simple initialization work in your DllMain() function.</span></span> <span data-ttu-id="ef8ee-251">Pour plus d’informations, consultez fonction de rappel DllMain.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-251">See DllMain Callback Function for more details.</span></span> <span data-ttu-id="ef8ee-252">En particulier, n’appelez pas LoadLibraryEx ou CoCreateInstance</span><span class="sxs-lookup"><span data-stu-id="ef8ee-252">Especially do not call LoadLibraryEx or CoCreateInstance</span></span>
-   <span data-ttu-id="ef8ee-253">Écrivez vos propres primitives de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-253">Write your own locking primitives.</span></span> <span data-ttu-id="ef8ee-254">Le code de synchronisation personnalisé peut facilement introduire des bogues subtils dans votre base de code.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-254">Custom synchronization code can easily introduce subtle bugs into your code base.</span></span> <span data-ttu-id="ef8ee-255">Utilisez plutôt la sélection enrichie d’objets de synchronisation du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-255">Use the rich selection of operating system synchronization objects instead</span></span>
-   <span data-ttu-id="ef8ee-256">Effectuez n’importe quel travail dans les constructeurs et les destructeurs pour les variables globales, ils sont exécutés dans le cadre du verrouillage du chargeur</span><span class="sxs-lookup"><span data-stu-id="ef8ee-256">Do any work in the constructors and destructors for global variables, they are executed under the loader lock</span></span>

<span data-ttu-id="ef8ee-257">**Soyez vigilant avec les exceptions**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-257">**Be Careful with Exceptions**</span></span>

<span data-ttu-id="ef8ee-258">Les exceptions permettent de séparer le déroulement normal du programme et la gestion des erreurs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-258">Exceptions allow the separation of normal program flow and error handling.</span></span> <span data-ttu-id="ef8ee-259">En raison de cette séparation, il peut être difficile de connaître l’état précis du programme avant l’exception, et le gestionnaire d’exceptions peut manquer des étapes essentielles pour restaurer un état valide.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-259">Because of this separation, it can be difficult to know the precise state of the program prior to the exception and the exception handler might miss crucial steps in restoring a valid state.</span></span> <span data-ttu-id="ef8ee-260">Cela est particulièrement vrai pour les acquisitions de verrous qui doivent être libérées dans le gestionnaire afin d’éviter les blocages futurs.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-260">This is especially true for lock acquisitions that need to be released in the handler to prevent future deadlocks.</span></span>

<span data-ttu-id="ef8ee-261">L’exemple de code ci-dessous illustre ce problème.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-261">The sample code below illustrates this issue.</span></span> <span data-ttu-id="ef8ee-262">L’accès illimité à la variable « buffer » entraîne parfois une violation d’accès (AV).</span><span class="sxs-lookup"><span data-stu-id="ef8ee-262">The unbounded access to the "buffer" variable will occasionally result in an access violation (AV).</span></span> <span data-ttu-id="ef8ee-263">Cette solution antivirus est interceptée par le gestionnaire d’exceptions natif, mais elle n’a aucun moyen simple de déterminer si la section critique a déjà été acquise au moment de l’exception (l’AV peut même avoir été placé quelque part dans le code EnterCriticalSection).</span><span class="sxs-lookup"><span data-stu-id="ef8ee-263">This AV is caught by the native exception handler, but it has no easy way of determining if the critical section was already acquired at the time of the exception (the AV could even have taken place somewhere in the EnterCriticalSection code).</span></span>

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

<span data-ttu-id="ef8ee-264">**Ne**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-264">**Do:**</span></span>

-   <span data-ttu-id="ef8ee-265">Supprimer les \_ \_ tentatives/ \_ \_ sauf si possible ; n’utilisez pas SetUnhandledExceptionFilter</span><span class="sxs-lookup"><span data-stu-id="ef8ee-265">Remove \_\_try/\_\_except whenever possible; do not use SetUnhandledExceptionFilter</span></span>
-   <span data-ttu-id="ef8ee-266">Encapsulez vos verrous dans des \_ modèles de type PTR automatique personnalisés si vous utilisez des exceptions C++.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-266">Wrap your locks in custom auto\_ptr-like templates if you use C++ exceptions.</span></span> <span data-ttu-id="ef8ee-267">Le verrou doit être libéré dans le destructeur.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-267">The lock should be released in the destructor.</span></span> <span data-ttu-id="ef8ee-268">Pour les exceptions natives, les verrous sont libérés dans votre \_ \_ instruction finally</span><span class="sxs-lookup"><span data-stu-id="ef8ee-268">For native exceptions release the locks in your \_\_finally statement</span></span>
-   <span data-ttu-id="ef8ee-269">Faites attention au code s’exécutant dans un gestionnaire d’exceptions natif ; l’exception peut avoir divulgué de nombreux verrous, donc votre gestionnaire ne doit pas acquérir</span><span class="sxs-lookup"><span data-stu-id="ef8ee-269">Be careful with the code executing in a native exception handler; the exception might have leaked many locks, so your handler should not acquire any</span></span>

<span data-ttu-id="ef8ee-270">**Ne pas :**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-270">**Do not:**</span></span>

-   <span data-ttu-id="ef8ee-271">Gérez les exceptions natives si elles ne sont pas nécessaires ou requises par les API Win32.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-271">Handle native exceptions if not necessary or required by the Win32 APIs.</span></span> <span data-ttu-id="ef8ee-272">Si vous utilisez des gestionnaires d’exceptions natifs pour la création de rapports ou la récupération de données après des défaillances catastrophiques, envisagez d’utiliser le mécanisme de système d’exploitation par défaut de Rapport d’erreurs Windows à la place</span><span class="sxs-lookup"><span data-stu-id="ef8ee-272">If you use native exception handlers for reporting or data recovery after catastrophic failures, consider using the default operating system mechanism of Windows Error Reporting instead</span></span>
-   <span data-ttu-id="ef8ee-273">Utilisez des exceptions C++ avec n’importe quel type de code d’interface utilisateur (User32). une exception levée dans un rappel transite par des couches de code C fournies par le système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="ef8ee-273">Use C++ exceptions with any kind of UI (user32) code; an exception thrown in a callback will travel through layers of C code provided by the operating system.</span></span> <span data-ttu-id="ef8ee-274">Ce code ne connaît pas les sémantiques de la désroll C++</span><span class="sxs-lookup"><span data-stu-id="ef8ee-274">That code does not know about C++ unroll semantics</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="ef8ee-275">Liens vers les ressources</span><span class="sxs-lookup"><span data-stu-id="ef8ee-275">Links to Resources</span></span>

-   [<span data-ttu-id="ef8ee-276">Rapport d’erreurs Windows</span><span class="sxs-lookup"><span data-stu-id="ef8ee-276">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   <span data-ttu-id="ef8ee-277">[Conception asynchrone](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="ef8ee-277">[Asynchronous Design](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="ef8ee-278">E/s asynchrones</span><span class="sxs-lookup"><span data-stu-id="ef8ee-278">Asynchronous I/O</span></span>](../fileio/synchronous-and-asynchronous-i-o.md)
-   [<span data-ttu-id="ef8ee-279">**AttachThreadInput fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-279">**AttachThreadInput Function**</span></span>](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   <span data-ttu-id="ef8ee-280">[**\_classe PTR automatique**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="ef8ee-280">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="ef8ee-281">**DisableProcessWindowsGhosting fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-281">**DisableProcessWindowsGhosting Function**</span></span>](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [<span data-ttu-id="ef8ee-282">**Fonction de rappel DllMain**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-282">**DllMain Callback Function**</span></span>](../dlls/dllmain.md)
-   <span data-ttu-id="ef8ee-283">[Événements](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="ef8ee-283">[Events](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)</span></span>
-   [<span data-ttu-id="ef8ee-284">**Fonction GetMessage**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-284">**GetMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [<span data-ttu-id="ef8ee-285">Annulation d’e/s</span><span class="sxs-lookup"><span data-stu-id="ef8ee-285">I/O cancellation</span></span>](../fileio/canceling-pending-i-o-operations.md)
-   [<span data-ttu-id="ef8ee-286">**IsHungAppWindow fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-286">**IsHungAppWindow Function**</span></span>](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [<span data-ttu-id="ef8ee-287">File d’attente de messages</span><span class="sxs-lookup"><span data-stu-id="ef8ee-287">Message Queue</span></span>](../winmsg/using-messages-and-message-queues.md)
-   [<span data-ttu-id="ef8ee-288">**MsgWaitForMultipleObjects fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-288">**MsgWaitForMultipleObjects Function**</span></span>](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [<span data-ttu-id="ef8ee-289">Nouvelle API de pool de threads</span><span class="sxs-lookup"><span data-stu-id="ef8ee-289">New Thread Pool API</span></span>](../procthread/thread-pool-api.md)
-   [<span data-ttu-id="ef8ee-290">**PostMessage, fonction**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-290">**PostMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [<span data-ttu-id="ef8ee-291">Redémarrage et récupération</span><span class="sxs-lookup"><span data-stu-id="ef8ee-291">Restart and Recovery</span></span>](../recovery/registering-for-application-restart.md)
-   [<span data-ttu-id="ef8ee-292">**SendMessageCallback fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-292">**SendMessageCallback Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [<span data-ttu-id="ef8ee-293">**SendNotifyMessage fonction)**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-293">**SendNotifyMessage Function**</span></span>](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [<span data-ttu-id="ef8ee-294">Objets de synchronisation</span><span class="sxs-lookup"><span data-stu-id="ef8ee-294">Synchronization Objects</span></span>](../sync/about-synchronization.md)
-   [<span data-ttu-id="ef8ee-295">**Fonction TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="ef8ee-295">**TerminateThread Function**</span></span>](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [<span data-ttu-id="ef8ee-296">Rapport d’erreurs Windows</span><span class="sxs-lookup"><span data-stu-id="ef8ee-296">Windows Error Reporting</span></span>](../wer/windows-error-reporting.md)
-   [<span data-ttu-id="ef8ee-297">Winqual</span><span class="sxs-lookup"><span data-stu-id="ef8ee-297">Winqual</span></span>](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
