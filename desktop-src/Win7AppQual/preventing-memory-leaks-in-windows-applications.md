---
description: Découvrez comment empêcher les fuites de mémoire dans les applications Windows pour les plateformes Windows 7 et Windows Server 2008 R2.
ms.assetid: c5dedcab-3e6f-433f-95de-d741321c683e
title: Prévention des fuites de mémoire dans les applications Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e973da19d075ac94824df340d1741fd9cefb3486
ms.sourcegitcommit: af9983bab40fe0b042f177ce7ca79f2eb0f9d0e8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/06/2021
ms.locfileid: "104560930"
---
# <a name="preventing-memory-leaks-in-windows-applications"></a><span data-ttu-id="eb8ee-103">Prévention des fuites de mémoire dans les applications Windows</span><span class="sxs-lookup"><span data-stu-id="eb8ee-103">Preventing Memory Leaks in Windows Applications</span></span>

## <a name="affected-platforms"></a><span data-ttu-id="eb8ee-104">Plateformes affectées</span><span class="sxs-lookup"><span data-stu-id="eb8ee-104">Affected Platforms</span></span>

<span data-ttu-id="eb8ee-105">**Clients** -Windows 7</span><span class="sxs-lookup"><span data-stu-id="eb8ee-105">**Clients** - Windows 7</span></span>  
<span data-ttu-id="eb8ee-106">**Serveurs** -Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="eb8ee-106">**Servers** - Windows Server 2008 R2</span></span>  

## <a name="description"></a><span data-ttu-id="eb8ee-107">Description</span><span class="sxs-lookup"><span data-stu-id="eb8ee-107">Description</span></span>

<span data-ttu-id="eb8ee-108">Les fuites de mémoire sont une classe de bogues dans laquelle l’application ne parvient pas à libérer de la mémoire lorsqu’elle n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-108">Memory leaks are a class of bugs where the application fails to release memory when no longer needed.</span></span> <span data-ttu-id="eb8ee-109">Au fil du temps, les fuites de mémoire affectent les performances de l’application en question, ainsi que du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-109">Over time, memory leaks affect the performance of both the particular application as well as the operating system.</span></span> <span data-ttu-id="eb8ee-110">Une fuite importante peut entraîner des temps de réponse inacceptable en raison d’une pagination excessive.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-110">A large leak might result in unacceptable response times due to excessive paging.</span></span> <span data-ttu-id="eb8ee-111">Finalement, l’application, ainsi que d’autres parties du système d’exploitation, rencontrent des défaillances.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-111">Eventually the application as well as other parts of the operating system will experience failures.</span></span>

<span data-ttu-id="eb8ee-112">Windows libérera toute la mémoire allouée par l’application lors de l’arrêt du processus, si bien que les applications à exécution réduite n’affecteront pas de manière significative les performances globales du système.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-112">Windows will free all memory allocated by the application on process termination, so short-running applications will not affect overall system performance significantly.</span></span> <span data-ttu-id="eb8ee-113">Toutefois, les fuites dans les processus de longue durée, telles que les services ou les plug-ins d’explorateur, peuvent avoir un impact considérable sur la fiabilité du système et peuvent forcer l’utilisateur à redémarrer Windows afin de rendre le système utilisable à nouveau.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-113">However, leaks in long-running processes like services or even Explorer plug-ins can greatly impact system reliability and might force the user to reboot Windows in order to make the system usable again.</span></span>

<span data-ttu-id="eb8ee-114">Les applications peuvent allouer de la mémoire en leur nom par plusieurs moyens.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-114">Applications can allocate memory on their behalf by multiple means.</span></span> <span data-ttu-id="eb8ee-115">Chaque type d’allocation peut entraîner une fuite si elle n’est pas libérée après utilisation.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-115">Each type of allocation can result in a leak if not freed after use.</span></span> <span data-ttu-id="eb8ee-116">Voici quelques exemples de modèles d’allocation courants :</span><span class="sxs-lookup"><span data-stu-id="eb8ee-116">Here are some examples of common allocation patterns:</span></span>

-   <span data-ttu-id="eb8ee-117">Mémoire du tas via la fonction [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) ou ses équivalents de Runtime C/C++ **malloc** ou **New**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-117">Heap memory via the [**HeapAlloc**](/windows/win32/api/heapapi/nf-heapapi-heapalloc) function or its C/C++ runtime equivalents **malloc** or **new**</span></span>
-   <span data-ttu-id="eb8ee-118">Allocation directe à partir du système d’exploitation via la fonction [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) .</span><span class="sxs-lookup"><span data-stu-id="eb8ee-118">Direct allocations from the operating system via the [**VirtualAlloc**](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) function.</span></span>
-   <span data-ttu-id="eb8ee-119">Les handles de noyau créés via des API Kernel32 telles que [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)ou [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)détiennent la mémoire du noyau pour le compte de l’application.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-119">Kernel handles created via Kernel32 APIs such as [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea), [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa), or [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread), hold kernel memory on behalf of the application</span></span>
-   <span data-ttu-id="eb8ee-120">Les handles GDI et utilisateur créés via les API User32 et gdi32 (par défaut, chaque processus a un quota de 10 000 descripteurs)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-120">GDI and USER handles created via User32 and Gdi32 APIs (by default, each process has a quota of 10,000 handles)</span></span>

## <a name="best-practices"></a><span data-ttu-id="eb8ee-121">Bonnes pratiques</span><span class="sxs-lookup"><span data-stu-id="eb8ee-121">Best Practices</span></span>

<span data-ttu-id="eb8ee-122">La surveillance de la consommation des ressources de votre application au fil du temps est la première étape de la détection et du diagnostic des fuites de mémoire.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-122">Monitoring the resource consumption of your application over time is the first step in detecting and diagnosing memory leaks.</span></span> <span data-ttu-id="eb8ee-123">Utilisez le gestionnaire des tâches Windows et ajoutez les colonnes suivantes : « taille de validation », « Handles », « objets utilisateur » et « objets GDI ».</span><span class="sxs-lookup"><span data-stu-id="eb8ee-123">Use Windows Task Manager and add the following columns: "Commit Size", "Handles", "User Objects", and "GDI Objects".</span></span> <span data-ttu-id="eb8ee-124">Cela vous permettra d’établir une ligne de base pour votre application et de surveiller l’utilisation des ressources au fil du temps.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-124">This will allow you to establish a baseline for your application and monitor resource usage over time.</span></span>

![Capture d’écran montrant la page « processus » dans le gestionnaire des tâches de Windows.](images/preventingmemoryleaks-windowstaskmanager.gif)

<span data-ttu-id="eb8ee-126">Les outils Microsoft suivants fournissent des informations plus détaillées et peuvent aider à détecter et à diagnostiquer les fuites pour les différents types d’allocation dans votre application :</span><span class="sxs-lookup"><span data-stu-id="eb8ee-126">The following Microsoft tools provide more-detailed information and can help to detect and diagnose leaks for the various allocation types in your application:</span></span>

-   <span data-ttu-id="eb8ee-127">L’analyseur de performances et les moniteur de ressource font partie de Windows 7 et peuvent surveiller et tracer l’utilisation des ressources au fil du temps</span><span class="sxs-lookup"><span data-stu-id="eb8ee-127">Performance Monitor and Resource Monitor are part of Windows 7 and can monitor and graph resource use over time</span></span>
-   <span data-ttu-id="eb8ee-128">La dernière version de Application Verifier peut diagnostiquer les fuites de tas sur Windows 7</span><span class="sxs-lookup"><span data-stu-id="eb8ee-128">The latest version of Application Verifier can diagnose heap leaks on Windows 7</span></span>
-   <span data-ttu-id="eb8ee-129">UMDH, qui fait partie des outils de débogage pour Windows, analyse les allocations de mémoire du tas pour un processus donné et peut aider à trouver des fuites et d’autres modèles d’utilisation inhabituels.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-129">UMDH, which is part of the Debugging Tools for Windows, analyzes the heap memory allocations for a given process and can help find leaks and other unusual usage patterns</span></span>
-   <span data-ttu-id="eb8ee-130">Xperf est un outil d’analyse des performances sophistiqué avec prise en charge des traces d’allocation de tas</span><span class="sxs-lookup"><span data-stu-id="eb8ee-130">Xperf is a sophisticated performance analysis tool with support for heap allocation traces</span></span>
-   <span data-ttu-id="eb8ee-131">Le tas de débogage CRT effectue le suivi des allocations de tas et peut vous aider à générer vos propres fonctionnalités de débogage de tas</span><span class="sxs-lookup"><span data-stu-id="eb8ee-131">CRT Debug Heap tracks heap allocations and can help build your own heap debugging features</span></span>

<span data-ttu-id="eb8ee-132">Certaines pratiques de codage et de conception peuvent limiter le nombre de fuites dans votre code.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-132">Certain coding and design practices can limit the number of leaks in your code.</span></span>

-   <span data-ttu-id="eb8ee-133">Utilisez des pointeurs intelligents dans du code C++ pour les allocations de tas, ainsi que pour les ressources Win32, telles que les **Handles** de noyau.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-133">Use smart pointers in C++ code both for heap allocations as well as for Win32 resources like kernel **HANDLE** s.</span></span> <span data-ttu-id="eb8ee-134">La bibliothèque C++ standard fournit la **classe \_ ptr automatique** pour les allocations de tas.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-134">The C++ Standard library provides the **auto\_ptr** class for heap allocations.</span></span> <span data-ttu-id="eb8ee-135">Pour les autres types d’allocation, vous devez écrire vos propres classes.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-135">For other allocation types you will need to write your own classes.</span></span> <span data-ttu-id="eb8ee-136">La bibliothèque ATL fournit un ensemble complet de classes pour la gestion automatique des ressources pour les objets de segment de mémoire et les handles de noyau</span><span class="sxs-lookup"><span data-stu-id="eb8ee-136">The ATL library provides a rich set of classes for automatic resource management for both heap objects and kernel handles</span></span>
-   <span data-ttu-id="eb8ee-137">Utilisez des fonctionnalités intrinsèques du compilateur comme **\_ com \_ ptr \_ t** pour encapsuler vos pointeurs d’interface com en « pointeurs intelligents » et pour faciliter le décompte de références.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-137">Use compiler intrinsic features like **\_com\_ptr\_t** to encapsulate your COM interface pointers into "smart pointers" and assist with reference counting.</span></span> <span data-ttu-id="eb8ee-138">Il existe des classes similaires pour les autres types de données COM : **\_ BSTR \_ t** et **\_ Variant \_ t**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-138">There are similar classes for other COM data types: **\_bstr\_t** and **\_variant\_t**</span></span>
-   <span data-ttu-id="eb8ee-139">Surveillez l’utilisation inhabituelle de la mémoire dans le code .NET.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-139">Monitor your .NET code unusual memory usage.</span></span> <span data-ttu-id="eb8ee-140">Le code managé n’est pas immunisé contre les fuites de mémoire.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-140">Managed code is not immune to memory leaks.</span></span> <span data-ttu-id="eb8ee-141">Consultez [« suivi des fuites de mémoire managées »](/archive/blogs/ricom/) pour savoir comment rechercher des fuites de gc</span><span class="sxs-lookup"><span data-stu-id="eb8ee-141">See ["Tracking down managed memory leaks"](/archive/blogs/ricom/) on how to find GC leaks</span></span>
-   <span data-ttu-id="eb8ee-142">Tenez compte des modèles de fuite dans le code côté client Web.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-142">Be aware of leak patterns in web client-side code.</span></span> <span data-ttu-id="eb8ee-143">Les références circulaires entre les objets COM et les moteurs de script tels que JScript peuvent provoquer des fuites importantes dans les applications Web.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-143">Circular references between COM objects and scripting engines like JScript can cause large leaks in web applications.</span></span> <span data-ttu-id="eb8ee-144">[« Comprendre et résoudre les modèles de fuites d’Internet Explorer »](/previous-versions/ms976398(v=msdn.10)) contient plus d’informations sur ces types de fuites.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-144">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10)) has more information on these kinds of leaks.</span></span> <span data-ttu-id="eb8ee-145">Vous pouvez utiliser le détecteur de fuites de mémoire JavaScript pour déboguer les fuites de mémoire dans votre code.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-145">You can use the JavaScript Memory Leak Detector to debug memory leaks in your code.</span></span> <span data-ttu-id="eb8ee-146">Bien que Windows Internet Explorer 8, qui est livré avec Windows 7, atténue la plupart de ces problèmes, les navigateurs plus anciens restent vulnérables à ces bogues.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-146">While Windows Internet Explorer 8, which is shipping with Windows 7, mitigates most of these issues, older browsers are still vulnerable to these bugs</span></span>
-   <span data-ttu-id="eb8ee-147">Évitez d’utiliser plusieurs chemins de sortie à partir d’une fonction.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-147">Avoid using multiple exit paths from a function.</span></span> <span data-ttu-id="eb8ee-148">Les allocations affectées aux variables à la portée de la fonction doivent être libérées dans un bloc particulier à la fin de la fonction</span><span class="sxs-lookup"><span data-stu-id="eb8ee-148">Allocations assigned to variables at function scope should be freed in one particular block at the end of the function</span></span>
-   <span data-ttu-id="eb8ee-149">N’utilisez pas d’exceptions dans votre code sans libérer toutes les variables locales dans les fonctions.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-149">Do not use exceptions in your code without freeing all local variables in functions.</span></span> <span data-ttu-id="eb8ee-150">Si vous utilisez des exceptions natives, libérez toutes vos allocations dans le \_ \_ bloc finally.</span><span class="sxs-lookup"><span data-stu-id="eb8ee-150">If you use native exceptions, free all your allocations inside the \_\_finally block.</span></span> <span data-ttu-id="eb8ee-151">Si vous utilisez des exceptions C++, vous devez encapsuler tous vos tas et les allocations de handle dans des pointeurs intelligents</span><span class="sxs-lookup"><span data-stu-id="eb8ee-151">If you use C++ exceptions, all your heap and handle allocations need to be wrapped in smart pointers</span></span>
-   <span data-ttu-id="eb8ee-152">Ne pas supprimer ou réinitialiser un objet [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) sans appeler la fonction [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-152">Do not discard or reinitialize a [**PROPVARIANT**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) object without calling the [**PropVariantClear**](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear) function</span></span>

## <a name="links-to-resources"></a><span data-ttu-id="eb8ee-153">Liens vers les ressources</span><span class="sxs-lookup"><span data-stu-id="eb8ee-153">Links to Resources</span></span>

<span data-ttu-id="eb8ee-154">*Modèles d’allocation courants :*</span><span class="sxs-lookup"><span data-stu-id="eb8ee-154">*Common Allocation Patterns:*</span></span>

-   [<span data-ttu-id="eb8ee-155">**Fonction d’allocation du tas**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-155">**Heap Allocation Function**</span></span>](/windows/win32/api/heapapi/nf-heapapi-heapalloc)
-   <span data-ttu-id="eb8ee-156">[**Fonction d’allocation de mémoire**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-156">[**Memory Allocation Function**](https://msdn.microsoft.com/library/6ewkz86d(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="eb8ee-157">[**New, opérateur (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-157">[**New Operator (C++)**](https://msdn.microsoft.com/library/kewsb8ba(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="eb8ee-158">**Fonction d’allocation virtuelle**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-158">**Virtual Allocation Function**</span></span>](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
-   [<span data-ttu-id="eb8ee-159">Objets de noyau</span><span class="sxs-lookup"><span data-stu-id="eb8ee-159">Kernel Objects</span></span>](../sysinfo/kernel-objects.md)
-   [<span data-ttu-id="eb8ee-160">Handles d’objet GDI</span><span class="sxs-lookup"><span data-stu-id="eb8ee-160">GDI Object Handles</span></span>](../sysinfo/gdi-objects.md)
-   [<span data-ttu-id="eb8ee-161">Handles d’objet d’interface utilisateur</span><span class="sxs-lookup"><span data-stu-id="eb8ee-161">User Interface Object Handles</span></span>](../sysinfo/user-objects.md)

<span data-ttu-id="eb8ee-162">*Outils Microsoft :*</span><span class="sxs-lookup"><span data-stu-id="eb8ee-162">*Microsoft Tools:*</span></span>

-   [<span data-ttu-id="eb8ee-163">Application Verifier</span><span class="sxs-lookup"><span data-stu-id="eb8ee-163">Application Verifier</span></span>](application-verifier.md)
-   [<span data-ttu-id="eb8ee-164">Outils de débogage pour Windows</span><span class="sxs-lookup"><span data-stu-id="eb8ee-164">Debugging Tools for Windows</span></span>](/windows-hardware/drivers/debugger/)
-   [<span data-ttu-id="eb8ee-165">Segment de mémoire de vidage en mode utilisateur</span><span class="sxs-lookup"><span data-stu-id="eb8ee-165">User-Mode Dump Heap</span></span>](/windows-hardware/drivers/debugger/umdh)
-   [<span data-ttu-id="eb8ee-166">Outil de capture, de traitement et d’analyse de trace</span><span class="sxs-lookup"><span data-stu-id="eb8ee-166">Trace Capture, Processing, and Analysis Tool</span></span>](https://msdn.microsoft.com/performance/cc825801.aspx)
-   [<span data-ttu-id="eb8ee-167">Tas de débogage CRT</span><span class="sxs-lookup"><span data-stu-id="eb8ee-167">CRT Debug Heap</span></span>](/visualstudio/debugger/crt-debug-heap-details?view=vs-2015)

<span data-ttu-id="eb8ee-168">*Liens supplémentaires :*</span><span class="sxs-lookup"><span data-stu-id="eb8ee-168">*Additional Links:*</span></span>

-   <span data-ttu-id="eb8ee-169">[**\_classe PTR automatique**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-169">[**auto\_ptr Class**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="eb8ee-170">[Classes de mémoire Active Template Library (ATL)](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-170">[Active Template Library (ATL) Memory Classes](https://msdn.microsoft.com/library/44yh1z4f(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="eb8ee-171">[**\_\_objet com PTR \_ t**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-171">[**\_com\_ptr\_t Object**](https://msdn.microsoft.com/library/417w8b3b(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="eb8ee-172">[**\_BSTR \_ t (classe)**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-172">[**\_bstr\_t Class**](https://msdn.microsoft.com/library/zthfhkd6(v=VS.71).aspx)</span></span>
-   <span data-ttu-id="eb8ee-173">[**\_\_classe YT variant**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-173">[**\_variant\_yt Class**](https://msdn.microsoft.com/library/x295h94e(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="eb8ee-174">« Suivi des fuites de mémoire gérées »</span><span class="sxs-lookup"><span data-stu-id="eb8ee-174">"Tracking down managed memory leaks"</span></span>](/archive/blogs/ricom/)
-   <span data-ttu-id="eb8ee-175">[« Comprendre et résoudre les modèles de fuites d’Internet Explorer »](/previous-versions/ms976398(v=msdn.10))</span><span class="sxs-lookup"><span data-stu-id="eb8ee-175">["Understanding and Solving Internet Explorer Leak Patterns"](/previous-versions/ms976398(v=msdn.10))</span></span>
-   [<span data-ttu-id="eb8ee-176">« Détecteur de fuites de mémoire JavaScript »</span><span class="sxs-lookup"><span data-stu-id="eb8ee-176">"JavaScript Memory Leak Detector"</span></span>](/archive/blogs/gpde/new-javascript-memory-leak-detector-from-our-team)
-   <span data-ttu-id="eb8ee-177">[Atténuation des fuites de mémoire circulaire (dans les navigateurs) :](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span><span class="sxs-lookup"><span data-stu-id="eb8ee-177">[Circular Memory Leak Mitigation (in browsers):](/previous-versions/windows/internet-explorer/ie-developer/platform-apis/dd361842(v=vs.85))</span></span>
-   <span data-ttu-id="eb8ee-178">[**try-finally, instruction**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span><span class="sxs-lookup"><span data-stu-id="eb8ee-178">[**try-finally statement**](https://msdn.microsoft.com/library/yb3kz605(v=VS.71).aspx)</span></span>
-   [<span data-ttu-id="eb8ee-179">**PROPVARIANT, structure**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-179">**PROPVARIANT Structure**</span></span>](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)
-   [<span data-ttu-id="eb8ee-180">**PropVariantClear fonction)**</span><span class="sxs-lookup"><span data-stu-id="eb8ee-180">**PropVariantClear Function**</span></span>](/windows/win32/api/combaseapi/nf-combaseapi-propvariantclear)

 

 
