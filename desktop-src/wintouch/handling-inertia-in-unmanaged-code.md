---
title: Gestion de l’inertie dans du code non managé
description: Cette section explique comment utiliser l’interface IInertiaProcessor pour gérer l’inertie dans du code non managé.
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:
- Tactile Windows, inertie
- Tactile Windows, processeur de manipulation
- inertie, code non managé
- inertie, interface IInertiaProcessor
- inertie, processeur de manipulation
- processeur de manipulation, inertie
- Interface IInertiaProcessor, code non managé
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3de56d06547f426de252a89ef5172df3fe4ca439
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104028693"
---
# <a name="handling-inertia-in-unmanaged-code"></a><span data-ttu-id="fbcb2-110">Gestion de l’inertie dans du code non managé</span><span class="sxs-lookup"><span data-stu-id="fbcb2-110">Handling Inertia in Unmanaged Code</span></span>

<span data-ttu-id="fbcb2-111">Cette section explique comment utiliser l’interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) pour gérer l’inertie dans du code non managé.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-111">This section explains how to use the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface for handling inertia in unmanaged code.</span></span>

## <a name="overview"></a><span data-ttu-id="fbcb2-112">Vue d’ensemble</span><span class="sxs-lookup"><span data-stu-id="fbcb2-112">Overview</span></span>

<span data-ttu-id="fbcb2-113">Pour utiliser l’inertie dans du code non managé, vous devez implémenter des récepteurs d’événements à la fois pour le processeur de manipulation et le processeur d’inertie.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-113">To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor.</span></span> <span data-ttu-id="fbcb2-114">Commencez par ajouter la prise en charge de manipulation à votre application, comme décrit dans la section Ajout de la [prise en charge de manipulation au code non managé](adding-manipulation-support-in-unmanaged-code.md).</span><span class="sxs-lookup"><span data-stu-id="fbcb2-114">Start by adding manipulation support to your application as described in the section [Adding Manipulation Support to Unmanaged Code](adding-manipulation-support-in-unmanaged-code.md).</span></span> <span data-ttu-id="fbcb2-115">Notez que la prise en charge de la manipulation nécessite que vous utilisiez des messages tactiles plutôt que des messages de geste pour alimenter les données d’événement vers le processeur de manipulation.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-115">Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor.</span></span> <span data-ttu-id="fbcb2-116">Une fois que vous avez manipulé le travail, vous devez également implémenter un deuxième récepteur d’événements pour les événements que l’interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) générera ou devra modifier votre récepteur d’événements existant pour prendre en charge les événements générés par les interfaces **IInertiaProcessor** et [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-116">After you have manipulation working, you must also implement a second event sink for the events that the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the **IInertiaProcessor** and the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) interfaces.</span></span> <span data-ttu-id="fbcb2-117">Dans le cadre de cet exemple, il est plus facile de démarrer à partir du récepteur d’événements créé pour la section qui ajoute la prise en charge de manipulation au code non managé et d’ajouter un second constructeur qui fonctionne avec le processeur d’inertie plutôt que le processeur de manipulation.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-117">For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor.</span></span> <span data-ttu-id="fbcb2-118">De cette façon, l’implémentation du récepteur d’événements peut fonctionner pour le processeur de manipulation ou le processeur d’inertie.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-118">This way, the event sink implementation can function for either the manipulation processor or the inertia processor.</span></span> <span data-ttu-id="fbcb2-119">Outre l’ajout d’un second constructeur, le récepteur d’événements aura une variable qui indique s’il effectuera les opérations en fonction de l’entrée d’inertie plutôt que de manipuler l’entrée.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-119">In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</span></span>

### <a name="add-inertia-support-to-a-manipulation-processor-event-sink"></a><span data-ttu-id="fbcb2-120">Ajouter la prise en charge de l’inertie à un récepteur d’événements de processeur de manipulation</span><span class="sxs-lookup"><span data-stu-id="fbcb2-120">Add Inertia Support to a Manipulation Processor Event Sink</span></span>

<span data-ttu-id="fbcb2-121">Le code suivant montre le nouveau constructeur de récepteur d’événements, les nouvelles variables membres pour une interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) et un indicateur qui spécifie si le récepteur est en extrapolation pour l’inertie.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-121">The following code shows the new event sink constructor, new member variables for an [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface, and a flag indicating whether the sink is extrapolating for inertia.</span></span>


```C++
    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
```




```C++
    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
```



<span data-ttu-id="fbcb2-122">Une fois que votre en-tête de classe a les nouveaux constructeurs et un indicateur spécifiant si vous utilisez l’extrapolation, vous pouvez implémenter votre récepteur d’événements pour avoir des blocs de gestion distincts pour les événements [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) et [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-122">After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) events and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) events.</span></span> <span data-ttu-id="fbcb2-123">Le constructeur qui accepte un **IManipulationProcessor** et un **IInertiaProcessor** doit définir l’indicateur **fExtrapolating** sur false, ce qui indique qu’il s’agit d’un gestionnaire d’événements **IManipulationProcessor** .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-123">The constructor that accepts an **IManipulationProcessor** and an **IInertiaProcessor** should set the **fExtrapolating** flag to false, which indicates that this is a **IManipulationProcessor** event handler.</span></span> <span data-ttu-id="fbcb2-124">Le code suivant montre comment le constructeur pour un récepteur d’événements qui utilise le **IManipulationProcessor** peut être implémenté.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-124">The following code shows how the constructor for an event sink that uses the **IManipulationProcessor** could be implemented.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip->put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}
```



<span data-ttu-id="fbcb2-125">Le code suivant montre comment le constructeur pour un récepteur d’événements qui utilise le [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) peut être implémenté.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-125">The following code shows how the constructor for an event sink that uses the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) could be implemented.</span></span> <span data-ttu-id="fbcb2-126">Ce constructeur affecte la valeur true à l’indicateur **fExtrapolating** , ce qui indique que cette instance de la classe de récepteur d’événements effectuera l’extrapolation et effectuera toutes les opérations de déplacement effectuées précédemment par les événements du processeur de manipulation.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-126">This constructor sets the **fExtrapolating** flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</span></span>


```C++
CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert->QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &spConnectionContainer
        );
    //hr = manip->QueryInterface(&spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer->FindConnectionPoint(__uuidof(_IManipulationEvents), &m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint->Advise(this, &dwCookie);
}   
```



> [!Note]  
> <span data-ttu-id="fbcb2-127">L’implémentation de la classe du récepteur d’événements à partir du récepteur d’événements du processeur de manipulation est réutilisée comme récepteur d’événements pour le processeur d’inertie.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-127">The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</span></span>

 

<span data-ttu-id="fbcb2-128">Maintenant, lorsque vous construisez cette classe, **CManipulationEventSink**, elle peut être construite en tant que récepteur d’événements pour un processeur de manipulation ou en tant que récepteur d’événements pour un processeur d’inertie.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-128">Now when you construct this class, **CManipulationEventSink**, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor.</span></span> <span data-ttu-id="fbcb2-129">Lorsqu’il est construit en tant que récepteur d’événements du processeur d’inertie, l’indicateur **fExtrapolating** est défini sur true, ce qui indique que les événements de manipulation doivent être extrapolés.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-129">When it's constructed as an inertia processor event sink, it will have the **fExtrapolating** flag set to true, indicating that manipulation events should be extrapolated.</span></span>

> [!Note]  
> <span data-ttu-id="fbcb2-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) sera déclenchée par les interfaces [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) et [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-130">[**ManipulationStarted**](/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted) will be raised by both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interfaces.</span></span>

 

<span data-ttu-id="fbcb2-131">Lorsque la manipulation démarre, les propriétés de l’interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) sont définies.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-131">When manipulation starts, the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface properties are set.</span></span> <span data-ttu-id="fbcb2-132">Le code suivant montre comment l’événement Started est géré.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-132">The following code shows how the started event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert->put_InitialOriginX(x);
    m_pInert->put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert->put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert->put_BoundaryLeft  ( static_cast<float>(screenRect.left   * 100));
    m_pInert->put_BoundaryTop   ( static_cast<float>(screenRect.top    * 100));
    m_pInert->put_BoundaryRight ( static_cast<float>(screenRect.right  * 100));
    m_pInert->put_BoundaryBottom( static_cast<float>(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert->put_ElasticMarginLeft  (static_cast<float>(screenRect.left   * 5));
    m_pInert->put_ElasticMarginTop   (static_cast<float>(screenRect.top    * 5));
    m_pInert->put_ElasticMarginRight (static_cast<float>(screenRect.right  * 95));
    m_pInert->put_ElasticMarginBottom(static_cast<float>(screenRect.bottom * 95));
    
    
    return S_OK;
}
```



<span data-ttu-id="fbcb2-133">Dans cet exemple, les deltas de manipulation sont utilisés pour déplacer la fenêtre.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-133">In this example, manipulation deltas are used to move the window around.</span></span> <span data-ttu-id="fbcb2-134">Le code suivant montre comment l’événement Delta est géré.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-134">The following code shows how the delta event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast<int>(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast<int>(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast<int>(oldWidth * scaleDelta),                    // width
        static_cast<int>(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
```



<span data-ttu-id="fbcb2-135">Dans cet exemple, la manipulation des événements terminés démarre ou arrête un minuteur qui appellera le [**processus**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) sur l’interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-135">In this example, manipulation completed events either start or stop a timer that will call [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span> <span data-ttu-id="fbcb2-136">Le code suivant montre comment l’événement de manipulation terminée est géré.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-136">The following code shows how the completed manipulation event is handled.</span></span>


```C++
HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip->GetVelocityX(&vX);
        m_pManip->GetVelocityY(&vY);
        m_pManip->GetAngularVelocity(&vA);

        // complete any previous processing
        m_pInert->Complete();
        
        // Reset sets the  initial timestamp
        m_pInert->Reset();
                
        // 
        m_pInert->put_InitialVelocityX(vX);
        m_pInert->put_InitialVelocityY(vY);        
        
        m_pInert->put_InitialOriginX(x);
        m_pInert->put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
```



<span data-ttu-id="fbcb2-137">Le code suivant montre comment vous pouvez interpréter les messages **\_ du minuteur WM** dans **WndProc** pour effectuer des appels au [**processus**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) sur l’interface [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) .</span><span class="sxs-lookup"><span data-stu-id="fbcb2-137">The following code shows how you could interpret **WM\_TIMER** messages in **WndProc** to perform calls to [**Process**](/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process) on the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor) interface.</span></span>


```C++
case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc->Process(&b);        
  }
  break;
```



### <a name="coinitialize-the-inertia-processor-and-manipulation-processor-and-initialize-the-event-sinks"></a><span data-ttu-id="fbcb2-138">Coinitialisez le processeur d’inertie et le processeur de manipulation et initialisez les récepteurs d’événements.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-138">CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</span></span>

<span data-ttu-id="fbcb2-139">Après avoir modifié le récepteur d’événements pour qu’il prenne en charge à la fois [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) et [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), vous êtes prêt à initialiser les récepteurs d’événements et à les configurer pour qu’ils s’exécutent à partir de votre application.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-139">After you have your event sink modified to support both the [**IManipulationProcessor**](/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor) and the [**IInertiaProcessor**](/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor), you are ready to initialize the event sinks and set them up to run from your application.</span></span> <span data-ttu-id="fbcb2-140">Le code suivant montre comment les pointeurs d’interface sont alloués.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-140">The following code shows how the interface pointers are allocated.</span></span>


```C++
//Include windows.h for touch events
#include "windows.h"  

// Manipulation implementation file
#include <manipulations_i.c>
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
```



<span data-ttu-id="fbcb2-141">L’exemple de code suivant montre comment instancier vos interfaces.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-141">The following code example shows how to instantiate your interfaces.</span></span>


```C++
   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&g_pIInertProc)
   );
```



<span data-ttu-id="fbcb2-142">L’exemple de code suivant montre comment construire vos récepteurs d’événements en fonction des pointeurs d’interface et enregistrer la fenêtre pour l’entrée tactile.</span><span class="sxs-lookup"><span data-stu-id="fbcb2-142">The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</span></span>


```C++
   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
```



## <a name="related-topics"></a><span data-ttu-id="fbcb2-143">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="fbcb2-143">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fbcb2-144">Inertie</span><span class="sxs-lookup"><span data-stu-id="fbcb2-144">Inertia</span></span>](getting-started-with-inertia.md)
</dt> </dl>

 

 




