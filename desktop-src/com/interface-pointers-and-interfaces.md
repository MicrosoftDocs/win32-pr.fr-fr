---
title: Pointeurs d’interface et interfaces
description: Pointeurs d’interface et interfaces
ms.assetid: 8a8671fe-f0b2-4698-8c98-89753fffce0b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aa23d53f529c43fa7529d657108cc75cb6a23b15
ms.sourcegitcommit: d482e4276cc06515e9fade2f253a257ffc418ce5
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/24/2019
ms.locfileid: "106512630"
---
# <a name="interface-pointers-and-interfaces"></a><span data-ttu-id="ae72c-103">Pointeurs d’interface et interfaces</span><span class="sxs-lookup"><span data-stu-id="ae72c-103">Interface Pointers and Interfaces</span></span>

<span data-ttu-id="ae72c-104">Une instance d’une implémentation d’interface est en fait un pointeur vers un tableau de pointeurs vers des méthodes, autrement dit une table de fonctions qui fait référence à une implémentation de toutes les méthodes spécifiées dans l’interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-104">An instance of an interface implementation is actually a pointer to an array of pointers to methods - that is, a function table that refers to an implementation of all of the methods specified in the interface.</span></span> <span data-ttu-id="ae72c-105">Les objets avec plusieurs interfaces peuvent fournir des pointeurs vers plusieurs tables de fonctions.</span><span class="sxs-lookup"><span data-stu-id="ae72c-105">Objects with multiple interfaces can provide pointers to more than one function table.</span></span> <span data-ttu-id="ae72c-106">Tout code qui a un pointeur via lequel il peut accéder au tableau peut appeler les méthodes dans cette interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-106">Any code that has a pointer through which it can access the array can call the methods in that interface.</span></span>

<span data-ttu-id="ae72c-107">Parler précisément de cette indirection multiple est peu pratique. par conséquent, le pointeur vers la table de fonctions d’interface qu’un autre objet doit avoir pour appeler ses méthodes est appelé simplement un *pointeur d’interface*.</span><span class="sxs-lookup"><span data-stu-id="ae72c-107">Speaking precisely about this multiple indirection is inconvenient, so instead, the pointer to the interface function table that another object must have to call its methods is called simply an *interface pointer*.</span></span> <span data-ttu-id="ae72c-108">Vous pouvez créer manuellement des tables de fonctions dans une application C ou presque automatiquement à l’aide de Visual C++ (ou d’autres langages orientés objet qui prennent en charge COM).</span><span class="sxs-lookup"><span data-stu-id="ae72c-108">You can manually create function tables in a C application or almost automatically by using Visual C++ (or other object-oriented languages that support COM).</span></span>

<span data-ttu-id="ae72c-109">Avec la prise en charge de compilateur appropriée (qui est inhérente à C et C++), un client peut appeler une méthode d’interface par son nom, et non pas sa position dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="ae72c-109">With appropriate compiler support (which is inherent in C and C++), a client can call an interface method through its name, not its position in the array.</span></span> <span data-ttu-id="ae72c-110">Étant donné qu’une interface est un type, le compilateur, en fonction des noms de méthodes, peut vérifier les types de paramètres et les valeurs de retour de chaque appel de méthode d’interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-110">Because an interface is a type, the compiler, given the names of methods, can check the types of parameters and return values of each interface method call.</span></span> <span data-ttu-id="ae72c-111">En revanche, si un client utilise un schéma d’appel basé sur la position, cette vérification de type n’est pas disponible, même en C ou C++.</span><span class="sxs-lookup"><span data-stu-id="ae72c-111">In contrast, if a client uses a position-based calling scheme, such type-checking is not available, even in C or C++.</span></span>

<span data-ttu-id="ae72c-112">Chaque interface est un contrat immuable d’un groupe fonctionnel de méthodes.</span><span class="sxs-lookup"><span data-stu-id="ae72c-112">Each interface is an immutable contract of a functional group of methods.</span></span> <span data-ttu-id="ae72c-113">Vous référencez une interface au moment de l’exécution avec un identificateur d’interface global unique (IID).</span><span class="sxs-lookup"><span data-stu-id="ae72c-113">You reference an interface at run time with a globally unique interface identifier (IID).</span></span> <span data-ttu-id="ae72c-114">Cet IID, qui est une instance spécifique d’un identificateur global unique (GUID) pris en charge par COM, permet à un client de demander précisément à un objet s’il prend en charge la sémantique de l’interface, sans surcharge inutile, et sans la confusion qui peut se produire dans un système en présence de plusieurs versions de la même interface avec le même nom.</span><span class="sxs-lookup"><span data-stu-id="ae72c-114">This IID, which is a specific instance of a globally unique identifier (GUID) supported by COM, allows a client to ask an object precisely whether it supports the semantics of the interface, without unnecessary overhead and without the confusion that could arise in a system from having multiple versions of the same interface with the same name.</span></span>

<span data-ttu-id="ae72c-115">Pour résumer, il est important de comprendre ce qu’est une interface COM et n’est pas :</span><span class="sxs-lookup"><span data-stu-id="ae72c-115">To summarize, it is important to understand what a COM interface is, and is not:</span></span>

-   <span data-ttu-id="ae72c-116">Une interface COM n’est pas la même chose qu’une classe C++.</span><span class="sxs-lookup"><span data-stu-id="ae72c-116">A COM interface is not the same as a C++ class.</span></span> <span data-ttu-id="ae72c-117">La définition virtuelle pure ne comporte aucune implémentation.</span><span class="sxs-lookup"><span data-stu-id="ae72c-117">The pure virtual definition carries no implementation.</span></span> <span data-ttu-id="ae72c-118">Si vous êtes un programmeur C++, vous pouvez définir l’implémentation d’une interface en tant que classe, mais cela se trouve sous l’en-tête des détails d’implémentation, que COM ne spécifie pas.</span><span class="sxs-lookup"><span data-stu-id="ae72c-118">If you are a C++ programmer, you can define your implementation of an interface as a class, but this falls under the heading of implementation details, which COM does not specify.</span></span> <span data-ttu-id="ae72c-119">Une instance d’un objet qui implémente une interface doit être créée pour que l’interface existe réellement.</span><span class="sxs-lookup"><span data-stu-id="ae72c-119">An instance of an object that implements an interface must be created for the interface actually to exist.</span></span> <span data-ttu-id="ae72c-120">En outre, différentes classes d’objets peuvent implémenter une interface de manière différente, mais elles peuvent être utilisées de manière interchangeable sous forme binaire, à condition que le comportement soit conforme à la définition de l’interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-120">Furthermore, different object classes may implement an interface differently yet be used interchangeably in binary form, as long as the behavior conforms to the interface definition.</span></span>
-   <span data-ttu-id="ae72c-121">Une interface COM n’est pas un objet.</span><span class="sxs-lookup"><span data-stu-id="ae72c-121">A COM interface is not an object.</span></span> <span data-ttu-id="ae72c-122">Il s’agit simplement d’un groupe de fonctions associé et est la norme binaire par laquelle les clients et les objets communiquent.</span><span class="sxs-lookup"><span data-stu-id="ae72c-122">It is simply a related group of functions and is the binary standard through which clients and objects communicate.</span></span> <span data-ttu-id="ae72c-123">Tant qu’il peut fournir des pointeurs vers des méthodes d’interface, l’objet peut être implémenté dans n’importe quel langage avec une représentation d’état interne.</span><span class="sxs-lookup"><span data-stu-id="ae72c-123">As long as it can provide pointers to interface methods, the object can be implemented in any language with any internal state representation.</span></span>
-   <span data-ttu-id="ae72c-124">Les interfaces COM sont fortement typées.</span><span class="sxs-lookup"><span data-stu-id="ae72c-124">COM interfaces are strongly typed.</span></span> <span data-ttu-id="ae72c-125">Chaque interface a son propre identificateur d’interface (GUID), ce qui élimine le risque de duplication qui peut se produire avec n’importe quel autre schéma d’attribution de noms.</span><span class="sxs-lookup"><span data-stu-id="ae72c-125">Every interface has its own interface identifier (a GUID), which eliminates the possibility of duplication that could occur with any other naming scheme.</span></span>
-   <span data-ttu-id="ae72c-126">Les interfaces COM sont immuables.</span><span class="sxs-lookup"><span data-stu-id="ae72c-126">COM interfaces are immutable.</span></span> <span data-ttu-id="ae72c-127">Vous ne pouvez pas définir une nouvelle version d’une ancienne interface et lui attribuer le même identificateur.</span><span class="sxs-lookup"><span data-stu-id="ae72c-127">You cannot define a new version of an old interface and give it the same identifier.</span></span> <span data-ttu-id="ae72c-128">L’ajout ou la suppression de méthodes d’une interface ou la modification d’une sémantique crée une nouvelle interface, et non une nouvelle version d’une ancienne interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-128">Adding or removing methods of an interface or changing semantics creates a new interface, not a new version of an old interface.</span></span> <span data-ttu-id="ae72c-129">Par conséquent, une nouvelle interface ne peut pas entrer en conflit avec une ancienne interface.</span><span class="sxs-lookup"><span data-stu-id="ae72c-129">Therefore, a new interface cannot conflict with an old interface.</span></span> <span data-ttu-id="ae72c-130">Toutefois, les objets peuvent prendre en charge plusieurs interfaces simultanément et peuvent exposer des interfaces qui sont des révisions consécutives d’une interface, avec des identificateurs différents.</span><span class="sxs-lookup"><span data-stu-id="ae72c-130">However, objects can support multiple interfaces simultaneously and can expose interfaces that are successive revisions of an interface, with different identifiers.</span></span> <span data-ttu-id="ae72c-131">Ainsi, chaque interface est un contrat distinct, et les objets du système ne doivent pas se préoccuper de savoir si la version de l’interface qu’elle appelle est celle qu’elle attend.</span><span class="sxs-lookup"><span data-stu-id="ae72c-131">Thus, each interface is a separate contract, and systemwide objects need not be concerned about whether the version of the interface they are calling is the one they expect.</span></span> <span data-ttu-id="ae72c-132">L’ID d’interface (IID) définit le contrat d’interface de manière explicite et unique.</span><span class="sxs-lookup"><span data-stu-id="ae72c-132">The interface ID (IID) defines the interface contract explicitly and uniquely.</span></span>

## <a name="related-topics"></a><span data-ttu-id="ae72c-133">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="ae72c-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="ae72c-134">Objets et interfaces COM</span><span class="sxs-lookup"><span data-stu-id="ae72c-134">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




