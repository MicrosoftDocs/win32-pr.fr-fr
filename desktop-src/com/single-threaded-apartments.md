---
title: Single-Threaded Apartments
description: Single-Threaded Apartments
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382936"
---
# <a name="single-threaded-apartments"></a><span data-ttu-id="a1233-103">Single-Threaded Apartments</span><span class="sxs-lookup"><span data-stu-id="a1233-103">Single-Threaded Apartments</span></span>

<span data-ttu-id="a1233-104">L’utilisation de cloisonnements à thread unique (le processus de modèle Apartment) offre un paradigme basé sur les messages pour gérer plusieurs objets exécutés simultanément.</span><span class="sxs-lookup"><span data-stu-id="a1233-104">Using single-threaded apartments (the apartment model process) offers a message-based paradigm for dealing with multiple objects running concurrently.</span></span> <span data-ttu-id="a1233-105">Elle vous permet d’écrire du code plus efficace en autorisant un thread, pendant qu’il attend la fin d’une opération longue, afin d’autoriser l’exécution d’un autre thread.</span><span class="sxs-lookup"><span data-stu-id="a1233-105">It enables you to write more efficient code by allowing a thread, while it waits for some time-consuming operation to complete, to allow another thread to be executed.</span></span>

<span data-ttu-id="a1233-106">Chaque thread dans un processus qui est initialisé comme un processus de modèle cloisonné, et qui récupère et distribue des messages de fenêtre, est un thread cloisonné à thread unique.</span><span class="sxs-lookup"><span data-stu-id="a1233-106">Each thread in a process that is initialized as an apartment model process, and that retrieves and dispatches window messages, is a single-threaded apartment thread.</span></span> <span data-ttu-id="a1233-107">Chaque thread vit dans son propre cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="a1233-107">Each thread lives within its own apartment.</span></span> <span data-ttu-id="a1233-108">Dans un cloisonnement, les pointeurs d’interface peuvent être passés sans marshaling et, par conséquent, tous les objets d’un thread cloisonné de thread unique communiquent directement.</span><span class="sxs-lookup"><span data-stu-id="a1233-108">Within an apartment, interface pointers can be passed without marshaling, and therefore, all objects in one single-threaded apartment thread communicate directly.</span></span>

<span data-ttu-id="a1233-109">Regroupement logique d’objets connexes qui s’exécutent tous sur le même thread et qui, par conséquent, doivent avoir une exécution synchrone, peuvent résider sur le même thread cloisonné de thread unique.</span><span class="sxs-lookup"><span data-stu-id="a1233-109">A logical grouping of related objects that all execute on the same thread, and therefore must have synchronous execution, could live on the same single-threaded apartment thread.</span></span> <span data-ttu-id="a1233-110">Toutefois, un objet de modèle Apartment ne peut pas résider sur plus d’un thread.</span><span class="sxs-lookup"><span data-stu-id="a1233-110">However, an apartment model object cannot reside on more than one thread.</span></span> <span data-ttu-id="a1233-111">Les appels aux objets d’autres threads doivent être effectués dans le contexte du thread propriétaire. par conséquent, le modèle COM distribué passe automatiquement les threads pour vous lorsque vous appelez sur un proxy.</span><span class="sxs-lookup"><span data-stu-id="a1233-111">Calls to objects in other threads must be made within the context of the owning thread, so distributed COM switches threads for you automatically when you call on a proxy.</span></span>

<span data-ttu-id="a1233-112">Les modèles interprocessus et interthreads sont similaires.</span><span class="sxs-lookup"><span data-stu-id="a1233-112">The interprocess and interthread models are similar.</span></span> <span data-ttu-id="a1233-113">Lorsqu’il est nécessaire de passer un pointeur d’interface à un objet dans un autre cloisonnement (sur un autre thread) au sein du même processus, vous utilisez le même modèle de marshaling que celui utilisé par les objets de différents processus pour passer des pointeurs au-delà des limites du processus.</span><span class="sxs-lookup"><span data-stu-id="a1233-113">When it is necessary to pass an interface pointer to an object in another apartment (on another thread) within the same process, you use the same marshaling model that objects in different processes use to pass pointers across process boundaries.</span></span> <span data-ttu-id="a1233-114">En obtenant un pointeur vers l’objet de marshaling standard, vous pouvez marshaler des pointeurs d’interface à travers les limites de thread (entre les cloisonnements) de la même façon que vous le feriez entre les processus.</span><span class="sxs-lookup"><span data-stu-id="a1233-114">By getting a pointer to the standard marshaling object, you can marshal interface pointers across thread boundaries (between apartments) in the same way you do between processes.</span></span> <span data-ttu-id="a1233-115">(Les pointeurs d’interface doivent être marshalés lorsqu’ils sont transmis entre les cloisonnements.)</span><span class="sxs-lookup"><span data-stu-id="a1233-115">(Interface pointers must be marshaled when passed between apartments.)</span></span>

<span data-ttu-id="a1233-116">Les règles pour les cloisonnements à thread unique sont simples, mais il est important de les suivre avec soin :</span><span class="sxs-lookup"><span data-stu-id="a1233-116">Rules for single-threaded apartments are simple, but it is important to follow them carefully:</span></span>

-   <span data-ttu-id="a1233-117">Chaque objet doit résider sur un seul thread (dans un thread unique cloisonné).</span><span class="sxs-lookup"><span data-stu-id="a1233-117">Every object should live on only one thread (within a single-threaded apartment).</span></span>
-   <span data-ttu-id="a1233-118">Initialisez la bibliothèque COM pour chaque thread.</span><span class="sxs-lookup"><span data-stu-id="a1233-118">Initialize the COM library for each thread.</span></span>
-   <span data-ttu-id="a1233-119">Marshaler tous les pointeurs vers des objets lors de leur passage entre des cloisonnements.</span><span class="sxs-lookup"><span data-stu-id="a1233-119">Marshal all pointers to objects when passing them between apartments.</span></span>
-   <span data-ttu-id="a1233-120">Chaque cloisonnement à thread unique doit avoir une boucle de message pour gérer les appels d’autres processus et des appartements au sein du même processus.</span><span class="sxs-lookup"><span data-stu-id="a1233-120">Each single-threaded apartment must have a message loop to handle calls from other processes and apartments within the same process.</span></span> <span data-ttu-id="a1233-121">Les Apartments à thread unique sans objets (client uniquement) ont également besoin d’une boucle de message pour distribuer les messages de diffusion utilisés par certaines applications.</span><span class="sxs-lookup"><span data-stu-id="a1233-121">Single-threaded apartments without objects (client only) also need a message loop to dispatch the broadcast messages that some applications use.</span></span>
-   <span data-ttu-id="a1233-122">Les objets basés sur des DLL ou in-process n’appellent pas les fonctions d’initialisation COM. au lieu de cela, ils inscrivent leur modèle de thread avec la valeur nommée **ThreadingModel** sous la clé [InprocServer32](inprocserver32.md) dans le registre.</span><span class="sxs-lookup"><span data-stu-id="a1233-122">DLL-based or in-process objects do not call the COM initialization functions; instead, they register their threading model with the **ThreadingModel** named-value under the [InprocServer32](inprocserver32.md) key in the registry.</span></span> <span data-ttu-id="a1233-123">Les objets reconnaissants au cloisonnement doivent également écrire des points d’entrée de DLL avec soin.</span><span class="sxs-lookup"><span data-stu-id="a1233-123">Apartment-aware objects must also write DLL entry points carefully.</span></span> <span data-ttu-id="a1233-124">Des considérations spéciales s’appliquent aux serveurs de thread dans les processus.</span><span class="sxs-lookup"><span data-stu-id="a1233-124">There are special considerations that apply to threading in-process servers.</span></span> <span data-ttu-id="a1233-125">Pour plus d’informations, consultez [problèmes de Threading du serveur in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="a1233-125">For more information, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="a1233-126">Si plusieurs objets peuvent résider sur un seul thread, aucun objet de modèle Apartment ne peut résider sur plus d’un thread.</span><span class="sxs-lookup"><span data-stu-id="a1233-126">While multiple objects can live on a single thread, no apartment model object can live on more than one thread.</span></span>

<span data-ttu-id="a1233-127">Chaque thread d’un processus client ou d’un serveur hors processus doit appeler [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), ou appeler [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) et spécifier coinit \_ APARTMENTTHREADED pour le paramètre *dwCoInit* .</span><span class="sxs-lookup"><span data-stu-id="a1233-127">Each thread of a client process or out-of-process server must call [**CoInitialize**](/windows/desktop/api/Objbase/nf-objbase-coinitialize), or call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) and specify COINIT\_APARTMENTTHREADED for the *dwCoInit* parameter.</span></span> <span data-ttu-id="a1233-128">Le cloisonnement principal est le thread qui appelle **CoInitializeEx** en premier.</span><span class="sxs-lookup"><span data-stu-id="a1233-128">The main apartment is the thread that calls **CoInitializeEx** first.</span></span> <span data-ttu-id="a1233-129">Pour plus d’informations sur les serveurs in-process, consultez [problèmes de Threading du serveur in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="a1233-129">For information on in-process servers, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="a1233-130">Tous les appels à un objet doivent être effectués sur son thread (dans son cloisonnement).</span><span class="sxs-lookup"><span data-stu-id="a1233-130">All calls to an object must be made on its thread (within its apartment).</span></span> <span data-ttu-id="a1233-131">Il est interdit d’appeler directement un objet à partir d’un autre thread. l’utilisation d’objets de cette manière libre de threads peut entraîner des problèmes pour les applications.</span><span class="sxs-lookup"><span data-stu-id="a1233-131">It is forbidden to call an object directly from another thread; using objects in this free-threaded manner could cause problems for applications.</span></span> <span data-ttu-id="a1233-132">L’implication de cette règle est que tous les pointeurs vers des objets doivent être marshalés lorsqu’ils sont transmis entre les cloisonnements.</span><span class="sxs-lookup"><span data-stu-id="a1233-132">The implication of this rule is that all pointers to objects must be marshaled when passed between apartments.</span></span> <span data-ttu-id="a1233-133">COM fournit les deux fonctions suivantes à cet effet :</span><span class="sxs-lookup"><span data-stu-id="a1233-133">COM provides the following two functions for this purpose:</span></span>

-   <span data-ttu-id="a1233-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshale une interface dans un objet de flux qui est retourné à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="a1233-134">[**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) marshals an interface into a stream object that is returned to the caller.</span></span>
-   <span data-ttu-id="a1233-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) démarshale un pointeur d’interface à partir d’un objet de flux et le libère.</span><span class="sxs-lookup"><span data-stu-id="a1233-135">[**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) unmarshals an interface pointer from a stream object and releases it.</span></span>

<span data-ttu-id="a1233-136">Ces fonctions encapsulent les appels aux fonctions [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) et [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , qui requièrent l’utilisation de l' \_ indicateur InProc MSHCTX.</span><span class="sxs-lookup"><span data-stu-id="a1233-136">These functions wrap calls to [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) and [**CoUnmarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) functions, which require the use of the MSHCTX\_INPROC flag.</span></span>

<span data-ttu-id="a1233-137">En général, le marshaling est effectué automatiquement par COM.</span><span class="sxs-lookup"><span data-stu-id="a1233-137">In general, the marshaling is accomplished automatically by COM.</span></span> <span data-ttu-id="a1233-138">Par exemple, lors du passage d’un pointeur d’interface en tant que paramètre dans un appel de méthode sur un proxy à un objet d’un autre cloisonnement, ou lors de l’appel de [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com effectue le marshaling automatiquement.</span><span class="sxs-lookup"><span data-stu-id="a1233-138">For example, when passing an interface pointer as a parameter in a method call on a proxy to an object in another apartment, or when calling [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), COM does the marshaling automatically.</span></span> <span data-ttu-id="a1233-139">Toutefois, dans certains cas spéciaux, où l’enregistreur d’application passe des pointeurs d’interface entre les cloisonnements sans utiliser les mécanismes COM normaux, le writer doit gérer le marshaling manuellement.</span><span class="sxs-lookup"><span data-stu-id="a1233-139">However, in some special cases, where the application writer is passing interface pointers between apartments without using the normal COM mechanisms, the writer must handle the marshaling manually.</span></span>

<span data-ttu-id="a1233-140">Si un cloisonnement (Apartment 1) dans un processus a un pointeur d’interface et qu’un autre cloisonnement (Apartment 2) requiert son utilisation, Apartment 1 doit appeler [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) pour marshaler l’interface.</span><span class="sxs-lookup"><span data-stu-id="a1233-140">If one apartment (Apartment 1) in a process has an interface pointer and another apartment (Apartment 2) requires its use, Apartment 1 must call [**CoMarshalInterThreadInterfaceInStream**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) to marshal the interface.</span></span> <span data-ttu-id="a1233-141">Le flux créé par cette fonction est thread-safe et doit être stocké dans une variable qui est accessible par Apartment 2.</span><span class="sxs-lookup"><span data-stu-id="a1233-141">The stream that is created by this function is thread-safe and must be stored in a variable that is accessible by Apartment 2.</span></span> <span data-ttu-id="a1233-142">Apartment 2 doit passer ce flux à [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) pour démarshaler l’interface et récupérer un pointeur vers un proxy via lequel il peut accéder à l’interface.</span><span class="sxs-lookup"><span data-stu-id="a1233-142">Apartment 2 must pass this stream to [**CoGetInterfaceAndReleaseStream**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) to unmarshal the interface and will get back a pointer to a proxy through which it can access the interface.</span></span> <span data-ttu-id="a1233-143">Le cloisonnement principal doit rester actif jusqu’à ce que le client ait terminé tout le travail COM (car certains objets in-process sont chargés dans le cloisonnement principal, comme décrit dans les [problèmes de Threading du serveur in-process](in-process-server-threading-issues.md)).</span><span class="sxs-lookup"><span data-stu-id="a1233-143">The main apartment must remain alive until the client has completed all COM work (because some in-process objects are loaded in the main apartment, as described in [In-Process Server Threading Issues](in-process-server-threading-issues.md)).</span></span> <span data-ttu-id="a1233-144">Une fois qu’un objet a été passé entre les threads de cette manière, il est très facile de passer des pointeurs d’interface en tant que paramètres.</span><span class="sxs-lookup"><span data-stu-id="a1233-144">After one object has been passed between threads in this manner, it is very easy to pass interface pointers as parameters.</span></span> <span data-ttu-id="a1233-145">De cette façon, COM distribué effectue le marshaling et le basculement de threads pour l’application.</span><span class="sxs-lookup"><span data-stu-id="a1233-145">That way, distributed COM does the marshaling and thread switching for the application.</span></span>

<span data-ttu-id="a1233-146">Pour gérer les appels d’autres processus et cloisonnés au sein d’un même processus, chaque cloisonnement à thread unique doit avoir une boucle de message.</span><span class="sxs-lookup"><span data-stu-id="a1233-146">To handle calls from other processes and apartments within the same process, each single-threaded apartment must have a message loop.</span></span> <span data-ttu-id="a1233-147">Cela signifie que la fonction de travail du thread doit avoir une boucle GetMessage/DispatchMessage.</span><span class="sxs-lookup"><span data-stu-id="a1233-147">This means that the thread's work function must have a GetMessage/DispatchMessage loop.</span></span> <span data-ttu-id="a1233-148">Si d’autres primitives de synchronisation sont utilisées pour la communication entre les threads, la fonction [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) peut être utilisée pour attendre les messages et pour les événements de synchronisation de threads.</span><span class="sxs-lookup"><span data-stu-id="a1233-148">If other synchronization primitives are being used to communicate between threads, the [**MsgWaitForMultipleObjects**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) function can be used to wait both for messages and for thread synchronization events.</span></span> <span data-ttu-id="a1233-149">La documentation de cette fonction a un exemple de ce type de boucle de combinaison.</span><span class="sxs-lookup"><span data-stu-id="a1233-149">The documentation for this function has an example of this sort of combination loop.</span></span>

<span data-ttu-id="a1233-150">COM crée une fenêtre masquée à l’aide de la classe Windows « OleMainThreadWndClass » dans chaque cloisonnement à thread unique.</span><span class="sxs-lookup"><span data-stu-id="a1233-150">COM creates a hidden window using the Windows class "OleMainThreadWndClass" in each single-threaded apartment.</span></span> <span data-ttu-id="a1233-151">Un appel à un objet est reçu en tant que message de fenêtre dans cette fenêtre masquée.</span><span class="sxs-lookup"><span data-stu-id="a1233-151">A call to an object is received as a window message to this hidden window.</span></span> <span data-ttu-id="a1233-152">Lorsque l’appartement de l’objet récupère et distribue le message, la fenêtre masquée la reçoit.</span><span class="sxs-lookup"><span data-stu-id="a1233-152">When the object's apartment retrieves and dispatches the message, the hidden window will receive it.</span></span> <span data-ttu-id="a1233-153">La procédure de fenêtre appellera ensuite la méthode d’interface correspondante de l’objet.</span><span class="sxs-lookup"><span data-stu-id="a1233-153">The window procedure will then call the corresponding interface method of the object.</span></span>

<span data-ttu-id="a1233-154">Lorsque plusieurs clients appellent un objet, les appels sont mis en file d’attente dans la file d’attente de messages et l’objet reçoit un appel chaque fois que son cloisonnement récupère et distribue des messages.</span><span class="sxs-lookup"><span data-stu-id="a1233-154">When multiple clients call an object, the calls are queued in the message queue and the object will receive a call each time its apartment retrieves and dispatches messages.</span></span> <span data-ttu-id="a1233-155">Étant donné que les appels sont synchronisés par COM et que les appels sont toujours remis par le thread qui appartient au cloisonnement de l’objet, les implémentations d’interface de l’objet n’ont pas besoin de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="a1233-155">Because the calls are synchronized by COM and the calls are always delivered by the thread that belongs to the object's apartment, the object's interface implementations need not provide synchronization.</span></span> <span data-ttu-id="a1233-156">Les Apartments à thread unique peuvent implémenter [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) pour leur permettre d’annuler des appels ou de recevoir des messages de fenêtre si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="a1233-156">Single-threaded apartments can implement [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) to permit them to cancel calls or receive window messages when necessary.</span></span>

<span data-ttu-id="a1233-157">L’objet peut être réentré si l’une de ses implémentations de méthode d’interface récupère et distribue des messages ou effectue un appel ORPC à un autre thread, provoquant ainsi la remise d’un autre appel à l’objet (par le même cloisonnement).</span><span class="sxs-lookup"><span data-stu-id="a1233-157">The object can be reentered if one of its interface method implementations retrieves and dispatches messages or makes an ORPC call to another thread, thereby causing another call to be delivered to the object (by the same apartment).</span></span> <span data-ttu-id="a1233-158">OLE n’empêche pas la réentrance sur le même thread, mais il peut aider à assurer la sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="a1233-158">OLE does not prevent reentrancy on the same thread, but it can help provide thread safety.</span></span> <span data-ttu-id="a1233-159">Cela est identique à la façon dont une procédure de fenêtre peut être réentrée si elle récupère et distribue des messages lors du traitement d’un message.</span><span class="sxs-lookup"><span data-stu-id="a1233-159">This is identical to the way in which a window procedure can be reentered if it retrieves and dispatches messages while processing a message.</span></span> <span data-ttu-id="a1233-160">Toutefois, l’appel d’un serveur cloisonné à thread unique hors processus qui appelle un autre serveur à thread unique cloisonné permet de réentrer le premier serveur.</span><span class="sxs-lookup"><span data-stu-id="a1233-160">However, calling an out-of-process single-threaded apartment server that calls another single-threaded apartment server will allow the first server to be reentered.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a1233-161">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="a1233-161">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a1233-162">Accès aux interfaces à travers les Apartments</span><span class="sxs-lookup"><span data-stu-id="a1233-162">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="a1233-163">Choix du modèle de thread</span><span class="sxs-lookup"><span data-stu-id="a1233-163">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="a1233-164">Apartments (cloisonnés) multithread</span><span class="sxs-lookup"><span data-stu-id="a1233-164">Multithreaded Apartments</span></span>](multithreaded-apartments.md)
</dt> <dt>

[<span data-ttu-id="a1233-165">Problèmes liés aux threads du serveur in-process</span><span class="sxs-lookup"><span data-stu-id="a1233-165">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="a1233-166">Processus, threads et Apartments</span><span class="sxs-lookup"><span data-stu-id="a1233-166">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="a1233-167">Communication monothread et multithread</span><span class="sxs-lookup"><span data-stu-id="a1233-167">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 