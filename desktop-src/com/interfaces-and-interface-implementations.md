---
title: Interfaces et implémentations d’interface
description: COM fait une distinction fondamentale entre les définitions d’interface et leurs implémentations.
ms.assetid: f50b3e8f-bf87-4525-b47b-96e75b3a05b9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: db8df92ac8b851925d82a4b03505fa4c5ab3dc39
ms.sourcegitcommit: 80d74c0bf4fc402865a1ad223480abe1ce4d1115
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/12/2020
ms.locfileid: "104030909"
---
# <a name="interfaces-and-interface-implementations"></a><span data-ttu-id="55020-103">Interfaces et implémentations d’interface</span><span class="sxs-lookup"><span data-stu-id="55020-103">Interfaces and Interface Implementations</span></span>

<span data-ttu-id="55020-104">COM fait une distinction fondamentale entre les définitions d’interface et leurs implémentations.</span><span class="sxs-lookup"><span data-stu-id="55020-104">COM makes a fundamental distinction between interface definitions and their implementations.</span></span>

<span data-ttu-id="55020-105">Une *interface* est en fait un contrat qui se compose d’un groupe de prototypes de fonction associés dont l’utilisation est définie mais dont l’implémentation n’est pas.</span><span class="sxs-lookup"><span data-stu-id="55020-105">An *interface* is actually a contract that consists of a group of related function prototypes whose usage is defined but whose implementation is not.</span></span> <span data-ttu-id="55020-106">Ces prototypes de fonction sont équivalents à des classes de base virtuelles pures en programmation C++.</span><span class="sxs-lookup"><span data-stu-id="55020-106">These function prototypes are equivalent to pure virtual base classes in C++ programming.</span></span> <span data-ttu-id="55020-107">Une définition d’interface spécifie les fonctions membres de l’interface, appelées *méthodes*, leurs types de retour, le nombre et les types de leurs paramètres, et ce qu’ils doivent faire.</span><span class="sxs-lookup"><span data-stu-id="55020-107">An interface definition specifies the interface's member functions, called *methods*, their return types, the number and types of their parameters, and what they must do.</span></span> <span data-ttu-id="55020-108">Aucune implémentation n’est associée à une interface.</span><span class="sxs-lookup"><span data-stu-id="55020-108">There is no implementation associated with an interface.</span></span>

<span data-ttu-id="55020-109">Une *implémentation d’interface* est le code fourni par un programmeur pour effectuer les actions spécifiées dans une définition d’interface.</span><span class="sxs-lookup"><span data-stu-id="55020-109">An *interface implementation* is the code a programmer supplies to carry out the actions specified in an interface definition.</span></span> <span data-ttu-id="55020-110">Les implémentations de nombreuses interfaces qu’un programmeur peut utiliser dans une application basée sur un objet sont incluses dans les bibliothèques COM.</span><span class="sxs-lookup"><span data-stu-id="55020-110">Implementations of many of the interfaces a programmer can use in an object-based application are included in the COM libraries.</span></span> <span data-ttu-id="55020-111">Toutefois, les programmeurs sont libres d’ignorer ces implémentations et d’écrire leurs propres implémentations.</span><span class="sxs-lookup"><span data-stu-id="55020-111">However, programmers are free to ignore these implementations and write their own.</span></span> <span data-ttu-id="55020-112">Une implémentation d’interface doit être associée à un objet lorsqu’une instance de cet objet est créée, et l’implémentation fournit les services offerts par l’objet.</span><span class="sxs-lookup"><span data-stu-id="55020-112">An interface implementation is to be associated with an object when an instance of that object is created, and the implementation provides the services that the object offers.</span></span>

<span data-ttu-id="55020-113">Par exemple, une interface hypothétique nommée IStack peut définir deux méthodes, nommées push et pop, en spécifiant que les appels successifs à la méthode pop retournent, dans l’ordre inverse, les valeurs passées précédemment à la méthode push.</span><span class="sxs-lookup"><span data-stu-id="55020-113">For example, a hypothetical interface named IStack might define two methods, named Push and Pop, specifying that successive calls to the Pop method return, in reverse order, values previously passed to the Push method.</span></span> <span data-ttu-id="55020-114">Cette définition d’interface ne spécifie pas comment les fonctions doivent être implémentées dans le code.</span><span class="sxs-lookup"><span data-stu-id="55020-114">This interface definition would not specify how the functions are to be implemented in code.</span></span> <span data-ttu-id="55020-115">Dans l’implémentation de l’interface, un programmeur peut implémenter la pile en tant que tableau et implémenter les méthodes push et pop de manière à accéder à ce tableau, tandis qu’un autre programmeur peut utiliser une liste liée et implémenter les méthodes en conséquence.</span><span class="sxs-lookup"><span data-stu-id="55020-115">In implementing the interface, one programmer might implement the stack as an array and implement the Push and Pop methods in such a way as to access that array, while another programmer might use a linked list and would implement the methods accordingly.</span></span> <span data-ttu-id="55020-116">Quelle que soit l’implémentation particulière des méthodes push et pop, la représentation en mémoire d’un pointeur vers une interface IStack et, par conséquent, son utilisation par un client, est complètement déterminée par la définition de l’interface.</span><span class="sxs-lookup"><span data-stu-id="55020-116">Regardless of a particular implementation of the Push and Pop methods, the in-memory representation of a pointer to an IStack interface, and therefore its use by a client, is completely determined by the interface definition.</span></span>

<span data-ttu-id="55020-117">Les objets simples ne prennent en charge qu’une seule interface.</span><span class="sxs-lookup"><span data-stu-id="55020-117">Simple objects support only a single interface.</span></span> <span data-ttu-id="55020-118">Les objets plus compliqués, tels que les objets incorporables, prennent généralement en charge plusieurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="55020-118">More complicated objects, such as embeddable objects, typically support several interfaces.</span></span> <span data-ttu-id="55020-119">Les clients ont accès à un objet COM uniquement par le biais d’un pointeur vers l’une de ses interfaces, qui, à son tour, permet au client d’appeler l’une des méthodes qui composent cette interface.</span><span class="sxs-lookup"><span data-stu-id="55020-119">Clients have access to a COM object only through a pointer to one of its interfaces, which, in turn, allows the client to call any of the methods that make up that interface.</span></span> <span data-ttu-id="55020-120">Ces méthodes déterminent la façon dont un client peut utiliser les données de l’objet.</span><span class="sxs-lookup"><span data-stu-id="55020-120">These methods determine how a client can use the object's data.</span></span>

<span data-ttu-id="55020-121">Les interfaces définissent un contrat entre un objet et ses clients.</span><span class="sxs-lookup"><span data-stu-id="55020-121">Interfaces define a contract between an object and its clients.</span></span> <span data-ttu-id="55020-122">Le contrat spécifie les méthodes qui doivent être associées à chaque interface et le comportement de chacune des méthodes en termes d’entrée et de sortie.</span><span class="sxs-lookup"><span data-stu-id="55020-122">The contract specifies the methods that must be associated with each interface and what the behavior of each of the methods must be in terms of input and output.</span></span> <span data-ttu-id="55020-123">Le contrat ne définit généralement pas comment implémenter les méthodes dans une interface.</span><span class="sxs-lookup"><span data-stu-id="55020-123">The contract generally does not define how to implement the methods in an interface.</span></span> <span data-ttu-id="55020-124">Un autre aspect important du contrat est que si un objet prend en charge une interface, il doit prendre en charge toutes les méthodes de cette interface de quelque façon que ce soit.</span><span class="sxs-lookup"><span data-stu-id="55020-124">Another important aspect of the contract is that if an object supports an interface, it must support all of that interface's methods in some way.</span></span> <span data-ttu-id="55020-125">Toutes les méthodes d’une implémentation n’ont pas besoin de faire quoi que ce soit.</span><span class="sxs-lookup"><span data-stu-id="55020-125">Not all of the methods in an implementation need to do something.</span></span> <span data-ttu-id="55020-126">Si un objet ne prend pas en charge la fonction impliquée par une méthode, son implémentation peut être un retour simple ou éventuellement le retour d’un message d’erreur explicite, mais les méthodes doivent exister.</span><span class="sxs-lookup"><span data-stu-id="55020-126">If an object does not support the function implied by a method, its implementation may be a simple return or perhaps the return of a meaningful error message—but the methods must exist.</span></span>

## <a name="related-topics"></a><span data-ttu-id="55020-127">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="55020-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="55020-128">Objets et interfaces COM</span><span class="sxs-lookup"><span data-stu-id="55020-128">COM Objects and Interfaces</span></span>](com-objects-and-interfaces.md)
</dt> </dl>

 

 




