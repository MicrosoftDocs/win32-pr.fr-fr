---
title: Vue d’ensemble technique COM
ms.assetid: 519c87cc-b442-4187-af2a-124a1e4e8b49
description: 'En savoir plus sur : vue d’ensemble technique de COM'
keywords:
- COM présentation technique com
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be5dc95ffae5166d86cd8110cab1a6b90e6ffa5c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "104110571"
---
# <a name="com-technical-overview"></a><span data-ttu-id="247f0-104">Vue d’ensemble technique COM</span><span class="sxs-lookup"><span data-stu-id="247f0-104">COM Technical Overview</span></span>

<span data-ttu-id="247f0-105">Cette rubrique fournit une vue d’ensemble du modèle COM (Component Object Model) Microsoft :</span><span class="sxs-lookup"><span data-stu-id="247f0-105">This topic provides an overview of the Microsoft Component Object Model (COM):</span></span>

-   [<span data-ttu-id="247f0-106">Introduction à COM</span><span class="sxs-lookup"><span data-stu-id="247f0-106">Introduction to COM</span></span>](#introduction-to-com)
-   [<span data-ttu-id="247f0-107">Objets et interfaces</span><span class="sxs-lookup"><span data-stu-id="247f0-107">Objects and Interfaces</span></span>](#objects-and-interfaces)
-   [<span data-ttu-id="247f0-108">Implémentation de l’interface</span><span class="sxs-lookup"><span data-stu-id="247f0-108">Interface implementation</span></span>](#interface-implementation)
-   [<span data-ttu-id="247f0-109">Interface IUnknown</span><span class="sxs-lookup"><span data-stu-id="247f0-109">The IUnknown Interface</span></span>](#the-iunknown-interface)
-   [<span data-ttu-id="247f0-110">Modèle client/serveur</span><span class="sxs-lookup"><span data-stu-id="247f0-110">The Client/Server Model</span></span>](#the-clientserver-model)
-   [<span data-ttu-id="247f0-111">Gestionnaire de contrôle des services</span><span class="sxs-lookup"><span data-stu-id="247f0-111">Service Control Manager</span></span>](#service-control-manager)
-   [<span data-ttu-id="247f0-112">Réutilisabilité</span><span class="sxs-lookup"><span data-stu-id="247f0-112">Reusability</span></span>](#reusability)
-   [<span data-ttu-id="247f0-113">Objets de stockage et de flux</span><span class="sxs-lookup"><span data-stu-id="247f0-113">Storage and Stream Objects</span></span>](#storage-and-stream-objects)
-   [<span data-ttu-id="247f0-114">Transfert de données</span><span class="sxs-lookup"><span data-stu-id="247f0-114">Data Transfer</span></span>](#data-transfer)
-   [<span data-ttu-id="247f0-115">Communication à distance</span><span class="sxs-lookup"><span data-stu-id="247f0-115">Remoting</span></span>](#remoting)
-   [<span data-ttu-id="247f0-116">Sécurité</span><span class="sxs-lookup"><span data-stu-id="247f0-116">Security</span></span>](#security)
-   [<span data-ttu-id="247f0-117">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="247f0-117">Related topics</span></span>](#related-topics)

## <a name="introduction-to-com"></a><span data-ttu-id="247f0-118">Introduction à COM</span><span class="sxs-lookup"><span data-stu-id="247f0-118">Introduction to COM</span></span>

<span data-ttu-id="247f0-119">Le modèle COM (Component Object Model) Microsoft définit une norme d’interopérabilité binaire pour créer des bibliothèques logicielles réutilisables qui interagissent au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="247f0-119">The Microsoft Component Object Model (COM) defines a binary interoperability standard for creating reusable software libraries that interact at run time.</span></span> <span data-ttu-id="247f0-120">Vous pouvez utiliser des bibliothèques COM sans avoir besoin de les compiler dans votre application.</span><span class="sxs-lookup"><span data-stu-id="247f0-120">You can use COM libraries without the requirement of compiling them into your application.</span></span> <span data-ttu-id="247f0-121">COM est la base d’un certain nombre de produits et de technologies Microsoft, tels que Windows Media Player et Windows Server.</span><span class="sxs-lookup"><span data-stu-id="247f0-121">COM is the foundation for a number of Microsoft products and technologies, such as Windows Media Player and Windows Server.</span></span>

<span data-ttu-id="247f0-122">COM définit une norme binaire qui s’applique à de nombreux systèmes d’exploitation et plates-formes matérielles.</span><span class="sxs-lookup"><span data-stu-id="247f0-122">COM defines a binary standard that applies to many operating systems and hardware platforms.</span></span> <span data-ttu-id="247f0-123">Pour l’informatique en réseau, COM définit un protocole et un format de câble standard pour l’interaction entre les objets qui s’exécutent sur différentes plateformes matérielles.</span><span class="sxs-lookup"><span data-stu-id="247f0-123">For network computing, COM defines a standard wire format and protocol for interaction among objects that run on different hardware platforms.</span></span> <span data-ttu-id="247f0-124">COM est indépendant du langage d’implémentation, ce qui signifie que vous pouvez créer des bibliothèques COM à l’aide de différents langages de programmation, tels que C++ et ceux du .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="247f0-124">COM is independent of implementation language, which means that you can create COM libraries by using different programming languages, such as C++ and those in the .NET Framework.</span></span>

<span data-ttu-id="247f0-125">La spécification COM fournit tous les concepts fondamentaux qui permettent la réutilisation de logiciels interplateformes :</span><span class="sxs-lookup"><span data-stu-id="247f0-125">The COM specification provides all of the fundamental concepts that enable cross-platform software reuse:</span></span>

-   <span data-ttu-id="247f0-126">Norme binaire pour les appels de fonction entre les composants.</span><span class="sxs-lookup"><span data-stu-id="247f0-126">A binary standard for function calls between components.</span></span>
-   <span data-ttu-id="247f0-127">Provision pour les regroupements fortement typés de fonctions en interfaces.</span><span class="sxs-lookup"><span data-stu-id="247f0-127">A provision for strongly-typed groupings of functions into interfaces.</span></span>
-   <span data-ttu-id="247f0-128">Interface de base qui fournit le polymorphisme, la découverte des fonctionnalités et le suivi de la durée de vie des objets.</span><span class="sxs-lookup"><span data-stu-id="247f0-128">A base interface that provides polymorphism, feature discovery, and object lifetime tracking.</span></span>
-   <span data-ttu-id="247f0-129">Mécanisme qui identifie de façon unique les composants et leurs interfaces.</span><span class="sxs-lookup"><span data-stu-id="247f0-129">A mechanism that uniquely identifies components and their interfaces.</span></span>
-   <span data-ttu-id="247f0-130">Chargeur de composant qui crée des instances de composant à partir d’un déploiement.</span><span class="sxs-lookup"><span data-stu-id="247f0-130">A component loader that creates component instances from a deployment.</span></span>

<span data-ttu-id="247f0-131">COM a un certain nombre de parties qui fonctionnent ensemble pour permettre la création d’applications créées à partir de composants réutilisables :</span><span class="sxs-lookup"><span data-stu-id="247f0-131">COM has a number of parts that work together to enable the creation of applications that are built from reusable components:</span></span>

-   <span data-ttu-id="247f0-132">*Système hôte* qui fournit un environnement d’exécution conforme à la spécification com.</span><span class="sxs-lookup"><span data-stu-id="247f0-132">A *host system* that provides a run-time environment that conforms to the COM specification.</span></span>
-   <span data-ttu-id="247f0-133">Les *interfaces* qui définissent les contrats de fonctionnalités et les *composants* qui implémentent les interfaces.</span><span class="sxs-lookup"><span data-stu-id="247f0-133">*Interfaces* that define feature contracts, and *components* that implement interfaces.</span></span>
-   <span data-ttu-id="247f0-134">Les *serveurs* qui fournissent des composants au système, ainsi que les *clients* qui utilisent les fonctionnalités fournies par les composants.</span><span class="sxs-lookup"><span data-stu-id="247f0-134">*Servers* that provide components to the system, and *clients* that use the features provided by components.</span></span>
-   <span data-ttu-id="247f0-135">*Registre* qui effectue le suivi des emplacements où les composants sont déployés sur des hôtes locaux et distants.</span><span class="sxs-lookup"><span data-stu-id="247f0-135">A *registry* that tracks where components are deployed on local and remote hosts.</span></span>
-   <span data-ttu-id="247f0-136">*Gestionnaire de contrôle des services* qui localise les composants sur les hôtes locaux et distants et connecte les serveurs aux clients.</span><span class="sxs-lookup"><span data-stu-id="247f0-136">A *Service Control Manager* that locates components on local and remote hosts and connects servers to clients.</span></span>
-   <span data-ttu-id="247f0-137">Protocole de *stockage structuré* qui définit comment parcourir le contenu des fichiers sur le système de fichiers de l’hôte.</span><span class="sxs-lookup"><span data-stu-id="247f0-137">A *structured storage* protocol that defines how to navigate the contents of files on the host's file system.</span></span>

<span data-ttu-id="247f0-138">L’activation de la réutilisation de code sur les hôtes et les plateformes est essentielle à COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-138">Enabling code re-use across hosts and platforms is central to COM.</span></span> <span data-ttu-id="247f0-139">Une implémentation d’interface réutilisable est nommée un *composant*, un *objet de composant* ou un *objet com*.</span><span class="sxs-lookup"><span data-stu-id="247f0-139">A reusable interface implementation is named a *component*, a *component object*, or a *COM object*.</span></span> <span data-ttu-id="247f0-140">Un composant implémente une ou plusieurs interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-140">A component implements one or more COM interfaces.</span></span>

<span data-ttu-id="247f0-141">Vous définissez une bibliothèque COM personnalisée en concevant les interfaces implémentées par votre bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="247f0-141">You define a custom COM library by designing the interfaces that your library implements.</span></span> <span data-ttu-id="247f0-142">Les consommateurs de votre bibliothèque peuvent découvrir et utiliser ses fonctionnalités sans aucune connaissance du déploiement et des détails de l’implémentation de votre bibliothèque.</span><span class="sxs-lookup"><span data-stu-id="247f0-142">Consumers of your library can discover and use its features without any knowledge of your library's deployment and implementation details.</span></span>

## <a name="objects-and-interfaces"></a><span data-ttu-id="247f0-143">Objets et interfaces</span><span class="sxs-lookup"><span data-stu-id="247f0-143">Objects and Interfaces</span></span>

<span data-ttu-id="247f0-144">Un objet COM expose ses fonctionnalités par le biais d’une *interface*, qui est une collection de fonctions membres.</span><span class="sxs-lookup"><span data-stu-id="247f0-144">A COM object exposes its features through an *interface*, which is a collection of member functions.</span></span> <span data-ttu-id="247f0-145">Une interface COM définit le comportement et les responsabilités attendus d’un composant, et spécifie un contrat fortement typé qui fournit un petit ensemble d’opérations connexes.</span><span class="sxs-lookup"><span data-stu-id="247f0-145">A COM interface defines the expected behavior and responsibilities of a component, and it specifies a strongly-typed contract that provides a small set of related operations.</span></span> <span data-ttu-id="247f0-146">Toutes les communications entre les composants COM se produisent par le biais d’interfaces, et tous les services offerts par un composant sont exposés via son interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-146">All communication among COM components occurs through interfaces, and all services offered by a component are exposed through its interface.</span></span> <span data-ttu-id="247f0-147">Un appelant peut accéder uniquement aux fonctions membres de l’interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-147">A caller can access only the interface member functions.</span></span> <span data-ttu-id="247f0-148">L’état interne n’est pas disponible pour un appelant, sauf s’il est exposé dans l’interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-148">Internal state is unavailable to a caller unless it is exposed in the interface.</span></span>

<span data-ttu-id="247f0-149">Les interfaces sont fortement typées.</span><span class="sxs-lookup"><span data-stu-id="247f0-149">Interfaces are strongly typed.</span></span> <span data-ttu-id="247f0-150">Chaque interface a son propre identificateur d’interface unique, appelé IID, ce qui élimine les collisions pouvant se produire avec des noms explicites.</span><span class="sxs-lookup"><span data-stu-id="247f0-150">Every interface has its own unique interface identifier, named an IID, which eliminates collisions that could occur with human-readable names.</span></span> <span data-ttu-id="247f0-151">L’IID est un identificateur global unique (GUID), qui est identique à l’identificateur unique universel (UUID) défini par l’environnement de calcul distribué OSF (Open Software Foundation).</span><span class="sxs-lookup"><span data-stu-id="247f0-151">The IID is a globally unique identifier (GUID), which is the same as the Universally Unique ID (UUID) defined by the Open Software Foundation (OSF) Distributed Computing Environment (DCE).</span></span> <span data-ttu-id="247f0-152">Lorsque vous créez une nouvelle interface, vous devez créer un nouvel identificateur pour cette interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-152">When you create a new interface, you must create a new identifier for that interface.</span></span> <span data-ttu-id="247f0-153">Quand un appelant utilise une interface, il doit utiliser l’identificateur unique.</span><span class="sxs-lookup"><span data-stu-id="247f0-153">When a caller uses an interface, it must use the unique identifier.</span></span> <span data-ttu-id="247f0-154">Cette identification explicite améliore la robustesse en éliminant les conflits de noms qui entraîneraient un échec au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="247f0-154">This explicit identification improves robustness by eliminating naming conflicts that would result in run-time failure.</span></span>

<span data-ttu-id="247f0-155">Lorsque vous définissez une nouvelle interface, vous pouvez créer une définition d’interface à l’aide du langage IDL (Interface Definition Language).</span><span class="sxs-lookup"><span data-stu-id="247f0-155">When you define a new interface, you can create an interface definition by using the interface definition language (IDL).</span></span> <span data-ttu-id="247f0-156">À partir de cette définition d’interface, le compilateur IDL Microsoft génère des fichiers d’en-tête pour une utilisation par les applications à l’aide de l’interface et du code source pour gérer les appels de procédure distante.</span><span class="sxs-lookup"><span data-stu-id="247f0-156">From this interface definition, the Microsoft IDL compiler generates header files for use by applications using the interface, and source code to handle remote procedure calls.</span></span> <span data-ttu-id="247f0-157">L’IDL fourni par Microsoft est basé sur des extensions simples de l’IDL DCE, une norme du secteur pour l’informatique distribuée basée sur les appels de procédure distante (RPC).</span><span class="sxs-lookup"><span data-stu-id="247f0-157">The IDL supplied by Microsoft is based on simple extensions to DCE IDL, an industry standard for Remote Procedure Call (RPC)-based distributed computing.</span></span> <span data-ttu-id="247f0-158">IDL est un outil pour la commodité du concepteur d’interface et n’est pas central pour l’interopérabilité COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-158">IDL is a tool for the convenience of the interface designer and is not central to COM interoperability.</span></span> <span data-ttu-id="247f0-159">Avec IDL, vous n’avez pas besoin de créer manuellement des fichiers d’en-tête pour chaque environnement de programmation.</span><span class="sxs-lookup"><span data-stu-id="247f0-159">With IDL, you do not need to create header files manually for each programming environment.</span></span> <span data-ttu-id="247f0-160">Pour plus d’informations, consultez [définition des interfaces com](defining-com-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-160">For more information, see [Defining COM Interfaces](defining-com-interfaces.md).</span></span>

<span data-ttu-id="247f0-161">L’héritage est utilisé avec modération dans les interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-161">Inheritance is used sparingly in COM interfaces.</span></span> <span data-ttu-id="247f0-162">COM prend en charge l’héritage d’interface uniquement pour réutiliser un contrat associé à une interface de base.</span><span class="sxs-lookup"><span data-stu-id="247f0-162">COM supports interface inheritance only to reuse a contract associated with a base interface.</span></span> <span data-ttu-id="247f0-163">COM ne prend pas en charge l’héritage sélectif ; par conséquent, si une interface hérite d’une autre, elle comprend toutes les fonctions définies par l’interface de base.</span><span class="sxs-lookup"><span data-stu-id="247f0-163">COM does not support selective inheritance; therefore, if one interface inherits from another, it includes all of the functions that the base interface defines.</span></span> <span data-ttu-id="247f0-164">En outre, les interfaces utilisent uniquement l’héritage unique, au lieu de plusieurs héritages, pour obtenir des fonctions à partir d’une interface de base.</span><span class="sxs-lookup"><span data-stu-id="247f0-164">In addition, interfaces use only single inheritance, instead of multiple inheritance, to obtain functions from a base interface.</span></span>

## <a name="interface-implementation"></a><span data-ttu-id="247f0-165">Implémentation de l’interface</span><span class="sxs-lookup"><span data-stu-id="247f0-165">Interface implementation</span></span>

<span data-ttu-id="247f0-166">Vous ne pouvez pas créer une instance d’une interface COM seule.</span><span class="sxs-lookup"><span data-stu-id="247f0-166">You cannot create an instance of a COM interface by itself.</span></span> <span data-ttu-id="247f0-167">Au lieu de cela, vous créez une instance d’une classe qui implémente l’interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-167">Instead, you create an instance of a class that implements the interface.</span></span> <span data-ttu-id="247f0-168">En C++, une interface COM est modélisée en tant que *classe de base abstraite*, ce qui signifie que l’interface est une classe C++ qui contient uniquement des fonctions membres virtuelles pures.</span><span class="sxs-lookup"><span data-stu-id="247f0-168">In C++, a COM interface is modeled as an *abstract base class*, which means that the interface is a C++ class that contains only pure virtual member functions.</span></span> <span data-ttu-id="247f0-169">Une bibliothèque C++ implémente des objets COM en héritant des signatures de fonction membre d’une ou plusieurs interfaces, en substituant chaque fonction membre et en fournissant une implémentation pour chaque fonction.</span><span class="sxs-lookup"><span data-stu-id="247f0-169">A C++ library implements COM objects by inheriting the member function signatures from one or more interfaces, overriding each member function, and providing an implementation for each function.</span></span>

<span data-ttu-id="247f0-170">Vous pouvez utiliser n’importe quel langage de programmation qui prend en charge le concept de pointeurs de fonction pour implémenter une interface COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-170">You can use any programming language that supports the concept of function pointers to implement a COM interface.</span></span> <span data-ttu-id="247f0-171">Par exemple, en C, une interface est une structure contenant un pointeur vers une table de pointeurs de fonction, un pour chaque méthode dans l’interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-171">For example, in C, an interface is a structure containing a pointer to a table of function pointers, one for each method in the interface.</span></span>

<span data-ttu-id="247f0-172">Lorsque vous implémentez une interface, votre classe doit fournir une implémentation pour chaque fonction dans l’interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-172">When you implement an interface, your class must provide an implementation for every function in the interface.</span></span> <span data-ttu-id="247f0-173">Si la classe n’a pas de travail à effectuer dans une fonction d’interface, l’implémentation peut être une instruction return unique.</span><span class="sxs-lookup"><span data-stu-id="247f0-173">If the class has no work to do in an interface function, the implementation may be a single return statement.</span></span>

<span data-ttu-id="247f0-174">Une classe COM est identifiée à l’aide d’un ID de classe 128 bits unique (CLSID) qui associe une classe à un déploiement particulier dans le système de fichiers, qui pour Windows est une DLL ou un EXE.</span><span class="sxs-lookup"><span data-stu-id="247f0-174">A COM class is identified by using a unique 128-bit Class ID (CLSID) that associates a class with a particular deployment in the file system, which for Windows is a DLL or EXE.</span></span> <span data-ttu-id="247f0-175">Un CLSID est un GUID, ce qui signifie qu’aucune autre classe n’a le même CLSID.</span><span class="sxs-lookup"><span data-stu-id="247f0-175">A CLSID is a GUID, which means that no other class has the same CLSID.</span></span> <span data-ttu-id="247f0-176">L’utilisation d’identificateurs de classe uniques empêche les collisions de noms entre les classes.</span><span class="sxs-lookup"><span data-stu-id="247f0-176">The use of unique class identifiers prevents name collisions among classes.</span></span> <span data-ttu-id="247f0-177">Par exemple, deux fournisseurs différents peuvent écrire une classe nommée CStack, mais les deux classes ont un CLSID unique, de sorte que toute possibilité de collision est évitée.</span><span class="sxs-lookup"><span data-stu-id="247f0-177">For example, two different vendors can write a class named CStack, but both classes have a unique CLSID, so any possibility of a collision is avoided.</span></span>

<span data-ttu-id="247f0-178">Vous obtenez un nouveau CLSID à l’aide de la fonction [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) ou à l’aide d’un outil de création com, tel que Visual Studio, qui appelle cette fonction en interne.</span><span class="sxs-lookup"><span data-stu-id="247f0-178">You obtain a new CLSID by using the [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) function or by using a COM authoring tool, such as Visual Studio, that calls this function internally.</span></span>

## <a name="the-iunknown-interface"></a><span data-ttu-id="247f0-179">Interface IUnknown</span><span class="sxs-lookup"><span data-stu-id="247f0-179">The IUnknown Interface</span></span>

<span data-ttu-id="247f0-180">Toutes les interfaces COM héritent de l’interface [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) .</span><span class="sxs-lookup"><span data-stu-id="247f0-180">All COM interfaces inherit from the [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) interface.</span></span> <span data-ttu-id="247f0-181">L’interface **IUnknown** contient les opérations com fondamentales pour la gestion de la durée de vie du polymorphisme et des instances.</span><span class="sxs-lookup"><span data-stu-id="247f0-181">The **IUnknown** interface contains the fundamental COM operations for polymorphism and instance lifetime management.</span></span> <span data-ttu-id="247f0-182">L’interface **IUnknown** a trois fonctions membres, nommées [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)et [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span><span class="sxs-lookup"><span data-stu-id="247f0-182">The **IUnknown** interface has three member functions, named [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref), and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).</span></span> <span data-ttu-id="247f0-183">Tous les objets COM sont requis pour implémenter l’interface **IUnknown** .</span><span class="sxs-lookup"><span data-stu-id="247f0-183">All COM objects are required to implement the **IUnknown** interface.</span></span>

<span data-ttu-id="247f0-184">La fonction membre [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) fournit le polymorphisme pour com.</span><span class="sxs-lookup"><span data-stu-id="247f0-184">The [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) member function provides polymorphism for COM.</span></span> <span data-ttu-id="247f0-185">Appelez **QueryInterface** pour déterminer au moment de l’exécution si un objet com prend en charge une interface particulière.</span><span class="sxs-lookup"><span data-stu-id="247f0-185">Call **QueryInterface** to determine at run time whether a COM object supports a particular interface.</span></span> <span data-ttu-id="247f0-186">L’objet COM retourne un pointeur d’interface dans le `ppvObject` paramètre s’il implémente l’interface demandée ; sinon, il retourne `NULL` .</span><span class="sxs-lookup"><span data-stu-id="247f0-186">The COM object returns an interface pointer in the `ppvObject` parameter if it implements the requested interface, otherwise it returns `NULL`.</span></span> <span data-ttu-id="247f0-187">La fonction membre **QueryInterface** active la navigation parmi toutes les interfaces prises en charge par un objet com.</span><span class="sxs-lookup"><span data-stu-id="247f0-187">The **QueryInterface** member function enables navigation among all of the interfaces that a COM object supports.</span></span>

<span data-ttu-id="247f0-188">La durée de vie d’une instance d’objet COM est contrôlée par son *décompte de références*.</span><span class="sxs-lookup"><span data-stu-id="247f0-188">The lifetime of a COM object instance is controlled by its *reference count*.</span></span> <span data-ttu-id="247f0-189">Les [](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) fonctions membres IUnknown [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) et [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) contrôlent le nombre.</span><span class="sxs-lookup"><span data-stu-id="247f0-189">The [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) member functions [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) control the count.</span></span> <span data-ttu-id="247f0-190">**AddRef** incrémente le nombre et la **libération** décrémente le nombre.</span><span class="sxs-lookup"><span data-stu-id="247f0-190">**AddRef** increments the count and **Release** decrements the count.</span></span> <span data-ttu-id="247f0-191">Lorsque le décompte de références atteint zéro, la fonction membre **Release** peut libérer l’instance, car aucun appelant ne l’utilise.</span><span class="sxs-lookup"><span data-stu-id="247f0-191">When the reference count reaches zero, the **Release** member function may free the instance, because no callers are using it.</span></span>

## <a name="the-clientserver-model"></a><span data-ttu-id="247f0-192">Modèle client/serveur</span><span class="sxs-lookup"><span data-stu-id="247f0-192">The Client/Server Model</span></span>

<span data-ttu-id="247f0-193">Une classe COM implémente un certain nombre d’interfaces COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-193">A COM class implements a number of COM interfaces.</span></span> <span data-ttu-id="247f0-194">L’implémentation se compose de fichiers binaires qui s’exécutent lorsqu’un appelant interagit avec une instance de la classe COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-194">The implementation consists of binaries that run when a caller interacts with an instance of the COM class.</span></span> <span data-ttu-id="247f0-195">COM permet l’utilisation d’une classe dans différentes applications, y compris les applications écrites sans connaissance d’une classe particulière.</span><span class="sxs-lookup"><span data-stu-id="247f0-195">COM enables using a class in different applications, including applications written without knowledge of a particular class.</span></span> <span data-ttu-id="247f0-196">Sur une plate-forme Windows, les classes existent dans une bibliothèque de liens dynamiques (DLL) ou dans une autre application (EXE).</span><span class="sxs-lookup"><span data-stu-id="247f0-196">On a Windows platform, classes exist either in a dynamic-linked library (DLL) or in another application (EXE).</span></span>

<span data-ttu-id="247f0-197">Sur son système hôte, COM gère une base de données d’inscription de tous les CLSID pour les objets COM installés sur le système.</span><span class="sxs-lookup"><span data-stu-id="247f0-197">On its host system, COM maintains a registration database of all the CLSIDs for the COM objects installed on the system.</span></span> <span data-ttu-id="247f0-198">La base de données d’inscription est un mappage entre chaque CLSID et l’emplacement de la DLL ou de l’EXE qui héberge la classe correspondante.</span><span class="sxs-lookup"><span data-stu-id="247f0-198">The registration database is a mapping between each CLSID and the location of the DLL or EXE that houses the corresponding class.</span></span> <span data-ttu-id="247f0-199">COM interroge cette base de données chaque fois qu’un appelant souhaite créer une instance d’une classe COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-199">COM queries this database whenever a caller wants to create an instance of a COM class.</span></span> <span data-ttu-id="247f0-200">L’appelant doit connaître uniquement le CLSID pour demander une nouvelle instance de la classe.</span><span class="sxs-lookup"><span data-stu-id="247f0-200">The caller needs to know only the CLSID to request a new instance of the class.</span></span>

<span data-ttu-id="247f0-201">L’interaction entre un objet COM et ses appelants est modélisée en tant que relation client/serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-201">The interaction between a COM object and its callers is modeled as a client/server relationship.</span></span> <span data-ttu-id="247f0-202">Le client est l’appelant qui demande un objet COM du système, et le serveur est le module qui héberge les objets COM qui fournit des services aux clients.</span><span class="sxs-lookup"><span data-stu-id="247f0-202">The client is the caller that requests a COM object from the system, and the server is the module that houses COM objects that provides services to clients.</span></span>

<span data-ttu-id="247f0-203">Un client COM est un appelant qui passe un CLSID au système pour demander une instance d’un objet COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-203">A COM client is any caller that passes a CLSID to the system to request an instance of a COM object.</span></span> <span data-ttu-id="247f0-204">La façon la plus simple de créer une instance consiste à appeler la fonction COM [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span><span class="sxs-lookup"><span data-stu-id="247f0-204">The simplest way to create an instance is to call the COM function, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).</span></span>

<span data-ttu-id="247f0-205">La fonction [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) crée une instance du CLSID spécifié et retourne un pointeur d’interface du type demandé par le client.</span><span class="sxs-lookup"><span data-stu-id="247f0-205">The [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function creates one instance of the specified CLSID and returns an interface pointer of the type requested by the client.</span></span> <span data-ttu-id="247f0-206">Le client est responsable de la gestion de la durée de vie de l’instance en appelant sa fonction [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) lorsque le client a fini de l’utiliser.</span><span class="sxs-lookup"><span data-stu-id="247f0-206">The client is responsible for managing the lifetime of the instance by calling its [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) function when the client has finished using it.</span></span> <span data-ttu-id="247f0-207">Pour créer plusieurs objets basés sur un seul CLSID, appelez la fonction [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) .</span><span class="sxs-lookup"><span data-stu-id="247f0-207">To create multiple objects based on a single CLSID, call the [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) function.</span></span> <span data-ttu-id="247f0-208">Pour vous connecter à un objet déjà créé et en cours d’exécution, appelez la fonction [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) .</span><span class="sxs-lookup"><span data-stu-id="247f0-208">To connect to an object that is already created and running, call the [**GetActiveObject**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) function.</span></span>

<span data-ttu-id="247f0-209">Un serveur COM fournit une implémentation COM au système.</span><span class="sxs-lookup"><span data-stu-id="247f0-209">A COM server provides a COM implementation to the system.</span></span> <span data-ttu-id="247f0-210">Un serveur associe un CLSID à une classe COM, héberge l’implémentation de la classe, implémente une fabrique de classes pour créer des instances de la classe et permet de décharger le serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-210">A server associates a CLSID with a COM class, houses the implementation of the class, implements a class factory for creating instances of the class, and provides for unloading the server.</span></span>

> [!Note]  
> <span data-ttu-id="247f0-211">Un serveur COM n’est pas le même que l’objet COM qu’il fournit au système.</span><span class="sxs-lookup"><span data-stu-id="247f0-211">A COM server is not the same as the COM object that it provides to the system.</span></span>

 

<span data-ttu-id="247f0-212">Pour permettre la création d’un objet COM, un serveur COM doit fournir une implémentation de l’interface [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) .</span><span class="sxs-lookup"><span data-stu-id="247f0-212">To enable creating a COM object, a COM server must provide an implementation of the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface.</span></span> <span data-ttu-id="247f0-213">Les clients peuvent appeler la méthode [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) pour demander une nouvelle instance d’un objet com, mais ces demandes sont généralement encapsulées dans la fonction [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) .</span><span class="sxs-lookup"><span data-stu-id="247f0-213">Clients can call the [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) method to request a new instance of a COM object, but usually such requests are encapsulated in the [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) function.</span></span>

<span data-ttu-id="247f0-214">Vous pouvez déployer un serveur COM en tant que bibliothèque partagée qui est chargée dans le processus du client au moment de l’exécution (DLL sur les plateformes Windows) ou en tant que module exécutable (EXE sur les plateformes Windows).</span><span class="sxs-lookup"><span data-stu-id="247f0-214">You can deploy a COM server either as a shared library that is loaded into the client's process at run time (DLL on Windows platforms) or as an executable module (EXE on Windows platforms).</span></span> <span data-ttu-id="247f0-215">Pour plus d’informations, consultez [inscription d’applications com](registering-com-applications.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-215">For more information, see [Registering COM Applications](registering-com-applications.md).</span></span>

## <a name="service-control-manager"></a><span data-ttu-id="247f0-216">Gestionnaire de contrôle des services</span><span class="sxs-lookup"><span data-stu-id="247f0-216">Service Control Manager</span></span>

<span data-ttu-id="247f0-217">Le gestionnaire de contrôle des services (SCM) gère la demande du client pour une instance d’un objet COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-217">The Service Control Manager (SCM) handles the client request for an instance of a COM object.</span></span> <span data-ttu-id="247f0-218">La liste suivante présente la séquence des événements :</span><span class="sxs-lookup"><span data-stu-id="247f0-218">The following list shows the sequence of events:</span></span>

-   <span data-ttu-id="247f0-219">Un client demande un pointeur d’interface à un objet COM à partir de la bibliothèque COM en appelant une fonction telle que [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) avec le CLSID de l’objet com.</span><span class="sxs-lookup"><span data-stu-id="247f0-219">A client requests an interface pointer to a COM object from the COM Library by calling a function such as [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) with the CLSID of the COM object.</span></span>
-   <span data-ttu-id="247f0-220">La bibliothèque COM interroge le SCM pour trouver le serveur qui correspond au CLSID demandé.</span><span class="sxs-lookup"><span data-stu-id="247f0-220">The COM Library queries the SCM to find the server that corresponds with the requested CLSID.</span></span>
-   <span data-ttu-id="247f0-221">Le SCM localise le serveur et demande la création de l’objet COM à partir de la fabrique de classes fournie par le serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-221">The SCM locates the server and requests the creation of the COM object from the class factory that is provided by the server.</span></span>
-   <span data-ttu-id="247f0-222">En cas de réussite, la bibliothèque COM retourne un pointeur d’interface vers le client.</span><span class="sxs-lookup"><span data-stu-id="247f0-222">If successful, the COM Library returns an interface pointer to the client.</span></span>

<span data-ttu-id="247f0-223">Une fois que le système COM a connecté un objet serveur à un client, le client et l’objet communiquent directement.</span><span class="sxs-lookup"><span data-stu-id="247f0-223">After the COM system connects a server object to a client, the client and object communicate directly.</span></span> <span data-ttu-id="247f0-224">Il n’y a aucune surcharge supplémentaire due à l’appel par le biais d’une exécution intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="247f0-224">There is no added overhead from calling through an intermediary run time.</span></span>

<span data-ttu-id="247f0-225">Lorsque vous inscrivez un serveur COM auprès du système hôte, vous pouvez spécifier différentes méthodes d’activation du serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-225">When you register a COM server with the host system, you can specify different ways for the server to be activated.</span></span> <span data-ttu-id="247f0-226">La liste suivante présente les trois façons dont le SCM peut activer un serveur COM :</span><span class="sxs-lookup"><span data-stu-id="247f0-226">The following list shows the three ways that the SCM can activate a COM server:</span></span>

-   <span data-ttu-id="247f0-227">In-process : le SCM retourne le chemin d’accès de fichier de la DLL qui contient l’implémentation du serveur d’objets.</span><span class="sxs-lookup"><span data-stu-id="247f0-227">In-process: The SCM returns the file path of the DLL that contains the object server implementation.</span></span> <span data-ttu-id="247f0-228">La bibliothèque COM charge la DLL et l’interroge pour son pointeur d’interface de fabrique de classes.</span><span class="sxs-lookup"><span data-stu-id="247f0-228">The COM Library loads the DLL and queries it for its class factory interface pointer.</span></span>
-   <span data-ttu-id="247f0-229">Local : le SCM démarre l’exécutable local qui inscrit une fabrique de classe au démarrage, et son pointeur d’interface est disponible pour le système et les clients.</span><span class="sxs-lookup"><span data-stu-id="247f0-229">Local: The SCM starts the local executable which registers a class factory on startup, and its interface pointer is available to the system and clients.</span></span>
-   <span data-ttu-id="247f0-230">Distant : le SCM local acquiert un pointeur d’interface de fabrique de classes à partir du SCM qui s’exécute sur un ordinateur distant.</span><span class="sxs-lookup"><span data-stu-id="247f0-230">Remote: The local SCM acquires a class factory interface pointer from the SCM that is running on a remote computer.</span></span>

<span data-ttu-id="247f0-231">Lorsqu’un client demande un objet COM, la bibliothèque COM contacte le SCM sur l’hôte local.</span><span class="sxs-lookup"><span data-stu-id="247f0-231">When a client requests a COM object, the COM Library contacts the SCM on the local host.</span></span> <span data-ttu-id="247f0-232">Le SCM localise le serveur COM approprié, qui peut être local ou distant, et le serveur retourne un pointeur d’interface vers la fabrique de classe du serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-232">The SCM locates the appropriate COM server, which may be local or remote, and the server returns an interface pointer to the server's class factory.</span></span> <span data-ttu-id="247f0-233">Lorsque la fabrique de classe est disponible, la bibliothèque COM ou le client peut utiliser la fabrique de classe pour créer l’objet demandé.</span><span class="sxs-lookup"><span data-stu-id="247f0-233">When the class factory is available, the COM Library or the client can use the class factory to create the requested object.</span></span> <span data-ttu-id="247f0-234">Pour plus d’informations, consultez [Implementing IClassFactory](implementing-iclassfactory.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-234">For more information, see [Implementing IClassFactory](implementing-iclassfactory.md).</span></span>

## <a name="reusability"></a><span data-ttu-id="247f0-235">Possibilité de réutilisation</span><span class="sxs-lookup"><span data-stu-id="247f0-235">Reusability</span></span>

<span data-ttu-id="247f0-236">COM prend en charge la *réutilisation de la boîte noire*, ce qui signifie que les détails d’implémentation d’un composant réutilisable ne sont pas exposés aux clients.</span><span class="sxs-lookup"><span data-stu-id="247f0-236">COM supports *black-box reusability*, which means that the implementation details of a reusable component are not exposed to clients.</span></span> <span data-ttu-id="247f0-237">Pour permettre la réutilisation de la boîte noire, COM prend en charge deux mécanismes par lesquels un objet peut réutiliser un autre.</span><span class="sxs-lookup"><span data-stu-id="247f0-237">To achieve black-box reusability, COM supports two mechanisms through which one object may reuse another.</span></span> <span data-ttu-id="247f0-238">Les deux formes de réutilisation sont des *imbrications* et des *agrégations* nommées.</span><span class="sxs-lookup"><span data-stu-id="247f0-238">The two forms of reuse are named *containment* and *aggregation*.</span></span> <span data-ttu-id="247f0-239">Par Convention, l’objet qui est réutilisé est nommé l' *objet interne* et l’objet qui utilise l’objet interne est nommé l' *objet externe*.</span><span class="sxs-lookup"><span data-stu-id="247f0-239">By convention, the object being reused is named the *inner object*, and the object that is making use of the inner object is named the *outer object*.</span></span>

<span data-ttu-id="247f0-240">Dans la relation contenant-contenu, l’objet externe se comporte comme un client de l’objet interne.</span><span class="sxs-lookup"><span data-stu-id="247f0-240">In containment, the outer object behaves as a client of the inner object.</span></span> <span data-ttu-id="247f0-241">L’objet externe est un conteneur logique pour l’objet interne et, lorsque l’objet externe utilise les services de l’objet interne, l’objet externe délègue l’implémentation aux interfaces de l’objet interne.</span><span class="sxs-lookup"><span data-stu-id="247f0-241">The outer object is a logical container for the inner object, and when the outer object uses the services of the inner object, the outer object delegates implementation to the inner object's interfaces.</span></span> <span data-ttu-id="247f0-242">Cela signifie que l’objet externe est implémenté en termes de services de l’objet interne.</span><span class="sxs-lookup"><span data-stu-id="247f0-242">This means that the outer object is implemented in terms of the inner object's services.</span></span> <span data-ttu-id="247f0-243">L’objet externe peut ne pas prendre en charge les mêmes interfaces que l’objet interne, et l’objet externe peut utiliser l’interface d’un objet interne pour faciliter l’implémentation des parties d’une interface différente sur l’objet externe.</span><span class="sxs-lookup"><span data-stu-id="247f0-243">The outer object may not support the same interfaces as the inner object, and the outer object may use an inner object's interface to help with implementing parts of a different interface on the outer object.</span></span>

<span data-ttu-id="247f0-244">Dans l’agrégation, l’objet externe expose les interfaces de l’objet interne comme si elles étaient implémentées sur l’objet externe.</span><span class="sxs-lookup"><span data-stu-id="247f0-244">In aggregation, the outer object exposes interfaces from the inner object as if they were implemented on the outer object.</span></span> <span data-ttu-id="247f0-245">Cela est utile lorsque l’objet externe délègue toujours chaque appel sur l’une de ses interfaces à la même interface de l’objet interne.</span><span class="sxs-lookup"><span data-stu-id="247f0-245">This is useful when the outer object would always delegate every call on one of its interfaces to the same interface of the inner object.</span></span> <span data-ttu-id="247f0-246">L’agrégation est une pratique qui permet à l’objet externe d’éviter une surcharge d’implémentation supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="247f0-246">Aggregation is a convenience that enables the outer object to avoid extra implementation overhead.</span></span>

<span data-ttu-id="247f0-247">Pour plus d’informations, consultez [réutilisation des objets](reusing-objects.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-247">For more information, see [Reusing Objects](reusing-objects.md).</span></span>

## <a name="storage-and-stream-objects"></a><span data-ttu-id="247f0-248">Objets de stockage et de flux</span><span class="sxs-lookup"><span data-stu-id="247f0-248">Storage and Stream Objects</span></span>

<span data-ttu-id="247f0-249">Les objets COM enregistrent l’État dans un fichier à l’aide du *stockage structuré*, qui est une forme de stockage persistant qui permet la navigation dans le contenu d’un fichier à l’aide de la sémantique du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="247f0-249">COM objects save state to a file by using *structured storage*, which is a form of persistent storage that enables navigation of a file's contents by using file system semantics.</span></span> <span data-ttu-id="247f0-250">Le traitement du contenu d’un fichier de cette manière active des fonctionnalités telles que l’accès incrémentiel, les transactions et le partage entre les processus.</span><span class="sxs-lookup"><span data-stu-id="247f0-250">Treating a file's contents in this manner enables features such as incremental access, transactions, and sharing among processes.</span></span>

<span data-ttu-id="247f0-251">La spécification de stockage persistant COM fournit deux types d’éléments de stockage : les objets de stockage et les objets de flux.</span><span class="sxs-lookup"><span data-stu-id="247f0-251">The COM persistent storage specification provides for two types of storage elements: storage objects and stream objects.</span></span> <span data-ttu-id="247f0-252">Ces objets sont implémentés par la bibliothèque COM, et les applications utilisateur implémentent rarement ces éléments de stockage.</span><span class="sxs-lookup"><span data-stu-id="247f0-252">These objects are implemented by the COM Library, and user applications rarely implement these storage elements.</span></span> <span data-ttu-id="247f0-253">Les objets de stockage implémentent l’interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , et les objets de flux implémentent l’interface [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="247f0-253">Storage objects implement the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, and stream objects implement the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface.</span></span>

<span data-ttu-id="247f0-254">Un objet de flux contient des données et est conceptuellement similaire à un fichier unique dans un système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="247f0-254">A stream object contains data and is conceptually similar to a single file in a file system.</span></span> <span data-ttu-id="247f0-255">Chaque flux dispose de droits d’accès et d’un seul pointeur de recherche.</span><span class="sxs-lookup"><span data-stu-id="247f0-255">Each stream has access rights and a single seek pointer.</span></span> <span data-ttu-id="247f0-256">À l’aide de l’interface [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , vous pouvez lire, écrire, Rechercher et exécuter d’autres opérations sur les données sous-jacentes du flux.</span><span class="sxs-lookup"><span data-stu-id="247f0-256">Through the [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) interface, you can read, write, seek, and perform other operations on the stream's underlying data.</span></span> <span data-ttu-id="247f0-257">Un flux est nommé à l’aide d’une chaîne de texte.</span><span class="sxs-lookup"><span data-stu-id="247f0-257">A stream is named by using a text string.</span></span> <span data-ttu-id="247f0-258">Il peut contenir n’importe quelle structure interne, car il s’agit d’un flux plat d’octets.</span><span class="sxs-lookup"><span data-stu-id="247f0-258">It can contain any internal structure, because it is a flat stream of bytes.</span></span> <span data-ttu-id="247f0-259">En outre, les fonctions de l’interface **IStream** sont similaires aux fonctions standard basées sur les handles de fichiers, telles que celles de la bibliothèque Runtime C ANSI.</span><span class="sxs-lookup"><span data-stu-id="247f0-259">In addition, the functions in the **IStream** interface are similar to standard file-handle based functions, such as those in the ANSI C run-time library.</span></span>

<span data-ttu-id="247f0-260">Un objet de stockage est conceptuellement similaire à un répertoire dans un système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="247f0-260">A storage object is conceptually similar to a directory in a file system.</span></span> <span data-ttu-id="247f0-261">Chaque stockage peut contenir un nombre quelconque d’objets de sous-stockage et un nombre quelconque de flux.</span><span class="sxs-lookup"><span data-stu-id="247f0-261">Each storage can contain any number of sub-storage objects and any number of streams.</span></span> <span data-ttu-id="247f0-262">Chaque stockage dispose de ses propres droits d’accès.</span><span class="sxs-lookup"><span data-stu-id="247f0-262">Each storage has its own access rights.</span></span> <span data-ttu-id="247f0-263">À l’aide de l’interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , vous pouvez effectuer des opérations telles que l’énumération, le déplacement, la copie, le changement de nom, la création et la suppression d’éléments.</span><span class="sxs-lookup"><span data-stu-id="247f0-263">Through the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface, you can perform operations such as enumerating, moving, copying, renaming, creating, and deleting elements.</span></span> <span data-ttu-id="247f0-264">Un objet de stockage ne stocke pas les données définies par l’application, mais stocke implicitement les noms des éléments (stockages et flux) qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="247f0-264">A storage object does not store application-defined data, but it stores implicitly the names of the elements (storages and streams) that it contains.</span></span>

<span data-ttu-id="247f0-265">Les objets de stockage et de flux sont partageables entre les processus lorsqu’ils sont implémentés conformément à la spécification COM sur une plateforme hôte.</span><span class="sxs-lookup"><span data-stu-id="247f0-265">Storage and stream objects are sharable among processes when they are implemented according to the COM specification on a host platform.</span></span> <span data-ttu-id="247f0-266">Cela permet aux objets qui exécutent in-process ou out-of-process d’avoir un accès incrémentiel équivalent à leur stockage de fichiers.</span><span class="sxs-lookup"><span data-stu-id="247f0-266">This enables objects that are running in-process or out-of-process to have equal incremental access to their file storage.</span></span> <span data-ttu-id="247f0-267">Étant donné que COM est chargé séparément dans chaque processus, il utilise des mécanismes de mémoire partagée pris en charge par le système d’exploitation pour communiquer l’état des éléments ouverts et leurs modes d’accès entre les processus.</span><span class="sxs-lookup"><span data-stu-id="247f0-267">Because COM is loaded into each process separately, it uses operating-system supported shared memory mechanisms to communicate the state of opened elements and their access modes between processes.</span></span>

<span data-ttu-id="247f0-268">Chaque objet de stockage et de flux d’un fichier structuré a un nom pour l’identifier.</span><span class="sxs-lookup"><span data-stu-id="247f0-268">Every storage and stream object in a structured file has a name to identify it.</span></span> <span data-ttu-id="247f0-269">Le nom est une chaîne qui suit une convention particulière.</span><span class="sxs-lookup"><span data-stu-id="247f0-269">The name is a string that follows a particular convention.</span></span> <span data-ttu-id="247f0-270">Pour plus d’informations, consultez [conventions d’affectation de noms](/windows/desktop/Stg/storage-object-naming-conventions)pour les objets de stockage.</span><span class="sxs-lookup"><span data-stu-id="247f0-270">For more information, see [Storage Object Naming Conventions](/windows/desktop/Stg/storage-object-naming-conventions).</span></span> <span data-ttu-id="247f0-271">Le nom est passé aux fonctions [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) pour spécifier l’élément dans le stockage sur lequel opérer.</span><span class="sxs-lookup"><span data-stu-id="247f0-271">The name is passed to [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) functions to specify which element in the storage to operate on.</span></span> <span data-ttu-id="247f0-272">Les noms des objets de stockage racine sont les mêmes que les noms de fichiers dans le système de fichiers sous-jacent, et ces noms doivent respecter les conventions et restrictions du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="247f0-272">Names of root storage objects are the same as file names in the underlying file system, and these names must follow the file system's conventions and restrictions.</span></span> <span data-ttu-id="247f0-273">Chaînes passées aux fonctions liées au stockage, dont les fichiers de noms sont transmis au système de fichiers sans interprétation ou modification.</span><span class="sxs-lookup"><span data-stu-id="247f0-273">Strings passed to storage-related functions which name files are passed through to the file system without interpretation or changes.</span></span>

<span data-ttu-id="247f0-274">Les noms des éléments contenus dans les objets de stockage sont gérés par l’implémentation de l’objet de stockage en question.</span><span class="sxs-lookup"><span data-stu-id="247f0-274">Names of elements that are contained within storage objects are managed by the implementation of the particular storage object in question.</span></span> <span data-ttu-id="247f0-275">Toutes les implémentations des objets de stockage doivent prendre en charge les noms d’éléments de 32 caractères, et certaines implémentations peuvent prendre en charge des noms plus longs.</span><span class="sxs-lookup"><span data-stu-id="247f0-275">All implementations of storage objects must support element names that are 32 characters in length, and some implementations may support longer names.</span></span> <span data-ttu-id="247f0-276">Les noms sont stockés avec la casse conservée, mais ils sont comparés comme ne respectant pas la casse.</span><span class="sxs-lookup"><span data-stu-id="247f0-276">Names are stored with case preserved, but they are compared as case-insensitive.</span></span> <span data-ttu-id="247f0-277">Les applications qui définissent les noms des éléments de stockage doivent choisir des noms qui fonctionnent dans les deux cas.</span><span class="sxs-lookup"><span data-stu-id="247f0-277">Applications that define storage element names must choose names that work in either situation.</span></span>

<span data-ttu-id="247f0-278">Vous accédez à chaque élément d’un fichier de stockage structuré en utilisant des fonctions et des interfaces implémentées par COM.</span><span class="sxs-lookup"><span data-stu-id="247f0-278">You access every element in a structured storage file by using functions and interfaces that are implemented by COM.</span></span> <span data-ttu-id="247f0-279">Cela signifie que d’autres applications peuvent parcourir le fichier en naviguant avec les fonctions d’interface [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) qui fournissent des services de type annuaire.</span><span class="sxs-lookup"><span data-stu-id="247f0-279">This means that other applications can browse the file by navigating with the [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) interface functions that provide directory-like services.</span></span> <span data-ttu-id="247f0-280">En outre, d’autres applications peuvent utiliser les données du fichier, sans avoir à exécuter l’application qui a écrit le fichier.</span><span class="sxs-lookup"><span data-stu-id="247f0-280">Also, other applications can use the file's data, without having to run the application that wrote the file.</span></span> <span data-ttu-id="247f0-281">Lorsqu’une application COM accède aux fichiers de stockage structurés d’une autre application, les droits d’accès Windows standard s’appliquent et l’application doit disposer de privilèges suffisants.</span><span class="sxs-lookup"><span data-stu-id="247f0-281">When a COM application accesses the structured storage files of another application, standard Windows access rights apply, and the application must have sufficient privileges.</span></span>

<span data-ttu-id="247f0-282">Un objet COM peut lire et écrire lui-même dans un stockage persistant.</span><span class="sxs-lookup"><span data-stu-id="247f0-282">A COM object can read and write itself to persistent storage.</span></span> <span data-ttu-id="247f0-283">Un client interroge l’une des interfaces relatives à la persistance sur l’objet COM, en fonction du contexte de l’opération.</span><span class="sxs-lookup"><span data-stu-id="247f0-283">A client queries for one of the persistence-related interfaces on the COM object, depending on the context of the operation.</span></span> <span data-ttu-id="247f0-284">Les objets COM peuvent implémenter n’importe quelle combinaison des interfaces suivantes :</span><span class="sxs-lookup"><span data-stu-id="247f0-284">COM objects can implement any combination of the following interfaces:</span></span>

-   <span data-ttu-id="247f0-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): l’objet com lit et écrit son état persistant dans un objet de stockage.</span><span class="sxs-lookup"><span data-stu-id="247f0-285">[**IPersistStorage**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): The COM object reads and writes its persistent state to a storage object.</span></span> <span data-ttu-id="247f0-286">Le client fournit l’objet avec un pointeur [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) via cette interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-286">The client provides the object with an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) pointer through this interface.</span></span> <span data-ttu-id="247f0-287">Il s’agit de la seule interface de persistance qui comprend la sémantique pour l’accès incrémentiel.</span><span class="sxs-lookup"><span data-stu-id="247f0-287">This is the only persistence interface that includes semantics for incremental access.</span></span>
-   <span data-ttu-id="247f0-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): l’objet com lit et écrit son état persistant dans un objet de flux.</span><span class="sxs-lookup"><span data-stu-id="247f0-288">[**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): The COM object reads and writes its persistent state to a stream object.</span></span> <span data-ttu-id="247f0-289">Le client fournit l’objet avec un pointeur [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) via cette interface.</span><span class="sxs-lookup"><span data-stu-id="247f0-289">The client provides the object with an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) pointer through this interface.</span></span>
-   <span data-ttu-id="247f0-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): l’objet com lit et écrit son état persistant directement dans un fichier sur le système sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="247f0-290">[**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): The COM object reads and writes its persistent state directly to a file on the underlying system.</span></span> <span data-ttu-id="247f0-291">Cette interface n’implique pas [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) ou [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , sauf si le fichier sous-jacent est accessible par le biais de ces interfaces, mais l’interface **IPersistFile** n’a aucune sémantique pour les stockages et les flux.</span><span class="sxs-lookup"><span data-stu-id="247f0-291">This interface does not involve [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) unless the underlying file is accessed through these interfaces, but the **IPersistFile** interface has no semantics for storages and streams.</span></span> <span data-ttu-id="247f0-292">Le client fournit l’objet avec un nom de fichier et appelle les fonctions [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) ou [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) .</span><span class="sxs-lookup"><span data-stu-id="247f0-292">The client provides the object with a file name and calls the [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) or [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) functions.</span></span>

## <a name="data-transfer"></a><span data-ttu-id="247f0-293">Transfert de données</span><span class="sxs-lookup"><span data-stu-id="247f0-293">Data Transfer</span></span>

<span data-ttu-id="247f0-294">Le stockage structuré fournit la base pour l’échange de données entre les processus et les objets COM, qui est nommé *transfert de données uniforme*.</span><span class="sxs-lookup"><span data-stu-id="247f0-294">Structured storage provides the basis for data exchange between COM objects and processes, which is named *uniform data transfer*.</span></span> <span data-ttu-id="247f0-295">Avant l’implémentation de COM dans OLE 2, le transfert de données sur Windows était spécifié par les *protocoles de transfert*, tels que le presse-papiers et les protocoles de glisser-déplacer.</span><span class="sxs-lookup"><span data-stu-id="247f0-295">Before COM was implemented in OLE 2, data transfer on Windows was specified by *transfer protocols*, such as the clipboard and drag-drop protocols.</span></span> <span data-ttu-id="247f0-296">Chaque protocole de transfert avait son propre ensemble de fonctions qui délimitent le protocole à la requête, et du code spécifique était nécessaire pour gérer chaque protocole et procédure d’échange.</span><span class="sxs-lookup"><span data-stu-id="247f0-296">Each transfer protocol had its own set of functions that bound the protocol to the query, and specific code was required to handle each different protocol and exchange procedure.</span></span> <span data-ttu-id="247f0-297">Le transfert de données uniforme représente tous les transferts de données à l’aide de l’interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) , qui sépare les opérations courantes d’échange de données du protocole de transfert.</span><span class="sxs-lookup"><span data-stu-id="247f0-297">Uniform data transfer represents all data transfers by using the [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface, which separates common data exchange operations from the transfer protocol.</span></span>

<span data-ttu-id="247f0-298">L’interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) encapsule les opérations d’extraction et de définition standard sur les données, les requêtes et les énumérations, et les notifications qui détectent le moment où les données sont modifiées dans un objet.</span><span class="sxs-lookup"><span data-stu-id="247f0-298">The [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface encapsulates the standard get and set operations on data, queries and enumerations, and notifications that detect when data changes in an object.</span></span> <span data-ttu-id="247f0-299">Le transfert de données uniforme permet une description détaillée des formats de données, ainsi que l’utilisation de différents supports de stockage pour le transfert de données.</span><span class="sxs-lookup"><span data-stu-id="247f0-299">Uniform data transfer enables rich descriptions of data formats, as well as the use of different storage media for the data transfer.</span></span>

<span data-ttu-id="247f0-300">Lors du transfert de données uniforme, tous les protocoles échangent un pointeur vers une interface [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) .</span><span class="sxs-lookup"><span data-stu-id="247f0-300">During uniform data transfer, all protocols exchange a pointer to an [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="247f0-301">Le serveur est la source des données et implémente un objet de données qui est utilisable dans tout protocole d’échange de données.</span><span class="sxs-lookup"><span data-stu-id="247f0-301">The server is the source of the data and implements one data object, which is usable in any data exchange protocol.</span></span> <span data-ttu-id="247f0-302">Le client consomme les données et demande des données à partir d’un objet de données lorsqu’il reçoit un pointeur **IDataObject** de n’importe quel protocole.</span><span class="sxs-lookup"><span data-stu-id="247f0-302">The client consumes the data and requests data from a data object when it receives an **IDataObject** pointer from any protocol.</span></span> <span data-ttu-id="247f0-303">Une fois l’échange de pointeur effectué, les deux côtés gèrent l’échange de données de manière uniforme, via l’interface **IDataObject** .</span><span class="sxs-lookup"><span data-stu-id="247f0-303">After the pointer exchange has occurred, both sides handle data exchange in a uniform fashion, through the **IDataObject** interface.</span></span>

<span data-ttu-id="247f0-304">COM définit deux structures de données qui permettent le transfert de données uniforme.</span><span class="sxs-lookup"><span data-stu-id="247f0-304">COM defines two data structures that enable uniform data transfer.</span></span> <span data-ttu-id="247f0-305">La structure [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) représente un format de presse-papiers généralisé, et la structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) représente le support de transfert sous la forme d’un handle de mémoire.</span><span class="sxs-lookup"><span data-stu-id="247f0-305">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure represents a generalized clipboard format, and the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure represents the transfer medium as a memory handle.</span></span>

<span data-ttu-id="247f0-306">Le client crée une structure [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) pour indiquer le type de données qu’il demande à partir d’une source de données, et il est utilisé par la source de données pour décrire les formats qu’il fournit.</span><span class="sxs-lookup"><span data-stu-id="247f0-306">The client creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to indicate the type of data that it requests from a data source, and it is used by the data source to describe what formats it provides.</span></span> <span data-ttu-id="247f0-307">Le client interroge une source de données à la recherche de ses formats disponibles en demandant son interface [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) .</span><span class="sxs-lookup"><span data-stu-id="247f0-307">The client queries a data source for its available formats by requesting its [**IEnumFORMATETC**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="247f0-308">Pour plus d’informations, consultez [la structure FORMATETC](the-formatetc-structure.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-308">For more information, see [The FORMATETC Structure](the-formatetc-structure.md).</span></span>

<span data-ttu-id="247f0-309">Le client crée une structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) et la passe à la méthode [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) , et l’objet de données retourne les données dans la structure **STGMEDIUM** fournie.</span><span class="sxs-lookup"><span data-stu-id="247f0-309">The client creates a [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure and passes it to the [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) method, and the data object returns the data in the provided **STGMEDIUM** structure.</span></span>

<span data-ttu-id="247f0-310">La structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) permet aux clients et aux sources de données de choisir le support Exchange le plus efficace.</span><span class="sxs-lookup"><span data-stu-id="247f0-310">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure enables both clients and data sources to choose the most efficient exchange medium.</span></span> <span data-ttu-id="247f0-311">Par exemple, si les données à échanger sont très volumineuses, la source de données peut indiquer un support sur disque comme format préféré, au lieu de la mémoire principale.</span><span class="sxs-lookup"><span data-stu-id="247f0-311">For example, if the data to be exchanged is very large, the data source can indicate a disk-based medium as its preferred format, instead of main memory.</span></span> <span data-ttu-id="247f0-312">Cette flexibilité permet d’échanger efficacement des données qui peuvent être aussi rapides que le passage d’un pointeur vers une [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) ou un [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span><span class="sxs-lookup"><span data-stu-id="247f0-312">This flexibility enables efficient data exchanges that can be as fast as passing a pointer to an [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) or an [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream).</span></span> <span data-ttu-id="247f0-313">Pour plus d’informations, consultez [la structure STGMEDIUM](the-stgmedium-structure.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-313">For more information, see [The STGMEDIUM Structure](the-stgmedium-structure.md).</span></span>

<span data-ttu-id="247f0-314">Un client d’une source de données peut nécessiter une notification lorsque les données sont modifiées.</span><span class="sxs-lookup"><span data-stu-id="247f0-314">A client of a data source may require notification when the data changes.</span></span> <span data-ttu-id="247f0-315">COM gère les notifications de modification de données à l’aide d’un objet de *récepteur* de notifications, qui implémente l’interface [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) .</span><span class="sxs-lookup"><span data-stu-id="247f0-315">COM handles data-change notifications by using an *advise sink* object, which implements the [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) interface.</span></span> <span data-ttu-id="247f0-316">L’objet de récepteur de notifications et l’interface **IAdviseSink** sont implémentés par le client, qui passe un pointeur **IAdviseSink** à la source de données.</span><span class="sxs-lookup"><span data-stu-id="247f0-316">The advise sink object and the **IAdviseSink** interface are implemented by the client, which passes an **IAdviseSink** pointer to the data source.</span></span> <span data-ttu-id="247f0-317">Lorsque la source de données détecte une modification apportée aux données sous-jacentes, elle appelle une méthode **IAdviseSink** pour notifier le client.</span><span class="sxs-lookup"><span data-stu-id="247f0-317">When the data source detects a change in the underlying data, it calls an **IAdviseSink** method to notify the client.</span></span> <span data-ttu-id="247f0-318">Pour plus d’informations, consultez [notification de données](data-notification.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-318">For more information, see [Data Notification](data-notification.md).</span></span>

## <a name="remoting"></a><span data-ttu-id="247f0-319">Communication à distance</span><span class="sxs-lookup"><span data-stu-id="247f0-319">Remoting</span></span>

<span data-ttu-id="247f0-320">COM active le calcul à distance et distribué.</span><span class="sxs-lookup"><span data-stu-id="247f0-320">COM enables remote and distributed computation.</span></span> <span data-ttu-id="247f0-321">La *communication à distance* de l’interface permet à une fonction membre de retourner un pointeur d’interface vers un objet com qui se trouve dans un processus différent ou sur un ordinateur hôte différent.</span><span class="sxs-lookup"><span data-stu-id="247f0-321">*Interface remoting* enables a member function to return an interface pointer to a COM object that is in a different process or on a different host computer.</span></span> <span data-ttu-id="247f0-322">L’infrastructure qui effectue la communication à distance de l’interface est transparente pour le client et le serveur d’objets.</span><span class="sxs-lookup"><span data-stu-id="247f0-322">The infrastructure that performs the interface remoting is transparent to both the client and the object server.</span></span> <span data-ttu-id="247f0-323">Ni le client ni le serveur n’ont besoin des détails de déploiement d’un autre pour communiquer via une interface distante.</span><span class="sxs-lookup"><span data-stu-id="247f0-323">Neither the client nor the server need one another's deployment details to communicate through a remoted interface.</span></span> <span data-ttu-id="247f0-324">Un client appelle des fonctions membres sur la même interface pour communiquer avec un objet COM qui est in-process, out-of-process sur l’hôte local ou sur un ordinateur distant.</span><span class="sxs-lookup"><span data-stu-id="247f0-324">A client calls member functions on the same interface to communicate with a COM object that is in-process, out-of-process on the local host, or on a remote computer.</span></span> <span data-ttu-id="247f0-325">Les appels locaux et distants sur la même interface ne peuvent pas être différenciés par le client.</span><span class="sxs-lookup"><span data-stu-id="247f0-325">Local and remote calls on the same interface are indistinguishable to the client.</span></span>

<span data-ttu-id="247f0-326">Pour communiquer avec un objet COM, un client appelle toujours une implémentation in-process.</span><span class="sxs-lookup"><span data-stu-id="247f0-326">To communicate with a COM object, a client always calls an in-process implementation.</span></span> <span data-ttu-id="247f0-327">Si l’objet COM est in-process, l’appel est direct.</span><span class="sxs-lookup"><span data-stu-id="247f0-327">If the COM object is in-process, the call is direct.</span></span> <span data-ttu-id="247f0-328">Si l’objet COM est hors processus ou distant, COM fournit une implémentation de *proxy* qui transfère l’appel à l’objet à l’aide du protocole d’appel de procédure distante (RPC).</span><span class="sxs-lookup"><span data-stu-id="247f0-328">If the COM object is out-of-process or remote, COM provides a *proxy* implementation that forwards the call to the object by using the Remote Procedure Call (RPC) protocol.</span></span>

<span data-ttu-id="247f0-329">Un objet COM reçoit toujours les appels d’un client par le biais d’une implémentation in-process.</span><span class="sxs-lookup"><span data-stu-id="247f0-329">A COM object always receives calls from a client through an in-process implementation.</span></span> <span data-ttu-id="247f0-330">Si l’appelant est in-process, l’appel est direct.</span><span class="sxs-lookup"><span data-stu-id="247f0-330">If the caller is in-process, the call is direct.</span></span> <span data-ttu-id="247f0-331">Si l’appelant est hors processus ou distant, COM fournit une implémentation de *stub* qui reçoit l’appel de procédure distante du proxy dans le processus client.</span><span class="sxs-lookup"><span data-stu-id="247f0-331">If the caller is out-of-process or remote, COM provides a *stub* implementation that receives the remote procedure call from the proxy in the client process.</span></span>

<span data-ttu-id="247f0-332">Le *marshaling* est la procédure permettant d’empaqueter la pile des appels pour la transmission du proxy au stub.</span><span class="sxs-lookup"><span data-stu-id="247f0-332">*Marshaling* is the procedure for packaging the call stack for transmission from proxy to stub.</span></span> <span data-ttu-id="247f0-333">Le *démarshaling* est le désassemblage qui se produit à la fin de la réception.</span><span class="sxs-lookup"><span data-stu-id="247f0-333">*Unmarshaling* is the unpackaging that occurs at the receiving end.</span></span> <span data-ttu-id="247f0-334">Les valeurs de retour sont marshalées et démarshalées du stub vers le proxy.</span><span class="sxs-lookup"><span data-stu-id="247f0-334">Return values are marshaled and unmarshaled from the stub to the proxy.</span></span> <span data-ttu-id="247f0-335">Ce type de communication est également appelé envoi d’un appel *sur le réseau*.</span><span class="sxs-lookup"><span data-stu-id="247f0-335">This kind of communication is also referred to as sending a call *over the wire*.</span></span>

<span data-ttu-id="247f0-336">Chaque type de données est associé à des règles de marshaling.</span><span class="sxs-lookup"><span data-stu-id="247f0-336">Each different data type has rules for marshaling.</span></span> <span data-ttu-id="247f0-337">Les pointeurs d’interface ont également un protocole de marshaling, qui est encapsulé dans la fonction [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) .</span><span class="sxs-lookup"><span data-stu-id="247f0-337">Interface pointers also have a marshaling protocol, which is encapsulated in the [**CoMarshalInterface**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) function.</span></span> <span data-ttu-id="247f0-338">Dans la plupart des cas, le *marshaling d’interface standard*, fourni par le système, est suffisant, mais un objet com peut éventuellement implémenter un *marshaling d’interface personnalisé* pour contrôler la création de proxys d’objets distants à lui-même.</span><span class="sxs-lookup"><span data-stu-id="247f0-338">In most cases, *standard interface marshaling*, which is provided by the system, is sufficient, but a COM object optionally may implement *custom interface marshaling* to control the creation of remote object proxies to itself.</span></span> <span data-ttu-id="247f0-339">Pour plus d’informations, consultez [communication entre les objets](inter-object-communication.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-339">For more information, see [Inter-Object Communication](inter-object-communication.md).</span></span>

## <a name="security"></a><span data-ttu-id="247f0-340">Sécurité</span><span class="sxs-lookup"><span data-stu-id="247f0-340">Security</span></span>

<span data-ttu-id="247f0-341">COM fournit deux formes de sécurité des applications.</span><span class="sxs-lookup"><span data-stu-id="247f0-341">COM provides two forms of application security.</span></span> <span data-ttu-id="247f0-342">L’une est la *sécurité d’activation*, qui spécifie la façon dont les nouveaux objets sont créés, la façon dont les clients se connectent aux objets nouveaux et existants, ainsi que la façon dont certains services publics, tels que la table de classes et la table d’objets en cours d’exécution, sont sécurisés.</span><span class="sxs-lookup"><span data-stu-id="247f0-342">One is *activation security*, which specifies how new objects are created, how clients connect to new and existing objects, and how certain public services, such as the Class Table and the Running Object Table are secured.</span></span> <span data-ttu-id="247f0-343">L’autre est *appeler Security*, qui spécifie comment la sécurité opère dans une connexion établie entre un client et un objet com.</span><span class="sxs-lookup"><span data-stu-id="247f0-343">The other is *call security*, which specifies how security operates in an established connection between a client to a COM object.</span></span>

<span data-ttu-id="247f0-344">La sécurité d’activation est appliquée automatiquement par le gestionnaire de contrôle des services (SCM).</span><span class="sxs-lookup"><span data-stu-id="247f0-344">Activation security is applied automatically by the Service Control Manager (SCM).</span></span> <span data-ttu-id="247f0-345">Lorsque le SCM reçoit une demande de récupération d’un objet COM, il vérifie la demande par rapport aux informations de sécurité stockées dans le registre.</span><span class="sxs-lookup"><span data-stu-id="247f0-345">When the SCM receives a request to retrieve a COM object, it checks the request against security information that is stored in the registry.</span></span>

<span data-ttu-id="247f0-346">Les implémentations SCM offrent généralement une configuration basée sur le registre pour l’administration des classes déployées et pour des comptes d’utilisateur spécifiques sur l’ordinateur hôte.</span><span class="sxs-lookup"><span data-stu-id="247f0-346">SCM implementations usually offer registry-driven configuration for administering deployed classes and for specific user accounts on the host.</span></span> <span data-ttu-id="247f0-347">Pour plus d’informations, consultez [sécurité de l’activation](activation-security.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-347">For more information, see [Activation Security](activation-security.md).</span></span>

<span data-ttu-id="247f0-348">La sécurité de l’appel est appliquée automatiquement ou est appliquée par l’application.</span><span class="sxs-lookup"><span data-stu-id="247f0-348">Call security is applied automatically or is enforced by the application.</span></span> <span data-ttu-id="247f0-349">Si l’application fournit des informations d’installation, COM effectue les vérifications nécessaires pour sécuriser l’application.</span><span class="sxs-lookup"><span data-stu-id="247f0-349">If the application provides setup information, COM performs the necessary checks to secure the application.</span></span>

<span data-ttu-id="247f0-350">Le mécanisme automatique vérifie la sécurité pour le processus, mais pas pour les objets ou méthodes individuels.</span><span class="sxs-lookup"><span data-stu-id="247f0-350">The automatic mechanism checks security for the process, but not for individual objects or methods.</span></span> <span data-ttu-id="247f0-351">Si une application nécessite une sécurité plus précise, COM fournit des fonctions que les applications peuvent utiliser pour effectuer leur propre vérification de sécurité.</span><span class="sxs-lookup"><span data-stu-id="247f0-351">If an application requires more fine-grained security, COM provides functions that applications may use do their own security checking.</span></span>

<span data-ttu-id="247f0-352">Les mécanismes automatiques et personnalisés peuvent être utilisés ensemble, de sorte qu’une application peut demander à COM de procéder à la vérification de la sécurité automatique, puis de l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="247f0-352">The automatic and custom mechanisms can be used together, so an application may ask COM to perform automatic security checking and then perform its own.</span></span>

<span data-ttu-id="247f0-353">Les services de sécurité des appels COM sont répartis dans les catégories suivantes :</span><span class="sxs-lookup"><span data-stu-id="247f0-353">COM call security services are divided into the following categories:</span></span>

-   <span data-ttu-id="247f0-354">Fonctions générales qui sont appelées par les clients et les serveurs, ce qui permet au mécanisme de sécurité automatique d’être inscrit et d’inscrire les services d’authentification automatique.</span><span class="sxs-lookup"><span data-stu-id="247f0-354">General functions that are called by both clients and servers, which enable the automatic security mechanism to be initialized and automatic authentication services to be registered.</span></span> <span data-ttu-id="247f0-355">Les API de sécurité d’appel générales sont les fonctions [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) et [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) .</span><span class="sxs-lookup"><span data-stu-id="247f0-355">The general call security APIs are the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) and [**CoQueryAuthenticationServices**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) functions.</span></span>
-   <span data-ttu-id="247f0-356">Interfaces sur les proxys clients, qui permettent au client de contrôler la sécurité sur les appels à des interfaces individuelles.</span><span class="sxs-lookup"><span data-stu-id="247f0-356">Interfaces on client proxies, which enable the client to control the security on calls to individual interfaces.</span></span> <span data-ttu-id="247f0-357">L’interface [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) et les fonctions [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)et [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) fournissent la sécurité de l’appel sur un objet distant.</span><span class="sxs-lookup"><span data-stu-id="247f0-357">The [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface and the [**CoQueryProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), and [**CoCopyProxy**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) functions provide call security on a remote object.</span></span>
-   <span data-ttu-id="247f0-358">Les fonctions côté serveur et les interfaces de contexte d’appel, qui permettent au serveur de récupérer les informations de sécurité relatives à un appel et d’emprunter l’identité de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="247f0-358">Server-side functions and call-context interfaces, which enable the server to retrieve security information about a call and to impersonate the caller.</span></span> <span data-ttu-id="247f0-359">L’interface [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) et les fonctions [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient)et [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) fournissent la sécurité de l’appel côté serveur.</span><span class="sxs-lookup"><span data-stu-id="247f0-359">The [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface and the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**CoImpersonateClient**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient), and [**CoRevertToSelf**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) functions provide server-side call security.</span></span>

<span data-ttu-id="247f0-360">Souvent, le client interroge l’objet COM pour l’interface [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) , qui est implémentée localement par la couche de communication à distance.</span><span class="sxs-lookup"><span data-stu-id="247f0-360">Often, the client queries the COM object for the [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) interface, which is implemented locally by the remoting layer.</span></span> <span data-ttu-id="247f0-361">Le client utilise cette interface pour contrôler la sécurité des proxies d’interface individuels sur l’objet COM avant d’effectuer un appel sur l’une des interfaces.</span><span class="sxs-lookup"><span data-stu-id="247f0-361">The client uses this interface to control the security of individual interface proxies on the COM object before making a call on one of the interfaces.</span></span>

<span data-ttu-id="247f0-362">Lorsqu’un appel arrive sur le serveur, le serveur peut appeler la fonction [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) pour récupérer une interface [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) , ce qui permet au serveur de vérifier l’authentification du client et d’emprunter l’identité du client, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="247f0-362">When a call arrives at the server, the server may call the [**CoGetCallContext**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) function to retrieve an [**IServerSecurity**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) interface, which allows the server to check the client's authentication and to impersonate the client, if necessary.</span></span> <span data-ttu-id="247f0-363">L’objet **IServerSecurity** est valide pour la durée de l’appel.</span><span class="sxs-lookup"><span data-stu-id="247f0-363">The **IServerSecurity** object is valid for the duration of the call.</span></span>

<span data-ttu-id="247f0-364">Appelez la fonction [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) pour initialiser la couche de sécurité et définir les valeurs spécifiées comme valeur par défaut de sécurité.</span><span class="sxs-lookup"><span data-stu-id="247f0-364">Call the [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) function to initialize the security layer and set the specified values as the security default.</span></span> <span data-ttu-id="247f0-365">Si un processus n’appelle pas **CoInitializeSecurity**, com l’appelle automatiquement la première fois qu’une interface est marshalée ou démarshalée, en inscrivant la sécurité par défaut du système.</span><span class="sxs-lookup"><span data-stu-id="247f0-365">If a process does not call **CoInitializeSecurity**, COM calls it automatically the first time an interface is marshaled or unmarshaled, registering the system default security.</span></span> <span data-ttu-id="247f0-366">La fonction **CoInitializeSecurity** permet au client d’établir la sécurité de l’appel par défaut pour le processus, ce qui évite l’utilisation de [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) sur des proxies individuels.</span><span class="sxs-lookup"><span data-stu-id="247f0-366">The **CoInitializeSecurity** function allows the client to establish default call security for the process, which avoids the use of [**IClientSecurity**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) on individual proxies.</span></span> <span data-ttu-id="247f0-367">La fonction **CoInitializeSecurity** permet à un serveur d’inscrire des services d’authentification automatique pour le processus.</span><span class="sxs-lookup"><span data-stu-id="247f0-367">The **CoInitializeSecurity** function enables a server to register automatic authentication services for the process.</span></span> <span data-ttu-id="247f0-368">Pour plus d’informations, consultez [Setting Process-Wide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span><span class="sxs-lookup"><span data-stu-id="247f0-368">For more information, see [Setting Process-Wide Security with CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="247f0-369">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="247f0-369">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="247f0-370">Clients et serveurs COM</span><span class="sxs-lookup"><span data-stu-id="247f0-370">COM Clients and Servers</span></span>](com-clients-and-servers.md)
</dt> <dt>

[<span data-ttu-id="247f0-371">Définition d’interfaces COM</span><span class="sxs-lookup"><span data-stu-id="247f0-371">Defining COM Interfaces</span></span>](defining-com-interfaces.md)
</dt> <dt>

[<span data-ttu-id="247f0-372">Inscription des applications COM</span><span class="sxs-lookup"><span data-stu-id="247f0-372">Registering COM Applications</span></span>](registering-com-applications.md)
</dt> <dt>

[<span data-ttu-id="247f0-373">Sécurité dans COM</span><span class="sxs-lookup"><span data-stu-id="247f0-373">Security in COM</span></span>](security-in-com.md)
</dt> <dt>

[<span data-ttu-id="247f0-374">Processus, threads et Apartments</span><span class="sxs-lookup"><span data-stu-id="247f0-374">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> </dl>

 

 
