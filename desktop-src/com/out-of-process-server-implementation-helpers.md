---
title: Assistances pour l’implémentation de serveur hors processus
description: Assistances pour l’implémentation de serveur hors processus
ms.assetid: 18641a84-56f8-4d27-9ddb-fa64011ac8ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 264d3f26b179b3ecb659ef93785c8c223b6c524e
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382975"
---
# <a name="out-of-process-server-implementation-helpers"></a><span data-ttu-id="c435a-103">Assistances pour l’implémentation de serveur hors processus</span><span class="sxs-lookup"><span data-stu-id="c435a-103">Out-of-Process Server Implementation Helpers</span></span>

<span data-ttu-id="c435a-104">Quatre fonctions d’assistance qui peuvent être appelées par des serveurs hors processus sont disponibles pour simplifier le travail d’écriture de code serveur.</span><span class="sxs-lookup"><span data-stu-id="c435a-104">Four helper functions that can be called by out-of-process servers are available to simplify the job of writing server code.</span></span> <span data-ttu-id="c435a-105">En général, les clients COM et les serveurs COM in-process ne les appellent pas.</span><span class="sxs-lookup"><span data-stu-id="c435a-105">COM clients and COM in-process servers typically would not call them.</span></span> <span data-ttu-id="c435a-106">Ces fonctions sont conçues pour aider à éviter les conditions de concurrence dans l’activation du serveur lorsque les serveurs comportent plusieurs cloisonnements ou plusieurs objets de classe.</span><span class="sxs-lookup"><span data-stu-id="c435a-106">These functions are designed to help prevent race conditions in server activation when the servers have multiple apartments or multiple class objects.</span></span> <span data-ttu-id="c435a-107">Ils peuvent également être utilisés aussi facilement pour les serveurs d’objets à un seul thread et à classe unique.</span><span class="sxs-lookup"><span data-stu-id="c435a-107">They can also, however, as easily be used for single-threaded and single class object servers.</span></span> <span data-ttu-id="c435a-108">Les fonctions sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="c435a-108">The functions are as follows:</span></span>

-   [<span data-ttu-id="c435a-109">**CoAddRefServerProcess**</span><span class="sxs-lookup"><span data-stu-id="c435a-109">**CoAddRefServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess)
-   [<span data-ttu-id="c435a-110">**CoReleaseServerProcess**</span><span class="sxs-lookup"><span data-stu-id="c435a-110">**CoReleaseServerProcess**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)
-   [<span data-ttu-id="c435a-111">**CoSuspendClassObjects**</span><span class="sxs-lookup"><span data-stu-id="c435a-111">**CoSuspendClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects)
-   [<span data-ttu-id="c435a-112">**CoResumeClassObjects**</span><span class="sxs-lookup"><span data-stu-id="c435a-112">**CoResumeClassObjects**</span></span>](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects)

<span data-ttu-id="c435a-113">Pour s’arrêter correctement, un serveur COM doit effectuer le suivi du nombre d’instances d’objet qu’il a instanciées et du nombre de fois que sa méthode [**IClassFactory :: LockServer,**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) a été appelée.</span><span class="sxs-lookup"><span data-stu-id="c435a-113">To shut down properly, a COM server must keep track of how many object instances it has instantiated and how many times its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method has been called.</span></span> <span data-ttu-id="c435a-114">Ce n’est que lorsque ces deux nombres atteignent la valeur zéro et que le serveur est arrêté.</span><span class="sxs-lookup"><span data-stu-id="c435a-114">Only when both of these counts reach zero can a server shut down.</span></span> <span data-ttu-id="c435a-115">Dans les serveurs COM monothread, la décision d’arrêter a été coordonnée avec les demandes d’activation entrantes, qui ont été sérialisées par la file d’attente de messages.</span><span class="sxs-lookup"><span data-stu-id="c435a-115">In single-threaded COM servers, the decision to shut down was coordinated with incoming activation requests, which were serialized by the message queue.</span></span> <span data-ttu-id="c435a-116">Le serveur, lors de la réception d’une version sur son instance d’objet finale et de la décision d’arrêter, révoque ses objets de classe avant la distribution d’autres demandes d’activation.</span><span class="sxs-lookup"><span data-stu-id="c435a-116">The server, upon receiving a release on its final object instance and deciding to shut down, would revoke its class objects before any more activation requests were dispatched.</span></span> <span data-ttu-id="c435a-117">Si une demande d’activation a été envoyée après ce point, COM reconnaît que les objets de classe ont été révoqués et retournerait une erreur au gestionnaire de contrôle des services, ce qui entraînerait l’exécution d’une nouvelle instance du processus serveur local.</span><span class="sxs-lookup"><span data-stu-id="c435a-117">If an activation request did come in after this point, COM would recognize that the class objects were revoked and would return an error to the Service Control Manager (SCM), which would then cause a new instance of the local server process to be run.</span></span>

<span data-ttu-id="c435a-118">Toutefois, dans un serveur de modèles cloisonnés, dans lequel des objets de classe différents sont inscrits sur différents cloisonnements, et dans tous les serveurs à thread libre, cette décision d’arrêt doit être coordonnée avec les demandes d’activation sur plusieurs threads afin qu’un thread du serveur ne décide pas de s’arrêter alors qu’un autre thread du serveur est occupé à traiter des objets de classe ou des</span><span class="sxs-lookup"><span data-stu-id="c435a-118">However, in an apartment model server, in which different class objects are registered on different apartments, and in all free-threaded servers, this decision to shut down must be coordinated with activation requests across multiple threads so that one thread of the server does not decide to shut down while another thread of the server is busy handing out class objects or object instances.</span></span> <span data-ttu-id="c435a-119">Une approche classique mais difficile à résoudre consiste à avoir le serveur, après avoir révoqué ses objets de classe, revérifier son nombre d’instances et rester actif jusqu’à ce que toutes les instances aient été libérées.</span><span class="sxs-lookup"><span data-stu-id="c435a-119">One classical but cumbersome approach to solving this is to have the server, after it has revoked its class objects, recheck its instance count and stay alive until all instances have been released.</span></span>

<span data-ttu-id="c435a-120">Pour faciliter la gestion de ces types de conditions de concurrence pour les rédacteurs de serveur, COM fournit deux fonctions de décompte de références :</span><span class="sxs-lookup"><span data-stu-id="c435a-120">To make it easier for server writers to handle these types of race conditions, COM provides two reference counting functions:</span></span>

-   <span data-ttu-id="c435a-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) incrémente un décompte de références globales par processus.</span><span class="sxs-lookup"><span data-stu-id="c435a-121">[**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) increments a global per-process reference count.</span></span>
-   <span data-ttu-id="c435a-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) décrémente le décompte de références globales par processus.</span><span class="sxs-lookup"><span data-stu-id="c435a-122">[**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) decrements the global per-process reference count.</span></span>

<span data-ttu-id="c435a-123">Lorsque le nombre de références globales par processus atteint zéro, COM appelle automatiquement [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), ce qui empêche toute nouvelle demande d’activation d’entrer dans.</span><span class="sxs-lookup"><span data-stu-id="c435a-123">When the global per-process reference count reaches zero, COM automatically calls [**CoSuspendClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-cosuspendclassobjects), which prevents any new activation requests from coming in.</span></span> <span data-ttu-id="c435a-124">Le serveur peut ensuite annuler l’inscription de ses différents objets de classe à partir de ses différents threads, sans craindre qu’une autre demande d’activation arrive.</span><span class="sxs-lookup"><span data-stu-id="c435a-124">The server can then deregister its various class objects from its various threads at leisure without worry that another activation request may come in.</span></span> <span data-ttu-id="c435a-125">Toutes les nouvelles demandes d’activation sont désormais gérées par le SCM lançant une nouvelle instance du processus serveur local.</span><span class="sxs-lookup"><span data-stu-id="c435a-125">All new activation requests are henceforth handled by the SCM launching a new instance of the local server process.</span></span>

<span data-ttu-id="c435a-126">Le moyen le plus simple pour une application serveur locale d’utiliser ces fonctions consiste à appeler [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) dans le constructeur pour chacun de ses objets d’instance et dans chacune de ses méthodes [**IClassFactory :: LockServer,**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) lorsque le paramètre de *troupeau* a la **valeur true**.</span><span class="sxs-lookup"><span data-stu-id="c435a-126">The simplest way for a local server application to make use of these functions is to call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) in the constructor for each of its instance objects and in each of its [**IClassFactory::LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) methods when the *fLock* parameter is **TRUE**.</span></span> <span data-ttu-id="c435a-127">L’application serveur doit également appeler [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) dans le destructeur de chacun de ses objets d’instance et dans chacune de ses méthodes IClassFactory ::**LockServer,** lorsque le paramètre de *troupeau* a la **valeur false**.</span><span class="sxs-lookup"><span data-stu-id="c435a-127">The server application should also call [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess) in the destructor of each of its instance objects and in each of its IClassFactory::**LockServer** methods when the *fLock* parameter is **FALSE**.</span></span>

<span data-ttu-id="c435a-128">Enfin, l’application serveur doit prêter attention au code de retour de [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess)et, si elle retourne 0, l’application serveur doit lancer son nettoyage, qui, pour un serveur avec plusieurs threads, signifie généralement qu’elle doit signaler ses différents threads pour quitter leurs boucles de message et appeler [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) et [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span><span class="sxs-lookup"><span data-stu-id="c435a-128">Finally, the server application should pay attention to the return code from [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess), and if it returns 0, the server application should initiate its cleanup, which, for a server with multiple threads, typically means that it should signal its various threads to exit their message loops and call [**CoAddRefServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coaddrefserverprocess) and [**CoReleaseServerProcess**](/windows/desktop/api/combaseapi/nf-combaseapi-coreleaseserverprocess).</span></span> <span data-ttu-id="c435a-129">Si les fonctions de gestion de la durée de vie des processus serveur sont utilisées, elles doivent être utilisées dans les instances d’objet et la méthode [**LockServer,**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) ; dans le cas contraire, l’application serveur peut être arrêtée prématurément.</span><span class="sxs-lookup"><span data-stu-id="c435a-129">If the server process lifetime management functions are used, they must be used in both the object instances and the [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) method; otherwise, the server application may be shut down prematurely.</span></span>

<span data-ttu-id="c435a-130">Quand une demande [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) est effectuée, com contacte le serveur, marshale l’interface [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) de l’objet de classe, retourne au processus client, démarshale l’interface **IClassFactory** et le retourne au client.</span><span class="sxs-lookup"><span data-stu-id="c435a-130">When a [**CoGetClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) request is made, COM contacts the server, marshals the [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) interface of the class object, returns to the client process, unmarshals the **IClassFactory** interface, and returns this to the client.</span></span> <span data-ttu-id="c435a-131">À ce stade, les clients appellent généralement [**LockServer,**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) avec la **valeur true** pour empêcher l’arrêt du processus serveur.</span><span class="sxs-lookup"><span data-stu-id="c435a-131">At this point, clients typically call [**LockServer**](/windows/win32/api/unknwn/nf-unknwn-iclassfactory-lockserver) with **TRUE** to prevent the server process from shutting down.</span></span> <span data-ttu-id="c435a-132">Toutefois, il existe un délai entre le moment où l’objet de classe est marshalé et celui où le client appelle **LockServer,** dans lequel un autre client peut se connecter au même serveur, obtenir une instance et libérer cette instance, provoquant ainsi l’arrêt du serveur et la sortie du premier client et son séchage avec un pointeur **IClassFactory** déconnecté.</span><span class="sxs-lookup"><span data-stu-id="c435a-132">However, there is a window of time between when the class object is marshaled and when the client calls **LockServer** in which another client could connect to the same server, get an instance, and release that instance, thus causing the server to shut down and leaving the first client high and dry with a disconnected **IClassFactory** pointer.</span></span> <span data-ttu-id="c435a-133">Pour éviter cette condition de concurrence, COM ajoute un appel implicite à **LockServer,** avec la **valeur true** à l’objet de classe lorsqu’il marshale l’interface **IClassFactory** et un appel implicite à **LockServer,** avec la **valeur false** lorsque le client libère l’interface **IClassFactory** .</span><span class="sxs-lookup"><span data-stu-id="c435a-133">To prevent this race condition, COM adds an implicit call to **LockServer** with **TRUE** to the class object when it marshals the **IClassFactory** interface and an implicit call to **LockServer** with **FALSE** when the client releases the **IClassFactory** interface.</span></span> <span data-ttu-id="c435a-134">Par conséquent, il n’est pas nécessaire de rappeler à distance **LockServer,** sur le serveur, et le proxy pour **LockServer,** retourne simplement S \_ OK sans la communication à distance effective de l’appel.</span><span class="sxs-lookup"><span data-stu-id="c435a-134">Therefore, it is not necessary to remote **LockServer** calls back to the server, and the proxy for **LockServer** simply returns S\_OK without actually remoting the call.</span></span>

<span data-ttu-id="c435a-135">Il existe une autre condition de concurrence liée à l’activation lors de l’initialisation d’un processus serveur hors processus.</span><span class="sxs-lookup"><span data-stu-id="c435a-135">There is another activation-related race condition during initialization of an out-of-process server process.</span></span> <span data-ttu-id="c435a-136">Un serveur COM qui inscrit plusieurs classes appelle en général [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) avec \_ \_ le serveur local REGCLS pour chaque CLSID qu’il prend en charge.</span><span class="sxs-lookup"><span data-stu-id="c435a-136">A COM server that registers multiple classes typically calls [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER for each CLSID it supports.</span></span> <span data-ttu-id="c435a-137">Après avoir effectué cette opération pour toutes les classes, le serveur entre dans sa boucle de message.</span><span class="sxs-lookup"><span data-stu-id="c435a-137">After it has done this for all classes, the server enters its message loop.</span></span> <span data-ttu-id="c435a-138">Pour un serveur COM à thread unique, toutes les demandes d’activation sont bloquées jusqu’à ce que le serveur entre dans la boucle de message.</span><span class="sxs-lookup"><span data-stu-id="c435a-138">For a single-threaded COM server, all activation requests are blocked until the server enters the message loop.</span></span> <span data-ttu-id="c435a-139">Toutefois, pour un serveur de modèle cloisonné qui inscrit des objets de classe différents dans différents cloisonnements et pour tous les serveurs à threads libres, les demandes d’activation peuvent arriver plus tôt que cela.</span><span class="sxs-lookup"><span data-stu-id="c435a-139">However, for an apartment model server that registers different class objects in different apartments and for all free-threaded servers, activation requests can arrive earlier than this.</span></span> <span data-ttu-id="c435a-140">Dans le cas de serveurs de modèles cloisonnés, les demandes d’activation peuvent arriver dès qu’un thread a entré sa boucle de message.</span><span class="sxs-lookup"><span data-stu-id="c435a-140">In the case of apartment model servers, activation requests could arrive as soon as any one thread has entered its message loop.</span></span> <span data-ttu-id="c435a-141">Dans le cas de serveurs à threads libres, une demande d’activation peut arriver dès que le premier objet de classe est inscrit.</span><span class="sxs-lookup"><span data-stu-id="c435a-141">In the case of free-threaded servers, an activation request could arrive as soon as the first class object is registered.</span></span> <span data-ttu-id="c435a-142">Dans la mesure où une activation peut se produire au début, il est également possible que la version finale se produise (et par conséquent provoque l’arrêt du serveur) avant que le reste du serveur ait pu terminer l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="c435a-142">Since an activation can happen this early, it is also possible for the final release to occur (and therefore cause the server to begin shutting down) before the rest of the server has had a chance to finish initializing.</span></span>

<span data-ttu-id="c435a-143">Pour éliminer ces conditions de concurrence et simplifier la tâche de l’enregistreur de serveur, n’importe quel serveur qui souhaite inscrire plusieurs objets de classe avec COM doit appeler [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) avec \_ \_ le serveur local REGCLS \| REGCLS \_ suspendu pour chaque CLSID différent pris en charge par le serveur.</span><span class="sxs-lookup"><span data-stu-id="c435a-143">To eliminate these race conditions and simplify the job of the server writer, any server that wants to register multiple class objects with COM should call [**CoRegisterClassObject**](/windows/desktop/api/combaseapi/nf-combaseapi-coregisterclassobject) with REGCLS\_LOCAL\_SERVER \| REGCLS\_SUSPENDED for each different CLSID the server supports.</span></span> <span data-ttu-id="c435a-144">Une fois que toutes les classes ont été inscrites et que le processus serveur est prêt à accepter les demandes d’activation entrantes, le serveur doit effectuer un appel à [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span><span class="sxs-lookup"><span data-stu-id="c435a-144">After all classes have been registered and the server process is ready to accept incoming activation requests, the server should make one call to [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects).</span></span> <span data-ttu-id="c435a-145">Cette fonction indique à COM d’informer le SCM sur toutes les classes inscrites, et il commence à autoriser les demandes d’activation dans le processus serveur.</span><span class="sxs-lookup"><span data-stu-id="c435a-145">This function tells COM to inform the SCM about all the registered classes, and it begins letting activation requests into the server process.</span></span> <span data-ttu-id="c435a-146">L’utilisation de ces fonctions offre les avantages suivants :</span><span class="sxs-lookup"><span data-stu-id="c435a-146">Using these functions provides the following advantages:</span></span>

-   <span data-ttu-id="c435a-147">Un seul appel est adressé au SCM, quel que soit le nombre de CLSID inscrits, ce qui réduit le temps d’enregistrement global (et donc le temps de démarrage de l’application serveur).</span><span class="sxs-lookup"><span data-stu-id="c435a-147">Only one call is made to the SCM, regardless of how many CLSIDs are registered, thus reducing the overall registration time (and hence startup time of the server application).</span></span>
-   <span data-ttu-id="c435a-148">Si le serveur possède plusieurs cloisonnements et que différents CLSID sont inscrits dans des cloisonnements différents, ou si le serveur est un serveur libre de threads, aucune demande d’activation ne se produira jusqu’à ce que le serveur appelle [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), ce qui permet au serveur d’inscrire tous ses CLSID et d’être correctement configuré avant d’avoir à gérer les demandes d’activation et les demandes d’arrêt possibles.</span><span class="sxs-lookup"><span data-stu-id="c435a-148">If the server has multiple apartments and different CLSIDs are registered in different apartments, or if the server is a free-threaded server, no activation requests will come in until the server calls [**CoResumeClassObjects**](/windows/desktop/api/combaseapi/nf-combaseapi-coresumeclassobjects), giving the server a chance to register all of its CLSIDs and get properly set up before having to deal with activation requests and possible shut down requests.</span></span>

## <a name="related-topics"></a><span data-ttu-id="c435a-149">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="c435a-149">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="c435a-150">Responsabilités du serveur COM</span><span class="sxs-lookup"><span data-stu-id="c435a-150">COM Server Responsibilities</span></span>](com-server-responsibilities.md)
</dt> </dl>

 

 