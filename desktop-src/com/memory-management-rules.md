---
title: Règles de gestion de la mémoire
description: Règles de gestion de la mémoire
ms.assetid: 769127a1-1a14-4ed4-9d38-7cf3e571b661
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56e7ad2483b794ec5c2e9c325bca8e469ff4ae0b
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104102440"
---
# <a name="memory-management-rules"></a><span data-ttu-id="296b2-103">Règles de gestion de la mémoire</span><span class="sxs-lookup"><span data-stu-id="296b2-103">Memory Management Rules</span></span>

<span data-ttu-id="296b2-104">La durée de vie des pointeurs vers les interfaces est toujours gérée par le biais des méthodes [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) et [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) sur chaque interface com.</span><span class="sxs-lookup"><span data-stu-id="296b2-104">The lifetime of pointers to interfaces is always managed through the [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) methods on every COM interface.</span></span> <span data-ttu-id="296b2-105">Pour plus d’informations, consultez [règles de gestion des décomptes de références](rules-for-managing-reference-counts.md).</span><span class="sxs-lookup"><span data-stu-id="296b2-105">For more information, see [Rules for Managing Reference Counts](rules-for-managing-reference-counts.md).</span></span>

<span data-ttu-id="296b2-106">Pour tous les autres paramètres, il est important d’adhérer à certaines règles de gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="296b2-106">For all other parameters, it is important to adhere to certain rules for managing memory.</span></span> <span data-ttu-id="296b2-107">Les règles suivantes s’appliquent à tous les paramètres de l’interface MethodsÂ, y compris les valueâ de retour, qui ne sont pas passés par valeur :</span><span class="sxs-lookup"><span data-stu-id="296b2-107">The following rules apply to all parameters of interface methodsâ€”including the return valueâ€”that are not passed by value:</span></span>

-   <span data-ttu-id="296b2-108">Les paramètres in doivent être alloués et libérés par l’appelant.</span><span class="sxs-lookup"><span data-stu-id="296b2-108">In-parameters must be allocated and freed by the caller.</span></span>
-   <span data-ttu-id="296b2-109">Les paramètres out doivent être alloués par celui appelé ; ils sont libérés par l’appelant à l’aide de l’allocateur de mémoire de tâche COM standard.</span><span class="sxs-lookup"><span data-stu-id="296b2-109">Out-parameters must be allocated by the one called; they are freed by the caller using the standard COM task memory allocator.</span></span> <span data-ttu-id="296b2-110">Pour plus d’informations, consultez [l’allocation de mémoire OLE](the-ole-memory-allocator.md) .</span><span class="sxs-lookup"><span data-stu-id="296b2-110">See [The OLE Memory Allocator](the-ole-memory-allocator.md) for more information.</span></span>
-   <span data-ttu-id="296b2-111">In/out : les paramètres sont initialement alloués par l’appelant, puis libérés et réalloués par celui-ci, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="296b2-111">In/out-parameters are initially allocated by the caller, and then freed and reallocated by the one called, if necessary.</span></span> <span data-ttu-id="296b2-112">Comme c’est le cas pour les paramètres out, l’appelant est responsable de la libération de la valeur finale retournée.</span><span class="sxs-lookup"><span data-stu-id="296b2-112">As is true for out parameters, the caller is responsible for freeing the final returned value.</span></span> <span data-ttu-id="296b2-113">L’allocateur de mémoire COM standard doit être utilisé.</span><span class="sxs-lookup"><span data-stu-id="296b2-113">The standard COM memory allocator must be used.</span></span>

<span data-ttu-id="296b2-114">Dans les deux derniers cas, où un morceau de code alloue la mémoire et un morceau de code différent le libère, l’utilisation de l’allocateur COM permet de s’assurer que les deux parties du code utilisent les mêmes méthodes d’allocation.</span><span class="sxs-lookup"><span data-stu-id="296b2-114">In the latter two cases, where one piece of code allocates the memory and a different piece of code frees it, using the COM allocator ensures that the two pieces of code are using the same allocation methods.</span></span>

<span data-ttu-id="296b2-115">Un autre domaine nécessitant une attention particulière est le traitement des paramètres out et out en cas de défaillance.</span><span class="sxs-lookup"><span data-stu-id="296b2-115">Another area that needs special attention is the treatment of out and in-out parameters in failure conditions.</span></span> <span data-ttu-id="296b2-116">Si une fonction retourne un code d’échec, l’appelant n’a généralement aucun moyen de nettoyer les paramètres out ou out.</span><span class="sxs-lookup"><span data-stu-id="296b2-116">If a function returns a failure code, the caller typically has no way to clean up the out or in-out parameters.</span></span> <span data-ttu-id="296b2-117">Cela provoque les règles supplémentaires suivantes :</span><span class="sxs-lookup"><span data-stu-id="296b2-117">This leads to the following additional rules:</span></span>

-   <span data-ttu-id="296b2-118">En cas de condition d’erreur, les paramètres doivent toujours être définis de manière fiable sur une valeur qui sera nettoyée sans aucune action de l’appelant.</span><span class="sxs-lookup"><span data-stu-id="296b2-118">In case of an error condition, parameters must always be reliably set to a value that will be cleaned up without any action by the caller.</span></span>
-   <span data-ttu-id="296b2-119">Tous les paramètres de point de sortie doivent avoir explicitement la valeur **null**.</span><span class="sxs-lookup"><span data-stu-id="296b2-119">All out pointer parameters must explicitly be set to **NULL**.</span></span> <span data-ttu-id="296b2-120">Elles sont généralement passées dans un paramètre pointeur vers pointeur, mais peuvent également être passées en tant que membres d’une structure que l’appelant alloue et que le code appelé remplit.</span><span class="sxs-lookup"><span data-stu-id="296b2-120">These are usually passed in a pointer-to-pointer parameter but can also be passed as members of a structure that the caller allocates and the called code fills.</span></span> <span data-ttu-id="296b2-121">Le moyen le plus simple de s’en assurer est (en partie) de définir ces valeurs sur **null** dans l’entrée de la fonction.</span><span class="sxs-lookup"><span data-stu-id="296b2-121">The most straightforward way to ensure this is (in part) to set these values to **NULL** on function entry.</span></span> <span data-ttu-id="296b2-122">Cette règle est importante, car elle favorise une interopérabilité des applications plus robuste.</span><span class="sxs-lookup"><span data-stu-id="296b2-122">This rule is important because it promotes more robust application interoperability.</span></span>
-   <span data-ttu-id="296b2-123">Dans les conditions d’erreur, tous les paramètres d’entrée-sortie doivent être laissés seul par le code appelé (par conséquent, restant à la valeur à laquelle ils ont été initialisés par l’appelant) ou être définis explicitement, comme dans le cas d’une erreur de retour de paramètre de sortie.</span><span class="sxs-lookup"><span data-stu-id="296b2-123">Under error conditions, all in-out parameters must either be left alone by the code called (thus remaining at the value to which they were initialized by the caller) or be explicitly set, as in the out parameter error return case.</span></span>

<span data-ttu-id="296b2-124">N’oubliez pas que ces conventions de gestion de la mémoire pour les applications COM s’appliquent uniquement à travers les interfaces publiques et APIsâ. en effet, il n’y a aucune exigence à ce que l’allocation de mémoire strictement interne à une application COM doive être effectuée à l’aide de ces mécanismes.</span><span class="sxs-lookup"><span data-stu-id="296b2-124">Remember that these memory management conventions for COM applications apply only across public interfaces and APIsâ€”there is no requirement at all that memory allocation strictly internal to a COM application need be done using these mechanisms.</span></span>

<span data-ttu-id="296b2-125">COM utilise en interne les appels de procédure distante (RPC) pour communiquer entre les clients et les serveurs.</span><span class="sxs-lookup"><span data-stu-id="296b2-125">COM internally uses Remote Procedure Calls (RPC) to communicate between clients and servers.</span></span> <span data-ttu-id="296b2-126">Pour plus d’informations sur la gestion de la mémoire dans les stubs de serveur RPC, consultez la rubrique gestion de la [mémoire de serveur stub](../rpc/server-stub-memory-management.md) .</span><span class="sxs-lookup"><span data-stu-id="296b2-126">For more information about managing memory in RPC server stubs, see the [Server-stub Memory Management](../rpc/server-stub-memory-management.md) topic.</span></span>

## <a name="related-topics"></a><span data-ttu-id="296b2-127">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="296b2-127">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="296b2-128">Gestion de l’allocation de mémoire</span><span class="sxs-lookup"><span data-stu-id="296b2-128">Managing Memory Allocation</span></span>](managing-memory-allocation.md)
</dt> </dl>

 

 