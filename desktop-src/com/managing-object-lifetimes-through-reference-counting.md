---
title: Gestion des durées de vie des objets via le décompte de références
description: Gestion des durées de vie des objets via le décompte de références
ms.assetid: 7f9da5a9-0435-431c-8f90-56e2e489c431
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7aac184baea9198721e6cdf9c0444a8c6431db08
ms.sourcegitcommit: f0ca63c18dc52c357d3398af7be766d2bdd40be7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/17/2020
ms.locfileid: "106510251"
---
# <a name="managing-object-lifetimes-through-reference-counting"></a><span data-ttu-id="e91b9-103">Gestion des durées de vie des objets via le décompte de références</span><span class="sxs-lookup"><span data-stu-id="e91b9-103">Managing Object Lifetimes Through Reference Counting</span></span>

<span data-ttu-id="e91b9-104">Dans les systèmes d’objets traditionnels, le cycle de vie des objets, c’est-à-dire les problèmes liés à la création et à la suppression d’objets, est géré implicitement par le langage (ou le temps d’exécution du langage) ou explicitement par les programmeurs d’applications.</span><span class="sxs-lookup"><span data-stu-id="e91b9-104">In traditional object systems, the life cycle of objects—that is, the issues surrounding the creation and deletion of objects—is handled implicitly by the language (or the language run time) or explicitly by application programmers.</span></span>

<span data-ttu-id="e91b9-105">Dans un système évolutif et décentralisé constitué de composants réutilisés, il n’est plus vrai qu’un client, voire n’importe quel programmeur, « sache » toujours comment gérer la durée de vie d’un composant.</span><span class="sxs-lookup"><span data-stu-id="e91b9-105">In an evolving, decentrally constructed system made up of reused components, it is no longer true that any client, or even any programmer, always "knows" how to deal with a component's lifetime.</span></span> <span data-ttu-id="e91b9-106">Pour un client doté des privilèges de sécurité appropriés, il est toujours relativement facile de créer des objets via une requête simple, mais la suppression d’objets est une autre question.</span><span class="sxs-lookup"><span data-stu-id="e91b9-106">For a client with the right security privileges, it is still relatively easy to create objects through a simple request, but object deletion is another matter entirely.</span></span> <span data-ttu-id="e91b9-107">Il n’est pas toujours évident de préciser quand un objet n’est plus nécessaire et doit être supprimé.</span><span class="sxs-lookup"><span data-stu-id="e91b9-107">It is not necessarily clear when an object is no longer needed and should be deleted.</span></span> <span data-ttu-id="e91b9-108">(Les lecteurs familiers avec les environnements de programmation récupérés par le garbage collector, tels que Java, peuvent être désaccords ; Toutefois, les objets Java ne s’étendent pas aux limites de l’ordinateur ou même du processus, et par conséquent, le garbage collection est limité aux objets qui résident dans un espace de processus unique.</span><span class="sxs-lookup"><span data-stu-id="e91b9-108">(Readers familiar with garbage-collected programming environments, such as Java, may disagree; however, Java objects do not span machine or even process boundaries, and therefore the garbage collection is restricted to objects living within a single-process space.</span></span> <span data-ttu-id="e91b9-109">En outre, Java force l’utilisation d’un langage de programmation unique.) Même lorsque le client d’origine est terminé avec l’objet, il ne peut pas simplement arrêter l’objet, car d’autres clients ou clients peuvent toujours y avoir une référence.</span><span class="sxs-lookup"><span data-stu-id="e91b9-109">In addition, Java forces the use of a single programming language.) Even when the original client is done with the object, it cannot simply shut the object down, because some other client or clients might still have a reference to it.</span></span>

<span data-ttu-id="e91b9-110">Une façon de s’assurer qu’un objet n’est plus nécessaire est de dépendre entièrement d’un canal de communication sous-jacent pour informer le système lorsque toutes les connexions à un objet inter-processus ou inter-canaux ont disparu.</span><span class="sxs-lookup"><span data-stu-id="e91b9-110">One way to ensure that an object is no longer needed is to depend entirely on an underlying communication channel to inform the system when all connections to a cross-process or cross-channel object have disappeared.</span></span> <span data-ttu-id="e91b9-111">Toutefois, les schémas qui utilisent cette méthode sont inacceptables pour plusieurs raisons.</span><span class="sxs-lookup"><span data-stu-id="e91b9-111">However, schemes that use this method are unacceptable for several reasons.</span></span> <span data-ttu-id="e91b9-112">L’un des problèmes est qu’elle peut nécessiter une différence majeure entre le modèle de programmation inter-processus/réseau croisé et le modèle de programmation à processus unique.</span><span class="sxs-lookup"><span data-stu-id="e91b9-112">One problem is that it could require a major difference between the cross-process/cross-network programming model and the single-process programming model.</span></span> <span data-ttu-id="e91b9-113">Dans le modèle de programmation inter-processus/réseau croisé, le système de communication fournit les hooks nécessaires à la gestion de la durée de vie des objets, tandis que dans le modèle de programmation à processus unique, les objets sont connectés directement sans canal de communication intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="e91b9-113">In the cross-process/cross-network programming model, the communication system would provide the hooks necessary for object lifetime management, while in the single-process programming model, objects are directly connected without any intervening communications channel.</span></span> <span data-ttu-id="e91b9-114">Un autre problème est que ce schéma peut également entraîner une couche de logiciels fournis par le système qui interférerait avec les performances des composants dans le cas du processus in-process.</span><span class="sxs-lookup"><span data-stu-id="e91b9-114">Another problem is that this scheme could also result in a layer of system-provided software that would interfere with component performance in the in-process case.</span></span> <span data-ttu-id="e91b9-115">En outre, un mécanisme basé sur la surveillance explicite n’aurait pas tendance à se mettre à l’échelle vers plusieurs milliers ou millions d’objets.</span><span class="sxs-lookup"><span data-stu-id="e91b9-115">Furthermore, a mechanism based on explicit monitoring would not tend to scale toward many thousands or millions of objects.</span></span>

<span data-ttu-id="e91b9-116">COM offre une approche évolutive et distribuée de cet ensemble de problèmes.</span><span class="sxs-lookup"><span data-stu-id="e91b9-116">COM offers a scalable and distributed approach to this set of problems.</span></span> <span data-ttu-id="e91b9-117">Les clients disent à un objet lorsqu’ils l’utilisent et lorsqu’ils sont terminés, et les objets se suppriment lorsqu’ils ne sont plus nécessaires.</span><span class="sxs-lookup"><span data-stu-id="e91b9-117">Clients tell an object when they are using it and when they are done, and objects delete themselves when they are no longer needed.</span></span> <span data-ttu-id="e91b9-118">Cette approche impose que tous les objets comptent des références à elles-mêmes.</span><span class="sxs-lookup"><span data-stu-id="e91b9-118">This approach mandates that all objects count references to themselves.</span></span> <span data-ttu-id="e91b9-119">Des langages de programmation tels que Java, qui ont par nature leurs propres schémas de gestion de la durée de vie, comme garbage collection, peuvent utiliser le comptage de références de COM pour implémenter et utiliser les objets COM en interne, ce qui permet au programmeur d’éviter tout traitement.</span><span class="sxs-lookup"><span data-stu-id="e91b9-119">Programming languages such as Java, which inherently have their own lifetime management schemes, such as garbage collection, can use COM's reference counting to implement and use COM objects internally, allowing the programmer to avoid dealing with it.</span></span>

<span data-ttu-id="e91b9-120">Tout comme une application doit libérer de la mémoire qu’elle a allouée une fois que la mémoire n’est plus utilisée, un client d’un objet est chargé de libérer ses références à l’objet lorsque cet objet n’est plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="e91b9-120">Just as an application must free memory it has allocated once that memory is no longer in use, a client of an object is responsible for freeing its references to the object when that object is no longer needed.</span></span> <span data-ttu-id="e91b9-121">Dans un système orienté objet, le client ne peut le faire qu’en donnant à l’objet une instruction de libération proprement dite.</span><span class="sxs-lookup"><span data-stu-id="e91b9-121">In an object-oriented system, the client can do this only by giving the object an instruction to free itself.</span></span>

<span data-ttu-id="e91b9-122">Il est important qu’un objet soit libéré lorsqu’il n’est plus utilisé.</span><span class="sxs-lookup"><span data-stu-id="e91b9-122">It is important that an object be deallocated when it is no longer being used.</span></span> <span data-ttu-id="e91b9-123">La difficulté consiste à déterminer quand il est approprié de désallouer un objet.</span><span class="sxs-lookup"><span data-stu-id="e91b9-123">The difficulty lies in determining when it is appropriate to deallocate an object.</span></span> <span data-ttu-id="e91b9-124">Cela est facile avec des variables automatiques (celles allouées sur la pile). elles ne peuvent pas être utilisées en dehors du bloc dans lequel elles sont déclarées, de sorte que le compilateur les libère lorsque la fin du bloc est atteinte.</span><span class="sxs-lookup"><span data-stu-id="e91b9-124">This is easy with automatic variables (those allocated on the stack)—they cannot be used outside the block in which they're declared, so the compiler deallocates them when the end of the block is reached.</span></span> <span data-ttu-id="e91b9-125">Pour les objets COM, qui sont alloués dynamiquement, il revient aux clients d’un objet de décider quand ils n’ont plus besoin d’utiliser l’objet, en particulier les objets locaux ou distants qui peuvent être utilisés par plusieurs clients en même temps.</span><span class="sxs-lookup"><span data-stu-id="e91b9-125">For COM objects, which are dynamically allocated, it is up to the clients of an object to decide when they no longer need to use the object—especially local or remote objects that might be in use by multiple clients at the same time.</span></span> <span data-ttu-id="e91b9-126">L’objet doit attendre la fin de l’exécution de tous les clients avant de se libérer.</span><span class="sxs-lookup"><span data-stu-id="e91b9-126">The object must wait until all clients are finished with it before freeing itself.</span></span> <span data-ttu-id="e91b9-127">Étant donné que les objets COM sont manipulés via des pointeurs d’interface et peuvent être utilisés par des objets dans des processus différents ou sur d’autres ordinateurs, le système ne peut pas effectuer le suivi des clients d’un objet.</span><span class="sxs-lookup"><span data-stu-id="e91b9-127">Because COM objects are manipulated through interface pointers and can be used by objects in different processes or on other machines, the system cannot keep track of an object's clients.</span></span>

<span data-ttu-id="e91b9-128">La méthode du COM pour déterminer quand il est approprié de libérer un objet est le décompte de références manuel.</span><span class="sxs-lookup"><span data-stu-id="e91b9-128">COM's method of determining when it is appropriate to deallocate an object is manual reference counting.</span></span> <span data-ttu-id="e91b9-129">Chaque objet gère un nombre de références qui effectue le suivi du nombre de clients connectés, c’est-à-dire le nombre de pointeurs qui existent pour l’une de ses interfaces dans un client quelconque.</span><span class="sxs-lookup"><span data-stu-id="e91b9-129">Each object maintains a reference count that tracks how many clients are connected to it - that is, how many pointers exist to any of its interfaces in any client.</span></span>

<span data-ttu-id="e91b9-130">Pour plus d'informations, voir les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="e91b9-130">For more information, see the following topics:</span></span>

-   [<span data-ttu-id="e91b9-131">Implémentation du décompte de références</span><span class="sxs-lookup"><span data-stu-id="e91b9-131">Implementing Reference Counting</span></span>](implementing-reference-counting.md)
-   [<span data-ttu-id="e91b9-132">Règles pour la gestion des nombres de références</span><span class="sxs-lookup"><span data-stu-id="e91b9-132">Rules for Managing Reference Counts</span></span>](rules-for-managing-reference-counts.md)

## <a name="related-topics"></a><span data-ttu-id="e91b9-133">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="e91b9-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e91b9-134">Utilisation et implémentation de IUnknown</span><span class="sxs-lookup"><span data-stu-id="e91b9-134">Using and Implementing IUnknown</span></span>](using-and-implementing-iunknown.md)
</dt> </dl>

 

 




