---
title: Règles pour la gestion des nombres de références
description: L’utilisation d’un décompte de références pour gérer la durée de vie d’un objet permet à plusieurs clients d’obtenir et de libérer l’accès à un objet unique sans avoir à coordonner l’un avec l’autre pour gérer la durée de vie de l’objet.
ms.assetid: bbe7d16c-fcb7-474d-a22d-5a3b33dd800e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a9520cbbc88cb73c6e2abbd7908bed3754bb3945
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104382923"
---
# <a name="rules-for-managing-reference-counts"></a><span data-ttu-id="9d3b1-103">Règles pour la gestion des nombres de références</span><span class="sxs-lookup"><span data-stu-id="9d3b1-103">Rules for Managing Reference Counts</span></span>

<span data-ttu-id="9d3b1-104">L’utilisation d’un décompte de références pour gérer la durée de vie d’un objet permet à plusieurs clients d’obtenir et de libérer l’accès à un objet unique sans avoir à coordonner l’un avec l’autre pour gérer la durée de vie de l’objet.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-104">Using a reference count to manage an object's lifetime allows multiple clients to obtain and release access to a single object without having to coordinate with one another in managing the object's lifetime.</span></span> <span data-ttu-id="9d3b1-105">Tant que l’objet client est conforme à certaines règles d’utilisation, l’objet, en vigueur, fournit cette gestion.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-105">As long as the client object conforms to certain rules of use, the object, in effect, provides this management.</span></span> <span data-ttu-id="9d3b1-106">Ces règles spécifient comment gérer les références entre les objets.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-106">These rules specify how to manage references between objects.</span></span> <span data-ttu-id="9d3b1-107">(COM ne spécifie pas les implémentations internes d’objets, bien que ces règles soient un point de départ raisonnable pour une stratégie dans un objet.)</span><span class="sxs-lookup"><span data-stu-id="9d3b1-107">(COM does not specify internal implementations of objects, although these rules are a reasonable starting point for a policy within an object.)</span></span>

<span data-ttu-id="9d3b1-108">D’un point de vue conceptuel, les pointeurs d’interface peuvent être considérés comme résidant dans des variables de pointeur qui incluent tous les États de calcul internes qui contiennent un pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-108">Conceptually, interface pointers can be thought of as residing within pointer variables that include all the internal computation state that holds an interface pointer.</span></span> <span data-ttu-id="9d3b1-109">Cela inclut les variables dans les emplacements de mémoire, dans les registres internes du processeur, ainsi que les variables générées par le programmeur et générées par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-109">This would include variables in memory locations, in internal processor registers, and both programmer-generated and compiler-generated variables.</span></span> <span data-ttu-id="9d3b1-110">L’assignation ou l’initialisation d’une variable pointeur implique la création d’une nouvelle copie d’un pointeur déjà existant.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-110">Assignment to or initialization of a pointer variable involves creating a new copy of an already existing pointer.</span></span> <span data-ttu-id="9d3b1-111">Lorsqu’il y avait une copie du pointeur dans une variable (la valeur utilisée dans l’assignation/initialisation), il y en a maintenant deux.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-111">Where there was one copy of the pointer in some variable (the value used in the assignment/initialization), there are now two.</span></span> <span data-ttu-id="9d3b1-112">Une assignation à une variable pointeur détruit la copie du pointeur actuellement dans la variable, tout comme la destruction de la variable elle-même.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-112">An assignment to a pointer variable destroys the pointer copy presently in the variable, as does the destruction of the variable itself.</span></span> <span data-ttu-id="9d3b1-113">(Autrement dit, l’étendue dans laquelle la variable est trouvée, telle que le frame de pile, est détruite.)</span><span class="sxs-lookup"><span data-stu-id="9d3b1-113">(That is, the scope in which the variable is found, such as the stack frame, is destroyed.)</span></span>

<span data-ttu-id="9d3b1-114">Du point de vue du client COM, le décompte de références est toujours effectué pour chaque interface.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-114">From a COM client's perspective, reference counting is always done for each interface.</span></span> <span data-ttu-id="9d3b1-115">Les clients ne doivent jamais supposer qu’un objet utilise le même compteur pour toutes les interfaces.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-115">Clients should never assume that an object uses the same counter for all interfaces.</span></span>

<span data-ttu-id="9d3b1-116">Le cas par défaut est que [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) doit être appelé pour chaque nouvelle copie d’un pointeur d’interface et que [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) doit être appelé pour chaque destruction d’un pointeur d’interface, sauf si les règles suivantes l’autorisent autrement :</span><span class="sxs-lookup"><span data-stu-id="9d3b1-116">The default case is that [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) must be called for every new copy of an interface pointer and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) must be called for every destruction of an interface pointer, except where the following rules permit otherwise:</span></span>

-   <span data-ttu-id="9d3b1-117">**Paramètres d’extraction aux fonctions.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-117">**In-out parameters to functions.**</span></span> <span data-ttu-id="9d3b1-118">L’appelant doit appeler [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sur le paramètre, car il sera libéré (avec un appel à [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) dans le code d’implémentation lorsque la valeur out est stockée au-dessus.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-118">The caller must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the parameter because it will be released (with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)) in the implementing code when the out value is stored on top of it.</span></span>
-   <span data-ttu-id="9d3b1-119">**Récupération d’une variable globale.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-119">**Fetching a global variable.**</span></span> <span data-ttu-id="9d3b1-120">Lors de la création d’une copie locale d’un pointeur d’interface à partir d’une copie existante du pointeur dans une variable globale, vous devez appeler [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sur la copie locale, car une autre fonction peut détruire la copie dans la variable globale lorsque la copie locale est toujours valide.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-120">When creating a local copy of an interface pointer from an existing copy of the pointer in a global variable, you must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the local copy because another function might destroy the copy in the global variable while the local copy is still valid.</span></span>
-   <span data-ttu-id="9d3b1-121">**Nouveaux pointeurs synthétisés à partir de « l’air mince ».**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-121">**New pointers synthesized out of "thin air."**</span></span> <span data-ttu-id="9d3b1-122">Une fonction qui synthétise un pointeur d’interface à l’aide d’une connaissance interne spéciale plutôt que de l’obtenir à partir d’une autre source doit appeler [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initialement sur le pointeur récemment synthétisé.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-122">A function that synthesizes an interface pointer using special internal knowledge rather than obtaining it from some other source must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) initially on the newly synthesized pointer.</span></span> <span data-ttu-id="9d3b1-123">Les exemples importants de telles routines incluent les routines de création d’instance, les implémentations de [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), etc.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-123">Important examples of such routines include instance creation routines, implementations of [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), and so on.</span></span>
-   <span data-ttu-id="9d3b1-124">**Récupération d’une copie d’un pointeur stocké en interne.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-124">**Retrieving a copy of an internally stored pointer.**</span></span> <span data-ttu-id="9d3b1-125">Lorsqu’une fonction récupère une copie d’un pointeur stocké en interne par l’objet appelé, le code de cet objet doit appeler [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) sur le pointeur avant le retour de la fonction.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-125">When a function retrieves a copy of a pointer that is stored internally by the object called, that object's code must call [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) on the pointer before the function returns.</span></span> <span data-ttu-id="9d3b1-126">Une fois le pointeur récupéré, l’objet d’origine n’a aucun autre moyen de déterminer la façon dont sa durée de vie est associée à celle de la copie stockée en interne du pointeur.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-126">Once the pointer has been retrieved, the originating object has no other way of determining how its lifetime relates to that of the internally stored copy of the pointer.</span></span>

<span data-ttu-id="9d3b1-127">La seule exception au cas par défaut exige que le code de gestion connaisse les relations des durées de vie de deux ou plusieurs copies d’un pointeur vers la même interface sur un objet et qu’il vérifie simplement que l’objet n’est pas détruit en permettant à son décompte de références de passer à zéro.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-127">The only exceptions to the default case require that the managing code know the relationships of the lifetimes of two or more copies of a pointer to the same interface on an object and simply ensure that the object is not destroyed by allowing its reference count to go to zero.</span></span> <span data-ttu-id="9d3b1-128">Il y a généralement deux cas, comme suit :</span><span class="sxs-lookup"><span data-stu-id="9d3b1-128">There are generally two cases, as follows:</span></span>

-   <span data-ttu-id="9d3b1-129">Lorsqu’une copie d’un pointeur existe déjà et qu’une deuxième est créée par la suite, puis est détruite alors que la première copie existe toujours, les appels à [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) et [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)pour la deuxième copie peuvent être omis.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-129">When one copy of a pointer already exists and a second is created subsequently and then is destroyed while the first copy still exists, calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)for the second copy can be omitted.</span></span>
-   <span data-ttu-id="9d3b1-130">Lorsqu’il existe une copie d’un pointeur et qu’une deuxième est créée, puis que la première est détruite avant la seconde, les appels à [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)pour la deuxième copie et à [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pour la première copie peuvent être omis.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-130">When one copy of a pointer exists and a second is created and then the first is destroyed before the second, the calls to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)for the second copy and to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) for the first copy can be omitted.</span></span>

<span data-ttu-id="9d3b1-131">Voici des exemples spécifiques de ces situations, les deux premières étant particulièrement courantes :</span><span class="sxs-lookup"><span data-stu-id="9d3b1-131">The following are specific examples of these situations, the first two being especially common:</span></span>

-   <span data-ttu-id="9d3b1-132">**Dans les paramètres de fonctions.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-132">**In parameters to functions.**</span></span> <span data-ttu-id="9d3b1-133">La durée de vie de la copie d’un pointeur d’interface passé comme paramètre à une fonction est imbriquée dans celle du pointeur utilisé pour initialiser la valeur. il n’est donc pas nécessaire de disposer d’un décompte de références distinct sur le paramètre.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-133">The lifetime of the copy of an interface pointer passed as a parameter to a function is nested in that of the pointer used to initialize the value, so there is no need for a separate reference count on the parameter.</span></span>
-   <span data-ttu-id="9d3b1-134">**Les paramètres out des fonctions, y compris les valeurs de retour.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-134">**Out parameters from functions, including return values.**</span></span> <span data-ttu-id="9d3b1-135">Pour définir le paramètre out, la fonction doit avoir une copie stable du pointeur d’interface.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-135">To set the out parameter, the function must have a stable copy of the interface pointer.</span></span> <span data-ttu-id="9d3b1-136">Au retour, l’appelant est chargé de libérer le pointeur.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-136">On return, the caller is responsible for releasing the pointer.</span></span> <span data-ttu-id="9d3b1-137">Par conséquent, le paramètre out n’a pas besoin d’un nombre de références distinct.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-137">Therefore, the out parameter does not need a separate reference count.</span></span>
-   <span data-ttu-id="9d3b1-138">**Variables locales.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-138">**Local variables.**</span></span> <span data-ttu-id="9d3b1-139">Une implémentation de méthode contrôle les durées de vie de chacune des variables de pointeur allouées sur le frame de pile et peut l’utiliser pour déterminer comment omettre les paires de versions de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)redondantes / [](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) .</span><span class="sxs-lookup"><span data-stu-id="9d3b1-139">A method implementation has control of the lifetimes of each of the pointer variables allocated on the stack frame and can use this to determine how to omit redundant [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)/[**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) pairs.</span></span>
-   <span data-ttu-id="9d3b1-140">**Points de soulignement.**</span><span class="sxs-lookup"><span data-stu-id="9d3b1-140">**Backpointers.**</span></span> <span data-ttu-id="9d3b1-141">Certaines structures de données contiennent deux objets, chacun avec un pointeur vers l’autre.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-141">Some data structures contain two objects, each with a pointer to the other.</span></span> <span data-ttu-id="9d3b1-142">Si la durée de vie du premier objet est connue pour contenir la durée de vie de la seconde, il n’est pas nécessaire de disposer d’un décompte de références sur le deuxième pointeur de l’objet vers le premier objet.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-142">If the lifetime of the first object is known to contain the lifetime of the second, it is not necessary to have a reference count on the second object's pointer to the first object.</span></span> <span data-ttu-id="9d3b1-143">Souvent, il est important d’éviter ce cycle pour maintenir le comportement de désallocation approprié.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-143">Often, avoiding this cycle is important in maintaining the appropriate deallocation behavior.</span></span> <span data-ttu-id="9d3b1-144">Toutefois, les pointeurs non comptés doivent être utilisés avec une extrême prudence, car la partie du système d’exploitation qui gère le traitement à distance n’a aucun moyen de connaître cette relation.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-144">However, uncounted pointers should be used with extreme caution because the portion of the operating system that handles remote processing has no way of knowing about this relationship.</span></span> <span data-ttu-id="9d3b1-145">Par conséquent, dans la plupart des cas, le fait de faire en sorte que le point de présence du point de présence est un deuxième objet « Friend » du premier pointeur (ce qui évite la circularité) est la solution recommandée.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-145">Therefore, in almost all cases, having the backpointer see a second, "friend" object of the first pointer (thus avoiding the circularity) is the preferred solution.</span></span> <span data-ttu-id="9d3b1-146">L’architecture des objets connectables de COM, par exemple, utilise cette approche.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-146">COM's connectable objects architecture, for example, uses this approach.</span></span>

<span data-ttu-id="9d3b1-147">Lors de l’implémentation ou de l’utilisation d’objets comptés par référence, il peut être utile d’appliquer des *nombres de références artificielles*, ce qui garantit la stabilité des objets pendant le traitement d’une fonction.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-147">When implementing or using reference-counted objects, it may be useful to apply *artificial reference counts*, which guarantee object stability during processing of a function.</span></span> <span data-ttu-id="9d3b1-148">Lors de l’implémentation d’une méthode d’interface, vous pouvez appeler des fonctions qui ont la possibilité de décrémenter le décompte de références à un objet, provoquant une version prématurée de l’objet et l’échec de l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-148">In implementing a method of an interface, you might call functions that have a chance of decrementing your reference count to an object, causing a premature release of the object and failure of the implementation.</span></span> <span data-ttu-id="9d3b1-149">Un moyen fiable d’éviter cela consiste à insérer un appel à [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) au début de l’implémentation de la méthode et à le coupler avec un appel à [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) juste avant le retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-149">A robust way to avoid this is to insert a call to [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) at the beginning of the method implementation and pair it with a call to [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) just before the method returns.</span></span>

<span data-ttu-id="9d3b1-150">Dans certains cas, les valeurs de retour de [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) et [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) peuvent être instables et ne doivent pas être réutilisables ; elles doivent être utilisées uniquement à des fins de débogage ou de diagnostic.</span><span class="sxs-lookup"><span data-stu-id="9d3b1-150">In some situations, the return values of [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) and [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) may be unstable and should not be relied upon; they should be used only for debugging or diagnostic purposes.</span></span>

## <a name="related-topics"></a><span data-ttu-id="9d3b1-151">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="9d3b1-151">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="9d3b1-152">Gestion des durées de vie des objets via le décompte de références</span><span class="sxs-lookup"><span data-stu-id="9d3b1-152">Managing Object Lifetimes Through Reference Counting</span></span>](managing-object-lifetimes-through-reference-counting.md)
</dt> </dl>

 

 