---
title: Apartments (cloisonnés) multithread
description: Apartments (cloisonnés) multithread
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "106511102"
---
# <a name="multithreaded-apartments"></a><span data-ttu-id="98dd0-103">Apartments (cloisonnés) multithread</span><span class="sxs-lookup"><span data-stu-id="98dd0-103">Multithreaded Apartments</span></span>

<span data-ttu-id="98dd0-104">Dans un modèle à cloisonnement multithread, tous les threads du processus qui ont été initialisés en tant que threads libres résident dans un seul cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="98dd0-104">In a multithreaded apartment model, all the threads in the process that have been initialized as free-threaded reside in a single apartment.</span></span> <span data-ttu-id="98dd0-105">Par conséquent, il n’est pas nécessaire d’effectuer un marshaling entre les threads.</span><span class="sxs-lookup"><span data-stu-id="98dd0-105">Therefore, there is no need to marshal between threads.</span></span> <span data-ttu-id="98dd0-106">Les threads n’ont pas besoin de récupérer et de distribuer les messages, car COM n’utilise pas les messages de fenêtre dans ce modèle.</span><span class="sxs-lookup"><span data-stu-id="98dd0-106">The threads need not retrieve and dispatch messages because COM does not use window messages in this model.</span></span>

<span data-ttu-id="98dd0-107">Les appels aux méthodes d’objets dans le cloisonnement multithread peuvent être exécutés sur n’importe quel thread du cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="98dd0-107">Calls to methods of objects in the multithreaded apartment can be run on any thread in the apartment.</span></span> <span data-ttu-id="98dd0-108">Il n’existe aucune sérialisation des appels ; de nombreux appels peuvent se produire simultanément à la même méthode ou au même objet.</span><span class="sxs-lookup"><span data-stu-id="98dd0-108">There is no serialization of calls; many calls may occur to the same method or to the same object simultaneously.</span></span> <span data-ttu-id="98dd0-109">Les objets créés dans le cloisonnement multithread doivent être en mesure de gérer des appels sur leurs méthodes à tout moment à partir d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="98dd0-109">Objects created in the multithreaded apartment must be able to handle calls on their methods from other threads at any time.</span></span>

<span data-ttu-id="98dd0-110">Étant donné que les appels aux objets ne sont pas sérialisés, l’accès concurrentiel aux objets multithread offre les meilleures performances et tire le meilleur parti du matériel multiprocesseur pour les appels inter-threads, inter-processus et inter-ordinateurs.</span><span class="sxs-lookup"><span data-stu-id="98dd0-110">Because calls to objects are not serialized in any way, multithreaded object concurrency offers the highest performance and takes the best advantage of multiprocessor hardware for cross-thread, cross-process, and cross-machine calling.</span></span> <span data-ttu-id="98dd0-111">Cela signifie, toutefois, que le code pour les objets doit assurer la synchronisation dans leurs implémentations d’interface, en général à l’aide des primitives de synchronisation telles que les objets d’événement, les sections critiques, les mutex ou les sémaphores, qui sont décrits plus loin dans cette section.</span><span class="sxs-lookup"><span data-stu-id="98dd0-111">This means, however, that the code for objects must provide synchronization in their interface implementations, typically through the use of synchronization primitives such as event objects, critical sections, mutexes, or semaphores, which are described later in this section.</span></span> <span data-ttu-id="98dd0-112">En outre, étant donné que l’objet ne contrôle pas la durée de vie des threads qui y accèdent, aucun État spécifique au thread ne peut être stocké dans l’objet (dans le stockage local des threads).</span><span class="sxs-lookup"><span data-stu-id="98dd0-112">In addition, because the object doesn't control the lifetime of the threads that are accessing it, no thread-specific state may be stored in the object (in thread local storage).</span></span>

<span data-ttu-id="98dd0-113">Voici quelques considérations importantes concernant la synchronisation pour les Apartments multithread :</span><span class="sxs-lookup"><span data-stu-id="98dd0-113">Following are some important considerations regarding synchronization for multithreaded apartments:</span></span>

-   <span data-ttu-id="98dd0-114">COM assure la synchronisation des appels uniquement pour les cloisonnements à thread unique.</span><span class="sxs-lookup"><span data-stu-id="98dd0-114">COM provides call synchronization for single-threaded apartments only.</span></span>
-   <span data-ttu-id="98dd0-115">Les Apartments (cloisonnés) multithread ne reçoivent pas d’appels lors d’appels (sur le même thread).</span><span class="sxs-lookup"><span data-stu-id="98dd0-115">Multithreaded apartments do not receive calls while making calls (on the same thread).</span></span>
-   <span data-ttu-id="98dd0-116">Les Apartments multithread ne peuvent pas effectuer d’appels synchronisés en entrée.</span><span class="sxs-lookup"><span data-stu-id="98dd0-116">Multithreaded apartments cannot make input-synchronized calls.</span></span>
-   <span data-ttu-id="98dd0-117">Les appels asynchrones sont convertis en appels synchrones dans des Apartments multithread.</span><span class="sxs-lookup"><span data-stu-id="98dd0-117">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span>
-   <span data-ttu-id="98dd0-118">Le filtre de messages n’est appelé pour aucun thread dans un cloisonnement multithread.</span><span class="sxs-lookup"><span data-stu-id="98dd0-118">The message filter is not called for any thread in a multithreaded apartment.</span></span>

<span data-ttu-id="98dd0-119">Pour initialiser un thread en tant que thread libre, appelez [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), en spécifiant l’appel de manière multithread \_ .</span><span class="sxs-lookup"><span data-stu-id="98dd0-119">To initialize a thread as free-threaded, call [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), specifying COINIT\_MULTITHREADED.</span></span> <span data-ttu-id="98dd0-120">Pour plus d’informations sur les threads de serveur in-process, consultez [problèmes de Threading de serveur in-process](in-process-server-threading-issues.md).</span><span class="sxs-lookup"><span data-stu-id="98dd0-120">For information on in-process server threading, see [In-Process Server Threading Issues](in-process-server-threading-issues.md).</span></span>

<span data-ttu-id="98dd0-121">Plusieurs clients peuvent appeler simultanément, à partir de différents threads, un objet qui prend en charge le Threading libre.</span><span class="sxs-lookup"><span data-stu-id="98dd0-121">Multiple clients can simultaneously call, from different threads, an object that supports free-threading.</span></span> <span data-ttu-id="98dd0-122">Dans les serveurs hors processus libres de threads, COM, via le sous-système RPC, crée un pool de threads dans le processus serveur et un appel client (ou plusieurs appels client) peut être remis à tout moment par l’un de ces threads.</span><span class="sxs-lookup"><span data-stu-id="98dd0-122">In free-threaded out-of-process servers, COM, through the RPC subsystem, creates a pool of threads in the server process and a client call (or multiple client calls) can be delivered by any of these threads at any time.</span></span> <span data-ttu-id="98dd0-123">Un serveur out-of-process doit également implémenter la synchronisation dans sa fabrique de classe.</span><span class="sxs-lookup"><span data-stu-id="98dd0-123">An out-of-process server must also implement synchronization in its class factory.</span></span> <span data-ttu-id="98dd0-124">Les objets en thread libre, in-process, peuvent recevoir des appels directs à partir de plusieurs threads du client.</span><span class="sxs-lookup"><span data-stu-id="98dd0-124">Free-threaded, in-process objects can receive direct calls from multiple threads of the client.</span></span>

<span data-ttu-id="98dd0-125">Le client peut effectuer un travail COM dans plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="98dd0-125">The client can do COM work in multiple threads.</span></span> <span data-ttu-id="98dd0-126">Tous les threads appartiennent au même cloisonnement multithread.</span><span class="sxs-lookup"><span data-stu-id="98dd0-126">All threads belong to the same multithreaded apartment.</span></span> <span data-ttu-id="98dd0-127">Les pointeurs d’interface sont passés directement du thread au thread dans un cloisonnement multithread, de sorte que les pointeurs d’interface ne sont pas marshalés entre ses threads.</span><span class="sxs-lookup"><span data-stu-id="98dd0-127">Interface pointers are passed directly from thread to thread within a multithreaded apartment, so interface pointers are not marshaled between its threads.</span></span> <span data-ttu-id="98dd0-128">Les filtres de messages (implémentations de [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) ne sont pas utilisés dans les cloisonnements multithread.</span><span class="sxs-lookup"><span data-stu-id="98dd0-128">Message filters (implementations of [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) are not used in multithreaded apartments.</span></span> <span data-ttu-id="98dd0-129">Le thread client s’interrompt lorsqu’il effectue un appel COM aux objets hors cloisonnement et reprendra lorsque l’appel sera retourné.</span><span class="sxs-lookup"><span data-stu-id="98dd0-129">The client thread will suspend when it makes a COM call to out-of-apartment objects and will resume when the call returns.</span></span> <span data-ttu-id="98dd0-130">Les appels entre les processus sont toujours gérés par RPC.</span><span class="sxs-lookup"><span data-stu-id="98dd0-130">Calls between processes are still handled by RPC.</span></span>

<span data-ttu-id="98dd0-131">Les threads initialisés avec le modèle à thread libre doivent implémenter leur propre synchronisation.</span><span class="sxs-lookup"><span data-stu-id="98dd0-131">Threads initialized with the free-threaded model must implement their own synchronization.</span></span> <span data-ttu-id="98dd0-132">Comme mentionné plus haut dans cette section, Windows active cette implémentation via les primitives de synchronisation suivantes :</span><span class="sxs-lookup"><span data-stu-id="98dd0-132">As mentioned earlier in this section, Windows enables this implementation through the following synchronization primitives:</span></span>

-   <span data-ttu-id="98dd0-133">Les objets d’événement offrent un moyen de signaler un ou plusieurs threads qu’un événement s’est produit.</span><span class="sxs-lookup"><span data-stu-id="98dd0-133">Event objects provide a way of signaling one or more threads that an event has occurred.</span></span> <span data-ttu-id="98dd0-134">Tout thread dans un processus peut créer un objet d’événement.</span><span class="sxs-lookup"><span data-stu-id="98dd0-134">Any thread within a process can create an event object.</span></span> <span data-ttu-id="98dd0-135">Un descripteur de l’événement est retourné par la fonction de création d’événements, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span><span class="sxs-lookup"><span data-stu-id="98dd0-135">A handle to the event is returned by the event-creating function, [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa).</span></span> <span data-ttu-id="98dd0-136">Une fois qu’un objet d’événement a été créé, les threads avec un handle de l’objet peuvent attendre avant de poursuivre l’exécution.</span><span class="sxs-lookup"><span data-stu-id="98dd0-136">Once an event object has been created, threads with a handle to the object can wait on it before continuing execution.</span></span>
-   <span data-ttu-id="98dd0-137">Les sections critiques sont utilisées pour une section de code qui nécessite un accès exclusif à un ensemble de données partagées avant de pouvoir être exécutée et qui est utilisée uniquement par les threads dans un processus unique.</span><span class="sxs-lookup"><span data-stu-id="98dd0-137">Critical sections are used for a section of code that requires exclusive access to some set of shared data before it can be executed and that is used only by the threads within a single process.</span></span> <span data-ttu-id="98dd0-138">Une section critique est comme un tourniquet par lequel un seul thread à la fois peut réussir, en procédant comme suit :</span><span class="sxs-lookup"><span data-stu-id="98dd0-138">A critical section is like a turnstile through which only one thread at a time may pass, working as follows:</span></span>
    -   <span data-ttu-id="98dd0-139">Pour garantir qu’un seul thread à la fois accède à des données partagées, le thread principal d’un processus alloue une structure de \_ données de section critique globale et initialise ses membres.</span><span class="sxs-lookup"><span data-stu-id="98dd0-139">To ensure that no more than one thread at a time accesses shared data, a process's primary thread allocates a global CRITICAL\_SECTION data structure and initializes its members.</span></span> <span data-ttu-id="98dd0-140">Un thread entrant dans une section critique appelle la fonction [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) et modifie les membres de la structure de données.</span><span class="sxs-lookup"><span data-stu-id="98dd0-140">A thread entering a critical section calls the [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) function and modifies the data structure's members.</span></span>
    -   <span data-ttu-id="98dd0-141">Un thread tentant d’entrer dans une section critique appelle [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) , qui vérifie si la structure de données de la \_ section critique a été modifiée.</span><span class="sxs-lookup"><span data-stu-id="98dd0-141">A thread attempting to enter a critical section calls [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) which checks to see whether the CRITICAL\_SECTION data structure has been modified.</span></span> <span data-ttu-id="98dd0-142">Dans ce cas, un autre thread est actuellement dans la section critique et le thread suivant est mis en veille.</span><span class="sxs-lookup"><span data-stu-id="98dd0-142">If so, another thread is currently in the critical section and the subsequent thread is put to sleep.</span></span> <span data-ttu-id="98dd0-143">Un thread quittant une section critique appelle [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), qui réinitialise la structure de données.</span><span class="sxs-lookup"><span data-stu-id="98dd0-143">A thread leaving a critical section calls [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), which resets the data structure.</span></span> <span data-ttu-id="98dd0-144">Quand un thread quitte une section critique, le système sort l’un des threads en veille, qui entre ensuite dans la section critique.</span><span class="sxs-lookup"><span data-stu-id="98dd0-144">When a thread leaves a critical section, the system wakes one of the sleeping threads, which then enters the critical section.</span></span>
-   <span data-ttu-id="98dd0-145">Les mutex effectuent la même fonction qu’une section critique, sauf que le mutex est accessible aux threads exécutés dans des processus différents.</span><span class="sxs-lookup"><span data-stu-id="98dd0-145">Mutexes performs the same function as a critical section, except that the mutex is accessible to threads running in different processes.</span></span> <span data-ttu-id="98dd0-146">La possession d’un objet mutex revient à avoir le plancher dans un débat.</span><span class="sxs-lookup"><span data-stu-id="98dd0-146">Owning a mutex object is like having the floor in a debate.</span></span> <span data-ttu-id="98dd0-147">Un processus crée un objet mutex en appelant la fonction [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , qui retourne un handle.</span><span class="sxs-lookup"><span data-stu-id="98dd0-147">A process creates a mutex object by calling the [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) function, which returns a handle.</span></span> <span data-ttu-id="98dd0-148">Le premier thread qui demande un objet mutex obtient la propriété de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="98dd0-148">The first thread requesting a mutex object obtains ownership of it.</span></span> <span data-ttu-id="98dd0-149">Lorsque le thread a terminé avec le mutex, la propriété passe à d’autres threads sur la base du premier arrivé, premier servi.</span><span class="sxs-lookup"><span data-stu-id="98dd0-149">When the thread has finished with the mutex, ownership passes to other threads on a first-come, first-served basis.</span></span>
-   <span data-ttu-id="98dd0-150">Les sémaphores sont utilisés pour conserver un décompte de références sur une ressource disponible.</span><span class="sxs-lookup"><span data-stu-id="98dd0-150">Semaphores are used to maintain a reference count on some available resource.</span></span> <span data-ttu-id="98dd0-151">Un thread crée un sémaphore pour une ressource en appelant la fonction [**CreateSemaphore,**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) et en passant un pointeur vers la ressource, un nombre de ressources initial et le nombre maximal de ressources.</span><span class="sxs-lookup"><span data-stu-id="98dd0-151">A thread creates a semaphore for a resource by calling the [**CreateSemaphore**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) function and passing a pointer to the resource, an initial resource count, and the maximum resource count.</span></span> <span data-ttu-id="98dd0-152">Cette fonction retourne un handle.</span><span class="sxs-lookup"><span data-stu-id="98dd0-152">This function returns a handle.</span></span> <span data-ttu-id="98dd0-153">Un thread demandant une ressource passe son handle de sémaphore dans un appel à la fonction [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="98dd0-153">A thread requesting a resource passes its semaphore handle in a call to the [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) function.</span></span> <span data-ttu-id="98dd0-154">L’objet Semaphore interroge la ressource pour déterminer si elle est disponible.</span><span class="sxs-lookup"><span data-stu-id="98dd0-154">The semaphore object polls the resource to determine whether it is available.</span></span> <span data-ttu-id="98dd0-155">Si c’est le cas, le sémaphore décrémente le nombre de ressources et sort le thread en attente.</span><span class="sxs-lookup"><span data-stu-id="98dd0-155">If so, the semaphore decrements the resource count and wakes the waiting thread.</span></span> <span data-ttu-id="98dd0-156">Si le nombre est égal à zéro, le thread reste en veille jusqu’à ce qu’un autre thread libère une ressource, ce qui amène le sémaphore à incrémenter le nombre à un.</span><span class="sxs-lookup"><span data-stu-id="98dd0-156">If the count is zero, the thread remains asleep until another thread releases a resource, causing the semaphore to increment the count to one.</span></span>

## <a name="related-topics"></a><span data-ttu-id="98dd0-157">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="98dd0-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="98dd0-158">Accès aux interfaces à travers les Apartments</span><span class="sxs-lookup"><span data-stu-id="98dd0-158">Accessing Interfaces Across Apartments</span></span>](accessing-interfaces-across-apartments.md)
</dt> <dt>

[<span data-ttu-id="98dd0-159">Choix du modèle de thread</span><span class="sxs-lookup"><span data-stu-id="98dd0-159">Choosing the Threading Model</span></span>](choosing-the-threading-model.md)
</dt> <dt>

[<span data-ttu-id="98dd0-160">Problèmes liés aux threads du serveur in-process</span><span class="sxs-lookup"><span data-stu-id="98dd0-160">In-Process Server Threading Issues</span></span>](in-process-server-threading-issues.md)
</dt> <dt>

[<span data-ttu-id="98dd0-161">Processus, threads et Apartments</span><span class="sxs-lookup"><span data-stu-id="98dd0-161">Processes, Threads, and Apartments</span></span>](processes--threads--and-apartments.md)
</dt> <dt>

[<span data-ttu-id="98dd0-162">Communication monothread et multithread</span><span class="sxs-lookup"><span data-stu-id="98dd0-162">Single-Threaded and Multithreaded Communication</span></span>](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[<span data-ttu-id="98dd0-163">Apartments (cloisonnés) à thread unique</span><span class="sxs-lookup"><span data-stu-id="98dd0-163">Single-Threaded Apartments</span></span>](single-threaded-apartments.md)
</dt> </dl>

 

 