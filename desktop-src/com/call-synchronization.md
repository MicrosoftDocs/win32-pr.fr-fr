---
title: Synchronisation des appels
description: Synchronisation des appels
ms.assetid: e74407ef-f500-4d13-aef4-ca6bb37d5858
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ec9254aceaaa8a6fa26d56d4a86987cc955b90dc
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/21/2020
ms.locfileid: "104031923"
---
# <a name="call-synchronization"></a><span data-ttu-id="f28cc-103">Synchronisation des appels</span><span class="sxs-lookup"><span data-stu-id="f28cc-103">Call Synchronization</span></span>

<span data-ttu-id="f28cc-104">Les applications COM doivent être en mesure de traiter correctement les entrées utilisateur lors du traitement d’un ou de plusieurs appels de COM ou du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="f28cc-104">COM applications must be able to deal correctly with user input while processing one or more calls from COM or the operating system.</span></span> <span data-ttu-id="f28cc-105">COM assure la synchronisation des appels uniquement pour les cloisonnements à thread unique.</span><span class="sxs-lookup"><span data-stu-id="f28cc-105">COM provides call synchronization for single-threaded apartments only.</span></span> <span data-ttu-id="f28cc-106">Les Apartments (cloisonnés) multithread ne reçoivent pas d’appels lors de l’appel (sur le même thread).</span><span class="sxs-lookup"><span data-stu-id="f28cc-106">Multithreaded apartments (containing free-threaded threads) do not receive calls while making calls (on the same thread).</span></span> <span data-ttu-id="f28cc-107">Les cloisonnements multithread ne peuvent pas effectuer d’appels synchronisés d’entrée.</span><span class="sxs-lookup"><span data-stu-id="f28cc-107">Multithreaded apartments cannot make input synchronized calls.</span></span> <span data-ttu-id="f28cc-108">Les appels asynchrones sont convertis en appels synchrones dans des Apartments multithread.</span><span class="sxs-lookup"><span data-stu-id="f28cc-108">Asynchronous calls are converted to synchronous calls in multithreaded apartments.</span></span> <span data-ttu-id="f28cc-109">Le filtre de messages n’est appelé pour aucun thread dans un cloisonnement multithread.</span><span class="sxs-lookup"><span data-stu-id="f28cc-109">The message filter is not called for any thread in a multithreaded apartment.</span></span> <span data-ttu-id="f28cc-110">Pour plus d’informations sur les problèmes liés aux threads, consultez [processus, threads et Apartments](processes--threads--and-apartments.md).</span><span class="sxs-lookup"><span data-stu-id="f28cc-110">For more information about threading issues, see [Processes, Threads, and Apartments](processes--threads--and-apartments.md).</span></span>

<span data-ttu-id="f28cc-111">Les appels COM entre les processus se répartissent en trois catégories, comme suit :</span><span class="sxs-lookup"><span data-stu-id="f28cc-111">COM calls between processes fall into three categories, as follows:</span></span>

<dl> <dt>

<span data-ttu-id="f28cc-112"><span id="Synchronous_calls"></span><span id="synchronous_calls"></span><span id="SYNCHRONOUS_CALLS"></span>*Appels synchrones*</span><span class="sxs-lookup"><span data-stu-id="f28cc-112"><span id="Synchronous_calls"></span><span id="synchronous_calls"></span><span id="SYNCHRONOUS_CALLS"></span>*Synchronous calls*</span></span>
</dt> <dd>

<span data-ttu-id="f28cc-113">La majeure partie de la communication qui a lieu dans COM est synchrone.</span><span class="sxs-lookup"><span data-stu-id="f28cc-113">Most of the communication that takes place within COM is synchronous.</span></span> <span data-ttu-id="f28cc-114">Lors de l’exécution d’appels synchrones, l’appelant attend la réponse avant de continuer et peut recevoir des messages entrants en attente.</span><span class="sxs-lookup"><span data-stu-id="f28cc-114">When making synchronous calls, the caller waits for the reply before continuing and can receive incoming messages while waiting.</span></span> <span data-ttu-id="f28cc-115">COM entre une boucle modale pour attendre la réponse, recevoir et distribuer d’autres messages de manière contrôlée.</span><span class="sxs-lookup"><span data-stu-id="f28cc-115">COM enters a modal loop to wait for the reply, receiving and dispatching other messages in a controlled manner.</span></span>

</dd> <dt>

<span data-ttu-id="f28cc-116"><span id="Asynchronous_notifications"></span><span id="asynchronous_notifications"></span><span id="ASYNCHRONOUS_NOTIFICATIONS"></span>*Notifications asynchrones*</span><span class="sxs-lookup"><span data-stu-id="f28cc-116"><span id="Asynchronous_notifications"></span><span id="asynchronous_notifications"></span><span id="ASYNCHRONOUS_NOTIFICATIONS"></span>*Asynchronous notifications*</span></span>
</dt> <dd>

<span data-ttu-id="f28cc-117">Lors de l’envoi de notifications asynchrones, l’appelant n’attend pas la réponse.</span><span class="sxs-lookup"><span data-stu-id="f28cc-117">When sending asynchronous notifications, the caller does not wait for the reply.</span></span> <span data-ttu-id="f28cc-118">COM utilise [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) ou des événements de haut niveau pour envoyer des notifications asynchrones, en fonction de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="f28cc-118">COM uses [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) or high-level events to send asynchronous notifications, depending on the platform.</span></span> <span data-ttu-id="f28cc-119">COM définit cinq méthodes asynchrones de [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink):</span><span class="sxs-lookup"><span data-stu-id="f28cc-119">COM defines five asynchronous methods of [**IAdviseSink**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink):</span></span>

-   [<span data-ttu-id="f28cc-120">**N''est**</span><span class="sxs-lookup"><span data-stu-id="f28cc-120">**OnDataChange**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange)
-   [<span data-ttu-id="f28cc-121">**OnViewChange**</span><span class="sxs-lookup"><span data-stu-id="f28cc-121">**OnViewChange**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onviewchange)
-   [<span data-ttu-id="f28cc-122">**OnRename**</span><span class="sxs-lookup"><span data-stu-id="f28cc-122">**OnRename**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onrename)
-   [<span data-ttu-id="f28cc-123">**OnSave**</span><span class="sxs-lookup"><span data-stu-id="f28cc-123">**OnSave**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onsave)
-   [<span data-ttu-id="f28cc-124">**OnClose**</span><span class="sxs-lookup"><span data-stu-id="f28cc-124">**OnClose**</span></span>](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-onclose)

> [!Note]  
> <span data-ttu-id="f28cc-125">Alors que COM traite un appel asynchrone, les appels synchrones ne peuvent pas être effectués.</span><span class="sxs-lookup"><span data-stu-id="f28cc-125">While COM is processing an asynchronous call, synchronous calls cannot be made.</span></span> <span data-ttu-id="f28cc-126">Par exemple, l’implémentation d’une application conteneur de [**OnDataChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange) ne peut pas contenir un appel à [**IPersistStorage :: Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersiststorage-save).</span><span class="sxs-lookup"><span data-stu-id="f28cc-126">For example, a container application's implementation of [**OnDataChange**](/windows/desktop/api/ObjIdl/nf-objidl-iadvisesink-ondatachange) cannot contain a call to [**IPersistStorage::Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersiststorage-save).</span></span> <span data-ttu-id="f28cc-127">Ces appels sont les seuls appels asynchrones pris en charge par COM.</span><span class="sxs-lookup"><span data-stu-id="f28cc-127">These calls are the only asynchronous calls supported by COM.</span></span> <span data-ttu-id="f28cc-128">Il n’existe aucun moyen de créer une interface personnalisée qui est asynchrone à ce stade.</span><span class="sxs-lookup"><span data-stu-id="f28cc-128">There is no way to create a custom interface that is asynchronous at this time.</span></span>

 

</dd> <dt>

<span data-ttu-id="f28cc-129"><span id="Input-synchronized_calls"></span><span id="input-synchronized_calls"></span><span id="INPUT-SYNCHRONIZED_CALLS"></span>*Appels synchronisés en entrée*</span><span class="sxs-lookup"><span data-stu-id="f28cc-129"><span id="Input-synchronized_calls"></span><span id="input-synchronized_calls"></span><span id="INPUT-SYNCHRONIZED_CALLS"></span>*Input-synchronized calls*</span></span>
</dt> <dd>

<span data-ttu-id="f28cc-130">Lors de l’exécution d’appels synchronisés en entrée, l’objet appelé doit terminer l’appel avant de générer le contrôle.</span><span class="sxs-lookup"><span data-stu-id="f28cc-130">When making input-synchronized calls, the object called must complete the call before yielding control.</span></span> <span data-ttu-id="f28cc-131">Cela permet de s’assurer que la gestion du focus fonctionne correctement et que les données entrées par l’utilisateur sont traitées de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="f28cc-131">This helps ensure that focus management works correctly and that data entered by the user is processed appropriately.</span></span> <span data-ttu-id="f28cc-132">Ces appels sont effectués par COM via la fonction [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) , sans entrer de boucle modale.</span><span class="sxs-lookup"><span data-stu-id="f28cc-132">These calls are made by COM through the [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) function, without entering a modal loop.</span></span> <span data-ttu-id="f28cc-133">Lors du traitement d’un appel synchronisé en entrée, l’objet appelé ne doit pas appeler une fonction ou méthode (y compris des méthodes synchrones) qui peut donner le contrôle.</span><span class="sxs-lookup"><span data-stu-id="f28cc-133">While processing an input-synchronized call, the object called must not call any function or method (including synchronous methods) that might yield control.</span></span> <span data-ttu-id="f28cc-134">Les méthodes suivantes sont synchronisées entre les entrées</span><span class="sxs-lookup"><span data-stu-id="f28cc-134">The following methods are input synchronized</span></span>

-   [<span data-ttu-id="f28cc-135">**IOleWindow::GetWindow**</span><span class="sxs-lookup"><span data-stu-id="f28cc-135">**IOleWindow::GetWindow**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-iolewindow-getwindow)
-   [<span data-ttu-id="f28cc-136">**IOleInPlaceActiveObject :: OnFrameWindowActivate**</span><span class="sxs-lookup"><span data-stu-id="f28cc-136">**IOleInPlaceActiveObject::OnFrameWindowActivate**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-onframewindowactivate)
-   [<span data-ttu-id="f28cc-137">**IOleInPlaceActiveObject :: OnDocWindowActivate**</span><span class="sxs-lookup"><span data-stu-id="f28cc-137">**IOleInPlaceActiveObject::OnDocWindowActivate**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-ondocwindowactivate)
-   [<span data-ttu-id="f28cc-138">**IOleInPlaceActiveObject :: ResizeBorder**</span><span class="sxs-lookup"><span data-stu-id="f28cc-138">**IOleInPlaceActiveObject::ResizeBorder**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceactiveobject-resizeborder)
-   [<span data-ttu-id="f28cc-139">**IOleInPlaceUIWindow::GetBorder**</span><span class="sxs-lookup"><span data-stu-id="f28cc-139">**IOleInPlaceUIWindow::GetBorder**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-getborder)
-   [<span data-ttu-id="f28cc-140">**IOleInPlaceUIWindow::RequestBorderSpace**</span><span class="sxs-lookup"><span data-stu-id="f28cc-140">**IOleInPlaceUIWindow::RequestBorderSpace**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-requestborderspace)
-   [<span data-ttu-id="f28cc-141">**IOleInPlaceUIWindow::SetBorderSpace**</span><span class="sxs-lookup"><span data-stu-id="f28cc-141">**IOleInPlaceUIWindow::SetBorderSpace**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceuiwindow-setborderspace)
-   [<span data-ttu-id="f28cc-142">**IOleInPlaceFrame :: SetMenu**</span><span class="sxs-lookup"><span data-stu-id="f28cc-142">**IOleInPlaceFrame::SetMenu**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceframe-setmenu)
-   [<span data-ttu-id="f28cc-143">**IOleInPlaceFrame :: SetStatusText**</span><span class="sxs-lookup"><span data-stu-id="f28cc-143">**IOleInPlaceFrame::SetStatusText**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceframe-setstatustext)
-   [<span data-ttu-id="f28cc-144">**IOleInPlaceObject::SetObjectRects**</span><span class="sxs-lookup"><span data-stu-id="f28cc-144">**IOleInPlaceObject::SetObjectRects**</span></span>](/windows/desktop/api/OleIdl/nf-oleidl-ioleinplaceobject-setobjectrects)

</dd> </dl>

<span data-ttu-id="f28cc-145">Pour réduire les problèmes qui peuvent survenir à partir du traitement des messages asynchrones, la majorité des appels de méthode COM sont synchrones.</span><span class="sxs-lookup"><span data-stu-id="f28cc-145">To minimize problems that can arise from asynchronous message processing, the majority of COM method calls are synchronous.</span></span> <span data-ttu-id="f28cc-146">Avec la communication synchrone, il n’est pas nécessaire de disposer d’un code spécial pour distribuer et gérer les messages entrants.</span><span class="sxs-lookup"><span data-stu-id="f28cc-146">With synchronous communication, there is no need for special code to dispatch and handle incoming messages.</span></span> <span data-ttu-id="f28cc-147">Lorsqu’une application effectue un appel de méthode synchrone, COM entre une boucle d’attente modale qui gère les réponses requises et distribue les messages entrants aux applications susceptibles de les traiter.</span><span class="sxs-lookup"><span data-stu-id="f28cc-147">When an application makes a synchronous method call, COM enters a modal wait loop that handles the required replies and dispatches incoming messages to applications capable of processing them.</span></span>

<span data-ttu-id="f28cc-148">COM gère les appels de méthode en assignant un identificateur appelé *ID de thread logique*.</span><span class="sxs-lookup"><span data-stu-id="f28cc-148">COM manages method calls by assigning an identifier called a *logical thread ID*.</span></span> <span data-ttu-id="f28cc-149">Une nouvelle est affectée lorsqu’un utilisateur sélectionne une commande de menu ou lorsque l’application lance une nouvelle opération COM.</span><span class="sxs-lookup"><span data-stu-id="f28cc-149">A new one is assigned when a user selects a menu command or when the application initiates a new COM operation.</span></span> <span data-ttu-id="f28cc-150">Les appels suivants liés à l’appel COM initial reçoivent le même ID de thread logique que l’appel initial.</span><span class="sxs-lookup"><span data-stu-id="f28cc-150">Subsequent calls that relate to the initial COM call are assigned the same logical thread ID as the initial call.</span></span>

 

 