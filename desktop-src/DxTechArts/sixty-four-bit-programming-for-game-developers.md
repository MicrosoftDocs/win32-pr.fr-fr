---
title: programmation 64 bits pour les développeurs de jeux
description: Cet article traite des problèmes de compatibilité et de Portage et aide les développeurs à faciliter leur transition vers des plateformes 64 bits.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b12e57ea1b3cc3272ca40465df31a04244d99e68
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104031561"
---
# <a name="64-bit-programming-for-game-developers"></a><span data-ttu-id="cee2b-103">programmation 64 bits pour les développeurs de jeux</span><span class="sxs-lookup"><span data-stu-id="cee2b-103">64-bit programming for Game Developers</span></span>

<span data-ttu-id="cee2b-104">Les fabricants de processeurs expédient exclusivement des processeurs 64 bits sur leurs ordinateurs de bureau, et même les chipsets de la plupart des ordinateurs portables prennent en charge la technologie x64.</span><span class="sxs-lookup"><span data-stu-id="cee2b-104">Processor manufacturers are exclusively shipping 64-bit processors in their desktop computers, and even the chipsets of most laptop computers support x64 technology.</span></span> <span data-ttu-id="cee2b-105">Il est important pour les développeurs de jeux de tirer parti des améliorations apportées par les processeurs 64 bits avec leurs nouvelles applications et de s’assurer que leurs applications antérieures s’exécutent correctement sur les nouveaux processeurs et les éditions 64 bits de Windows Vista et Windows 7.</span><span class="sxs-lookup"><span data-stu-id="cee2b-105">It is important for game developers to take advantage of the improvements that 64-bit processors offer with their new applications and to ensure that their earlier applications run correctly on the new processors and the 64-bit editions of Windows Vista and Windows 7.</span></span> <span data-ttu-id="cee2b-106">Cet article traite des problèmes de compatibilité et de Portage et aide les développeurs à faciliter leur transition vers des plateformes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-106">This article addresses compatibility and porting issues and helps developers ease their transition to 64-bit platforms.</span></span>

<span data-ttu-id="cee2b-107">Microsoft possède actuellement les systèmes d’exploitation 64 bits suivants :</span><span class="sxs-lookup"><span data-stu-id="cee2b-107">Microsoft currently has the following 64-bit operating systems:</span></span>

-   <span data-ttu-id="cee2b-108">Windows Server 2003 Service Pack 1</span><span class="sxs-lookup"><span data-stu-id="cee2b-108">Windows Server 2003 Service Pack 1</span></span>
-   <span data-ttu-id="cee2b-109">Windows XP Professionnel Édition x64 (disponible pour les fabricants d’ordinateurs OEM et les développeurs via MSDN)</span><span class="sxs-lookup"><span data-stu-id="cee2b-109">Windows XP Professional x64 Edition (available to OEMs and to developers through MSDN)</span></span>
-   <span data-ttu-id="cee2b-110">Windows Vista</span><span class="sxs-lookup"><span data-stu-id="cee2b-110">Windows Vista</span></span>
-   <span data-ttu-id="cee2b-111">Windows Server 2008</span><span class="sxs-lookup"><span data-stu-id="cee2b-111">Windows Server 2008</span></span>
-   <span data-ttu-id="cee2b-112">Windows 7</span><span class="sxs-lookup"><span data-stu-id="cee2b-112">Windows 7</span></span>
-   <span data-ttu-id="cee2b-113">Windows Server 2008 R2</span><span class="sxs-lookup"><span data-stu-id="cee2b-113">Windows Server 2008 R2</span></span>

> [!Note]  
> <span data-ttu-id="cee2b-114">Windows Server 2008 R2 est uniquement disponible en version 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-114">Windows Server 2008 R2 is only available as a 64-bit edition.</span></span>

 

-   [<span data-ttu-id="cee2b-115">Différences dans la mémoire adressable</span><span class="sxs-lookup"><span data-stu-id="cee2b-115">Differences in Addressable Memory</span></span>](#differences-in-addressable-memory)
-   [<span data-ttu-id="cee2b-116">Spécification de la prise en charge des adresses importantes lors de la génération</span><span class="sxs-lookup"><span data-stu-id="cee2b-116">Specifying Large-Address-Aware When Building</span></span>](#specifying-large-address-aware-when-building)
-   [<span data-ttu-id="cee2b-117">Compatibilité des applications 32 bits sur les plateformes 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-117">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [<span data-ttu-id="cee2b-118">Pièges de compatibilité potentiels</span><span class="sxs-lookup"><span data-stu-id="cee2b-118">Potential Compatibility Pitfalls</span></span>](#potential-compatibility-pitfalls)
-   [<span data-ttu-id="cee2b-119">Portage d’applications vers des plateformes 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-119">Porting Applications to 64-Bit Platforms</span></span>](#porting-applications-to-64-bit-platforms)
-   [<span data-ttu-id="cee2b-120">Profilage et optimisation des applications portées</span><span class="sxs-lookup"><span data-stu-id="cee2b-120">Profiling and Optimization of Ported Applications</span></span>](#profiling-and-optimization-of-ported-applications)
-   [<span data-ttu-id="cee2b-121">Code managé sur un système d’exploitation 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-121">Managed Code on a 64-bit Operating System</span></span>](#managed-code-on-a-64-bit-operating-system)
-   [<span data-ttu-id="cee2b-122">Implications sur les performances de l’exécution d’un système d’exploitation 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-122">Performance Implications of Running a 64-bit Operating System</span></span>](#performance-implications-of-running-a-64-bit-operating-system)
-   [<span data-ttu-id="cee2b-123">Résumé</span><span class="sxs-lookup"><span data-stu-id="cee2b-123">Summary</span></span>](#summary)

## <a name="differences-in-addressable-memory"></a><span data-ttu-id="cee2b-124">Différences dans la mémoire adressable</span><span class="sxs-lookup"><span data-stu-id="cee2b-124">Differences in Addressable Memory</span></span>

<span data-ttu-id="cee2b-125">La première chose que la plupart des développeurs remarquent est que les processeurs 64 bits fournissent un énorme bond dans la quantité de mémoire physique et virtuelle qui peut être traitée.</span><span class="sxs-lookup"><span data-stu-id="cee2b-125">The first thing most developers notice is that 64-bit processors provide a huge leap in the amount of physical and virtual memory that can be addressed.</span></span>

-   <span data-ttu-id="cee2b-126">les applications 32 bits sur les plateformes 32 bits peuvent traiter jusqu’à 2 Go.</span><span class="sxs-lookup"><span data-stu-id="cee2b-126">32-bit applications on 32-bit platforms can address up to 2 GB.</span></span>
-   <span data-ttu-id="cee2b-127">les applications 32 bits générées avec l’indicateur d’éditeur de liens/LARGEADDRESSAWARE : YES sur 32 bits Windows XP ou Windows Server 2003 avec l’option de démarrage/3GB spéciale peuvent traiter jusqu’à 3 Go.</span><span class="sxs-lookup"><span data-stu-id="cee2b-127">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on 32-bit Windows XP or Windows Server 2003 with the special /3gb boot option can address up to 3 GB.</span></span> <span data-ttu-id="cee2b-128">Cela limite le noyau à 1 Go, ce qui peut entraîner l’échec de certains pilotes et/ou services.</span><span class="sxs-lookup"><span data-stu-id="cee2b-128">This constrains the kernel to only 1 GB which may cause some drivers and/or services to fail.</span></span>
-   <span data-ttu-id="cee2b-129">les applications 32 bits générées avec l’indicateur d’éditeur de liens/LARGEADDRESSAWARE : YES sur les éditions 32 bits de Windows Vista, Windows Server 2008 et Windows 7 peuvent traiter la mémoire jusqu’au nombre spécifié par l’élément de données de configuration de démarrage (BCD) IncreaseUserVa.</span><span class="sxs-lookup"><span data-stu-id="cee2b-129">32-bit applications built with the /LARGEADDRESSAWARE:YES linker flag on the 32-bit editions of Windows Vista, Windows Server 2008, and Windows 7 can address memory up to the number specified by the boot configuration data (BCD) element IncreaseUserVa.</span></span> <span data-ttu-id="cee2b-130">IncreaseUserVa peut avoir une valeur comprise entre 2048, la valeur par défaut, 3072 (qui correspond à la quantité de mémoire configurée par l’option de démarrage/3GB sur Windows XP).</span><span class="sxs-lookup"><span data-stu-id="cee2b-130">IncreaseUserVa can have a value ranging from 2048, the default, to 3072 (which matches the amount of memory configured by the /3gb boot option on Windows XP).</span></span> <span data-ttu-id="cee2b-131">Le reste de 4 Go est alloué au noyau et peut entraîner l’échec des configurations du pilote et du service.</span><span class="sxs-lookup"><span data-stu-id="cee2b-131">The remainder of 4 GB is allocated to the kernel and can result in failing driver and service configurations.</span></span>

    <span data-ttu-id="cee2b-132">Pour plus d’informations sur BCD, consultez [données de configuration de démarrage (BCD)](https://msdn.microsoft.com/library/aa362692.aspx) sur MSDN.</span><span class="sxs-lookup"><span data-stu-id="cee2b-132">For more information about BCD, see [Boot Configuration Data](https://msdn.microsoft.com/library/aa362692.aspx) on MSDN.</span></span>

-   <span data-ttu-id="cee2b-133">les applications 32 bits sur les plateformes 64 bits peuvent adresser jusqu’à 2 Go, ou jusqu’à 4 Go avec l’indicateur d’éditeur de liens/LARGEADDRESSAWARE : YES.</span><span class="sxs-lookup"><span data-stu-id="cee2b-133">32-bit applications on 64-bit platforms can address up to 2 GB, or up to 4 GB with the /LARGEADDRESSAWARE:YES linker flag.</span></span>
-   <span data-ttu-id="cee2b-134">les applications 64 bits utilisent 43 bits pour l’adressage, qui fournit 8 to d’adresse virtuelle pour les applications et 8 to réservés pour le noyau.</span><span class="sxs-lookup"><span data-stu-id="cee2b-134">64-bit applications use 43 bits for addressing, which provides 8 TB of virtual address for applications and 8 TB reserved for the kernel.</span></span>

<span data-ttu-id="cee2b-135">Au-delà de la mémoire, les applications 64 bits qui utilisent l’avantage d’e/s de fichier mappé en mémoire sont largement tirées de l’espace d’adressage virtuel accru.</span><span class="sxs-lookup"><span data-stu-id="cee2b-135">Beyond just memory, 64-bit applications that use memory-mapped file I/O benefit greatly from the increased virtual address space.</span></span> <span data-ttu-id="cee2b-136">L’architecture 64 bits offre également des performances à virgule flottante améliorées et une transmission plus rapide des paramètres.</span><span class="sxs-lookup"><span data-stu-id="cee2b-136">The 64-bit architecture also has improved floating-point performance and faster passing of parameters.</span></span> <span data-ttu-id="cee2b-137">Les processeurs 64 bits ont un double du nombre de registres, des types à usage général et des extensions streaming SIMD (SSE), ainsi que la prise en charge des jeux d’instructions SSE et SSE2 ; de nombreux processeurs 64 bits prennent même en charge les jeux d’instructions SSE3.</span><span class="sxs-lookup"><span data-stu-id="cee2b-137">Sixty-four-bit processors have double the number of registers, of both general purpose and streaming SIMD extensions (SSE) types, as well as support for SSE and SSE2 instruction sets; many 64-bit processors even support SSE3 instruction sets.</span></span>

## <a name="specifying-large-address-aware-when-building"></a><span data-ttu-id="cee2b-138">Spécification de la prise en charge des adresses importantes lors de la génération</span><span class="sxs-lookup"><span data-stu-id="cee2b-138">Specifying Large-Address-Aware When Building</span></span>

<span data-ttu-id="cee2b-139">Il est recommandé de spécifier la prise en charge des adresses importantes lors de la génération d’applications 32 bits, à l’aide de l’indicateur de l’éditeur de liens/LARGEADDRESSAWARE, même si l’application n’est pas destinée à une plateforme 64 bits, en raison des avantages acquis gratuitement.</span><span class="sxs-lookup"><span data-stu-id="cee2b-139">It is a good practice to specify large-address-aware when building 32-bit applications, by using the linker flag /LARGEADDRESSAWARE, even if the application is not intended for a 64-bit platform, because of the advantages that are gained at no cost.</span></span> <span data-ttu-id="cee2b-140">Comme expliqué précédemment, l’activation de cet indicateur pour une build permet à un programme 32 bits d’accéder à davantage de mémoire avec des options de démarrage spéciales sur un système d’exploitation 32 bits ou sur un système d’exploitation 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-140">As explained earlier, enabling this flag for a build allows a 32-bit program to access more memory with special boot options on a 32-bit OS or on a 64-bit OS.</span></span> <span data-ttu-id="cee2b-141">Toutefois, les développeurs doivent veiller à ce que les hypothèses de pointeur ne soient pas faites, par exemple en supposant que le bit de poids fort n’est jamais défini dans un pointeur 32 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-141">However, developers must be careful that pointer assumptions are not made, such as assuming that the high-bit is never set in a 32-bit pointer.</span></span> <span data-ttu-id="cee2b-142">En général, l’activation de l’indicateur/LARGEADDRESSAWARE est une bonne pratique.</span><span class="sxs-lookup"><span data-stu-id="cee2b-142">In general, enabling the /LARGEADDRESSAWARE flag is a good practice.</span></span>

<span data-ttu-id="cee2b-143">Les applications 32 bits qui prennent en charge les adresses peuvent déterminer au moment de l’exécution la quantité d’espace d’adressage virtuel totale qui leur est disponible avec la configuration actuelle du système d’exploitation en appelant [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span><span class="sxs-lookup"><span data-stu-id="cee2b-143">Thirty-two-bit applications that are large-address-aware can determine at run time how much total virtual address space is available to them with the current OS configuration by calling [**GlobalMemoryStatusEx**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).</span></span> <span data-ttu-id="cee2b-144">Le résultat ullTotalVirtual est compris entre 2147352576 octets (2 Go) et 4294836224 octets (4 Go).</span><span class="sxs-lookup"><span data-stu-id="cee2b-144">The ullTotalVirtual result will range from 2147352576 bytes (2 GB) to 4294836224 bytes (4 GB).</span></span> <span data-ttu-id="cee2b-145">Les valeurs supérieures à 3221094400 (3 Go) peuvent uniquement être obtenues sur les éditions 64 bits de Windows.</span><span class="sxs-lookup"><span data-stu-id="cee2b-145">Values that are larger than 3221094400 (3 GB) can only be obtained on 64-bit editions of Windows.</span></span> <span data-ttu-id="cee2b-146">Par exemple, si IncreaseUserVa a la valeur 2560, le résultat est ullTotalVirtual avec une valeur de 2684223488 octets.</span><span class="sxs-lookup"><span data-stu-id="cee2b-146">For example, if IncreaseUserVa has a value of 2560, the result is ullTotalVirtual with a value of 2684223488 bytes.</span></span>

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a><span data-ttu-id="cee2b-147">Compatibilité des applications 32 bits sur les plateformes 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-147">Compatibility of 32-Bit Applications on 64-Bit Platforms</span></span>

<span data-ttu-id="cee2b-148">Les systèmes d’exploitation Windows 64 bits sont compatibles binaires avec l’architecture IA32, et la majorité des API utilisées par les applications 32 bits sont disponibles via Windows 32 bits sur l’émulateur Windows 64 bits, WOW64.</span><span class="sxs-lookup"><span data-stu-id="cee2b-148">Sixty-four-bit Windows operating systems are binary compatible with the IA32 architecture, and the majority of APIs that 32-bit applications use are available through the Windows 32-bit on Windows 64-bit Emulator, WOW64.</span></span> <span data-ttu-id="cee2b-149">WOW64 permet de s’assurer que ces API fonctionnent comme prévu.</span><span class="sxs-lookup"><span data-stu-id="cee2b-149">WOW64 helps ensure that these APIs will work as intended.</span></span>

<span data-ttu-id="cee2b-150">WOW64 a une couche d’exécution qui gère le marshaling des données 32 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-150">WOW64 has an execution layer that handles the marshalling of 32-bit data.</span></span> <span data-ttu-id="cee2b-151">WOW64 redirige les demandes de fichier DLL, redirige certaines branches du Registre pour les applications 32 bits et reflète certaines branches du Registre pour les applications 32 et 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-151">WOW64 redirects DLL file requests, redirects some registry branches for 32-bit applications, and reflects some registry branches for 32- and 64-bit applications.</span></span>

<span data-ttu-id="cee2b-152">Pour plus d’informations sur WOW64, consultez les détails de l' [implémentation WOW64](/windows/desktop/WinProg64/wow64-implementation-details) sur MSDN.</span><span class="sxs-lookup"><span data-stu-id="cee2b-152">More information on WOW64 can be found at [WOW64 Implementation Details](/windows/desktop/WinProg64/wow64-implementation-details) on MSDN.</span></span> <span data-ttu-id="cee2b-153">Pour connaître les meilleures pratiques pour la création d’applications qui s’exécutent sur WOW64, consultez [meilleures pratiques pour WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) sur Windows Hardware Developer Central.</span><span class="sxs-lookup"><span data-stu-id="cee2b-153">For best practices for building applications that run on WOW64, see [Best Practices for WOW64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) on Windows Hardware Developer Central.</span></span>

### <a name="potential-compatibility-pitfalls"></a><span data-ttu-id="cee2b-154">Pièges de compatibilité potentiels</span><span class="sxs-lookup"><span data-stu-id="cee2b-154">Potential Compatibility Pitfalls</span></span>

<span data-ttu-id="cee2b-155">La plupart des applications développées pour une plateforme 32 bits s’exécuteront sans problème sur une plateforme 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-155">Most applications developed for a 32-bit platform will run without problems on a 64-bit platform.</span></span> <span data-ttu-id="cee2b-156">Certaines applications peuvent présenter des problèmes, notamment les suivants :</span><span class="sxs-lookup"><span data-stu-id="cee2b-156">A few applications could have issues, which might include the following:</span></span>

-   <span data-ttu-id="cee2b-157">Tous les pilotes pour les éditions 64 bits des systèmes d’exploitation Windows doivent être des versions 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-157">All drivers for by 64-bit editions of Windows operating systems must be 64-bit versions.</span></span> <span data-ttu-id="cee2b-158">L’exigence de nouveaux pilotes 64 bits a des implications pour les schémas de protection contre la copie qui reposent sur les anciens pilotes.</span><span class="sxs-lookup"><span data-stu-id="cee2b-158">Requiring new 64-bit drivers has implications for copy-protection schemes that rely on old drivers.</span></span> <span data-ttu-id="cee2b-159">Notez que les pilotes en mode noyau doivent être signés par Authenticode pour être chargés par les éditions 64 bits de Windows.</span><span class="sxs-lookup"><span data-stu-id="cee2b-159">Note that kernel-mode drivers must be Authenticode-signed to be loaded by 64-bit editions of Windows.</span></span>
-   <span data-ttu-id="cee2b-160">les processus 64 bits ne peuvent pas charger les dll 32 bits, et les processus 32 bits ne peuvent pas charger les dll 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-160">64-bit processes cannot load 32-bit DLLs, and 32-bit processes cannot load 64-bit DLLs.</span></span> <span data-ttu-id="cee2b-161">Les développeurs doivent s’assurer que les versions 64 bits des dll tierces sont disponibles avant de procéder au développement.</span><span class="sxs-lookup"><span data-stu-id="cee2b-161">Developers must ensure that 64-bit versions of third-party DLLs are available before proceeding with development.</span></span> <span data-ttu-id="cee2b-162">Si vous devez utiliser une DLL 32 bits dans un processus 64 bits, la communication entre processus Windows (IPC) peut être utilisée.</span><span class="sxs-lookup"><span data-stu-id="cee2b-162">If you must use a 32-bit DLL in a 64-bit process, then Windows inter-process communication (IPC) can be used.</span></span> <span data-ttu-id="cee2b-163">Les composants COM peuvent également utiliser les serveurs hors processus et le marshaling pour communiquer entre les limites, mais cela peut entraîner une baisse des performances.</span><span class="sxs-lookup"><span data-stu-id="cee2b-163">COM components can also make use of out-of-process servers and marshalling to communicate between boundaries, but doing so may introduce a performance penalty.</span></span>
-   <span data-ttu-id="cee2b-164">De nombreux processeurs x64 sont également des processeurs multicœurs, et les développeurs doivent tester la manière dont cela affecte leurs applications héritées.</span><span class="sxs-lookup"><span data-stu-id="cee2b-164">Many x64 processors are also multi-core processors, and developers need to test to how this affects their legacy applications.</span></span> <span data-ttu-id="cee2b-165">Vous trouverez plus d’informations sur les processeurs multicœurs et les implications pour les applications de jeu dans les [processeurs de synchronisation de jeux et multicœurs](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span><span class="sxs-lookup"><span data-stu-id="cee2b-165">More information on multi-core processors and the implications for gaming applications can be found in [Game Timing and Multicore Processors](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).</span></span>
-   <span data-ttu-id="cee2b-166">Les applications doivent également appeler [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) pour découvrir les chemins d’accès aux fichiers, car certains noms de dossiers ont été modifiés dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="cee2b-166">Applications should also call [**SHGetFolderPath**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) to discover file paths, as some folder names have changed in certain cases.</span></span> <span data-ttu-id="cee2b-167">Par exemple, les \_ fichiers programme CSIDL \_ retournent « C : \\ Program Files (x86) » pour une application 32 bits qui s’exécute sur une plateforme 64 bits au lieu de « c : \\ Program Files ».</span><span class="sxs-lookup"><span data-stu-id="cee2b-167">For example, CSIDL\_PROGRAM\_FILES would return "C:\\Program Files(x86)" for a 32-bit application running on a 64-bit platform instead of "C:\\Program Files".</span></span> <span data-ttu-id="cee2b-168">Les développeurs doivent être attentifs à la façon dont les fonctionnalités de redirection et de réflexion de l’émulateur WOW64 fonctionnent.</span><span class="sxs-lookup"><span data-stu-id="cee2b-168">Developers must be mindful of how the WOW64 emulator's redirection and reflection capabilities work.</span></span>

<span data-ttu-id="cee2b-169">En outre, les développeurs doivent être vigilants avec les programmes 16 bits qu’ils utilisent peut-être encore.</span><span class="sxs-lookup"><span data-stu-id="cee2b-169">In addition, developers need to be wary of 16-bit programs that they might still be using.</span></span> <span data-ttu-id="cee2b-170">WOW64 ne peut pas gérer les applications 16 bits. Cela comprend les anciens programmes d’installation et tous les programmes MS-DOS.</span><span class="sxs-lookup"><span data-stu-id="cee2b-170">WOW64 cannot handle 16-bit applications; this includes old installers and all MS-DOS programs.</span></span>

> [!Note]  
> <span data-ttu-id="cee2b-171">Les problèmes de compatibilité les plus courants sont les programmes d’installation qui exécutent du code 16 bits et qui n’ont pas de pilotes 64 bits pour les schémas de protection contre la copie.</span><span class="sxs-lookup"><span data-stu-id="cee2b-171">The most common compatibility issues are installers that execute 16-bit code and not having 64-bit drivers for copy protection schemes.</span></span>

 

<span data-ttu-id="cee2b-172">La section suivante traite des problèmes liés au portage de code vers le mode natif 64 bits pour les développeurs qui souhaitent s’assurer que leurs programmes hérités fonctionnent sur des plateformes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-172">The next section discusses issues related to porting code to 64-bit native for developers that want to ensure their legacy programs work on 64-bit platforms.</span></span> <span data-ttu-id="cee2b-173">C’est également pour les développeurs qui ne connaissent pas la programmation 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-173">It is also for developers who are unfamiliar with 64-bit programming.</span></span>

## <a name="porting-applications-to-64-bit-platforms"></a><span data-ttu-id="cee2b-174">Portage d’applications vers des plateformes 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-174">Porting Applications to 64-Bit Platforms</span></span>

<span data-ttu-id="cee2b-175">Le fait de disposer des bons outils et bibliothèques vous aidera à faciliter la transition du développement 32 bits à 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-175">Having the right tools and libraries will help to ease the transition from 32-bit to 64-bit development.</span></span> <span data-ttu-id="cee2b-176">Le kit de développement logiciel (SDK) DirectX 9 contient des bibliothèques qui prennent en charge les projets x86 et x64.</span><span class="sxs-lookup"><span data-stu-id="cee2b-176">The DirectX 9 SDK has libraries to support both x86- and x64-based projects.</span></span> <span data-ttu-id="cee2b-177">Microsoft Visual Studio 2005 et Visual Studio 2008 prennent en charge la génération de code pour x86 et x64, et elles sont fournies avec des bibliothèques optimisées pour la génération de code x64.</span><span class="sxs-lookup"><span data-stu-id="cee2b-177">Microsoft Visual Studio 2005 and Visual Studio 2008 support code generation for both x86 and x64, and they comes with libraries optimized for generating x64 code.</span></span> <span data-ttu-id="cee2b-178">Toutefois, il est également nécessaire pour les développeurs de distribuer les runtimes Visual C avec leurs applications.</span><span class="sxs-lookup"><span data-stu-id="cee2b-178">However, it will also be necessary for developers to distribute the Visual C runtimes with their applications.</span></span> <span data-ttu-id="cee2b-179">Notez que les éditions Express de Visual Studio 2005 et Visual Studio 2008 n’incluent pas le compilateur x64, contrairement aux éditions standard, Professional et Team System.</span><span class="sxs-lookup"><span data-stu-id="cee2b-179">Note that the Express Editions of Visual Studio 2005 and Visual Studio 2008 do not include the x64 compiler, but that the Standard, Professional, and Team System editions all do.</span></span>

<span data-ttu-id="cee2b-180">Les développeurs qui ciblent des plateformes 32 bits peuvent préparer le développement 64 bits pour faciliter la transition plus tard.</span><span class="sxs-lookup"><span data-stu-id="cee2b-180">Developers who are targeting 32-bit platforms can prepare for 64-bit development to make their transition easier later on.</span></span> <span data-ttu-id="cee2b-181">Lors de la compilation de projets 32 bits, les développeurs doivent utiliser l’indicateur/Wp64, ce qui entraîne la génération d’avertissements sur les problèmes affectant la portabilité.</span><span class="sxs-lookup"><span data-stu-id="cee2b-181">When compiling 32-bit projects, developers should use the /Wp64 flag, which will cause the generation of warnings about issues that affect portability.</span></span> <span data-ttu-id="cee2b-182">Le basculement vers les outils et les bibliothèques 64 bits générera probablement beaucoup de nouvelles erreurs de génération. par conséquent, il est recommandé de basculer entre les outils et les bibliothèques de bits neutres et de corriger les avertissements avant de passer à une version 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-182">Switching to 64-bit tools and libraries will probably generate a lot of new build errors initially; so, it is advisable to switch bit-neutral tools and libraries and correct any warnings before switching to a 64-bit build.</span></span>

<span data-ttu-id="cee2b-183">Toutefois, la modification des outils, la modification des bibliothèques et l’utilisation de certains indicateurs du compilateur ne suffisent pas.</span><span class="sxs-lookup"><span data-stu-id="cee2b-183">Changing tools, changing libraries, and using certain compiler flags will not be enough, though.</span></span> <span data-ttu-id="cee2b-184">Les hypothèses dans les normes de codage doivent être réévaluées pour s’assurer que les normes de codage actuelles n’autorisent pas les problèmes de portabilité.</span><span class="sxs-lookup"><span data-stu-id="cee2b-184">Assumptions in coding standards must be reevaluated to ensure that current coding standards don't allow portability issues.</span></span> <span data-ttu-id="cee2b-185">Les problèmes de portabilité peuvent inclure la troncation de pointeur, la taille et l’alignement des types de données, la dépendance sur les dll 32 bits, l’utilisation d’API héritées, le code assembleur et les anciens fichiers binaires.</span><span class="sxs-lookup"><span data-stu-id="cee2b-185">Portability issues can include pointer truncation, size and alignment of data types, reliance on 32-bit DLLs, use of legacy APIs, assembly code, and old binary files.</span></span>

> [!Note]  
> <span data-ttu-id="cee2b-186">Visual C++ 2010 comprend les en-têtes stdint. h et cstdint C99 qui définissent les types de portabilité standard Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 \_ t, IntPtr \_ t et UIntPtr \_ t.</span><span class="sxs-lookup"><span data-stu-id="cee2b-186">Visual C++ 2010 includes the stdint.h and cstdint C99 headers which define the standard portability types int32\_t, uint32\_t, int64\_t, uint64\_t, intptr\_t, and uintptr\_t.</span></span> <span data-ttu-id="cee2b-187">L’utilisation de ceux-ci avec les types de données standard ptrdiff \_ t et Size \_ t peut être préférable aux types Windows portabilty utilisés ci-dessous pour améliorer la portabilité du code.</span><span class="sxs-lookup"><span data-stu-id="cee2b-187">Using these along with the standard ptrdiff\_t and size\_t data types may be preferrable to the Windows portabilty types used below for improving portability of code.</span></span>

 

<span data-ttu-id="cee2b-188">Les principaux problèmes de Portage sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="cee2b-188">Major porting issues include the following:</span></span>

<dl> <dt>

<span data-ttu-id="cee2b-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Troncation de pointeur**</span><span class="sxs-lookup"><span data-stu-id="cee2b-189"><span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Pointer Truncation**</span></span>
</dt> <dd>

<span data-ttu-id="cee2b-190">Les pointeurs étant de 64 bits sur un système d’exploitation 64 bits, le cast de pointeurs vers d’autres types de données peut entraîner une troncation, et l’arithmétique de pointeur peut entraîner une altération.</span><span class="sxs-lookup"><span data-stu-id="cee2b-190">Pointers are 64-bits on a 64-bit OS, so casting pointers to other data types can result in truncation, and pointer arithmetic can result in corruption.</span></span> <span data-ttu-id="cee2b-191">L’utilisation de l’indicateur/Wp64 fournit généralement un avertissement sur ce type de problème, mais l’utilisation de types polymorphes (INT \_ ptr, DWORD \_ ptr, size \_ T, uint \_ ptr, etc.) lors de la conversion des types pointeur est une bonne pratique pour éviter tout problème.</span><span class="sxs-lookup"><span data-stu-id="cee2b-191">Using the /Wp64 flag will usually provide a warning about this kind of issue, but using polymorphic types (INT\_PTR, DWORD\_PTR, SIZE\_T, UINT\_PTR, and so on) when casting pointer types is a good practice to help avoid this issue altogether.</span></span> <span data-ttu-id="cee2b-192">Étant donné que les pointeurs sont 64 bits sur les nouvelles plateformes, les développeurs doivent vérifier l’ordre des pointeurs, ainsi que les types de données dans les classes et les structures, afin de réduire ou d’éliminer le remplissage.</span><span class="sxs-lookup"><span data-stu-id="cee2b-192">Since pointers are 64-bit on new platforms, developers should check the ordering of pointers, and the data types in classes and structures, to reduce or eliminate padding.</span></span>

</dd> <dt>

<span data-ttu-id="cee2b-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Types de données et fichiers binaires**</span><span class="sxs-lookup"><span data-stu-id="cee2b-193"><span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Data Types and Binary Files**</span></span>
</dt> <dd>

<span data-ttu-id="cee2b-194">Alors que les pointeurs augmentent de 32 bits à 64 sur une plateforme 64 bits, les autres types de données ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="cee2b-194">While pointers increase from 32 bits to 64 on a 64-bit platform, other data types don't.</span></span> <span data-ttu-id="cee2b-195">Les types de données à précision fixe (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) peuvent être utilisés dans des emplacements où la taille du type de données doit être connue. par exemple, dans une structure de fichiers binaires.</span><span class="sxs-lookup"><span data-stu-id="cee2b-195">Fixed-precision data types (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32, UINT64) can be used in places where the size of the data type must be known; for example, in a binary file structure.</span></span> <span data-ttu-id="cee2b-196">Les modifications apportées à la taille du pointeur et à l’alignement des données nécessitent un traitement spécial pour garantir la compatibilité 32 bits-à 64-bit.</span><span class="sxs-lookup"><span data-stu-id="cee2b-196">The changes in pointer size and data alignment require special handling to ensure 32-bit-to-64-bit compatibility.</span></span> <span data-ttu-id="cee2b-197">Pour plus d’informations, consultez [préparation pour Windows 64 bits : nouveaux types de données](/windows/desktop/WinProg64/the-new-data-types).</span><span class="sxs-lookup"><span data-stu-id="cee2b-197">More information can be found in [Getting Ready for 64-bit Windows: The New Data Types](/windows/desktop/WinProg64/the-new-data-types).</span></span>

</dd> <dt>

<span data-ttu-id="cee2b-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Anciennes API Win32 et alignement des données**</span><span class="sxs-lookup"><span data-stu-id="cee2b-198"><span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Older Win32 APIs and Data Alignment**</span></span>
</dt> <dd>

<span data-ttu-id="cee2b-199">Certaines API Win32 ont été dépréciées et remplacées par des appels d’API plus neutres tels que SetWindowLongPtr à la place de SetWindowLong.</span><span class="sxs-lookup"><span data-stu-id="cee2b-199">Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong.</span></span>

<span data-ttu-id="cee2b-200">La baisse des performances pour les accès non alignés est plus importante sur la plateforme x64 que sur une plateforme x86.</span><span class="sxs-lookup"><span data-stu-id="cee2b-200">The performance penalty for non-aligned accesses is greater on x64 platform than on an x86 platform.</span></span> <span data-ttu-id="cee2b-201">Les \_ macros alignement de type (t) et décalage de champ \_ (t, membre) peuvent être utilisées pour déterminer les informations d’alignement qui peuvent être utilisées directement par le code.</span><span class="sxs-lookup"><span data-stu-id="cee2b-201">The TYPE\_ALIGNMENT(t) and the FIELD\_OFFSET(t, member) macros can be used to determine alignment information that can used directly by code.</span></span> <span data-ttu-id="cee2b-202">L’utilisation correcte de ces macros mentionnées ci-dessus doit éliminer les pénalités potentielles d’accès non aligné.</span><span class="sxs-lookup"><span data-stu-id="cee2b-202">Correct use of these aforementioned macros should eliminate potential non-aligned access penalties.</span></span>

<span data-ttu-id="cee2b-203">Pour plus d’informations sur la macro d’alignement de TYPE \_ , la \_ macro décalage de champ et les informations de programmation 64 bits générales, consultez [programmation Windows sur 64 bits : conseils de migration : considérations supplémentaires](/windows/desktop/WinProg64/additional-considerations) et [préparation pour les fenêtres 64 bits : règles d’utilisation des pointeurs](/windows/desktop/WinProg64/rules-for-using-pointers).</span><span class="sxs-lookup"><span data-stu-id="cee2b-203">More information on the TYPE\_ALIGNMENT macro, the FIELD\_OFFSET macro, and general 64-bit programming information can be found at [64-bit Windows Programming: Migration Tips: Additional Considerations](/windows/desktop/WinProg64/additional-considerations) and [Getting Ready for 64-bit Windows: Rules for Using Pointers](/windows/desktop/WinProg64/rules-for-using-pointers).</span></span>

</dd> <dt>

<span data-ttu-id="cee2b-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Code assembleur**</span><span class="sxs-lookup"><span data-stu-id="cee2b-204"><span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Assembly Code**</span></span>
</dt> <dd>

<span data-ttu-id="cee2b-205">Le code assembleur inline n’est pas pris en charge sur les plateformes 64 bits et doit être remplacé.</span><span class="sxs-lookup"><span data-stu-id="cee2b-205">Inline assembly code is not supported on 64-bit platforms and needs to be replaced.</span></span> <span data-ttu-id="cee2b-206">Les modifications apportées à l’architecture peuvent avoir changé les goulots d’étranglement de l’application, et C/C++ ou intrinsèques peuvent obtenir des résultats similaires avec un code plus facile à lire.</span><span class="sxs-lookup"><span data-stu-id="cee2b-206">Changes in the architecture may have changed application bottlenecks, and C/C++ or intrinsics can achieve similar results with code that is easier to read.</span></span> <span data-ttu-id="cee2b-207">La pratique la plus recommandée consiste à basculer tout le code d’assembly vers C ou C++.</span><span class="sxs-lookup"><span data-stu-id="cee2b-207">The most advisable practice is to switch all assembly code to C or C++.</span></span> <span data-ttu-id="cee2b-208">Les intrinsèques peuvent être utilisés à la place du code assembleur, mais ne doivent être utilisés qu’après l’exécution du profilage et de l’analyse complets.</span><span class="sxs-lookup"><span data-stu-id="cee2b-208">Intrinsics can be used in place of assembly code, but should only be used after full profiling and analysis has been performed.</span></span>

<span data-ttu-id="cee2b-209">X87, MMX et 3DNow !</span><span class="sxs-lookup"><span data-stu-id="cee2b-209">The x87, MMX, and 3DNow!</span></span> <span data-ttu-id="cee2b-210">les jeux d’instructions sont déconseillés en mode 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-210">instruction sets are deprecated in 64-bit modes.</span></span> <span data-ttu-id="cee2b-211">Les ensembles d’instructions sont toujours présents pour la compatibilité descendante en mode 32 bits ; Toutefois, pour éviter des problèmes de compatibilité à l’avenir, leur utilisation dans les projets actuels et futurs est déconseillée.</span><span class="sxs-lookup"><span data-stu-id="cee2b-211">The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, their use in current and future projects is discouraged.</span></span>

</dd> <dt>

<span data-ttu-id="cee2b-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**API déconseillées**</span><span class="sxs-lookup"><span data-stu-id="cee2b-212"><span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Deprecated APIs**</span></span>
</dt> <dd>

<span data-ttu-id="cee2b-213">Certaines API DirectX plus anciennes ont été supprimées pour les applications natives 64 bits : DirectPlay 4 et versions antérieures, DirectDraw 6 et versions antérieures, Direct3D 8 et versions antérieures, et DirectInput 7 et versions antérieures.</span><span class="sxs-lookup"><span data-stu-id="cee2b-213">Some older DirectX APIs have been dropped for 64-bit native applications: DirectPlay 4 and earlier, DirectDraw 6 and earlier, Direct3D 8 and earlier, and DirectInput 7 and earlier.</span></span> <span data-ttu-id="cee2b-214">En outre, l’API principale de DirectMusic est disponible pour les applications 64 bits natives, mais la couche de performances et le producteur DirectMusic sont déconseillés.</span><span class="sxs-lookup"><span data-stu-id="cee2b-214">Also, the core API of DirectMusic is available to native 64-bit applications, but the performance layer and DirectMusic Producer are deprecated.</span></span>

<span data-ttu-id="cee2b-215">Visual Studio émet des avertissements de désapprobation, et ces modifications ne sont pas un problème pour les développeurs qui utilisent les API les plus récentes.</span><span class="sxs-lookup"><span data-stu-id="cee2b-215">Visual Studio issues deprecation warnings, and these changes are not an issue for developers who use the latest APIs.</span></span>

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a><span data-ttu-id="cee2b-216">Profilage et optimisation des applications portées</span><span class="sxs-lookup"><span data-stu-id="cee2b-216">Profiling and Optimization of Ported Applications</span></span>

<span data-ttu-id="cee2b-217">Tous les développeurs doivent reprofiler toutes les applications qui sont portées vers de nouvelles architectures.</span><span class="sxs-lookup"><span data-stu-id="cee2b-217">All developers need to re-profile any applications that are being ported to new architectures.</span></span> <span data-ttu-id="cee2b-218">De nombreuses applications qui sont portées sur des plateformes 64 bits auront des profils de performances différents de leurs versions 32 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-218">Many applications being ported to 64-bit platforms will have different performance profiles from their 32-bit versions.</span></span> <span data-ttu-id="cee2b-219">Les développeurs doivent exécuter des tests de performances 64 bits avant d’évaluer ce qui doit être optimisé.</span><span class="sxs-lookup"><span data-stu-id="cee2b-219">Developers need to run 64-bit performance tests before assessing what needs to be optimized.</span></span> <span data-ttu-id="cee2b-220">La bonne nouvelle à ce sujet est que de nombreuses optimisations traditionnelles fonctionnent sur des plateformes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-220">The good news about this is that many traditional optimizations work on 64-bit platforms.</span></span> <span data-ttu-id="cee2b-221">En outre, les compilateurs 64 bits peuvent également effectuer de nombreuses optimisations avec l’utilisation correcte des indicateurs de compilateur et des indicateurs de codage.</span><span class="sxs-lookup"><span data-stu-id="cee2b-221">In addition, 64-bit compilers can also perform many optimizations with the correct use of compiler flags and coding hints.</span></span>

<span data-ttu-id="cee2b-222">Certaines structures peuvent avoir leurs types de données internes réorganisés pour économiser l’espace mémoire et améliorer la mise en cache.</span><span class="sxs-lookup"><span data-stu-id="cee2b-222">Some structures may have their internal data types reordered to conserve memory space and improve caching.</span></span> <span data-ttu-id="cee2b-223">Les index de tableau peuvent être utilisés à la place d’un pointeur 64 bits complet dans certains cas.</span><span class="sxs-lookup"><span data-stu-id="cee2b-223">Array indices can be used instead of a full 64-bit pointer in some cases.</span></span> <span data-ttu-id="cee2b-224">L’indicateur/FP : Fast peut améliorer l’optimisation et la vectorisation à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="cee2b-224">The /fp:fast flag can improve floating-point optimizing and vectorization.</span></span> <span data-ttu-id="cee2b-225">L’utilisation \_ \_ de la restriction, declspec (restrict) et declspec (noalias) peut aider le compilateur à résoudre les alias et à améliorer l’utilisation du fichier de registre.</span><span class="sxs-lookup"><span data-stu-id="cee2b-225">Using \_\_restrict, declspec(restrict), and declspec(noalias) can help the compiler resolve aliasing and improve use of the register file.</span></span>

<span data-ttu-id="cee2b-226">Vous trouverez plus d’informations sur/FP : Fast sur [/FP (spécifier le comportement de Floating-Point)](/cpp/build/reference/fp-specify-floating-point-behavior).</span><span class="sxs-lookup"><span data-stu-id="cee2b-226">More information on /fp:fast can be found at [/fp (Specify Floating-Point Behavior)](/cpp/build/reference/fp-specify-floating-point-behavior).</span></span>

<span data-ttu-id="cee2b-227">Pour plus d’informations sur \_ \_ restrict [, consultez modificateurs spécifiques à Microsoft](/cpp/cpp/microsoft-specific-modifiers).</span><span class="sxs-lookup"><span data-stu-id="cee2b-227">More information on \_\_restrict can be found at [Microsoft-Specific Modifiers](/cpp/cpp/microsoft-specific-modifiers).</span></span>

<span data-ttu-id="cee2b-228">Pour plus d’informations sur declspec (restrict), consultez [meilleures pratiques](/cpp/build/optimization-best-practices)pour l’optimisation.</span><span class="sxs-lookup"><span data-stu-id="cee2b-228">More information on declspec(restrict) can be found at [Optimization Best Practices](/cpp/build/optimization-best-practices).</span></span>

<span data-ttu-id="cee2b-229">Vous trouverez plus d’informations sur declspec (noalias) dans [ \_ \_ declspec (noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span><span class="sxs-lookup"><span data-stu-id="cee2b-229">More information on declspec(noalias) can be found at [\_\_declspec(noalias)](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx).</span></span>

## <a name="managed-code-on-a-64-bit-operating-system"></a><span data-ttu-id="cee2b-230">Code managé sur un système d’exploitation 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-230">Managed Code on a 64-bit Operating System</span></span>

<span data-ttu-id="cee2b-231">Le code managé est utilisé par de nombreux développeurs de jeux dans leur chaîne d’outils. ainsi, une bonne compréhension de son comportement sur un système d’exploitation 64 bits peut être utile.</span><span class="sxs-lookup"><span data-stu-id="cee2b-231">Managed code is used by many game developers in their tool chain, so an understanding of how it behaves on a 64-bit OS can be helpful.</span></span> <span data-ttu-id="cee2b-232">Le code managé est un jeu d’instructions neutre. par conséquent, lorsque vous exécutez une application managée sur un système d’exploitation 64 bits, le Common Language Runtime (CLR) peut l’exécuter en tant que processus 32 bits ou 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-232">Managed code is instruction-set neutral, so when you run a managed application on a 64-bit OS, the Common Language Runtime (CLR) can run it as either a 32-bit or 64-bit process.</span></span> <span data-ttu-id="cee2b-233">Par défaut, le CLR exécute des applications gérées en tant que 64 bits et ne fonctionne pas correctement.</span><span class="sxs-lookup"><span data-stu-id="cee2b-233">By default, the CLR runs managed applications as 64-bit, and they should work fine with no problems.</span></span> <span data-ttu-id="cee2b-234">Toutefois, si votre application dépend d’une DLL native 32 bits, votre application échouera lorsqu’elle tentera d’appeler cette DLL.</span><span class="sxs-lookup"><span data-stu-id="cee2b-234">However, if your application depends on a DLL that is native 32-bit, then your application will fail when it tries to call this DLL.</span></span> <span data-ttu-id="cee2b-235">Un processus 64 bits a besoin d’un code entièrement 64 bits, et une DLL 32 bits ne peut pas être appelée à partir d’un processus de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-235">A 64-bit process needs completely 64-bit code, and a 32-bit DLL cannot be called from a 64-bit process.</span></span> <span data-ttu-id="cee2b-236">La meilleure solution à long terme consiste à compiler votre code natif comme 64-bit également, mais une solution parfaitement raisonnable à long terme consiste simplement à marquer votre application gérée comme étant pour x86 uniquement à l’aide de l’indicateur de build/Platform : x86.</span><span class="sxs-lookup"><span data-stu-id="cee2b-236">The best long-term solution is to compile your native code as 64-bit also, but a perfectly reasonable short-term solution is to simply mark your managed application as being for x86 only by using the /platform:x86 build flag.</span></span>

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a><span data-ttu-id="cee2b-237">Implications sur les performances de l’exécution d’un système d’exploitation 64 bits</span><span class="sxs-lookup"><span data-stu-id="cee2b-237">Performance Implications of Running a 64-bit Operating System</span></span>

<span data-ttu-id="cee2b-238">Étant donné que les processeurs dotés de l’architecture AMD64 et Intel 64 peuvent exécuter des instructions 32 bits en mode natif, ils peuvent exécuter des applications 32 bits à pleine vitesse, même sur un système d’exploitation de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-238">Because processors with AMD64 and Intel 64 architecture can execute 32-bit instructions natively, they can run 32-bit applications at full speed, even on a 64-bit OS.</span></span> <span data-ttu-id="cee2b-239">Il existe un coût modeste pour la conversion des paramètres entre 32 bits et 64 bits lors de l’appel de fonctions du système d’exploitation, mais ce coût est généralement négligeable.</span><span class="sxs-lookup"><span data-stu-id="cee2b-239">There is a modest cost for converting parameters between 32-bit and 64-bit when calling operating system functions, but this cost is generally negligible.</span></span> <span data-ttu-id="cee2b-240">Cela signifie que vous ne devriez voir aucun ralentissement lors de l’exécution d’applications 32 bits sur un système d’exploitation 64 bits.</span><span class="sxs-lookup"><span data-stu-id="cee2b-240">This means that you should see no slowdown when running 32-bit applications on a 64-bit OS.</span></span>

<span data-ttu-id="cee2b-241">Lorsque vous compilez des applications en tant que 64 bits, les calculs sont plus compliqués.</span><span class="sxs-lookup"><span data-stu-id="cee2b-241">When you compile applications as 64-bit, the calculations get more complicated.</span></span> <span data-ttu-id="cee2b-242">Un programme 64 bits utilise des pointeurs 64 bits, et ses instructions sont légèrement plus grandes, donc la mémoire requise est légèrement augmentée.</span><span class="sxs-lookup"><span data-stu-id="cee2b-242">A 64-bit program uses 64-bit pointers, and its instructions are slightly larger, so the memory requirement is slightly increased.</span></span> <span data-ttu-id="cee2b-243">Cela peut entraîner une légère baisse des performances.</span><span class="sxs-lookup"><span data-stu-id="cee2b-243">This can cause a slight drop in performance.</span></span> <span data-ttu-id="cee2b-244">D’un autre côté, le fait d’avoir deux fois plus de registres et d’avoir la possibilité d’effectuer des calculs d’entiers 64 bits dans une instruction unique est souvent plus que compenser.</span><span class="sxs-lookup"><span data-stu-id="cee2b-244">On the other hand, having twice as many registers and having the ability to do 64-bit integer calculations in a single instruction will often more than compensate.</span></span> <span data-ttu-id="cee2b-245">Le résultat net est qu’une application 64 bits peut s’exécuter légèrement plus lentement que la même application compilée en tant que 32 bits, mais elle s’exécute souvent un peu plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="cee2b-245">The net result is that a 64-bit application might run slightly slower than the same application compiled as 32-bit, but it will often run slightly faster.</span></span>

## <a name="summary"></a><span data-ttu-id="cee2b-246">Résumé</span><span class="sxs-lookup"><span data-stu-id="cee2b-246">Summary</span></span>

<span data-ttu-id="cee2b-247">Les architectures 64 bits permettent aux développeurs de pousser les limites sur la façon dont les jeux s’affichent, le son et les jouent.</span><span class="sxs-lookup"><span data-stu-id="cee2b-247">Sixty-four-bit architectures allow developers to push the limitations on how games look, sound, and play.</span></span> <span data-ttu-id="cee2b-248">Toutefois, la transition de la programmation 32 bits à la programmation 64 bits n’est pas évidente.</span><span class="sxs-lookup"><span data-stu-id="cee2b-248">Transitioning from 32-bit programming to 64-bit programming is not trivial, however.</span></span> <span data-ttu-id="cee2b-249">En comprenant les différences entre les deux, et en utilisant les outils les plus récents, la transition vers les plateformes 64 bits peut être plus facile et plus rapide.</span><span class="sxs-lookup"><span data-stu-id="cee2b-249">By understanding the differences between the two, and by using the newest tools, the transition to 64-bit platforms can be easier and faster.</span></span>

<span data-ttu-id="cee2b-250">Vous trouverez plus d’informations sur la programmation 64 bits dans [Visual C++ Centre de développement : programmation 64 bits](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span><span class="sxs-lookup"><span data-stu-id="cee2b-250">More information on 64-bit programming can be found at [Visual C++ Developer Center: 64-Bit Programming](https://msdn.microsoft.com/vstudio//aa336463.aspx).</span></span>

 

 