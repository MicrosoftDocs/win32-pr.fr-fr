---
title: Mappages d’ombres en cascade (CSM)
description: Les mappages d’ombre en cascade (CMS) constituent la meilleure façon de combattre l’une des erreurs les plus courantes avec l’utilisation d’un alias de perspective de masquage.
ms.assetid: d3570d0a-74e0-5b9c-6586-c933f630c4ee
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ae70433f97f33c3cc28af8e282b14ea1f513cf4d
ms.sourcegitcommit: 54db9e6a00a5c8f68e7c1a16b8c6d4943374498c
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/01/2021
ms.locfileid: "106540124"
---
# <a name="cascaded-shadow-maps"></a><span data-ttu-id="b256a-103">Mappages d’ombres en cascade (CSM)</span><span class="sxs-lookup"><span data-stu-id="b256a-103">Cascaded Shadow Maps</span></span>

<span data-ttu-id="b256a-104">Les cartes d’ombre en cascade (CMS) constituent la meilleure façon de combattre l’une des erreurs les plus courantes avec l’occultation : l’utilisation des alias de perspective.</span><span class="sxs-lookup"><span data-stu-id="b256a-104">Cascaded shadow maps (CSMs) are the best way to combat one of the most prevalent errors with shadowing: perspective aliasing.</span></span> <span data-ttu-id="b256a-105">Cet article technique, qui suppose que le lecteur est familiarisé avec le mappage des clichés instantanés, aborde le sujet de CMS.</span><span class="sxs-lookup"><span data-stu-id="b256a-105">This technical article, which assumes the reader is familiar with shadow mapping, tackles the topic of CSMs.</span></span> <span data-ttu-id="b256a-106">Plus précisément, il :</span><span class="sxs-lookup"><span data-stu-id="b256a-106">Specifically, it:</span></span>

-   <span data-ttu-id="b256a-107">explique la complexité de CMS ;</span><span class="sxs-lookup"><span data-stu-id="b256a-107">explains the complexity of CSMs;</span></span>
-   <span data-ttu-id="b256a-108">donne des détails sur les variations possibles des algorithmes CSM.</span><span class="sxs-lookup"><span data-stu-id="b256a-108">gives details on the possible variations of the CSM algorithms;</span></span>
-   <span data-ttu-id="b256a-109">décrit les deux techniques de filtrage les plus courantes : le filtrage en pourcentage plus proche (PCF) et le filtrage avec les mappages d’ombre de variance (VSMs);</span><span class="sxs-lookup"><span data-stu-id="b256a-109">describes the two most common filtering techniques—percentage closer filtering (PCF) and filtering with variance shadow maps (VSMs);</span></span>
-   <span data-ttu-id="b256a-110">identifie et traite certains des pièges courants associés à l’ajout du filtrage à CMS ; les</span><span class="sxs-lookup"><span data-stu-id="b256a-110">identifies and addresses some of the common pitfalls associated with adding filtering to CSMs; and</span></span>
-   <span data-ttu-id="b256a-111">montre comment mapper des CMS à Direct3D 10 via le matériel Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="b256a-111">shows how to map CSMs to Direct3D 10 through Direct3D 11 hardware.</span></span>

<span data-ttu-id="b256a-112">Vous trouverez le code utilisé dans cet article dans le kit de développement logiciel (SDK) DirectX dans les exemples CascadedShadowMaps11 et VarianceShadows11.</span><span class="sxs-lookup"><span data-stu-id="b256a-112">The code used in this article can be found in the DirectX Software Development Kit (SDK) in the CascadedShadowMaps11 and VarianceShadows11 samples.</span></span> <span data-ttu-id="b256a-113">Cet article s’avérera très utile après l’implémentation des techniques présentées dans l’article technique, les [techniques courantes pour améliorer les cartes de profondeur de cliché instantané](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps), sont implémentées.</span><span class="sxs-lookup"><span data-stu-id="b256a-113">This article will prove most useful after implementing the techniques covered in the technical article, [Common Techniques to Improve Shadow Depth Maps](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps), are implemented.</span></span>

## <a name="cascaded-shadow-maps-and-perspective-aliasing"></a><span data-ttu-id="b256a-114">Cartes fictives en cascade et alias de perspective</span><span class="sxs-lookup"><span data-stu-id="b256a-114">Cascaded Shadow Maps and Perspective Aliasing</span></span>

<span data-ttu-id="b256a-115">L’alias de perspective dans une table fictive est l’un des problèmes les plus difficiles à surmonter.</span><span class="sxs-lookup"><span data-stu-id="b256a-115">Perspective aliasing in a shadow map is one of the most difficult problems to overcome.</span></span> <span data-ttu-id="b256a-116">Dans l’article technique, les techniques courantes pour améliorer les cartes de profondeur de cliché instantané, les alias de perspective sont décrites et certaines approches permettant d’atténuer le problème sont identifiées.</span><span class="sxs-lookup"><span data-stu-id="b256a-116">In the technical article, Common Techniques to Improve Shadow Depth Maps, perspective aliasing is described and some approaches to mitigate the problem are identified.</span></span> <span data-ttu-id="b256a-117">En pratique, CMS a tendance à être la meilleure solution et est couramment utilisée dans les jeux modernes.</span><span class="sxs-lookup"><span data-stu-id="b256a-117">In practice, CSMs tend to be the best solution, and are commonly employed in modern games.</span></span>

<span data-ttu-id="b256a-118">Le concept de base de CMS est facile à comprendre.</span><span class="sxs-lookup"><span data-stu-id="b256a-118">The basic concept of CSMs is easy to understand.</span></span> <span data-ttu-id="b256a-119">Les différentes zones de l’appareil photo frustum nécessitent des cartes fictives avec des résolutions différentes.</span><span class="sxs-lookup"><span data-stu-id="b256a-119">Different areas of the camera frustum require shadow maps with different resolutions.</span></span> <span data-ttu-id="b256a-120">Les objets les plus proches de l’oeil requièrent une résolution supérieure à celle des objets distants.</span><span class="sxs-lookup"><span data-stu-id="b256a-120">Objects nearest the eye require a higher resolution than do more distant objects.</span></span> <span data-ttu-id="b256a-121">En fait, lorsque l’œil se déplace très près de la géométrie, les pixels les plus proches de l’œil peuvent nécessiter une résolution tellement importante que même un mappage d’ombre de 4096 × 4096 est insuffisant.</span><span class="sxs-lookup"><span data-stu-id="b256a-121">In fact, when the eye moves very close to the geometry, the pixels nearest the eye can require so much resolution that even a 4096 × 4096 shadow map is insufficient.</span></span>

<span data-ttu-id="b256a-122">L’idée de base de CMS est de partitionner le frustum en plusieurs Frusta.</span><span class="sxs-lookup"><span data-stu-id="b256a-122">The basic idea of CSMs is to partition the frustum into multiple frusta.</span></span> <span data-ttu-id="b256a-123">Un mappage d’ombre est rendu pour chaque subfrustum ; le nuanceur de pixels est ensuite un échantillon de la carte qui correspond le mieux à la résolution requise (figure 2).</span><span class="sxs-lookup"><span data-stu-id="b256a-123">A shadow map is rendered for each subfrustum; the pixel shader then samples from the map that most closely matches the required resolution (Figure 2).</span></span>

<span data-ttu-id="b256a-124">**Figure 1. Couverture des clichés instantanés**</span><span class="sxs-lookup"><span data-stu-id="b256a-124">**Figure 1. Shadow map coverage**</span></span>

![couverture des clichés instantanés](images/shadow-map-coverage.png)

<span data-ttu-id="b256a-126">Dans la figure 1, la qualité est indiquée (de gauche à droite) de la plus élevée à la plus faible.</span><span class="sxs-lookup"><span data-stu-id="b256a-126">In Figure 1, quality is shown (left to right) from highest to lowest.</span></span> <span data-ttu-id="b256a-127">La série de grilles représentant des cartes fictives avec un affichage frustum (cône inversé en rouge) montre comment la couverture des pixels est affectée avec différentes cartes d’ombre de résolution.</span><span class="sxs-lookup"><span data-stu-id="b256a-127">The series of grids representing shadow maps with a view frustum (inverted cone in red) shows how pixel coverage is affected with different resolution shadow maps.</span></span> <span data-ttu-id="b256a-128">Les ombres sont de qualité supérieure (pixels blancs) lorsqu’il y a un rapport de 1:1 pixels de correspondance dans l’espace clair aux texels dans le mappage des ombres.</span><span class="sxs-lookup"><span data-stu-id="b256a-128">Shadows are of the highest quality (white pixels) when there is a 1:1 ratio mapping pixels in light space to texels in the shadow map.</span></span> <span data-ttu-id="b256a-129">L’alias de perspective se présente sous la forme de cartes de textures de grande taille (image de gauche) quand un trop grand nombre de pixels est mappé au même Texel d’ombre.</span><span class="sxs-lookup"><span data-stu-id="b256a-129">Perspective aliasing occurs in the form of large, blocky texture maps (left image) when too many pixels map to the same shadow texel.</span></span> <span data-ttu-id="b256a-130">Lorsque le mappage d’ombre est trop grand, il est sous échantillonné.</span><span class="sxs-lookup"><span data-stu-id="b256a-130">When the shadow map is too large, it is under sampled.</span></span> <span data-ttu-id="b256a-131">Dans ce cas, les texels sont ignorés, les artefacts de scintillement sont introduits et les performances sont affectées.</span><span class="sxs-lookup"><span data-stu-id="b256a-131">In this case, texels are skipped, shimmering artifacts are introduced, and performance is affected.</span></span>

<span data-ttu-id="b256a-132">**Figure 2. Qualité de l’ombre CSM**</span><span class="sxs-lookup"><span data-stu-id="b256a-132">**Figure 2. CSM shadow quality**</span></span>

![qualité de l’ombre CSM](images/csm-shadow-quality.png)

<span data-ttu-id="b256a-134">La figure 2 montre des découpages à partir de la section de qualité la plus élevée dans chaque carte fictive de la figure 1.</span><span class="sxs-lookup"><span data-stu-id="b256a-134">Figure 2 shows cutouts from the highest quality section in each shadow map in Figure 1.</span></span> <span data-ttu-id="b256a-135">Le mappage des ombres avec les pixels les plus rapprochés (au sommet) est le plus proche de l’œil.</span><span class="sxs-lookup"><span data-stu-id="b256a-135">The shadow map with the most closely placed pixels (at the apex) is nearest the eye.</span></span> <span data-ttu-id="b256a-136">Techniquement, il s’agit de cartes de la même taille, avec le blanc et le gris utilisés pour illustrer la réussite du mappage des ombres en cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-136">Technically, these are maps of the same size, with white and grey used to exemplify the success of the cascaded shadow map.</span></span> <span data-ttu-id="b256a-137">Le blanc est idéal, car il montre une couverture correcte, soit un ratio 1:1 pour les pixels d’espace œil et les texels de la carte fictive.</span><span class="sxs-lookup"><span data-stu-id="b256a-137">White is ideal because it shows good coverage—a 1:1 ratio for eye-space pixels and shadow-map texels.</span></span>

<span data-ttu-id="b256a-138">CMS requièrent les étapes suivantes par frame.</span><span class="sxs-lookup"><span data-stu-id="b256a-138">CSMs require the following steps per frame.</span></span>

1.  <span data-ttu-id="b256a-139">Partitionnez le frustum dans subfrusta.</span><span class="sxs-lookup"><span data-stu-id="b256a-139">Partition the frustum into subfrusta.</span></span>
2.  <span data-ttu-id="b256a-140">Calcule une projection orthographique pour chaque subfrustum.</span><span class="sxs-lookup"><span data-stu-id="b256a-140">Compute an orthographic projection for each subfrustum.</span></span>
3.  <span data-ttu-id="b256a-141">Affichez un mappage d’ombre pour chaque subfrustum.</span><span class="sxs-lookup"><span data-stu-id="b256a-141">Render a shadow map for each subfrustum.</span></span>
4.  <span data-ttu-id="b256a-142">Affiche la scène.</span><span class="sxs-lookup"><span data-stu-id="b256a-142">Render the scene.</span></span>

    1.  <span data-ttu-id="b256a-143">Liez les mappages d’ombre et le rendu.</span><span class="sxs-lookup"><span data-stu-id="b256a-143">Bind the shadow maps and render.</span></span>
    2.  <span data-ttu-id="b256a-144">Le nuanceur vertex effectue les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="b256a-144">The vertex shader does the following:</span></span>

        -   <span data-ttu-id="b256a-145">Calcule des coordonnées de texture pour chaque subfrustum de lumière (sauf si la coordonnée de texture nécessaire est calculée dans le nuanceur de pixels).</span><span class="sxs-lookup"><span data-stu-id="b256a-145">Computes texture coordinates for each light subfrustum (unless the needed texture coordinate is calculated in the pixel shader).</span></span>
        -   <span data-ttu-id="b256a-146">Transforme et illumine le vertex, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="b256a-146">Transforms and lights the vertex, and so on.</span></span>

    3.  <span data-ttu-id="b256a-147">Le nuanceur de pixels effectue les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="b256a-147">The pixel shader does the following:</span></span>

        -   <span data-ttu-id="b256a-148">Détermine le mappage des ombres approprié.</span><span class="sxs-lookup"><span data-stu-id="b256a-148">Determines the proper shadow map.</span></span>
        -   <span data-ttu-id="b256a-149">Transforme les coordonnées de texture si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b256a-149">Transforms the texture coordinates if necessary.</span></span>
        -   <span data-ttu-id="b256a-150">Échantillonne l’en cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-150">Samples the cascade.</span></span>
        -   <span data-ttu-id="b256a-151">Illumine le pixel.</span><span class="sxs-lookup"><span data-stu-id="b256a-151">Lights the pixel.</span></span>

## <a name="partitioning-the-frustum"></a><span data-ttu-id="b256a-152">Partitionnement du frustum</span><span class="sxs-lookup"><span data-stu-id="b256a-152">Partitioning the Frustum</span></span>

<span data-ttu-id="b256a-153">Le partitionnement du frustum est l’acte de création de subfrusta.</span><span class="sxs-lookup"><span data-stu-id="b256a-153">Partitioning the frustum is the act of creating subfrusta.</span></span> <span data-ttu-id="b256a-154">L’une des techniques permettant de fractionner le frustum consiste à calculer les intervalles de 0 à 100% sur l’axe Z.</span><span class="sxs-lookup"><span data-stu-id="b256a-154">One technique for splitting the frustum is to calculate intervals from zero percent to one hundred percent in the Z-direction.</span></span> <span data-ttu-id="b256a-155">Chaque intervalle représente ensuite un plan proche et un plan Far sous la forme d’un pourcentage de l’axe Z.</span><span class="sxs-lookup"><span data-stu-id="b256a-155">Each interval then represents a near plane and a far plane as a percentage of the Z-axis.</span></span>

<span data-ttu-id="b256a-156">**Figure 3. Afficher les frustums partitionnés arbitrairement**</span><span class="sxs-lookup"><span data-stu-id="b256a-156">**Figure 3. View frustums partitioned arbitrarily**</span></span>

![afficher les frustums partitionnés arbitrairement](images/view-frustums-partitioned-arbitrarily.png)

<span data-ttu-id="b256a-158">Dans la pratique, le recalcul des fractionnements de frustum par image entraîne un scintillement des bords de l’ombre.</span><span class="sxs-lookup"><span data-stu-id="b256a-158">In practice, recalculating the frustum splits per frame causes shadow edges to shimmer.</span></span> <span data-ttu-id="b256a-159">La pratique généralement acceptée consiste à utiliser un ensemble statique d’intervalles en cascade par scénario.</span><span class="sxs-lookup"><span data-stu-id="b256a-159">The generally accepted practice is to use a static set of cascade intervals per scenario.</span></span> <span data-ttu-id="b256a-160">Dans ce scénario, l’intervalle le long de l’axe Z est utilisé pour décrire un subfrustum qui se produit lors du partitionnement du frustum.</span><span class="sxs-lookup"><span data-stu-id="b256a-160">In this scenario, the interval along the Z-axis is used to describe a subfrustum that occurs when partitioning the frustum.</span></span> <span data-ttu-id="b256a-161">La détermination des intervalles de taille corrects pour une scène donnée dépend de plusieurs facteurs.</span><span class="sxs-lookup"><span data-stu-id="b256a-161">Determining the correct size intervals for a given scene depends upon several factors.</span></span>

### <a name="orientation-of-the-scene-geometry"></a><span data-ttu-id="b256a-162">Orientation de la géométrie de la scène</span><span class="sxs-lookup"><span data-stu-id="b256a-162">Orientation of the Scene Geometry</span></span>

<span data-ttu-id="b256a-163">En ce qui concerne la géométrie de scène, l’orientation de l’appareil photo affecte la sélection de l’intervalle en cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-163">With respect to scene geometry, camera orientation affects cascade interval selection.</span></span> <span data-ttu-id="b256a-164">Par exemple, un appareil photo très proche du sol, tel qu’un appareil photo terrestre dans un jeu de football, a un ensemble statique différent d’intervalles en cascade qu’un appareil photo du ciel.</span><span class="sxs-lookup"><span data-stu-id="b256a-164">For example, a camera very near the ground, such as a ground camera in a football game, has a different static set of cascade intervals than a camera in the sky.</span></span>

<span data-ttu-id="b256a-165">La figure 4 montre des caméras différentes et leurs partitions respectives.</span><span class="sxs-lookup"><span data-stu-id="b256a-165">Figure 4 shows some different cameras and their respective partitions.</span></span> <span data-ttu-id="b256a-166">Lorsque la plage Z de la scène est très volumineuse, davantage de plans de fractionnement sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="b256a-166">When the scene's Z-range is very large, more split planes are required.</span></span> <span data-ttu-id="b256a-167">Par exemple, lorsque l’œil est très proche du plan de masse, mais que les objets distants sont toujours visibles, plusieurs cascades peuvent être nécessaires.</span><span class="sxs-lookup"><span data-stu-id="b256a-167">For example, when the eye is very near the ground plane, but distant objects are still visible, multiple cascades can be necessary.</span></span> <span data-ttu-id="b256a-168">En divisant le frustum afin que davantage de fractionnements soient proches de l’œil (où les alias de perspective changent le plus rapide) est également utile.</span><span class="sxs-lookup"><span data-stu-id="b256a-168">Dividing the frustum so that more splits are near the eye (where perspective aliasing is changing the fastest) is also valuable.</span></span> <span data-ttu-id="b256a-169">Lorsque la plus grande partie de la géométrie est divisée en une petite section (telle qu’une vue de traitement ou un simulateur de vol) de la vue frustum, moins de cascades sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="b256a-169">When most of the geometry is clumped into a small section (such as an overhead view or a flight simulator) of the view frustum, fewer cascades are necessary.</span></span>

<span data-ttu-id="b256a-170">**Figure 4. Différentes configurations nécessitent des fractionnements de frustum différents**</span><span class="sxs-lookup"><span data-stu-id="b256a-170">**Figure 4. Different configurations require different frustum splits**</span></span>

![différentes configurations nécessitent des fractionnements de frustum différents](images/different-configurations-require-different-frustum-splits.png)

<span data-ttu-id="b256a-172">Gauche Lorsque Geometry a une plage dynamique élevée en Z, un grand nombre de cascades sont nécessaires.</span><span class="sxs-lookup"><span data-stu-id="b256a-172">(Left) When geometry has a high dynamic range in Z, lots of cascades are required.</span></span> <span data-ttu-id="b256a-173">Gestionnaire Lorsque la géométrie a une plage dynamique faible dans Z, il y a peu d’avantages par rapport à plusieurs frustums.</span><span class="sxs-lookup"><span data-stu-id="b256a-173">(Center) When the geometry has low dynamic range in Z, there is little benefit from multiple frustums.</span></span> <span data-ttu-id="b256a-174">Approprié Seules trois partitions sont nécessaires lorsque la plage dynamique est moyenne.</span><span class="sxs-lookup"><span data-stu-id="b256a-174">(Right) Only three partitions are needed when the dynamic range is medium.</span></span>

### <a name="orientation-of-the-light-and-the-camera"></a><span data-ttu-id="b256a-175">Orientation de la lumière et de l’appareil photo</span><span class="sxs-lookup"><span data-stu-id="b256a-175">Orientation of the Light and the Camera</span></span>

<span data-ttu-id="b256a-176">La matrice de projection de chaque cascade est adaptée à son subfrustum correspondant.</span><span class="sxs-lookup"><span data-stu-id="b256a-176">Each cascade's projection matrix is fit tightly around its corresponding subfrustum.</span></span> <span data-ttu-id="b256a-177">Dans les configurations où l’appareil photo de vue et les directions de lumière sont orthogonaux, les cascades peuvent s’ajuster étroitement avec peu de chevauchement.</span><span class="sxs-lookup"><span data-stu-id="b256a-177">In configurations where the view camera and the light directions are orthogonal, the cascades can be fit tightly with little overlap.</span></span> <span data-ttu-id="b256a-178">Le chevauchement est plus grand que la lumière et la caméra de vue passent à l’alignement parallèle (figure 5).</span><span class="sxs-lookup"><span data-stu-id="b256a-178">The overlap becomes larger as the light and the view camera move into parallel alignment (Figure 5).</span></span> <span data-ttu-id="b256a-179">Lorsque la lumière et l’appareil photo de la vue sont presque parallèles, on parle de « Dueling Frusta » et est un scénario très dur pour la plupart des algorithmes d’occultation.</span><span class="sxs-lookup"><span data-stu-id="b256a-179">When the light and the view camera are nearly parallel, it is called a "dueling frusta," and is a very hard scenario for most shadowing algorithms.</span></span> <span data-ttu-id="b256a-180">Il n’est pas rare de contraindre la lumière et l’appareil photo afin que ce scénario ne se produise pas.</span><span class="sxs-lookup"><span data-stu-id="b256a-180">It is not uncommon to constrain the light and camera so that this scenario does not occur.</span></span> <span data-ttu-id="b256a-181">CMS, cependant, fonctionnent beaucoup mieux que de nombreux autres algorithmes dans ce scénario.</span><span class="sxs-lookup"><span data-stu-id="b256a-181">CSMs, however, perform much better than many other algorithms in this scenario.</span></span>

<span data-ttu-id="b256a-182">**Figure 5. Le chevauchement en cascade augmente, car la direction de la lumière est parallèle à la direction de la caméra**</span><span class="sxs-lookup"><span data-stu-id="b256a-182">**Figure 5. Cascade overlap increases as light direction becomes parallel with camera direction**</span></span>

![le chevauchement en cascade augmente, car la direction de la lumière est parallèle à la direction de la caméra](images/cascade-overlap-increases-as-light-direction-becomes.jpg)

<span data-ttu-id="b256a-184">De nombreuses implémentations de CSM utilisent des Frusta de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="b256a-184">Many CSM implementations use fixed-size frusta.</span></span> <span data-ttu-id="b256a-185">Le nuanceur de pixels peut utiliser la profondeur Z pour indexer dans le tableau des cascades lorsque le frustum est fractionné dans des intervalles de taille fixe.</span><span class="sxs-lookup"><span data-stu-id="b256a-185">The pixel shader can use the Z-depth to index into the array of cascades when the frustum is split in fixed-size intervals.</span></span>

## <a name="calculating-a-view-frustum-bound"></a><span data-ttu-id="b256a-186">Calcul d’un View-Frustum lié</span><span class="sxs-lookup"><span data-stu-id="b256a-186">Calculating a View-Frustum Bound</span></span>

<span data-ttu-id="b256a-187">Une fois les intervalles de frustum sélectionnés, les subfrusta sont créés à l’aide d’un des deux : ajuster à la scène et ajuster à la cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-187">Once the frustum intervals are selected, the subfrusta are created using one of two: fit to scene and fit to cascade.</span></span>

### <a name="fit-to-scene"></a><span data-ttu-id="b256a-188">Ajuster à la scène</span><span class="sxs-lookup"><span data-stu-id="b256a-188">Fit to Scene</span></span>

<span data-ttu-id="b256a-189">Toutes les Frusta peuvent être créées avec le même proche plan.</span><span class="sxs-lookup"><span data-stu-id="b256a-189">All of the frusta can be created with the same near plane.</span></span> <span data-ttu-id="b256a-190">Cela force le chevauchement des cascades.</span><span class="sxs-lookup"><span data-stu-id="b256a-190">This forces the cascades to overlap.</span></span> <span data-ttu-id="b256a-191">L’exemple CascadedShadowMaps11 appelle cette technique pour s’adapter à la scène.</span><span class="sxs-lookup"><span data-stu-id="b256a-191">The CascadedShadowMaps11 sample calls this technique fit to scene.</span></span>

### <a name="fit-to-cascade"></a><span data-ttu-id="b256a-192">Ajuster à la cascade</span><span class="sxs-lookup"><span data-stu-id="b256a-192">Fit to Cascade</span></span>

<span data-ttu-id="b256a-193">Vous pouvez également créer Frusta avec l’intervalle de partition réel utilisé comme plans near et Far.</span><span class="sxs-lookup"><span data-stu-id="b256a-193">Alternatively, frusta can be created with the actual partition interval being used as near and far planes.</span></span> <span data-ttu-id="b256a-194">Cela entraîne un ajustement plus étroit, mais dégénère pour ajuster à la scène dans le cas de Dueling Frusta.</span><span class="sxs-lookup"><span data-stu-id="b256a-194">This causes a tighter fit, but degenerates to fit to scene in the case of dueling frusta.</span></span> <span data-ttu-id="b256a-195">Les exemples CascadedShadowMaps11 appellent cette technique s’adaptent à cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-195">The CascadedShadowMaps11 samples calls this technique fit to cascade.</span></span>

<span data-ttu-id="b256a-196">Ces deux méthodes sont illustrées à la figure 6.</span><span class="sxs-lookup"><span data-stu-id="b256a-196">These two methods are shown in Figure 6.</span></span> <span data-ttu-id="b256a-197">Ajuster à cascade gaspille moins de résolution.</span><span class="sxs-lookup"><span data-stu-id="b256a-197">Fit to cascade wastes less resolution.</span></span> <span data-ttu-id="b256a-198">Le problème avec fit to cascade est que la projection orthographique augmente et diminue en fonction de l’orientation de la vue frustum.</span><span class="sxs-lookup"><span data-stu-id="b256a-198">The problem with fit to cascade is that the orthographic projection grows and shrinks based on the orientation of the view frustum.</span></span> <span data-ttu-id="b256a-199">La technique adapter à la scène remplit la projection orthographique de la taille maximale de la vue frustum en supprimant les artefacts qui s’affichent lorsque l’appareil photo est déplacé.</span><span class="sxs-lookup"><span data-stu-id="b256a-199">The fit to scene technique pads the orthographic projection by the max size of the view frustum removing the artifacts that appear when the view-camera moves.</span></span> <span data-ttu-id="b256a-200">Les [techniques courantes d’amélioration des cartes de profondeur des ombres](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps) traitent les artefacts qui apparaissent lorsque la lumière se déplace dans la section « déplacement de la lumière dans des incréments de taille de Texel ».</span><span class="sxs-lookup"><span data-stu-id="b256a-200">[Common Techniques to Improve Shadow Depth Maps](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps) addresses the artifacts that appear when the light moves in the section "Moving the light in texel sized increments."</span></span>

<span data-ttu-id="b256a-201">**Figure 6. Ajuster à la scène et ajuster à la cascade**</span><span class="sxs-lookup"><span data-stu-id="b256a-201">**Figure 6. Fit to scene vs. fit to cascade**</span></span>

![ajuster à la scène et ajuster à la cascade](images/fit-to-scene-vs-fit-to-cascade.png)

## <a name="render-the-shadow-map"></a><span data-ttu-id="b256a-203">Rendre le mappage des ombres</span><span class="sxs-lookup"><span data-stu-id="b256a-203">Render the Shadow Map</span></span>

<span data-ttu-id="b256a-204">L’exemple CascadedShadowMaps11 restitue les mappages d’ombres dans une mémoire tampon de grande taille.</span><span class="sxs-lookup"><span data-stu-id="b256a-204">The CascadedShadowMaps11 sample renders the shadow maps into one large buffer.</span></span> <span data-ttu-id="b256a-205">Cela est dû au fait que PCF sur des tableaux de texture est une fonctionnalité Direct3D 10,1.</span><span class="sxs-lookup"><span data-stu-id="b256a-205">This is because PCF on texture arrays is a Direct3D 10.1 feature.</span></span> <span data-ttu-id="b256a-206">Pour chaque cascade, une fenêtre d’affichage qui couvre la section de la mémoire tampon de profondeur correspondant à cette cascade est créée.</span><span class="sxs-lookup"><span data-stu-id="b256a-206">For every cascade, a viewport is created that covers the section of the depth buffer corresponding to that cascade.</span></span> <span data-ttu-id="b256a-207">Un nuanceur de pixels null est lié, car seule la profondeur est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b256a-207">A null pixel shader is bound because only the depth is needed.</span></span> <span data-ttu-id="b256a-208">Enfin, la fenêtre d’affichage et la matrice fictive appropriées sont définies pour chaque cascade à mesure que les mappages de profondeur sont restitués l’un après l’autre dans le tampon d’ombre principal.</span><span class="sxs-lookup"><span data-stu-id="b256a-208">Finally, the correct viewport and shadow matrix are set for each cascade as the depth maps are rendered one at a time into the main shadow buffer.</span></span>

## <a name="render-the-scene"></a><span data-ttu-id="b256a-209">Rendu de la scène</span><span class="sxs-lookup"><span data-stu-id="b256a-209">Render the Scene</span></span>

<span data-ttu-id="b256a-210">La mémoire tampon contenant les ombres est maintenant liée au nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="b256a-210">The buffer containing the shadows is now bound to the pixel shader.</span></span> <span data-ttu-id="b256a-211">Il existe deux méthodes pour sélectionner la cascade implémentée dans l’exemple CascadedShadowMaps11.</span><span class="sxs-lookup"><span data-stu-id="b256a-211">There are two methods for selecting the cascade implemented in the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="b256a-212">Ces deux méthodes sont expliquées avec le code du nuanceur.</span><span class="sxs-lookup"><span data-stu-id="b256a-212">These two methods are explained with shader code.</span></span>

### <a name="interval-based-cascade-selection"></a><span data-ttu-id="b256a-213">Interval-Based la sélection en cascade</span><span class="sxs-lookup"><span data-stu-id="b256a-213">Interval-Based Cascade Selection</span></span>

<span data-ttu-id="b256a-214">**Figure 7. Sélection de cascade basée sur des intervalles**</span><span class="sxs-lookup"><span data-stu-id="b256a-214">**Figure 7. Interval-based cascade selection**</span></span>

![sélection de cascade basée sur des intervalles](images/interval-based-cascade-selection.jpg)

<span data-ttu-id="b256a-216">Dans une sélection basée sur des intervalles (figure 7), le nuanceur de sommets calcule la position dans l’espace universel du vertex.</span><span class="sxs-lookup"><span data-stu-id="b256a-216">In interval-based selection (Figure 7), the vertex shader computes the position in world-space of the vertex.</span></span>


```C++
Output.vDepth = mul( Input.vPosition, m_mWorldView ).z;
```



<span data-ttu-id="b256a-217">Le nuanceur de pixels reçoit la profondeur interpolée.</span><span class="sxs-lookup"><span data-stu-id="b256a-217">The pixel shader receives the interpolated depth.</span></span>


```C++
fCurrentPixelDepth = Input.vDepth;
```



<span data-ttu-id="b256a-218">La sélection en cascade basée sur des intervalles utilise une comparaison vectorielle et un produit scalaire pour déterminer le cacade correct.</span><span class="sxs-lookup"><span data-stu-id="b256a-218">Interval-based cascade selection uses a vector comparison and a dot product to determine the correct cacade.</span></span> <span data-ttu-id="b256a-219">L' \_ \_ indicateur de nombre de cascades spécifie le nombre de cascades.</span><span class="sxs-lookup"><span data-stu-id="b256a-219">The CASCADE\_COUNT\_FLAG specifies the number of cascades.</span></span> <span data-ttu-id="b256a-220">Les données de m \_ fCascadeFrustumsEyeSpaceDepths \_ limitent la vue des partitions frustum.</span><span class="sxs-lookup"><span data-stu-id="b256a-220">The m\_fCascadeFrustumsEyeSpaceDepths\_data constrains the view frustum partitions.</span></span> <span data-ttu-id="b256a-221">Après la comparaison, fComparison contient la valeur 1, où le pixel actuel est plus grand que le cloisonnement, et la valeur 0 lorsque la cascade actuelle est plus petite.</span><span class="sxs-lookup"><span data-stu-id="b256a-221">After the comparison, the fComparison contains a value of 1 where the current pixel is larger than the barrier, and a value of 0 when the current cascade is smaller.</span></span> <span data-ttu-id="b256a-222">Un produit scalaire additionne ces valeurs dans un index de tableau.</span><span class="sxs-lookup"><span data-stu-id="b256a-222">A dot product sums these values into an array index.</span></span>


```C++
        float4 vCurrentPixelDepth = Input.vDepth;
        float4 fComparison = ( vCurrentPixelDepth > m_fCascadeFrustumsEyeSpaceDepths_data[0]);
        float fIndex = dot(
        float4( CASCADE_COUNT_FLAG > 0,
        CASCADE_COUNT_FLAG > 1,
        CASCADE_COUNT_FLAG > 2,
        CASCADE_COUNT_FLAG > 3)
        , fComparison );

        fIndex = min( fIndex, CASCADE_COUNT_FLAG );
        iCurrentCascadeIndex = (int)fIndex;
```



<span data-ttu-id="b256a-223">Une fois la cascade sélectionnée, la coordonnée de texture doit être transformée en cascade correcte.</span><span class="sxs-lookup"><span data-stu-id="b256a-223">Once the cascade is selected, the texture coordinate must be transformed to the correct cascade.</span></span>


```C++
vShadowTexCoord = mul( InterpolatedPosition, m_mShadow[iCascadeIndex] );
```



<span data-ttu-id="b256a-224">Cette coordonnée de texture est ensuite utilisée pour échantillonner la texture avec la coordonnée X et la coordonnée Y.</span><span class="sxs-lookup"><span data-stu-id="b256a-224">This texture coordinate is then used to sample the texture with the X-coordinate and the Y-coordinate.</span></span> <span data-ttu-id="b256a-225">La coordonnée Z est utilisée pour effectuer la comparaison de profondeur finale.</span><span class="sxs-lookup"><span data-stu-id="b256a-225">The Z-coordinate is used to do the final depth comparison.</span></span>

### <a name="map-based-cascade-selection"></a><span data-ttu-id="b256a-226">Map-Based la sélection en cascade</span><span class="sxs-lookup"><span data-stu-id="b256a-226">Map-Based Cascade Selection</span></span>

<span data-ttu-id="b256a-227">Sélection basée sur une carte (figure 8) tests effectués sur les quatre côtés des cascades pour trouver le mappage le plus étroit qui couvre le pixel spécifique.</span><span class="sxs-lookup"><span data-stu-id="b256a-227">Map-based selection (Figure 8) tests against the four sides of the cascades to find the tightest map that covers the specific pixel.</span></span> <span data-ttu-id="b256a-228">Au lieu de calculer la position dans l’espace universel, le nuanceur de sommets calcule la position de l’espace d’affichage pour chaque cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-228">Instead of calculating the position in world space, the vertex shader calculates the view-space position for every cascade.</span></span> <span data-ttu-id="b256a-229">Le nuanceur de pixels itère sur les cascades afin de mettre à l’échelle et de déplacer les coordonnées de texture afin qu’elles indexent la cascade actuelle.</span><span class="sxs-lookup"><span data-stu-id="b256a-229">The pixel shader iterates over the cascades in order to scale and shift the texture coordinates so that they index the current cascade.</span></span> <span data-ttu-id="b256a-230">La coordonnée de texture est ensuite testée par rapport aux limites de texture.</span><span class="sxs-lookup"><span data-stu-id="b256a-230">The texture coordinate is then tested against the texture bounds.</span></span> <span data-ttu-id="b256a-231">Lorsque les valeurs X et Y de la coordonnée de texture se trouvent dans une cascade, elles sont utilisées pour échantillonner la texture.</span><span class="sxs-lookup"><span data-stu-id="b256a-231">When the X and Y values of the texture coordinate fall inside a cascade, they are used to sample the texture.</span></span> <span data-ttu-id="b256a-232">La coordonnée Z est utilisée pour effectuer la comparaison de profondeur finale.</span><span class="sxs-lookup"><span data-stu-id="b256a-232">The Z-coordinate is used to do the final depth comparison.</span></span>

<span data-ttu-id="b256a-233">**Figure 8. Sélection de cascade basée sur une carte**</span><span class="sxs-lookup"><span data-stu-id="b256a-233">**Figure 8. Map-based cascade selection**</span></span>

![sélection de cascade basée sur une carte](images/map-based-cascade-selection.jpg)

### <a name="interval-based-selection-vs-map-based-selection"></a><span data-ttu-id="b256a-235">Sélection Interval-Based et Map-Based sélection</span><span class="sxs-lookup"><span data-stu-id="b256a-235">Interval-Based Selection vs. Map-Based Selection</span></span>

<span data-ttu-id="b256a-236">La sélection basée sur un intervalle est légèrement plus rapide que la sélection basée sur les mappages, car la sélection en cascade peut être effectuée directement.</span><span class="sxs-lookup"><span data-stu-id="b256a-236">Interval-based selection is slightly faster than map-based selection because the cascade selection can be done directly.</span></span> <span data-ttu-id="b256a-237">La sélection basée sur une carte doit croiser la coordonnée de texture avec les limites de la cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-237">Map-based selection must intersect the texture coordinate with the cascade bounds.</span></span>

<span data-ttu-id="b256a-238">La sélection basée sur une carte utilise la cascade de manière plus efficace lorsque les cartes fictives ne s’alignent pas parfaitement (voir figure 8).</span><span class="sxs-lookup"><span data-stu-id="b256a-238">Map-based selection uses the cascade more efficiently when shadow maps do not align perfectly (see Figure 8).</span></span>

## <a name="blend-between-cascades"></a><span data-ttu-id="b256a-239">Fusion entre les cascades</span><span class="sxs-lookup"><span data-stu-id="b256a-239">Blend between Cascades</span></span>

<span data-ttu-id="b256a-240">VSMs (abordé plus loin dans cet article) et des techniques de filtrage telles que PCF peuvent être utilisées avec des CMS basse résolution pour produire des ombres douces.</span><span class="sxs-lookup"><span data-stu-id="b256a-240">VSMs (discussed later in this article) and filtering techniques such as PCF can be used with low-resolution CSMs to produce soft shadows.</span></span> <span data-ttu-id="b256a-241">Malheureusement, cela se traduit par une jointure visible (figure 9) entre les couches de cascade, car la résolution ne correspond pas.</span><span class="sxs-lookup"><span data-stu-id="b256a-241">Unfortunately, this results in a visible seam (Figure 9) between cascade layers because the resolution does not match.</span></span> <span data-ttu-id="b256a-242">La solution consiste à créer une bande entre les cartes fictives où le test de cliché instantané est effectué pour les deux cascades.</span><span class="sxs-lookup"><span data-stu-id="b256a-242">The solution is to create a band between shadow maps where the shadow test is performed for both cascades.</span></span> <span data-ttu-id="b256a-243">Ensuite, le nuanceur interpole de manière linéaire entre les deux valeurs en fonction de l’emplacement du pixel dans la bande de fusion.</span><span class="sxs-lookup"><span data-stu-id="b256a-243">The shader then linearly interpolates between the two values based on the pixel's location in the blend band.</span></span> <span data-ttu-id="b256a-244">Les exemples CascadedShadowMaps11 et VarianceShadows11 fournissent un curseur d’interface graphique qui peut être utilisé pour augmenter et diminuer cette bande floue.</span><span class="sxs-lookup"><span data-stu-id="b256a-244">The samples CascadedShadowMaps11 and VarianceShadows11 provide a GUI slider that can be used to increase and decrease this blur band.</span></span> <span data-ttu-id="b256a-245">Le nuanceur effectue une branche dynamique afin que la grande majorité des pixels lisent uniquement la cascade actuelle.</span><span class="sxs-lookup"><span data-stu-id="b256a-245">The shader performs a dynamic branch so that the vast majority of pixels only read from the current cascade.</span></span>

<span data-ttu-id="b256a-246">**Figure 9. Coutures en cascade**</span><span class="sxs-lookup"><span data-stu-id="b256a-246">**Figure 9. Cascade seams**</span></span>

![coutures en cascade](images/cascade-seams.jpg)

<span data-ttu-id="b256a-248">Gauche Une jointure visible peut être affichée là où se chevauchent les cascades.</span><span class="sxs-lookup"><span data-stu-id="b256a-248">(Left) A visible seam can be seen where cascades overlap.</span></span> <span data-ttu-id="b256a-249">Approprié Quand les cascades sont fusionnées entre, aucune jointure n’est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b256a-249">(Right) When the cascades are blended between, no seam occurs.</span></span>

## <a name="filtering-shadow-maps"></a><span data-ttu-id="b256a-250">Filtrage des mappages d’ombre</span><span class="sxs-lookup"><span data-stu-id="b256a-250">Filtering Shadow Maps</span></span>

### <a name="pcf"></a><span data-ttu-id="b256a-251">PCF</span><span class="sxs-lookup"><span data-stu-id="b256a-251">PCF</span></span>

<span data-ttu-id="b256a-252">Le filtrage des mappages d’ombres ordinaires ne produit pas d’ombres floues et floues.</span><span class="sxs-lookup"><span data-stu-id="b256a-252">Filtering ordinary shadow maps does not produce soft, blurred shadows.</span></span> <span data-ttu-id="b256a-253">Le matériel de filtrage brouille les valeurs de profondeur, puis compare ces valeurs floues au Texel de l’espace clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-253">The filtering hardware blurs the depth values, and then compares those blurred values to the light space texel.</span></span> <span data-ttu-id="b256a-254">Le bord dur résultant du test de réussite/d’échec existe toujours.</span><span class="sxs-lookup"><span data-stu-id="b256a-254">The hard edge resulting from the pass/fail test still exists.</span></span> <span data-ttu-id="b256a-255">Le flou des mappages d’ombres sert uniquement à déplacer le bord dur de manière erronée.</span><span class="sxs-lookup"><span data-stu-id="b256a-255">Blurring shadow maps only serves to erroneously move the hard edge.</span></span> <span data-ttu-id="b256a-256">PCF active le filtrage sur les cartes fictives.</span><span class="sxs-lookup"><span data-stu-id="b256a-256">PCF enables filtering on shadow maps.</span></span> <span data-ttu-id="b256a-257">L’idée générale de PCF est de calculer un pourcentage du pixel dans l’ombre en fonction du nombre de sous-échantillons qui réussissent le test de profondeur sur le nombre total de sous-échantillons.</span><span class="sxs-lookup"><span data-stu-id="b256a-257">The general idea of PCF is to calculate a percentage of the pixel in shadow based on the number of subsamples that pass the depth test over the total number of subsamples.</span></span>

<span data-ttu-id="b256a-258">Le matériel Direct3D 10 et Direct3D 11 peut exécuter PCF.</span><span class="sxs-lookup"><span data-stu-id="b256a-258">Direct3D 10 and Direct3D 11 hardware can perform PCF.</span></span> <span data-ttu-id="b256a-259">L’entrée d’un échantillonneur PCF se compose de la coordonnée de texture et d’une valeur de profondeur de comparaison.</span><span class="sxs-lookup"><span data-stu-id="b256a-259">The input to a PCF sampler consists of the texture-coordinate and a comparison depth value.</span></span> <span data-ttu-id="b256a-260">Par souci de simplicité, PCF est expliqué avec un filtre à quatre clics.</span><span class="sxs-lookup"><span data-stu-id="b256a-260">For simplicity, PCF is explained with a four-tap filter.</span></span> <span data-ttu-id="b256a-261">L’échantillon de texture lit la texture quatre fois, de la même manière qu’un filtre standard.</span><span class="sxs-lookup"><span data-stu-id="b256a-261">The texture sampler reads the texture four times, similar to a standard filter.</span></span> <span data-ttu-id="b256a-262">Toutefois, le résultat retourné est un pourcentage des pixels qui ont passé le test de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-262">However, the returned result is a percentage of the pixels that passed the depth test.</span></span> <span data-ttu-id="b256a-263">La figure 10 montre comment un pixel qui passe l’un des quatre tests de profondeur est de 25% dans une ombre.</span><span class="sxs-lookup"><span data-stu-id="b256a-263">Figure 10 shows how a pixel that passes one of the four depth tests is 25 percent in shadow.</span></span> <span data-ttu-id="b256a-264">La valeur réelle retournée est une interpolation linéaire basée sur les coordonnées de sous-Texel des lectures de texture pour produire un dégradé lisse.</span><span class="sxs-lookup"><span data-stu-id="b256a-264">The actual value returned is a linear interpolation based on the subtexel coordinates of the texture reads to produce a smooth gradient.</span></span> <span data-ttu-id="b256a-265">Sans cette interpolation linéaire, le PCF à quatre clics ne peut retourner que cinq valeurs : {0,0, 0,25, 0,5, 0,75, 1,0}.</span><span class="sxs-lookup"><span data-stu-id="b256a-265">Without this linear interpolation, the four-tap PCF would only be able to return five values: { 0.0, 0.25, 0.5, 0.75, 1.0 }.</span></span>

<span data-ttu-id="b256a-266">**Figure 10. Image filtrée PCF, avec 25% du pixel sélectionné couverts**</span><span class="sxs-lookup"><span data-stu-id="b256a-266">**Figure 10. PCF filtered image, with 25 percent of the selected pixel covered**</span></span>

![image filtrée PCF, avec 25% du pixel sélectionné couverts](images/pcf-filtered-image.png)

<span data-ttu-id="b256a-268">Il est également possible d’effectuer PCF sans prise en charge matérielle ou d’étendre PCF à des noyaux plus importants.</span><span class="sxs-lookup"><span data-stu-id="b256a-268">It is also possible to do PCF without hardware support or extend PCF to larger kernels.</span></span> <span data-ttu-id="b256a-269">Certaines techniques encodent même des exemples avec un noyau pondéré.</span><span class="sxs-lookup"><span data-stu-id="b256a-269">Some techniques even sample with a weighted kernel.</span></span> <span data-ttu-id="b256a-270">Pour ce faire, créez un noyau (tel qu’un gaussien) pour une grille N × N.</span><span class="sxs-lookup"><span data-stu-id="b256a-270">To do this, create a kernel (such as a Gaussian) for an N × N grid.</span></span> <span data-ttu-id="b256a-271">Les poids doivent être additionnés à 1.</span><span class="sxs-lookup"><span data-stu-id="b256a-271">The weights must add up to 1.</span></span> <span data-ttu-id="b256a-272">La texture est ensuite échantillonnée des occurrences N2.</span><span class="sxs-lookup"><span data-stu-id="b256a-272">The texture is then sampled N2 times.</span></span> <span data-ttu-id="b256a-273">Chaque échantillon est mis à l’échelle en fonction des pondérations correspondantes dans le noyau.</span><span class="sxs-lookup"><span data-stu-id="b256a-273">Each sample is scaled by the corresponding weights in the kernel.</span></span> <span data-ttu-id="b256a-274">L’exemple CascadedShadowMaps11 utilise cette approche.</span><span class="sxs-lookup"><span data-stu-id="b256a-274">The CascadedShadowMaps11 sample uses this approach.</span></span>

### <a name="depth-bias"></a><span data-ttu-id="b256a-275">Décalage de profondeur</span><span class="sxs-lookup"><span data-stu-id="b256a-275">Depth Bias</span></span>

<span data-ttu-id="b256a-276">Le décalage de profondeur devient encore plus important lorsque de gros noyaux PCF sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="b256a-276">Depth bias becomes even more important when large PCF kernels are used.</span></span> <span data-ttu-id="b256a-277">Elle est uniquement valide pour comparer la profondeur d’espace clair d’un pixel au pixel auquel elle est mappée dans le mappage de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-277">It is only valid to compare a pixel's light-space depth against the pixel it maps to in the depth map.</span></span> <span data-ttu-id="b256a-278">Les voisins de la représentation de la correspondance de profondeur font référence à une autre position.</span><span class="sxs-lookup"><span data-stu-id="b256a-278">The depth map texel's neighbors refer to a different position.</span></span> <span data-ttu-id="b256a-279">Cette profondeur est susceptible d’être similaire, mais elle peut être très différente en fonction de la scène.</span><span class="sxs-lookup"><span data-stu-id="b256a-279">This depth is likely to be similar, but can be very different depending on the scene.</span></span> <span data-ttu-id="b256a-280">La figure 11 met en surbrillance les artefacts qui se produisent.</span><span class="sxs-lookup"><span data-stu-id="b256a-280">Figure 11 highlights the artifacts that occur.</span></span> <span data-ttu-id="b256a-281">Une seule profondeur est comparée à trois texels voisins dans le mappage des ombres.</span><span class="sxs-lookup"><span data-stu-id="b256a-281">A single depth is compared to three neighboring texels in the shadow map.</span></span> <span data-ttu-id="b256a-282">L’un des tests de profondeur échoue de manière erronée, car sa profondeur n’est pas corrélée à la profondeur de l’espace clair calculé de la géométrie actuelle.</span><span class="sxs-lookup"><span data-stu-id="b256a-282">One of the depth tests erroneously fails because its depth does not correlate to the computed light-space depth of the current geometry.</span></span> <span data-ttu-id="b256a-283">Pour résoudre ce problème, il est recommandé d’utiliser un décalage plus grand.</span><span class="sxs-lookup"><span data-stu-id="b256a-283">The recommended solution to this problem is to use a larger offset.</span></span> <span data-ttu-id="b256a-284">Un décalage trop important peut toutefois entraîner Peter panoramisation.</span><span class="sxs-lookup"><span data-stu-id="b256a-284">Too large of an offset, however, can result in Peter Panning.</span></span> <span data-ttu-id="b256a-285">Le calcul d’un plan étroit et du plan Far permet de réduire les effets de l’utilisation d’un décalage.</span><span class="sxs-lookup"><span data-stu-id="b256a-285">Calculating a tight near plane and far plane helps reduce the effects of using an offset.</span></span>

<span data-ttu-id="b256a-286">**Figure 11. Auto-occultation erronée**</span><span class="sxs-lookup"><span data-stu-id="b256a-286">**Figure 11. Erroneous self-shadowing**</span></span>

![Auto-occultation erronée](images/erroneous-self-shadowing.png)

<span data-ttu-id="b256a-288">Les résultats de l’auto-occultation erronés proviennent de la comparaison des pixels de la profondeur d’espace clair aux texels du mappage d’ombre qui ne sont pas corrélés.</span><span class="sxs-lookup"><span data-stu-id="b256a-288">The erroneous self-shadowing results from comparing pixels in the light-space depth to the texels in the shadow map that do not correlate.</span></span> <span data-ttu-id="b256a-289">La profondeur dans l’espace clair est corrélée avec l’ombre 2 dans le mappage de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-289">The depth in light-space correlates to shadow texel 2 in the depth map.</span></span> <span data-ttu-id="b256a-290">Texel 1 est supérieur à la profondeur de l’espace clair, tandis que 2 est égal à et 3 à moins.</span><span class="sxs-lookup"><span data-stu-id="b256a-290">Texel 1 is greater than the light-space depth while 2 is equal and 3 is less.</span></span> <span data-ttu-id="b256a-291">Les texels 2 et 3 réussissent le test de profondeur, tandis que Texel 1 échoue.</span><span class="sxs-lookup"><span data-stu-id="b256a-291">Texels 2 and 3 pass the depth test, while Texel 1 fails.</span></span>

### <a name="calculating-a-per-texel-depth-bias-with-ddx-and-ddy-for-large-pcfs"></a><span data-ttu-id="b256a-292">Calcul d’un écart de profondeur de Per-Texel avec DDX et DDY pour les grands PCFs</span><span class="sxs-lookup"><span data-stu-id="b256a-292">Calculating a Per-Texel Depth Bias with DDX and DDY for Large PCFs</span></span>

<span data-ttu-id="b256a-293">Le calcul d’un décalage de profondeur par Texel avec **ddx** et **ddy** pour des PCFs de grande taille est une technique qui calcule le décalage de profondeur correct (en supposant que la surface est planaire) pour le Texel de la carte fictive adjacente.</span><span class="sxs-lookup"><span data-stu-id="b256a-293">Calculating a per texel depth bias with **ddx** and **ddy** for large PCFs is a technique that calculates the correct depth bias—assuming the surface is planar—for the adjacent shadow map texel.</span></span>

<span data-ttu-id="b256a-294">Cette technique correspond à la profondeur de comparaison d’un plan à l’aide des informations dérivées.</span><span class="sxs-lookup"><span data-stu-id="b256a-294">This technique fits the comparison depth to a plane using the derivative information.</span></span> <span data-ttu-id="b256a-295">Étant donné que cette technique est complexe en termes de calcul, elle doit être utilisée uniquement quand un GPU a des cycles de calcul à Spare.</span><span class="sxs-lookup"><span data-stu-id="b256a-295">Because this technique is computationally complex, it should be used only when a GPU has compute cycles to spare.</span></span> <span data-ttu-id="b256a-296">En cas d’utilisation de noyaux très volumineux, il peut s’agir de la seule technique qui consiste à supprimer les artefacts d’auto-occultation sans provoquer de panoramique Peter.</span><span class="sxs-lookup"><span data-stu-id="b256a-296">When very large kernels are used, this may be the only technique that works to remove self-shadowing artifacts without causing Peter Panning.</span></span>

<span data-ttu-id="b256a-297">La figure 12 met en évidence le problème.</span><span class="sxs-lookup"><span data-stu-id="b256a-297">Figure 12 highlights the problem.</span></span> <span data-ttu-id="b256a-298">La profondeur dans l’espace clair est connue pour le Texel qui est comparé.</span><span class="sxs-lookup"><span data-stu-id="b256a-298">The depth in light-space is known for the one texel that is being compared.</span></span> <span data-ttu-id="b256a-299">Les profondeurs clairs qui correspondent aux texels voisins dans le mappage de profondeur sont inconnus.</span><span class="sxs-lookup"><span data-stu-id="b256a-299">The light-space depths that correspond to the neighboring texels in the depth map are unknown.</span></span>

<span data-ttu-id="b256a-300">**Figure 12. Plan de scène et de profondeur**</span><span class="sxs-lookup"><span data-stu-id="b256a-300">**Figure 12. Scene and depth map**</span></span>

![plan de scène et de profondeur](images/scene-and-depth-map.png)

<span data-ttu-id="b256a-302">La scène rendue est affichée à gauche et la carte de profondeur avec un exemple de bloc Texel est affichée à droite.</span><span class="sxs-lookup"><span data-stu-id="b256a-302">The rendered scene is shown at left, and the depth map with a sample texel block is shown at right.</span></span> <span data-ttu-id="b256a-303">Le Texel de l’espace œil correspond au pixel étiqueté D au centre du bloc.</span><span class="sxs-lookup"><span data-stu-id="b256a-303">The eye-space texel maps to the pixel labeled D in the center of the block.</span></span> <span data-ttu-id="b256a-304">Cette comparaison est exacte.</span><span class="sxs-lookup"><span data-stu-id="b256a-304">This comparison is accurate.</span></span> <span data-ttu-id="b256a-305">La profondeur de l’espace œil est correcte en corrélation avec les pixels que le voisin D est inconnu.</span><span class="sxs-lookup"><span data-stu-id="b256a-305">The correct depth in eye space correlating to the pixels that neighbor D is unknown.</span></span> <span data-ttu-id="b256a-306">Le mappage des texels voisins à l’espace œil est possible uniquement si nous supposons que le pixel se rapporte au même triangle que D.</span><span class="sxs-lookup"><span data-stu-id="b256a-306">Mapping the neighboring texels back to eye space is possible only if we assume the pixel pertains to the same triangle as D.</span></span>

<span data-ttu-id="b256a-307">La profondeur est connue pour le Texel qui se met en corrélation avec la position de l’espace clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-307">The depth is known for the texel that correlates with the light-space position.</span></span> <span data-ttu-id="b256a-308">La profondeur est inconnue pour les texels voisins dans la carte de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-308">The depth is unknown for the neighboring texels in the depth map.</span></span>

<span data-ttu-id="b256a-309">À un niveau élevé, cette technique utilise les opérations HLSL **ddx** et **ddy** pour rechercher la dérivée de la position de l’espace clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-309">At a high level, this technique uses the **ddx** and **ddy** HLSL operations to find the derivative of the light-space position.</span></span> <span data-ttu-id="b256a-310">Cela n’est pas insignifiant, car les opérations dérivées retournent le dégradé de la profondeur d’espace clair par rapport à l’espace à l’écran.</span><span class="sxs-lookup"><span data-stu-id="b256a-310">This is nontrivial because the derivative operations return the gradient of the light-space depth with respect to screen space.</span></span> <span data-ttu-id="b256a-311">Pour convertir cela en un dégradé de la profondeur d’espace clair par rapport à l’espace clair, une matrice de conversion doit être calculée.</span><span class="sxs-lookup"><span data-stu-id="b256a-311">To convert this to a gradient of the light-space depth with respect to light space, a conversion matrix must be calculated.</span></span>

### <a name="explanation-with-shader-code"></a><span data-ttu-id="b256a-312">Explication du code du nuanceur</span><span class="sxs-lookup"><span data-stu-id="b256a-312">Explanation with Shader Code</span></span>

<span data-ttu-id="b256a-313">Les détails du reste de l’algorithme sont fournis comme une explication du code du nuanceur qui effectue cette opération.</span><span class="sxs-lookup"><span data-stu-id="b256a-313">The details of the rest of the algorithm are given as an explanation of the shader code that performs this operation.</span></span> <span data-ttu-id="b256a-314">Ce code se trouve dans l’exemple CascadedShadowMaps11.</span><span class="sxs-lookup"><span data-stu-id="b256a-314">This code can be found in the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="b256a-315">La figure 13 montre comment les coordonnées de la texture de l’espace lumineux sont mappées à la carte de profondeur et comment les dérivés dans X et Y peuvent être utilisés pour créer une matrice de transformation.</span><span class="sxs-lookup"><span data-stu-id="b256a-315">Figure 13 shows how the light-space texture coordinates map to the depth map and how the derivatives in X and Y can be used to create a transformation matrix.</span></span>

<span data-ttu-id="b256a-316">**Figure 13. Screen-espace sur la matrice de l’espace clair**</span><span class="sxs-lookup"><span data-stu-id="b256a-316">**Figure 13. Screen-space to light-space matrix**</span></span>

![Screen-espace sur la matrice de l’espace clair](images/screen-space-to-light-space-matrix.png)

<span data-ttu-id="b256a-318">Les dérivés de la position de l’espace clair dans X et Y sont utilisés pour créer cette matrice.</span><span class="sxs-lookup"><span data-stu-id="b256a-318">The derivatives of the light-space position in X and Y are used to create this matrix.</span></span>

<span data-ttu-id="b256a-319">La première étape consiste à calculer la dérivée de la position de l’espace d’affichage clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-319">The first step is to calculate the derivative of the light-view-space position.</span></span>


```C++
          float3 vShadowTexDDX = ddx (vShadowMapTextureCoordViewSpace);
          float3 vShadowTexDDY = ddy (vShadowMapTextureCoordViewSpace);
```



<span data-ttu-id="b256a-320">Les GPU de classe Direct3D 11 calculent ces dérivés en exécutant 2 × 2 Quad de pixels en parallèle et en soustrayant les coordonnées de texture du voisin dans X pour **ddx** et du voisin dans Y pour **ddy**.</span><span class="sxs-lookup"><span data-stu-id="b256a-320">Direct3D 11 class GPUs calculate these derivatives by running 2 × 2 quad of pixels in parallel and subtracting the texture coordinates from the neighbor in X for **ddx** and from the neighbor in Y for **ddy**.</span></span> <span data-ttu-id="b256a-321">Ces deux dérivées composent les lignes d’une matrice 2 × 2.</span><span class="sxs-lookup"><span data-stu-id="b256a-321">These two derivatives make up the rows of a 2 × 2 matrix.</span></span> <span data-ttu-id="b256a-322">Dans sa forme actuelle, cette matrice peut être utilisée pour convertir les pixels voisins de l’espace à l’écran en pentes d’espaces clairs.</span><span class="sxs-lookup"><span data-stu-id="b256a-322">In its current form, this matrix could be used to convert screen-space neighboring pixels to light-space slopes.</span></span> <span data-ttu-id="b256a-323">Toutefois, l’inverse de cette matrice est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="b256a-323">However, the inverse of this matrix is needed.</span></span> <span data-ttu-id="b256a-324">Matrice qui transforme les pixels voisins de l’espace lumineux en pentes d’espace à l’écran.</span><span class="sxs-lookup"><span data-stu-id="b256a-324">A matrix that transforms light-space neighboring pixels to screen-space slopes is needed.</span></span>


```C++
          float2x2 matScreentoShadow = float2x2( vShadowTexDDX.xy, vShadowTexDDY.xy );
          float fInvDeterminant = 1.0f / fDeterminant;

          float2x2 matShadowToScreen = float2x2 (
          matScreentoShadow._22 * fInvDeterminant,
          matScreentoShadow._12 * -fInvDeterminant,
          matScreentoShadow._21 * -fInvDeterminant,
          matScreentoShadow._11 * fInvDeterminant );
```



<span data-ttu-id="b256a-325">**Figure 14. Espace clair vers l’espace à l’écran**</span><span class="sxs-lookup"><span data-stu-id="b256a-325">**Figure 14. Light-space to screen-space**</span></span>

![espace clair vers l’espace à l’écran](images/light-space-to-screen-space.png)

<span data-ttu-id="b256a-327">Cette matrice est ensuite utilisée pour transformer les deux texels au-dessus et à droite du Texel actuel.</span><span class="sxs-lookup"><span data-stu-id="b256a-327">This matrix is then used to transform the two texels above and to the right of the current texel.</span></span> <span data-ttu-id="b256a-328">Ces voisins sont représentés comme un décalage par rapport au Texel actuel.</span><span class="sxs-lookup"><span data-stu-id="b256a-328">These neighbors are represented as an offset from the current texel.</span></span>


```C++
          float2 vRightShadowTexelLocation = float2( m_fTexelSize, 0.0f );
          float2 vUpShadowTexelLocation = float2( 0.0f, m_fTexelSize );
          float2 vRightTexelDepthRatio = mul( vRightShadowTexelLocation,
          matShadowToScreen );
          float2 vUpTexelDepthRatio = mul( vUpShadowTexelLocation,
          matShadowToScreen );
```



<span data-ttu-id="b256a-329">Le rapport créé par la matrice est enfin multiplié par les dérivés de profondeur pour calculer les décalages de profondeur pour les pixels voisins.</span><span class="sxs-lookup"><span data-stu-id="b256a-329">The ratio that the matrix creates is finally multiplied by the depth derivatives to calculate the depth offsets for the neighboring pixels.</span></span>


```C++
            float fUpTexelDepthDelta =
            vUpTexelDepthRatio.x * vShadowTexDDX.z
            + vUpTexelDepthRatio.y * vShadowTexDDY.z;
            float fRightTexelDepthDelta =
            vRightTexelDepthRatio.x * vShadowTexDDX.z
            + vRightTexelDepthRatio.y * vShadowTexDDY.z;
```



<span data-ttu-id="b256a-330">Ces pondérations peuvent désormais être utilisées dans une boucle PCF pour ajouter un décalage à la position.</span><span class="sxs-lookup"><span data-stu-id="b256a-330">These weights can now be used in a PCF loop to add an offset to the position.</span></span>


```C++
    for( int x = m_iPCFBlurForLoopStart; x < m_iPCFBlurForLoopEnd; ++x ) 
    {
        for( int y = m_iPCFBlurForLoopStart; y < m_iPCFBlurForLoopEnd; ++y )
            {
            if ( USE_DERIVATIVES_FOR_DEPTH_OFFSET_FLAG )
            {
            depthcompare += fRightTexelDepthDelta * ( (float) x ) +
            fUpTexelDepthDelta * ( (float) y );
            }
            // Compare the transformed pixel depth to the depth read
            // from the map.
            fPercentLit += g_txShadow.SampleCmpLevelZero( g_samShadow,
            float2(
            vShadowTexCoord.x + ( ( (float) x ) * m_fNativeTexelSizeInX ) ,
            vShadowTexCoord.y + ( ( (float) y ) * m_fTexelSize )
            ),
            depthcompare
            );
            }
     }
```



## <a name="pcf-and-csms"></a><span data-ttu-id="b256a-331">PCF et CMS</span><span class="sxs-lookup"><span data-stu-id="b256a-331">PCF and CSMs</span></span>

<span data-ttu-id="b256a-332">PCF ne fonctionne pas sur les tableaux de texture dans Direct3D 10.</span><span class="sxs-lookup"><span data-stu-id="b256a-332">PCF does not work on texture arrays in Direct3D 10.</span></span> <span data-ttu-id="b256a-333">Pour utiliser PCF, toutes les cascades sont stockées dans un grand Atlas de textures.</span><span class="sxs-lookup"><span data-stu-id="b256a-333">To use PCF, all of the cascades are stored in one large texture atlas.</span></span>

### <a name="derivative-based-offset"></a><span data-ttu-id="b256a-334">Décalage de Derivative-Based</span><span class="sxs-lookup"><span data-stu-id="b256a-334">Derivative-Based Offset</span></span>

<span data-ttu-id="b256a-335">L’ajout des décalages basés sur les dérivés pour CMS présente des défis.</span><span class="sxs-lookup"><span data-stu-id="b256a-335">Adding the derivative based offsets for CSMs presents some challenges.</span></span> <span data-ttu-id="b256a-336">Cela est dû à un calcul de dérivé dans un contrôle de fluide divergent.</span><span class="sxs-lookup"><span data-stu-id="b256a-336">This is due to a derivative calculation within divergent flow control.</span></span> <span data-ttu-id="b256a-337">Le problème se produit en raison d’un fonctionnement fondamental des GPU.</span><span class="sxs-lookup"><span data-stu-id="b256a-337">The problem occurs because of a fundamental way that GPUs operate.</span></span> <span data-ttu-id="b256a-338">Les GPU Direct3D11 fonctionnent sur 2 × 2 Quad de pixels.</span><span class="sxs-lookup"><span data-stu-id="b256a-338">Direct3D11 GPUs operate on 2 × 2 quads of pixels.</span></span> <span data-ttu-id="b256a-339">Pour effectuer une dérivée, les GPU soustraient généralement la copie du pixel actuel d’une variable à partir de la copie du pixel voisin de la même variable.</span><span class="sxs-lookup"><span data-stu-id="b256a-339">To perform a derivative, GPUs generally subtract the current pixel's copy of a variable from the neighboring pixel's copy of that same variable.</span></span> <span data-ttu-id="b256a-340">La façon dont cela se produit varie d’un GPU au GPU.</span><span class="sxs-lookup"><span data-stu-id="b256a-340">How this happens varies from GPU to GPU.</span></span> <span data-ttu-id="b256a-341">Les coordonnées de la texture sont déterminées par une sélection en cascade basée sur une carte ou sur un intervalle.</span><span class="sxs-lookup"><span data-stu-id="b256a-341">The texture coordinates are determined by map-based or interval-based cascade selection.</span></span> <span data-ttu-id="b256a-342">Certains pixels d’un quadruple pixel choisissent une cascade différente de celle du reste des pixels.</span><span class="sxs-lookup"><span data-stu-id="b256a-342">Some pixels in a pixel quad choose a different cascade than the rest of the pixels.</span></span> <span data-ttu-id="b256a-343">Il en résulte des jointures visibles entre les clichés instantanés, car les décalages basés sur les dérivés sont maintenant complètement erronés.</span><span class="sxs-lookup"><span data-stu-id="b256a-343">This results in visible seams between shadow maps because the derivative-based offsets are now completely wrong.</span></span> <span data-ttu-id="b256a-344">La solution consiste à exécuter la dérivée sur les coordonnées de texture d’espace de l’affichage clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-344">The solution is to perform the derivative on light-view space texture coordinates.</span></span> <span data-ttu-id="b256a-345">Ces coordonnées sont identiques pour chaque cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-345">These coordinates are the same for every cascade.</span></span>

### <a name="padding-for-pcf-kernels"></a><span data-ttu-id="b256a-346">Remplissage pour les noyaux PCF</span><span class="sxs-lookup"><span data-stu-id="b256a-346">Padding for PCF Kernels</span></span>

<span data-ttu-id="b256a-347">Index des noyaux PCF en dehors d’une partition en cascade si le tampon d’ombre n’est pas rempli.</span><span class="sxs-lookup"><span data-stu-id="b256a-347">PCF kernels index outside of a cascade partition if the shadow buffer is not padded.</span></span> <span data-ttu-id="b256a-348">La solution consiste à remplir le bord extérieur de la cascade d’une moitié de la taille du noyau PCF.</span><span class="sxs-lookup"><span data-stu-id="b256a-348">The solution is to pad the outer rim of the cascade by one-half the size of the PCF kernel.</span></span> <span data-ttu-id="b256a-349">Elle doit être implémentée dans le nuanceur qui sélectionne la cascade et dans la matrice de projection qui doit rendre le en cascade suffisamment grand pour que la bordure soit conservée.</span><span class="sxs-lookup"><span data-stu-id="b256a-349">This must be implemented in the shader that selects the cascade and in the projection matrix that must render the cascade large enough that the border is preserved.</span></span>

## <a name="variance-shadow-maps"></a><span data-ttu-id="b256a-350">Cartes Shadow de variance</span><span class="sxs-lookup"><span data-stu-id="b256a-350">Variance Shadow Maps</span></span>

<span data-ttu-id="b256a-351">VSMs (consultez [écarts des clichés instantanés](https://portal.acm.org/citation.cfm?doid=1111411.1111440) par Donnelly et Lauritzen pour plus d’informations) activer le filtrage de carte d’ombre directe.</span><span class="sxs-lookup"><span data-stu-id="b256a-351">VSMs (see [Variance shadow maps](https://portal.acm.org/citation.cfm?doid=1111411.1111440) by Donnelly and Lauritzen for more information) enable direct shadow map filtering.</span></span> <span data-ttu-id="b256a-352">Lorsque vous utilisez VSMs, toute la puissance du matériel de filtrage de texture peut être utilisée.</span><span class="sxs-lookup"><span data-stu-id="b256a-352">When using VSMs, all of the power of the texture-filtering hardware can be used.</span></span> <span data-ttu-id="b256a-353">Le filtrage trilinéaire et anisotrope (figure 15) peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="b256a-353">Trilinear and anisotropic (Figure 15) filtering can be used.</span></span> <span data-ttu-id="b256a-354">En outre, les VSMs peuvent être flous directement par convolution.</span><span class="sxs-lookup"><span data-stu-id="b256a-354">Additionally, VSMs can be blurred directly through convolution.</span></span> <span data-ttu-id="b256a-355">VSMs présentent certains inconvénients ; deux canaux de données de profondeur doivent être stockés (profondeur et profondeur au carré).</span><span class="sxs-lookup"><span data-stu-id="b256a-355">VSMs do have some drawbacks; two channels of depth data must be stored (depth and depth squared).</span></span> <span data-ttu-id="b256a-356">Lorsque les ombres se chevauchent, la saignée est courante.</span><span class="sxs-lookup"><span data-stu-id="b256a-356">When shadows overlap, light-bleeding is common.</span></span> <span data-ttu-id="b256a-357">Ils fonctionnent bien, toutefois, avec des résolutions inférieures et peuvent être combinés avec CMS.</span><span class="sxs-lookup"><span data-stu-id="b256a-357">They work well, however, with lower resolutions and can be combined with CSMs.</span></span>

<span data-ttu-id="b256a-358">**Figure 15. Filtrage anisotrope**</span><span class="sxs-lookup"><span data-stu-id="b256a-358">**Figure 15. Anisotropic filtering**</span></span>

![filtrage anisotrope](images/anisotropic-filtering.png)

### <a name="algorithm-details"></a><span data-ttu-id="b256a-360">Détails des algorithmes</span><span class="sxs-lookup"><span data-stu-id="b256a-360">Algorithm Details</span></span>

<span data-ttu-id="b256a-361">Les VSMs fonctionnent en affichant la profondeur et la profondeur au carré d’un mappage de clichés instantanés sur deux canaux.</span><span class="sxs-lookup"><span data-stu-id="b256a-361">VSMs work by rendering the depth and the depth squared to a two-channel shadow map.</span></span> <span data-ttu-id="b256a-362">Ce mappage de clichés instantanés à deux canaux peut ensuite être flou et filtré comme une texture normale.</span><span class="sxs-lookup"><span data-stu-id="b256a-362">This two-channel shadow map can then be blurred and filtered just like a normal texture.</span></span> <span data-ttu-id="b256a-363">L’algorithme utilise ensuite l’inégalité de Chebychev dans le nuanceur de pixels pour estimer la fraction de la zone de pixels qui passerait le test de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-363">The algorithm then uses Chebychev's Inequality in the pixel shader to estimate the fraction of pixel area that would pass the depth test.</span></span>

<span data-ttu-id="b256a-364">Le nuanceur de pixels récupère les valeurs de profondeur et de carré de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-364">The pixel shader fetches the depth and depth-squared values.</span></span>


```C++
        float  fAvgZ  = mapDepth.x; // Filtered z
        float  fAvgZ2 = mapDepth.y; // Filtered z-squared
```



<span data-ttu-id="b256a-365">La comparaison de profondeur est effectuée.</span><span class="sxs-lookup"><span data-stu-id="b256a-365">The depth comparison is performed.</span></span>


```C++
        if ( fDepth <= fAvgZ )
        {
        fPercentLit = 1;
        }
```



<span data-ttu-id="b256a-366">Si la comparaison de profondeur échoue, le pourcentage du pixel allumé est estimé.</span><span class="sxs-lookup"><span data-stu-id="b256a-366">If the depth comparison fails, the percentage of the pixel that is lit is estimated.</span></span> <span data-ttu-id="b256a-367">La variance est calculée en tant que moyenne des carrés moins la moyenne des carrés.</span><span class="sxs-lookup"><span data-stu-id="b256a-367">Variance is calculated as average-of-squares minus square-of-average.</span></span>


```C++
        float variance = ( fAvgZ2 ) − ( fAvgZ * fAvgZ );
        variance = min( 1.0f, max( 0.0f, variance + 0.00001f ) );
```



<span data-ttu-id="b256a-368">La valeur fPercentLit est estimée avec l’inégalité de Chebychev.</span><span class="sxs-lookup"><span data-stu-id="b256a-368">The fPercentLit value is estimated with Chebychev's Inequality.</span></span>


```C++
        float mean           = fAvgZ;
        float d              = fDepth - mean;
        float fPercentLit    = variance / ( variance + d*d );
```



## <a name="light-bleeding"></a><span data-ttu-id="b256a-369">Saignement léger</span><span class="sxs-lookup"><span data-stu-id="b256a-369">Light Bleeding</span></span>

<span data-ttu-id="b256a-370">Le plus grand inconvénient de VSMs est le saignement léger (figure 16).</span><span class="sxs-lookup"><span data-stu-id="b256a-370">The biggest drawback to VSMs is light bleeding (Figure 16).</span></span> <span data-ttu-id="b256a-371">Un saignement lumineux se produit lorsque plusieurs conversions de clichés instantanés se occultaitnt le long des bords.</span><span class="sxs-lookup"><span data-stu-id="b256a-371">Light bleeding occurs when multiple shadow casters occlude each other along edges.</span></span> <span data-ttu-id="b256a-372">VSMs ombrer les bords des ombres en fonction des disparités de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-372">VSMs shade the edges of shadows based on depth disparities.</span></span> <span data-ttu-id="b256a-373">Lorsque les ombres se chevauchent, une disparité de profondeur existe au centre d’une région qui doit être masquée.</span><span class="sxs-lookup"><span data-stu-id="b256a-373">When shadows overlap each other, a depth disparity exists in the center of a region that should be shadowed.</span></span> <span data-ttu-id="b256a-374">Il s’agit d’un problème lié à l’utilisation de l’algorithme VSM.</span><span class="sxs-lookup"><span data-stu-id="b256a-374">This is a problem with using the VSM algorithm.</span></span>

<span data-ttu-id="b256a-375">**Figure 16. Saignements de la lumière VSM**</span><span class="sxs-lookup"><span data-stu-id="b256a-375">**Figure 16. VSM light bleeding**</span></span>

![saignements de la lumière VSM](images/vsm-light-bleeding.png)

<span data-ttu-id="b256a-377">Une solution partielle au problème consiste à élever le fPercentLit à une puissance.</span><span class="sxs-lookup"><span data-stu-id="b256a-377">A partial solution to the problem is to raise the fPercentLit to a power.</span></span> <span data-ttu-id="b256a-378">Cela a pour effet de amortir le flou, ce qui peut entraîner des artefacts où la disparité de profondeur est faible.</span><span class="sxs-lookup"><span data-stu-id="b256a-378">This has the effect of dampening the blur, which can cause artifacts where depth disparity is small.</span></span> <span data-ttu-id="b256a-379">Il existe parfois une valeur magique qui atténue le problème.</span><span class="sxs-lookup"><span data-stu-id="b256a-379">Sometimes there exists a magical value that alleviates the problem.</span></span>


```C++
fPercentLit = pow( p_max, MAGIC_NUMBER );
```



<span data-ttu-id="b256a-380">Une alternative à l’augmentation du pourcentage d’éclairage sur une puissance consiste à éviter les configurations où les ombres se chevauchent.</span><span class="sxs-lookup"><span data-stu-id="b256a-380">An alternative to raising the percent lit to a power is to avoid configurations where shadows overlap.</span></span> <span data-ttu-id="b256a-381">Même les configurations fictives fortement réglées présentent plusieurs contraintes sur la lumière, l’appareil photo et la géométrie.</span><span class="sxs-lookup"><span data-stu-id="b256a-381">Even highly tuned shadow configurations have several constraints on light, camera, and geometry.</span></span> <span data-ttu-id="b256a-382">Le saignement léger est également réduit en utilisant des textures de résolution plus élevée.</span><span class="sxs-lookup"><span data-stu-id="b256a-382">Light bleeding is also lessened by using higher resolution textures.</span></span>

<span data-ttu-id="b256a-383">Les cartes fictives de variances en couche (LVSMs) résolvent le problème au détriment de la Division des frustum en couches perpendiculaires à la lumière.</span><span class="sxs-lookup"><span data-stu-id="b256a-383">Layered variance shadow maps (LVSMs) solve the problem at the expense of breaking the frustum into layers that are perpendicular to the light.</span></span> <span data-ttu-id="b256a-384">Le nombre de mappages requis serait assez important quand les CMS sont également utilisés.</span><span class="sxs-lookup"><span data-stu-id="b256a-384">The number of maps required would be quite large when CSMs are also being used.</span></span>

<span data-ttu-id="b256a-385">En outre, Andrew Lauritzen, co-auteur du document sur VSMs et auteur d’un document sur LVSMs, a abordé la combinaison de cartes fictives exponentielles (ESMs) et de VSMs pour contrecarrer la fusion d’éclairage dans un [Forum Beyond3D](https://forum.beyond3d.com/showthread.php?t=47427).</span><span class="sxs-lookup"><span data-stu-id="b256a-385">Additionally, Andrew Lauritzen, co-author of the paper on VSMs, and author of a paper on LVSMs, discussed combining exponential shadow maps (ESMs) with VSMs to counteract light blending in a [Beyond3D Forum](https://forum.beyond3d.com/showthread.php?t=47427).</span></span>

## <a name="vsms-with-csms"></a><span data-ttu-id="b256a-386">VSMs avec CMS</span><span class="sxs-lookup"><span data-stu-id="b256a-386">VSMs with CSMs</span></span>

<span data-ttu-id="b256a-387">L’exemple VarianceShadow11 combine VSMs et CMS.</span><span class="sxs-lookup"><span data-stu-id="b256a-387">The sample VarianceShadow11 combines VSMs and CSMs.</span></span> <span data-ttu-id="b256a-388">La combinaison est relativement simple.</span><span class="sxs-lookup"><span data-stu-id="b256a-388">The combination is fairly straightforward.</span></span> <span data-ttu-id="b256a-389">L’exemple suit les mêmes étapes que l’exemple CascadedShadowMaps11.</span><span class="sxs-lookup"><span data-stu-id="b256a-389">The sample follows the same steps as the CascadedShadowMaps11 sample.</span></span> <span data-ttu-id="b256a-390">PCF n’étant pas utilisé, les ombres sont floues dans une convolution séparable à deux passes.</span><span class="sxs-lookup"><span data-stu-id="b256a-390">Because PCF is not used, the shadows are blurred in a two-pass separable convolution.</span></span> <span data-ttu-id="b256a-391">Le fait de ne pas utiliser PCF permet également à l’exemple d’utiliser des tableaux de texture au lieu d’un Atlas de textures.</span><span class="sxs-lookup"><span data-stu-id="b256a-391">Not using PCF also enables the sample to use texture arrays instead of a texture atlas.</span></span> <span data-ttu-id="b256a-392">PCF sur les tableaux de texture est une fonctionnalité Direct3D 10,1.</span><span class="sxs-lookup"><span data-stu-id="b256a-392">PCF on texture arrays is a Direct3D 10.1 feature.</span></span>

### <a name="gradients-with-csms"></a><span data-ttu-id="b256a-393">Dégradés avec CMS</span><span class="sxs-lookup"><span data-stu-id="b256a-393">Gradients with CSMs</span></span>

<span data-ttu-id="b256a-394">L’utilisation de dégradés avec CMS peut produire une couture le long de la bordure entre deux cascades, comme illustré dans la figure 17.</span><span class="sxs-lookup"><span data-stu-id="b256a-394">Using gradients with CSMs can produce a seam along the border between two cascades as seen in Figure 17.</span></span> <span data-ttu-id="b256a-395">L’exemple d’instruction utilise des dérivées entre les pixels pour calculer des informations, telles que le niveau de mipmap, nécessaires au filtre.</span><span class="sxs-lookup"><span data-stu-id="b256a-395">The sample instruction uses derivatives between pixels to calculate information, such as the mipmap level, needed by the filter.</span></span> <span data-ttu-id="b256a-396">Cela pose un problème en particulier pour la sélection mipmap ou le filtrage anisotrope.</span><span class="sxs-lookup"><span data-stu-id="b256a-396">This causes a problem in particular for mipmap selection or anisotropic filtering.</span></span> <span data-ttu-id="b256a-397">Lorsque les pixels d’un quadruple prennent différentes branches dans le nuanceur, les dérivés calculés par le matériel GPU ne sont pas valides.</span><span class="sxs-lookup"><span data-stu-id="b256a-397">When pixels in a quad take different branches in the shader, the derivatives calculated by the GPU hardware are invalid.</span></span> <span data-ttu-id="b256a-398">Cela aboutit à une jointure en escalier le long du mappage d’ombre.</span><span class="sxs-lookup"><span data-stu-id="b256a-398">This results in a jagged seam along the shadow map.</span></span>

<span data-ttu-id="b256a-399">**Figure 17. Jointures sur les bordures en cascade en raison d’un filtrage anisotrope avec un contrôle de Flow divergent**</span><span class="sxs-lookup"><span data-stu-id="b256a-399">**Figure 17. Seams on cascade borders due to anisotropic filtering with divergent flow control**</span></span>

![jointures sur les bordures en cascade en raison d’un filtrage anisotrope avec un contrôle de Flow divergent](images/seams-on-cascade-borders-due-to-anisotropic.jpg)

<span data-ttu-id="b256a-401">Ce problème est résolu en calculant les dérivés à la position dans l’espace d’affichage clair. la coordonnée de l’espace d’affichage clair n’est pas spécifique à la cascade sélectionnée.</span><span class="sxs-lookup"><span data-stu-id="b256a-401">This problem is solved by computing the derivatives on the position in light-view space; the light-view space coordinate is not specific to the selected cascade.</span></span> <span data-ttu-id="b256a-402">Les dérivés calculés peuvent être mis à l’échelle en fonction de la partie de l’échelle de la matrice de texture de projection au niveau de mipmap correct.</span><span class="sxs-lookup"><span data-stu-id="b256a-402">The computed derivatives can be scaled by the scale portion of the projection-texture matrix to the correct mipmap level.</span></span>


```C++
        float3 vShadowTexCoordDDX = ddx( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDX *= m_vCascadeScale[iCascade].xyz;
        float3 vShadowTexCoordDDY = ddy( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDY *= m_vCascadeScale[iCascade].xyz;

        mapDepth += g_txShadow.SampleGrad( g_samShadow, vShadowTexCoord.xyz,
        vShadowTexCoordDDX, vShadowTexCoordDDY );
```



## <a name="vsms-compared-to-standard-shadows-with-pcf"></a><span data-ttu-id="b256a-403">VSMs comparaison avec les ombres standard avec PCF</span><span class="sxs-lookup"><span data-stu-id="b256a-403">VSMs Compared to Standard Shadows with PCF</span></span>

<span data-ttu-id="b256a-404">VSMs et PCF tentent tous les deux de se rapprocher de la zone de pixels qui passerait le test de profondeur.</span><span class="sxs-lookup"><span data-stu-id="b256a-404">Both VSMs and PCF attempt to approximate the fraction of pixel area that would pass the depth test.</span></span> <span data-ttu-id="b256a-405">Les VSMs fonctionnent avec le matériel de filtrage et peuvent être flous avec les noyaux séparable.</span><span class="sxs-lookup"><span data-stu-id="b256a-405">VSMs work with filtering hardware and can be blurred with separable kernels.</span></span> <span data-ttu-id="b256a-406">Les noyaux de convolution séparable sont beaucoup moins chers à implémenter qu’un noyau complet.</span><span class="sxs-lookup"><span data-stu-id="b256a-406">Separable convolution kernels are considerably cheaper to implement than a full kernel.</span></span> <span data-ttu-id="b256a-407">En outre, VSMs compare une profondeur d’espace clair à une valeur de la carte de profondeur d’espace clair.</span><span class="sxs-lookup"><span data-stu-id="b256a-407">Additionally, VSMs compare one light-space depth against one value in the light-space depth map.</span></span> <span data-ttu-id="b256a-408">Cela signifie que les VSMs n’ont pas les mêmes problèmes de décalage que PCF.</span><span class="sxs-lookup"><span data-stu-id="b256a-408">This means that VSMs do not have the same offset problems as PCF.</span></span> <span data-ttu-id="b256a-409">Techniquement, VSMs est une profondeur d’échantillonnage sur une plus grande surface, ainsi qu’une analyse statistique.</span><span class="sxs-lookup"><span data-stu-id="b256a-409">Technically, VSMs are sampling depth over a greater area, as well as performing a statistical analysis.</span></span> <span data-ttu-id="b256a-410">Cela est moins précis que PCF.</span><span class="sxs-lookup"><span data-stu-id="b256a-410">This is less precise than PCF.</span></span> <span data-ttu-id="b256a-411">En pratique, les VSMs effectuent un bon travail de fusion, ce qui se traduit par un décalage moins important.</span><span class="sxs-lookup"><span data-stu-id="b256a-411">In practice, VSMs do a very good job of blending, which results in less offset being necessary.</span></span> <span data-ttu-id="b256a-412">Comme décrit ci-dessus, le nombre un inconvénients pour VSMs est le saignement léger.</span><span class="sxs-lookup"><span data-stu-id="b256a-412">As described above, the number one drawback to VSMs is light bleeding.</span></span>

<span data-ttu-id="b256a-413">VSMs et PCF représentent un compromis entre la puissance de calcul GPU et la bande passante de texture GPU.</span><span class="sxs-lookup"><span data-stu-id="b256a-413">VSMs and PCF represent a trade-off between GPU compute power and GPU texture bandwidth.</span></span> <span data-ttu-id="b256a-414">Les VSMs requièrent plus d’opérations mathématiques pour calculer la variance.</span><span class="sxs-lookup"><span data-stu-id="b256a-414">VSMs require more math to be performed to calculate the variance.</span></span> <span data-ttu-id="b256a-415">PCF requiert plus de bande passante de mémoire de texture.</span><span class="sxs-lookup"><span data-stu-id="b256a-415">PCF requires more texture memory bandwidth.</span></span> <span data-ttu-id="b256a-416">Les gros noyaux PCF peuvent rapidement devenir goulots d’étranglement en matière de bande passante.</span><span class="sxs-lookup"><span data-stu-id="b256a-416">Large PCF kernels can quickly become bottlenecked by texture bandwidth.</span></span> <span data-ttu-id="b256a-417">Avec la croissance de la puissance de calcul GPU plus rapidement que la bande passante GPU, les VSMs deviennent plus pratiques des deux algorithmes.</span><span class="sxs-lookup"><span data-stu-id="b256a-417">With GPU computation power growing more rapidly than GPU bandwidth, VSMs are becoming the more practical of the two algorithms.</span></span> <span data-ttu-id="b256a-418">Les VSMs sont également mieux adaptés aux mappages d’ombres de résolution inférieure en raison de la fusion et du filtrage.</span><span class="sxs-lookup"><span data-stu-id="b256a-418">VSMs also look better with lower resolution shadow maps due to blending and filtering.</span></span>

## <a name="summary"></a><span data-ttu-id="b256a-419">Résumé</span><span class="sxs-lookup"><span data-stu-id="b256a-419">Summary</span></span>

<span data-ttu-id="b256a-420">CMS offre une solution au problème d’alias de perspective.</span><span class="sxs-lookup"><span data-stu-id="b256a-420">CSMs offer a solution to the perspective aliasing problem.</span></span> <span data-ttu-id="b256a-421">Il existe plusieurs configurations possibles pour obtenir la fidélité visuelle nécessaire pour un titre.</span><span class="sxs-lookup"><span data-stu-id="b256a-421">There are several possible configurations to get the needed visual fidelity for a title.</span></span> <span data-ttu-id="b256a-422">PCF et VSMs sont largement utilisés et doivent être combinés avec CMS pour réduire les alias.</span><span class="sxs-lookup"><span data-stu-id="b256a-422">PCF and VSMs are widely used and should be combined with CSMs to reduce aliasing.</span></span>

## <a name="references"></a><span data-ttu-id="b256a-423">Références</span><span class="sxs-lookup"><span data-stu-id="b256a-423">References</span></span>

<span data-ttu-id="b256a-424">Donnelly, W. et Lauritzen, A. [variance les cartes Shadow](https://portal.acm.org/citation.cfm?doid=1111411.1111440).</span><span class="sxs-lookup"><span data-stu-id="b256a-424">Donnelly, W. and Lauritzen, A. [Variance shadow maps](https://portal.acm.org/citation.cfm?doid=1111411.1111440).</span></span> <span data-ttu-id="b256a-425">Dans SI3D' 06 : procédure du congrès 2006 sur les jeux et les graphiques 3D interactifs.</span><span class="sxs-lookup"><span data-stu-id="b256a-425">In SI3D '06: Proceedings of the 2006 symposium on Interactive 3D graphics and games.</span></span> <span data-ttu-id="b256a-426">2006.</span><span class="sxs-lookup"><span data-stu-id="b256a-426">2006.</span></span> <span data-ttu-id="b256a-427">pp. 161 – 165.</span><span class="sxs-lookup"><span data-stu-id="b256a-427">pp. 161–165.</span></span> <span data-ttu-id="b256a-428">New York, NY, USA : ACM Press.</span><span class="sxs-lookup"><span data-stu-id="b256a-428">New York, NY, USA: ACM Press.</span></span>

<span data-ttu-id="b256a-429">Lauritzen, Andrew et McCool, Michael.</span><span class="sxs-lookup"><span data-stu-id="b256a-429">Lauritzen, Andrew and McCool, Michael.</span></span> <span data-ttu-id="b256a-430">[Cartes fictives de variance en couches](https://portal.acm.org/citation.cfm?id=1375714.1375739&coll=GUIDE&dl=GUIDE&CFID=45360327&CFTOKEN=34578992).</span><span class="sxs-lookup"><span data-stu-id="b256a-430">[Layered variance shadow maps](https://portal.acm.org/citation.cfm?id=1375714.1375739&coll=GUIDE&dl=GUIDE&CFID=45360327&CFTOKEN=34578992).</span></span> <span data-ttu-id="b256a-431">Procédure de l’interface graphique 2008, du 28 au 30 mai, 2008, Windsor, Ontario, Canada.</span><span class="sxs-lookup"><span data-stu-id="b256a-431">Proceedings of graphics interface 2008, May 28–30, 2008, Windsor, Ontario, Canada.</span></span>

<span data-ttu-id="b256a-432">Engel, Woflgang F. section 4.</span><span class="sxs-lookup"><span data-stu-id="b256a-432">Engel, Woflgang F. Section 4.</span></span> <span data-ttu-id="b256a-433">Cartes fictives en cascade.</span><span class="sxs-lookup"><span data-stu-id="b256a-433">Cascaded Shadow Maps.</span></span> <span data-ttu-id="b256a-434">ShaderX5, techniques de rendu avancées, Wolfgang F. Engel, Ed.</span><span class="sxs-lookup"><span data-stu-id="b256a-434">ShaderX5 , Advanced Rendering Techniques, Wolfgang F. Engel, Ed.</span></span> <span data-ttu-id="b256a-435">Charles River un support, Boston, Massachusetts.</span><span class="sxs-lookup"><span data-stu-id="b256a-435">Charles River Media, Boston, Massachusetts.</span></span> <span data-ttu-id="b256a-436">2006.</span><span class="sxs-lookup"><span data-stu-id="b256a-436">2006.</span></span> <span data-ttu-id="b256a-437">pp. 197 – 206.</span><span class="sxs-lookup"><span data-stu-id="b256a-437">pp. 197–206.</span></span>

 

 