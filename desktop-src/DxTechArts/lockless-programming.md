---
title: Considérations sur la programmation sans verrou pour Xbox 360 et Microsoft Windows
description: Cet article donne une vue d’ensemble de certains des problèmes à prendre en compte lors de la tentative d’utilisation de techniques de programmation avec blocage.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 23bf8d66cada8aff00735fe6d6ac2d4f1369bc32
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/21/2020
ms.locfileid: "103941464"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a><span data-ttu-id="9005b-103">Considérations sur la programmation sans verrou pour Xbox 360 et Microsoft Windows</span><span class="sxs-lookup"><span data-stu-id="9005b-103">Lockless Programming Considerations for Xbox 360 and Microsoft Windows</span></span>

<span data-ttu-id="9005b-104">La programmation sans blocage est un moyen de partager en toute sécurité des données modifiées entre plusieurs threads sans avoir à acquérir et à libérer des verrous.</span><span class="sxs-lookup"><span data-stu-id="9005b-104">Lockless programming is a way to safely share changing data between multiple threads without the cost of acquiring and releasing locks.</span></span> <span data-ttu-id="9005b-105">Cela ressemble à une panacée, mais la programmation sans verrou est complexe et subtile, et peut parfois ne pas offrir les avantages qu’elle promet.</span><span class="sxs-lookup"><span data-stu-id="9005b-105">This sounds like a panacea, but lockless programming is complex and subtle, and sometimes doesn't give the benefits that it promises.</span></span> <span data-ttu-id="9005b-106">La programmation avec blocage est particulièrement complexe sur la Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="9005b-106">Lockless programming is particularly complex on Xbox 360.</span></span>

<span data-ttu-id="9005b-107">La programmation sans blocage est une technique valide pour la programmation multithread, mais elle ne doit pas être utilisée de façon légère.</span><span class="sxs-lookup"><span data-stu-id="9005b-107">Lockless programming is a valid technique for multithreaded programming, but it should not be used lightly.</span></span> <span data-ttu-id="9005b-108">Avant de l’utiliser, vous devez comprendre les complexités, et vous devez effectuer une mesure avec soin pour vous assurer qu’elle vous donne réellement les gains attendus.</span><span class="sxs-lookup"><span data-stu-id="9005b-108">Before using it you must understand the complexities, and you should measure carefully to make sure that it is actually giving you the gains that you expect.</span></span> <span data-ttu-id="9005b-109">Dans de nombreux cas, il existe des solutions plus simples et plus rapides, telles que le partage de données moins fréquemment, qui doivent être utilisées à la place.</span><span class="sxs-lookup"><span data-stu-id="9005b-109">In many cases, there are simpler and faster solutions, such as sharing data less frequently, which should be used instead.</span></span>

<span data-ttu-id="9005b-110">L’utilisation de la programmation sans blocage correctement et en toute sécurité nécessite une connaissance significative de votre matériel et de votre compilateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-110">Using lockless programming correctly and safely requires significant knowledge of both your hardware and your compiler.</span></span> <span data-ttu-id="9005b-111">Cet article donne une vue d’ensemble de certains des problèmes à prendre en compte lors de la tentative d’utilisation de techniques de programmation avec blocage.</span><span class="sxs-lookup"><span data-stu-id="9005b-111">This article gives an overview of some of the issues to consider when trying to use lockless programming techniques.</span></span>

## <a name="programming-with-locks"></a><span data-ttu-id="9005b-112">Programmation à l’aide de verrous</span><span class="sxs-lookup"><span data-stu-id="9005b-112">Programming with Locks</span></span>

<span data-ttu-id="9005b-113">Lors de l’écriture de code multithread, il est souvent nécessaire de partager des données entre les threads.</span><span class="sxs-lookup"><span data-stu-id="9005b-113">When writing multi-threaded code it is often necessary to share data between threads.</span></span> <span data-ttu-id="9005b-114">Si plusieurs threads lisent et écrivent simultanément des structures de données partagées, une altération de la mémoire peut se produire.</span><span class="sxs-lookup"><span data-stu-id="9005b-114">If multiple threads are simultaneously reading and writing the shared data structures, memory corruption can occur.</span></span> <span data-ttu-id="9005b-115">Le moyen le plus simple de résoudre ce problème consiste à utiliser des verrous.</span><span class="sxs-lookup"><span data-stu-id="9005b-115">The simplest way of solving this problem is to use locks.</span></span> <span data-ttu-id="9005b-116">Par exemple, si ManipulateSharedData doit être exécutée par un seul thread à la fois, une \_ section critique peut être utilisée pour garantir cela, comme dans le code suivant :</span><span class="sxs-lookup"><span data-stu-id="9005b-116">For instance, if ManipulateSharedData should only be executed by one thread at a time, a CRITICAL\_SECTION can be used to guarantee this, as in the following code:</span></span>

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

<span data-ttu-id="9005b-117">Ce code est relativement simple et simple, et il est facile de savoir qu’il est correct.</span><span class="sxs-lookup"><span data-stu-id="9005b-117">This code is fairly simple and straightforward, and it is easy to tell that it is correct.</span></span> <span data-ttu-id="9005b-118">Toutefois, la programmation avec des verrous est accompagnée de plusieurs inconvénients potentiels.</span><span class="sxs-lookup"><span data-stu-id="9005b-118">However, programming with locks comes with several potential disadvantages.</span></span> <span data-ttu-id="9005b-119">Par exemple, si deux threads essaient d’acquérir les deux mêmes verrous, mais les acquièrent dans un ordre différent, vous pouvez obtenir un blocage.</span><span class="sxs-lookup"><span data-stu-id="9005b-119">For example, if two threads try to acquire the same two locks but acquire them in a different order, you may get a deadlock.</span></span> <span data-ttu-id="9005b-120">Si un programme maintient un verrou trop long, en raison d’une conception médiocre ou parce que le thread a été échangé par un thread de priorité plus élevée, les autres threads peuvent être bloqués pendant une longue période.</span><span class="sxs-lookup"><span data-stu-id="9005b-120">If a program holds a lock for too long—because of poor design or because the thread has been swapped out by a higher priority thread—other threads may be blocked for a long time.</span></span> <span data-ttu-id="9005b-121">Ce risque est particulièrement intéressant sur la Xbox 360 parce que les threads logiciels reçoivent un thread matériel par le développeur et que le système d’exploitation ne les déplace pas vers un autre thread matériel, même si l’un d’eux est inactif.</span><span class="sxs-lookup"><span data-stu-id="9005b-121">This risk is particularly great on Xbox 360 because the software threads are assigned a hardware thread by the developer, and the operating system won't move them to another hardware thread, even if one is idle.</span></span> <span data-ttu-id="9005b-122">La Xbox 360 ne dispose pas non plus d’une protection contre l’inversion de priorité, où un thread de priorité élevée tourne dans une boucle en attendant qu’un thread de faible priorité libère un verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-122">The Xbox 360 also has no protection against priority inversion, where a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock.</span></span> <span data-ttu-id="9005b-123">Enfin, si un appel de procédure différé ou une routine de service d’interruption tente d’acquérir un verrou, vous risquez d’obtenir un blocage.</span><span class="sxs-lookup"><span data-stu-id="9005b-123">Finally, if a deferred procedure call or interrupt service routine tries to acquire a lock, you may get a deadlock.</span></span>

<span data-ttu-id="9005b-124">Malgré ces problèmes, les primitives de synchronisation, telles que les sections critiques, sont généralement la meilleure façon de coordonner plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="9005b-124">Despite these problems, synchronization primitives, such as critical sections, are generally the best way of coordinating multiple threads.</span></span> <span data-ttu-id="9005b-125">Si les primitives de synchronisation sont trop lentes, la meilleure solution consiste généralement à les utiliser moins fréquemment.</span><span class="sxs-lookup"><span data-stu-id="9005b-125">If the synchronization primitives are too slow, the best solution is usually to use them less frequently.</span></span> <span data-ttu-id="9005b-126">Toutefois, pour ceux qui peuvent se permettre d’avoir une complexité supplémentaire, une autre option est la programmation avec verrouillage.</span><span class="sxs-lookup"><span data-stu-id="9005b-126">However, for those who can afford the extra complexity, another option is lockless programming.</span></span>

## <a name="lockless-programming"></a><span data-ttu-id="9005b-127">Programmation avec blocage</span><span class="sxs-lookup"><span data-stu-id="9005b-127">Lockless Programming</span></span>

<span data-ttu-id="9005b-128">La programmation sans blocage, comme son nom l’indique, est une famille de techniques permettant de manipuler en toute sécurité des données partagées sans utiliser de verrous.</span><span class="sxs-lookup"><span data-stu-id="9005b-128">Lockless programming, as the name suggests, is a family of techniques for safely manipulating shared data without using locks.</span></span> <span data-ttu-id="9005b-129">Il existe des algorithmes de verrouillage disponibles pour transmettre des messages, partager des listes et des files d’attente de données, et d’autres tâches.</span><span class="sxs-lookup"><span data-stu-id="9005b-129">There are lockless algorithms available for passing messages, sharing lists and queues of data, and other tasks.</span></span>

<span data-ttu-id="9005b-130">Lors de la programmation sans verrou, vous devez gérer deux défis : les opérations non atomiques et la réorganisation.</span><span class="sxs-lookup"><span data-stu-id="9005b-130">When doing lockless programming, there are two challenges that you must deal with: non-atomic operations and reordering.</span></span>

## <a name="non-atomic-operations"></a><span data-ttu-id="9005b-131">Opérations non atomiques</span><span class="sxs-lookup"><span data-stu-id="9005b-131">Non-Atomic Operations</span></span>

<span data-ttu-id="9005b-132">Une opération atomique est une opération indivisible, dans laquelle d’autres threads sont assurés de ne jamais voir l’opération quand elle est à moitié terminée.</span><span class="sxs-lookup"><span data-stu-id="9005b-132">An atomic operation is one that is indivisible—one where other threads are guaranteed to never see the operation when it is half done.</span></span> <span data-ttu-id="9005b-133">Les opérations atomiques sont importantes pour la programmation sans blocage, car sans elles, les autres threads peuvent voir des valeurs semi-écrites ou un état incohérent.</span><span class="sxs-lookup"><span data-stu-id="9005b-133">Atomic operations are important for lockless programming, because without them, other threads might see half-written values, or otherwise inconsistent state.</span></span>

<span data-ttu-id="9005b-134">Sur tous les processeurs modernes, vous pouvez supposer que les lectures et les écritures des types natifs à alignement naturellement sont atomiques.</span><span class="sxs-lookup"><span data-stu-id="9005b-134">On all modern processors, you can assume that reads and writes of naturally aligned native types are atomic.</span></span> <span data-ttu-id="9005b-135">Tant que le bus de mémoire est au moins aussi grand que le type en cours de lecture ou d’écriture, l’UC lit et écrit ces types dans une transaction bus unique, ce qui empêche les autres threads de les voir dans un état semi-fini.</span><span class="sxs-lookup"><span data-stu-id="9005b-135">As long as the memory bus is at least as wide as the type being read or written, the CPU reads and writes these types in a single bus transaction, making it impossible for other threads to see them in a half-completed state.</span></span> <span data-ttu-id="9005b-136">Sur les systèmes x86 et x64, il n’est pas garanti que les lectures et écritures supérieures à huit octets sont atomiques.</span><span class="sxs-lookup"><span data-stu-id="9005b-136">On x86 and x64 there, is no guarantee that reads and writes larger than eight bytes are atomic.</span></span> <span data-ttu-id="9005b-137">Cela signifie que les lectures et écritures de 16 octets des registres d’extension streaming SIMD (SSE), et les opérations de chaîne, peuvent ne pas être atomiques.</span><span class="sxs-lookup"><span data-stu-id="9005b-137">This means that 16-byte reads and writes of streaming SIMD extension (SSE) registers, and string operations, might not be atomic.</span></span>

<span data-ttu-id="9005b-138">Les lectures et les écritures des types qui ne sont pas alignés naturellement, par exemple l’écriture de DWORDs qui traversent des limites de 4 octets, ne sont pas garanties atomiques.</span><span class="sxs-lookup"><span data-stu-id="9005b-138">Reads and writes of types that are not naturally aligned—for instance, writing DWORDs that cross four-byte boundaries—are not guaranteed to be atomic.</span></span> <span data-ttu-id="9005b-139">L’UC peut être amenée à effectuer ces opérations de lecture et d’écriture sous forme de transactions de bus multiples, ce qui peut permettre à un autre thread de modifier ou d’afficher les données au milieu de la lecture ou de l’écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-139">The CPU may have to do these reads and writes as multiple bus transactions, which could allow another thread to modify or see the data in the middle of the read or write.</span></span>

<span data-ttu-id="9005b-140">Les opérations composites, telles que la séquence de lecture-modification-écriture qui se produit lorsque vous incrémentez une variable partagée, ne sont pas atomiques.</span><span class="sxs-lookup"><span data-stu-id="9005b-140">Composite operations, such as the read-modify-write sequence that occurs when you increment a shared variable, are not atomic.</span></span> <span data-ttu-id="9005b-141">Sur la Xbox 360, ces opérations sont implémentées sous la forme de plusieurs instructions (LWZ, addi et STW), et le thread peut être transféré à partir de la séquence.</span><span class="sxs-lookup"><span data-stu-id="9005b-141">On Xbox 360, these operations are implemented as multiple instructions (lwz, addi, and stw), and the thread could be swapped out partway through the sequence.</span></span> <span data-ttu-id="9005b-142">Sur les systèmes x86 et x64, il existe une seule instruction (Inc) qui peut être utilisée pour incrémenter une variable en mémoire.</span><span class="sxs-lookup"><span data-stu-id="9005b-142">On x86 and x64, there is a single instruction (inc) that can be used to increment a variable in memory.</span></span> <span data-ttu-id="9005b-143">Si vous utilisez cette instruction, l’incrémentation d’une variable est atomique sur les systèmes à un seul processeur, mais elle n’est toujours pas atomique sur les systèmes multiprocesseurs.</span><span class="sxs-lookup"><span data-stu-id="9005b-143">If you use this instruction, incrementing a variable is atomic on single-processor systems, but it is still not atomic on multi-processor systems.</span></span> <span data-ttu-id="9005b-144">L’atomicité de Inc sur les systèmes multiprocesseurs x86 et x64 nécessite l’utilisation du préfixe de verrouillage, qui empêche un autre processeur d’effectuer sa propre séquence de lecture-modification-écriture entre la lecture et l’écriture de l’instruction Inc.</span><span class="sxs-lookup"><span data-stu-id="9005b-144">Making inc atomic on x86- and x64-based multi-processor systems requires using the lock prefix, which prevents another processor from doing its own read-modify-write sequence between the read and the write of the inc instruction.</span></span>

<span data-ttu-id="9005b-145">Le code suivant montre des exemples :</span><span class="sxs-lookup"><span data-stu-id="9005b-145">The following code shows some examples:</span></span>

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a><span data-ttu-id="9005b-146">Garantie de l’atomicité</span><span class="sxs-lookup"><span data-stu-id="9005b-146">Guaranteeing Atomicity</span></span>

<span data-ttu-id="9005b-147">Vous pouvez vous assurer que vous utilisez des opérations atomiques à l’aide d’une combinaison des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="9005b-147">You can be sure you are using atomic operations by a combination of the following:</span></span>

-   <span data-ttu-id="9005b-148">Opérations Atomic atomiques</span><span class="sxs-lookup"><span data-stu-id="9005b-148">Naturally atomic operations</span></span>
-   <span data-ttu-id="9005b-149">Verrous pour encapsuler des opérations composites</span><span class="sxs-lookup"><span data-stu-id="9005b-149">Locks to wrap composite operations</span></span>
-   <span data-ttu-id="9005b-150">Fonctions du système d’exploitation qui implémentent des versions atomiques des opérations composites populaires</span><span class="sxs-lookup"><span data-stu-id="9005b-150">Operating system functions that implement atomic versions of popular composite operations</span></span>

<span data-ttu-id="9005b-151">L’incrémentation d’une variable n’est pas une opération atomique et l’incrémentation peut entraîner une altération des données si elle est exécutée sur plusieurs threads.</span><span class="sxs-lookup"><span data-stu-id="9005b-151">Incrementing a variable is not an atomic operation, and incrementing may lead to data corruption if executed on multiple threads.</span></span>

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

<span data-ttu-id="9005b-152">Win32 est fourni avec une famille de fonctions qui offrent des versions de lecture-modification-écriture atomiques de plusieurs opérations courantes.</span><span class="sxs-lookup"><span data-stu-id="9005b-152">Win32 comes with a family of functions that offer atomic read-modify-write versions of several common operations.</span></span> <span data-ttu-id="9005b-153">Il s’agit de la famille de fonctions InterlockedXxx.</span><span class="sxs-lookup"><span data-stu-id="9005b-153">These are the InterlockedXxx family of functions.</span></span> <span data-ttu-id="9005b-154">Si toutes les modifications de la variable partagée utilisent ces fonctions, les modifications seront thread-safe.</span><span class="sxs-lookup"><span data-stu-id="9005b-154">If all modifications of the shared variable use these functions, the modifications will be thread safe.</span></span>

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a><span data-ttu-id="9005b-155">Réorganisation</span><span class="sxs-lookup"><span data-stu-id="9005b-155">Reordering</span></span>

<span data-ttu-id="9005b-156">La réorganisation est un problème plus subtil.</span><span class="sxs-lookup"><span data-stu-id="9005b-156">A more subtle problem is reordering.</span></span> <span data-ttu-id="9005b-157">Les lectures et écritures ne se produisent pas toujours dans l’ordre dans lequel vous les avez écrites dans votre code, ce qui peut entraîner des problèmes très confus.</span><span class="sxs-lookup"><span data-stu-id="9005b-157">Reads and writes do not always happen in the order that you have written them in your code, and this can lead to very confusing problems.</span></span> <span data-ttu-id="9005b-158">Dans de nombreux algorithmes multithread, un thread écrit des données, puis écrit dans un indicateur qui indique à d’autres threads que les données sont prêtes.</span><span class="sxs-lookup"><span data-stu-id="9005b-158">In many multi-threaded algorithms, a thread writes some data and then writes to a flag that tells other threads that the data is ready.</span></span> <span data-ttu-id="9005b-159">C’est ce qu’on appelle une version d’écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-159">This is known as a write-release.</span></span> <span data-ttu-id="9005b-160">Si les écritures sont réorganisées, d’autres threads peuvent voir que l’indicateur est défini avant de pouvoir voir les données écrites.</span><span class="sxs-lookup"><span data-stu-id="9005b-160">If the writes are reordered, other threads may see that the flag is set before they can see the written data.</span></span>

<span data-ttu-id="9005b-161">De même, dans de nombreux cas, un thread lit à partir d’un indicateur, puis lit des données partagées si l’indicateur indique que le thread a acquis l’accès aux données partagées.</span><span class="sxs-lookup"><span data-stu-id="9005b-161">Similarly, in many cases, a thread reads from a flag and then reads some shared data if the flag says that the thread has acquired access to the shared data.</span></span> <span data-ttu-id="9005b-162">C’est ce qu’on appelle une acquisition en lecture.</span><span class="sxs-lookup"><span data-stu-id="9005b-162">This is known as a read-acquire.</span></span> <span data-ttu-id="9005b-163">Si les lectures sont réorganisées, les données peuvent être lues à partir du stockage partagé avant l’indicateur, et les valeurs affichées peuvent ne pas être à jour.</span><span class="sxs-lookup"><span data-stu-id="9005b-163">If reads are reordered, then the data may be read from shared storage before the flag, and the values seen might not be up to date.</span></span>

<span data-ttu-id="9005b-164">La réorganisation des lectures et des écritures peut être effectuée à la fois par le compilateur et par le processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-164">Reordering of reads and writes can be done both by the compiler and by the processor.</span></span> <span data-ttu-id="9005b-165">Les compilateurs et les processeurs ont effectué cette réorganisation depuis des années, mais sur des ordinateurs à un seul processeur, le problème était moindre.</span><span class="sxs-lookup"><span data-stu-id="9005b-165">Compilers and processors have done this reordering for years, but on single-processor machines it was less of an issue.</span></span> <span data-ttu-id="9005b-166">Cela est dû au fait que la réorganisation de l’UC des lectures et écritures est invisible sur les ordinateurs à un seul processeur (pour le code de pilote sans périphérique qui ne fait pas partie d’un pilote de périphérique), et la réorganisation du compilateur des lectures et des écritures est moins susceptible de provoquer des problèmes sur les ordinateurs à un seul processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-166">This is because CPU rearrangement of reads and writes is invisible on single-processor machines (for non-device driver code that is not part of a device driver), and compiler rearrangement of reads and writes is less likely to cause problems on single-processor machines.</span></span>

<span data-ttu-id="9005b-167">Si le compilateur ou l’UC réorganise les écritures affichées dans le code suivant, un autre thread peut voir que l’indicateur Alive est défini tout en continuant à voir les anciennes valeurs pour x ou y.</span><span class="sxs-lookup"><span data-stu-id="9005b-167">If the compiler or the CPU rearranges the writes shown in the following code, another thread may see that the alive flag is set while still seeing the old values for x or y.</span></span> <span data-ttu-id="9005b-168">Une réorganisation similaire peut se produire lors de la lecture.</span><span class="sxs-lookup"><span data-stu-id="9005b-168">Similar rearrangement can happen when reading.</span></span>

<span data-ttu-id="9005b-169">Dans ce code, un thread ajoute une nouvelle entrée au tableau Sprite :</span><span class="sxs-lookup"><span data-stu-id="9005b-169">In this code, one thread adds a new entry to the sprite array:</span></span>

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="9005b-170">Dans ce bloc de code suivant, un autre thread lit le tableau Sprite :</span><span class="sxs-lookup"><span data-stu-id="9005b-170">In this next code block, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="9005b-171">Pour garantir la sécurité de ce Sprite, nous devons empêcher le compilateur et la réorganisation des lectures et des écritures par le processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-171">To make this sprite system safe, we need to prevent both compiler and CPU reordering of reads and writes.</span></span>

### <a name="understanding-cpu-rearrangement-of-writes"></a><span data-ttu-id="9005b-172">Présentation de la réorganisation de l’UC des écritures</span><span class="sxs-lookup"><span data-stu-id="9005b-172">Understanding CPU Rearrangement of Writes</span></span>

<span data-ttu-id="9005b-173">Certains processeurs réorganisent les écritures afin qu’elles soient visibles en externe par d’autres processeurs ou périphériques dans l’ordre des programmes.</span><span class="sxs-lookup"><span data-stu-id="9005b-173">Some CPUs rearrange writes so that they are externally visible to other processors or devices in non-program order.</span></span> <span data-ttu-id="9005b-174">Cette réorganisation n’est jamais visible pour le code non-thread unique, mais elle peut provoquer des problèmes dans le code multithread.</span><span class="sxs-lookup"><span data-stu-id="9005b-174">This rearranging is never visible to single-threaded non-driver code, but it can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="9005b-175">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="9005b-175">Xbox 360</span></span>

<span data-ttu-id="9005b-176">Bien que l’UC Xbox 360 ne réorganise pas les instructions, elle réorganise les opérations d’écriture, qui se terminent après les instructions elles-mêmes.</span><span class="sxs-lookup"><span data-stu-id="9005b-176">While the Xbox 360 CPU does not reorder instructions, it does rearrange write operations, which complete after the instructions themselves.</span></span> <span data-ttu-id="9005b-177">Cette réorganisation des écritures est spécifiquement autorisée par le modèle de mémoire PowerPC.</span><span class="sxs-lookup"><span data-stu-id="9005b-177">This rearranging of writes is specifically allowed by the PowerPC memory model.</span></span>

<span data-ttu-id="9005b-178">Les écritures sur la Xbox 360 n’accèdent pas directement au cache L2.</span><span class="sxs-lookup"><span data-stu-id="9005b-178">Writes on Xbox 360 do not go directly to the L2 cache.</span></span> <span data-ttu-id="9005b-179">Au lieu de cela, pour améliorer la bande passante d’écriture dans le cache L2, elles passent par les files d’attente du magasin, puis pour le stockage des tampons.</span><span class="sxs-lookup"><span data-stu-id="9005b-179">Instead, in order to improve L2 cache write bandwidth, they go through store queues and then to store-gather buffers.</span></span> <span data-ttu-id="9005b-180">Les mémoires tampons de regroupement de magasins permettent d’écrire des blocs de 64 octets dans le cache L2 en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="9005b-180">The store-gather buffers allow 64-byte blocks to be written to the L2 cache in one operation.</span></span> <span data-ttu-id="9005b-181">Il existe huit mémoires tampons de regroupement de magasins, qui permettent d’écrire efficacement dans plusieurs zones de mémoire différentes.</span><span class="sxs-lookup"><span data-stu-id="9005b-181">There are eight store-gather buffers, which allow efficient writing to several different areas of memory.</span></span>

<span data-ttu-id="9005b-182">Les mémoires tampons de la boutique sont normalement écrites dans le cache L2 dans l’ordre FIFO (premier entré, premier sorti).</span><span class="sxs-lookup"><span data-stu-id="9005b-182">The store-gather buffers are normally written to the L2 cache in first-in-first-out (FIFO) order.</span></span> <span data-ttu-id="9005b-183">Toutefois, si la ligne de cache cible d’une écriture ne se trouve pas dans le cache L2, cette écriture peut être retardée lorsque la ligne de cache est extraite de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="9005b-183">However, if the target cache-line of a write is not in the L2 cache, that write may be delayed while the cache-line is fetched from memory.</span></span>

<span data-ttu-id="9005b-184">Même lorsque les mémoires tampons de stockage sont écrites dans le cache L2 dans un ordre FIFO strict, cela ne garantit pas que les écritures individuelles sont écrites dans le cache L2 dans l’ordre.</span><span class="sxs-lookup"><span data-stu-id="9005b-184">Even when the store-gather buffers are written to the L2 cache in strict FIFO order, this does not guarantee that individual writes are written to the L2 cache in order.</span></span> <span data-ttu-id="9005b-185">Par exemple, imaginez que l’UC écrit à l’emplacement 0x1000, puis à l’emplacement 0x2000, puis à l’emplacement 0x1004.</span><span class="sxs-lookup"><span data-stu-id="9005b-185">For instance, imagine that the CPU writes to location 0x1000, then to location 0x2000, and then to location 0x1004.</span></span> <span data-ttu-id="9005b-186">La première écriture alloue une mémoire tampon de regroupement et la place au début de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="9005b-186">The first write allocates a store-gather buffer and puts it at the front of the queue.</span></span> <span data-ttu-id="9005b-187">La deuxième écriture alloue une autre mémoire tampon de stockage et la place ensuite dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="9005b-187">The second write allocates another store-gather buffer and puts it next in the queue.</span></span> <span data-ttu-id="9005b-188">La troisième écriture ajoute ses données à la première mémoire tampon de regroupement, qui reste au début de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="9005b-188">The third write adds its data to the first store-gather buffer, which remains at the front of the queue.</span></span> <span data-ttu-id="9005b-189">Ainsi, la troisième écriture finit par passer au cache L2 avant la deuxième écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-189">Thus, the third write ends up going to the L2 cache before the second write.</span></span>

<span data-ttu-id="9005b-190">La réorganisation provoquée par les mémoires tampons de la collecte des magasins est fondamentalement imprévisible, en particulier parce que les deux threads d’un noyau partagent les tampons de stockage, ce qui rend l’allocation et le vidage des mémoires tampons de la location de magasin extrêmement variables.</span><span class="sxs-lookup"><span data-stu-id="9005b-190">Reordering caused by store-gather buffers is fundamentally unpredictable, especially because both threads on a core share the store-gather buffers, making the allocation and emptying of the store-gather buffers highly variable.</span></span>

<span data-ttu-id="9005b-191">C’est un exemple de la façon dont les écritures peuvent être réorganisées.</span><span class="sxs-lookup"><span data-stu-id="9005b-191">This is one example of how writes can be reordered.</span></span> <span data-ttu-id="9005b-192">Il peut y avoir d’autres possibilités.</span><span class="sxs-lookup"><span data-stu-id="9005b-192">There may be other possibilities.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="9005b-193">x86 et x64</span><span class="sxs-lookup"><span data-stu-id="9005b-193">x86 and x64</span></span>

<span data-ttu-id="9005b-194">Même si les processeurs x86 et x64 réorganisent les instructions, ils ne réorganisent généralement pas les opérations d’écriture par rapport à d’autres écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-194">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder write operations relative to other writes.</span></span> <span data-ttu-id="9005b-195">Il existe certaines exceptions pour la mémoire allouée en écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-195">There are some exceptions for write-combined memory.</span></span> <span data-ttu-id="9005b-196">En outre, les opérations de chaîne (AVI et STOS) et les écritures SSE de 16 octets peuvent être réorganisées en interne, mais dans le cas contraire, les écritures ne sont pas réorganisées les unes par rapport aux autres.</span><span class="sxs-lookup"><span data-stu-id="9005b-196">Additionally, string operations (MOVS and STOS) and 16-byte SSE writes can be internally reordered, but otherwise, writes are not reordered relative to each other.</span></span>

### <a name="understanding-cpu-rearrangement-of-reads"></a><span data-ttu-id="9005b-197">Présentation de la réorganisation de l’UC des lectures</span><span class="sxs-lookup"><span data-stu-id="9005b-197">Understanding CPU Rearrangement of Reads</span></span>

<span data-ttu-id="9005b-198">Certains processeurs réorganisent les lectures afin qu’elles proviennent d’un stockage partagé dans un ordre non-programme.</span><span class="sxs-lookup"><span data-stu-id="9005b-198">Some CPUs rearrange reads so that they effectively come from shared storage in non-program order.</span></span> <span data-ttu-id="9005b-199">Cette réorganisation n’est jamais visible pour le code non-thread unique, mais peut provoquer des problèmes dans le code multithread.</span><span class="sxs-lookup"><span data-stu-id="9005b-199">This rearranging is never visible to single-threaded non-driver code, but can cause problems in multi-threaded code.</span></span>

### <a name="xbox-360"></a><span data-ttu-id="9005b-200">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="9005b-200">Xbox 360</span></span>

<span data-ttu-id="9005b-201">Les absences dans le cache peuvent entraîner des retards de lecture, ce qui fait que les lectures proviennent de la mémoire partagée dans le désordre et que le minutage de ces absences du cache est fondamentalement imprévisible.</span><span class="sxs-lookup"><span data-stu-id="9005b-201">Cache misses can cause some reads to be delayed, which effectively causes reads to come from shared memory out of order, and the timing of these cache misses is fundamentally unpredictable.</span></span> <span data-ttu-id="9005b-202">La prérécupération et la prédiction de branche peuvent également entraîner la sortie de données de la mémoire partagée dans le désordre.</span><span class="sxs-lookup"><span data-stu-id="9005b-202">Prefetching and branch prediction can also cause data to come from shared memory out of order.</span></span> <span data-ttu-id="9005b-203">Voici quelques exemples de la façon dont les lectures peuvent être réorganisées.</span><span class="sxs-lookup"><span data-stu-id="9005b-203">These are just a few examples of how reads can be reordered.</span></span> <span data-ttu-id="9005b-204">Il peut y avoir d’autres possibilités.</span><span class="sxs-lookup"><span data-stu-id="9005b-204">There may be other possibilities.</span></span> <span data-ttu-id="9005b-205">Cette réorganisation des lectures est spécifiquement autorisée par le modèle de mémoire PowerPC.</span><span class="sxs-lookup"><span data-stu-id="9005b-205">This rearranging of reads is specifically allowed by the PowerPC memory model.</span></span>

### <a name="x86-and-x64"></a><span data-ttu-id="9005b-206">x86 et x64</span><span class="sxs-lookup"><span data-stu-id="9005b-206">x86 and x64</span></span>

<span data-ttu-id="9005b-207">Même si les processeurs x86 et x64 réorganisent les instructions, ils ne réorganisent généralement pas les opérations de lecture par rapport à d’autres lectures.</span><span class="sxs-lookup"><span data-stu-id="9005b-207">Even though x86 and x64 CPUs do reorder instructions, they generally do not reorder read operations relative to other reads.</span></span> <span data-ttu-id="9005b-208">Les opérations de chaîne (AVI et STOS) et les lectures SSE de 16 octets peuvent être réorganisées en interne, mais dans le cas contraire, les lectures ne sont pas réorganisées les unes par rapport aux autres.</span><span class="sxs-lookup"><span data-stu-id="9005b-208">String operations (MOVS and STOS) and 16-byte SSE reads can be internally reordered, but otherwise, reads are not reordered relative to each other.</span></span>

### <a name="other-reordering"></a><span data-ttu-id="9005b-209">Autre réorganisation</span><span class="sxs-lookup"><span data-stu-id="9005b-209">Other Reordering</span></span>

<span data-ttu-id="9005b-210">Même si les processeurs x86 et x64 ne réorganisent pas les écritures par rapport à d’autres écritures, ou réorganisent les lectures par rapport à d’autres lectures, elles peuvent réorganiser les lectures par rapport aux écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-210">Even though x86 and x64 CPUs do not reorder writes relative to other writes, or reorder reads relative to other reads, they can reorder reads relative to writes.</span></span> <span data-ttu-id="9005b-211">Plus précisément, si un programme écrit dans un emplacement, puis lit à partir d’un autre emplacement, les données lues peuvent provenir de la mémoire partagée avant que les données écrites ne le fassent ici.</span><span class="sxs-lookup"><span data-stu-id="9005b-211">Specifically, if a program writes to one location followed by reading from a different location, the read data may come from shared memory before the written data makes it there.</span></span> <span data-ttu-id="9005b-212">Cette réorganisation peut rompre certains algorithmes, tels que les algorithmes d’exclusion mutuelle de Dekker.</span><span class="sxs-lookup"><span data-stu-id="9005b-212">This reordering can break some algorithms, such as Dekker’s mutual exclusion algorithms.</span></span> <span data-ttu-id="9005b-213">Dans l’algorithme de Dekker, chaque thread définit un indicateur pour indiquer qu’il souhaite entrer dans la zone critique, puis vérifie l’indicateur de l’autre thread pour déterminer si l’autre thread se trouve dans la zone critique ou s’il essaie de l’entrer.</span><span class="sxs-lookup"><span data-stu-id="9005b-213">In Dekker's algorithm, each thread sets a flag to indicate that it wants to enter the critical region, and then checks the other thread’s flag to see if the other thread is in the critical region or trying to enter it.</span></span> <span data-ttu-id="9005b-214">Le code initial suit.</span><span class="sxs-lookup"><span data-stu-id="9005b-214">The initial code follows.</span></span>

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

<span data-ttu-id="9005b-215">Le problème est que la lecture de la touche F1 dans P0Acquire peut lire à partir du stockage partagé avant que l’écriture dans F0 la rende dans le stockage partagé.</span><span class="sxs-lookup"><span data-stu-id="9005b-215">The problem is that the read of f1 in P0Acquire can read from shared storage before the write to f0 makes it to shared storage.</span></span> <span data-ttu-id="9005b-216">Pendant ce temps, la lecture de F0 dans P1Acquire peut lire à partir d’un stockage partagé avant que l’écriture dans la F1 le fasse dans le stockage partagé.</span><span class="sxs-lookup"><span data-stu-id="9005b-216">Meanwhile, the read of f0 in P1Acquire can read from shared storage before the write to f1 makes it to shared storage.</span></span> <span data-ttu-id="9005b-217">L’effet net est que les deux threads attribuent à leurs indicateurs la valeur TRUE et que les deux threads voient l’indicateur de l’autre thread comme ayant la valeur FALSe, de sorte qu’ils entrent tous deux dans la région critique.</span><span class="sxs-lookup"><span data-stu-id="9005b-217">The net effect is that both threads set their flags to TRUE, and both threads see the other thread's flag as being FALSE, so they both enter the critical region.</span></span> <span data-ttu-id="9005b-218">Par conséquent, même si les problèmes de réorganisation sur des systèmes x86 et x64 sont moins courants que sur la Xbox 360, ils peuvent toujours se produire.</span><span class="sxs-lookup"><span data-stu-id="9005b-218">Therefore, while problems with reordering on x86- and x64-based systems are less common than on Xbox 360, they definitely can still happen.</span></span> <span data-ttu-id="9005b-219">L’algorithme de Dekker ne fonctionne pas sans barrières de mémoire matérielle sur l’une de ces plateformes.</span><span class="sxs-lookup"><span data-stu-id="9005b-219">Dekker’s algorithm will not work without hardware memory barriers on any of these platforms.</span></span>

<span data-ttu-id="9005b-220">les processeurs x86 et x64 ne réorganisent pas une écriture anticipée d’une lecture précédente.</span><span class="sxs-lookup"><span data-stu-id="9005b-220">x86 and x64 CPUs will not reorder a write ahead of a previous read.</span></span> <span data-ttu-id="9005b-221">les processeurs x86 et x64 réorganisent uniquement les lectures anticipées des Écritures précédentes s’ils ciblent des emplacements différents.</span><span class="sxs-lookup"><span data-stu-id="9005b-221">x86 and x64 CPUs only reorder reads ahead of previous writes if they target different locations.</span></span>

<span data-ttu-id="9005b-222">Les processeurs PowerPC peuvent réorganiser les lectures en avance sur les écritures et peuvent réorganiser les écritures avant les lectures, à condition qu’elles soient sur des adresses différentes.</span><span class="sxs-lookup"><span data-stu-id="9005b-222">PowerPC CPUs can reorder reads ahead of writes, and can reorder writes ahead of reads, as long as they are to different addresses.</span></span>

### <a name="reordering-summary"></a><span data-ttu-id="9005b-223">Réorganisation du résumé</span><span class="sxs-lookup"><span data-stu-id="9005b-223">Reordering Summary</span></span>

<span data-ttu-id="9005b-224">L’UC Xbox 360 réorganise les opérations de mémoire de façon plus agressive que les processeurs x86 et x64, comme indiqué dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="9005b-224">The Xbox 360 CPU reorders memory operations much more aggressively than do x86 and x64 CPUs, as shown in the following table.</span></span> <span data-ttu-id="9005b-225">Pour plus d’informations, consultez la documentation du processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-225">For more details, consult the processor documentation.</span></span>



| <span data-ttu-id="9005b-226">Réorganisation de l’activité</span><span class="sxs-lookup"><span data-stu-id="9005b-226">Reordering Activity</span></span>           | <span data-ttu-id="9005b-227">x86 et x64</span><span class="sxs-lookup"><span data-stu-id="9005b-227">x86 and x64</span></span> | <span data-ttu-id="9005b-228">Xbox 360</span><span class="sxs-lookup"><span data-stu-id="9005b-228">Xbox 360</span></span> |
|-------------------------------|-------------|----------|
| <span data-ttu-id="9005b-229">Lectures anticipées</span><span class="sxs-lookup"><span data-stu-id="9005b-229">Reads moving ahead of reads</span></span>   | <span data-ttu-id="9005b-230">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-230">No</span></span>          | <span data-ttu-id="9005b-231">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-231">Yes</span></span>      |
| <span data-ttu-id="9005b-232">Les écritures se déplacent avant les écritures</span><span class="sxs-lookup"><span data-stu-id="9005b-232">Writes moving ahead of writes</span></span> | <span data-ttu-id="9005b-233">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-233">No</span></span>          | <span data-ttu-id="9005b-234">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-234">Yes</span></span>      |
| <span data-ttu-id="9005b-235">Les écritures se déplacent avant les lectures</span><span class="sxs-lookup"><span data-stu-id="9005b-235">Writes moving ahead of reads</span></span>  | <span data-ttu-id="9005b-236">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-236">No</span></span>          | <span data-ttu-id="9005b-237">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-237">Yes</span></span>      |
| <span data-ttu-id="9005b-238">Lectures anticipées des écritures</span><span class="sxs-lookup"><span data-stu-id="9005b-238">Reads moving ahead of writes</span></span>  | <span data-ttu-id="9005b-239">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-239">Yes</span></span>         | <span data-ttu-id="9005b-240">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-240">Yes</span></span>      |



 

## <a name="read-acquire-and-write-release-barriers"></a><span data-ttu-id="9005b-241">Barrières Read-Acquire et Write-Release</span><span class="sxs-lookup"><span data-stu-id="9005b-241">Read-Acquire and Write-Release Barriers</span></span>

<span data-ttu-id="9005b-242">Les constructions principales utilisées pour empêcher la réorganisation des lectures et des écritures sont appelées barrières de lecture-acquisition et de libération d’écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-242">The main constructs used to prevent reordering of reads and writes are called read-acquire and write-release barriers.</span></span> <span data-ttu-id="9005b-243">Une instruction Read-Acquire est la lecture d’un indicateur ou d’une autre variable pour obtenir la propriété d’une ressource, couplée à une barrière contre la réorganisation.</span><span class="sxs-lookup"><span data-stu-id="9005b-243">A read-acquire is a read of a flag or other variable to gain ownership of a resource, coupled with a barrier against reordering.</span></span> <span data-ttu-id="9005b-244">De même, une mise en écriture est une écriture d’un indicateur ou d’une autre variable pour accorder la propriété d’une ressource, couplée à une barrière contre la réorganisation.</span><span class="sxs-lookup"><span data-stu-id="9005b-244">Similarly, a write-release is a write of a flag or other variable to give away ownership of a resource, coupled with a barrier against reordering.</span></span>

<span data-ttu-id="9005b-245">Les définitions formelles, avec l’aimable Sutter des Herbs, sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="9005b-245">The formal definitions, courtesy of Herb Sutter, are:</span></span>

-   <span data-ttu-id="9005b-246">Une opération d’acquisition en lecture s’exécute avant toutes les lectures et écritures effectuées par le même thread qui le suit dans l’ordre du programme.</span><span class="sxs-lookup"><span data-stu-id="9005b-246">A read-acquire executes before all reads and writes by the same thread that follow it in program order.</span></span>
-   <span data-ttu-id="9005b-247">Une mise en écriture est exécutée après que toutes les opérations de lecture et d’écriture ont été effectuées par le même thread qui la précède dans l’ordre du programme.</span><span class="sxs-lookup"><span data-stu-id="9005b-247">A write-release executes after all reads and writes by the same thread that precede it in program order.</span></span>

<span data-ttu-id="9005b-248">Lorsque votre code acquiert la propriété de la mémoire, soit en obtenant un verrou, soit en extrayant un élément d’une liste liée partagée (sans verrou), il y a toujours une lecture impliquée (test d’un indicateur ou d’un pointeur pour voir si la propriété de la mémoire a été acquise).</span><span class="sxs-lookup"><span data-stu-id="9005b-248">When your code acquires ownership of some memory, either by acquiring a lock or by pulling an item off of a shared linked list (without a lock), there is always a read involved—testing a flag or pointer to see if ownership of the memory has been acquired.</span></span> <span data-ttu-id="9005b-249">Cette lecture peut faire partie d’une opération **InterlockedXxx** , auquel cas elle implique une lecture et une écriture, mais c’est la lecture qui indique si la propriété a été acquise.</span><span class="sxs-lookup"><span data-stu-id="9005b-249">This read may be part of an **InterlockedXxx** operation, in which case it involves both a read and a write, but it is the read that indicates whether ownership has been gained.</span></span> <span data-ttu-id="9005b-250">Une fois que la propriété de la mémoire est acquise, les valeurs sont généralement lues ou écrites dans cette mémoire, et il est très important que ces lectures et écritures s’exécutent après avoir acquis la propriété.</span><span class="sxs-lookup"><span data-stu-id="9005b-250">After ownership of the memory is acquired, values are typically read from or written to that memory, and it is very important that these reads and writes execute after acquiring ownership.</span></span> <span data-ttu-id="9005b-251">Un cloisonnement de lecture-acquisition garantit cela.</span><span class="sxs-lookup"><span data-stu-id="9005b-251">A read-acquire barrier guarantees this.</span></span>

<span data-ttu-id="9005b-252">Lorsque la propriété d’une partie de la mémoire est libérée, soit en libérant un verrou, soit en envoyant un élément à une liste liée partagée, il y a toujours une écriture impliquée qui notifie d’autres threads que la mémoire est à présent disponible.</span><span class="sxs-lookup"><span data-stu-id="9005b-252">When ownership of some memory is released, either by releasing a lock or by pushing an item on to a shared linked list, there is always a write involved which notifies other threads that the memory is now available to them.</span></span> <span data-ttu-id="9005b-253">Alors que votre code était propriétaire de la mémoire, il est probablement lu ou écrit dans celui-ci, et il est très important que ces lectures et écritures s’exécutent avant la libération de la propriété.</span><span class="sxs-lookup"><span data-stu-id="9005b-253">While your code had ownership of the memory, it probably read from or wrote to it, and it is very important that these reads and writes execute before releasing ownership.</span></span> <span data-ttu-id="9005b-254">Une barrière d’écriture garantit cela.</span><span class="sxs-lookup"><span data-stu-id="9005b-254">A write-release barrier guarantees this.</span></span>

<span data-ttu-id="9005b-255">Il est plus simple de considérer les barrières de lecture-acquisition et de libération en écriture comme des opérations uniques.</span><span class="sxs-lookup"><span data-stu-id="9005b-255">It is simplest to think of read-acquire and write-release barriers as single operations.</span></span> <span data-ttu-id="9005b-256">Toutefois, elles doivent parfois être construites à partir de deux parties : une lecture ou une écriture et un cloisonnement qui ne permet pas de déplacer des lectures ou des écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-256">However, they sometimes have to be constructed from two parts: a read or write and a barrier that does not allow reads or writes to move across it.</span></span> <span data-ttu-id="9005b-257">Dans ce cas, le placement du cloisonnement est essentiel.</span><span class="sxs-lookup"><span data-stu-id="9005b-257">In this case, the placement of the barrier is critical.</span></span> <span data-ttu-id="9005b-258">Pour un cloisonnement en lecture-acquisition, la lecture de l’indicateur est prise en premier, puis le cloisonnement, puis les lectures et écritures des données partagées.</span><span class="sxs-lookup"><span data-stu-id="9005b-258">For a read-acquire barrier, the read of the flag comes first, then the barrier, and then the reads and writes of the shared data.</span></span> <span data-ttu-id="9005b-259">Pour une barrière en écriture, les lectures et écritures des données partagées sont d’abord effectuées, puis le cloisonnement, puis l’écriture de l’indicateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-259">For a write-release barrier the reads and writes of the shared data come first, then the barrier, and then the write of the flag.</span></span>

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

<span data-ttu-id="9005b-260">La seule différence entre une lecture-acquisition et une version d’écriture est l’emplacement de la barrière de mémoire.</span><span class="sxs-lookup"><span data-stu-id="9005b-260">The only difference between a read-acquire and a write-release is the location of the memory barrier.</span></span> <span data-ttu-id="9005b-261">Une acquisition en lecture a le cloisonnement après l’opération de verrouillage, et une libération en écriture a le cloisonnement avant.</span><span class="sxs-lookup"><span data-stu-id="9005b-261">A read-acquire has the barrier after the lock operation, and a write-release has the barrier before.</span></span> <span data-ttu-id="9005b-262">Dans les deux cas, le cloisonnement est entre les références à la mémoire verrouillée et les références au verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-262">In both cases the barrier is in-between the references to the locked memory and the references to the lock.</span></span>

<span data-ttu-id="9005b-263">Pour comprendre pourquoi les barrières sont nécessaires lors de l’acquisition et lors de la publication des données, il est préférable (et plus précis) de considérer ces barrières comme garantissant la synchronisation avec la mémoire partagée, et non avec d’autres processeurs.</span><span class="sxs-lookup"><span data-stu-id="9005b-263">To understand why barriers are needed both when acquiring and when releasing data, it is best (and most accurate) to think of these barriers as guaranteeing synchronization with shared memory, not with other processors.</span></span> <span data-ttu-id="9005b-264">Si un processeur utilise une mise en écriture pour libérer de la mémoire partagée d’une structure de données, et qu’un autre processeur utilise une acquisition en lecture pour accéder à cette structure de données à partir de la mémoire partagée, le code fonctionnera correctement.</span><span class="sxs-lookup"><span data-stu-id="9005b-264">If one processor uses a write-release to release a data structure to shared memory, and another processor uses a read-acquire to gain access to that data structure from shared memory, the code will then work properly.</span></span> <span data-ttu-id="9005b-265">Si l’un des processeurs n’utilise pas la barrière appropriée, le partage de données peut échouer.</span><span class="sxs-lookup"><span data-stu-id="9005b-265">If either processor doesn't use the appropriate barrier, the data sharing may fail.</span></span>

<span data-ttu-id="9005b-266">L’utilisation de la barrière appropriée pour empêcher le compilateur et la réorganisation de l’UC pour votre plateforme est essentielle.</span><span class="sxs-lookup"><span data-stu-id="9005b-266">Using the right barrier to prevent compiler and CPU reordering for your platform is critical.</span></span>

<span data-ttu-id="9005b-267">L’un des avantages de l’utilisation des primitives de synchronisation fournies par le système d’exploitation est que tous ces éléments incluent les barrières de mémoire appropriées.</span><span class="sxs-lookup"><span data-stu-id="9005b-267">One of the advantages of using the synchronization primitives provided by the operating system is that all of them include the appropriate memory barriers.</span></span>

## <a name="preventing-compiler-reordering"></a><span data-ttu-id="9005b-268">Empêcher la réorganisation du compilateur</span><span class="sxs-lookup"><span data-stu-id="9005b-268">Preventing Compiler Reordering</span></span>

<span data-ttu-id="9005b-269">Le travail d’un compilateur consiste à optimiser de manière agressive votre code afin d’améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="9005b-269">A compiler's job is to aggressively optimize your code in order to improve performance.</span></span> <span data-ttu-id="9005b-270">Cela comprend la réorganisation des instructions là où elles sont utiles et où qu’elles ne changent pas le comportement.</span><span class="sxs-lookup"><span data-stu-id="9005b-270">This includes rearranging instructions wherever it is helpful and wherever it will not change behavior.</span></span> <span data-ttu-id="9005b-271">Étant donné que la norme C++ ne mentionne jamais le multithread et que le compilateur ne sait pas quel code doit être thread-safe, le compilateur suppose que votre code est monothread lors de la détermination des redispositions qu’il peut en toute sécurité.</span><span class="sxs-lookup"><span data-stu-id="9005b-271">Because the C++ Standard never mentions multithreading, and because the compiler doesn't know what code needs to be thread-safe, the compiler assumes that your code is single-threaded when deciding what rearrangements it can safely do.</span></span> <span data-ttu-id="9005b-272">Par conséquent, vous devez indiquer au compilateur qu’il n’est pas possible de réorganiser les lectures et les écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-272">Therefore, you need to tell the compiler when it is not allowed to reorder reads and writes.</span></span>

<span data-ttu-id="9005b-273">Avec Visual C++ vous pouvez empêcher la réorganisation du compilateur à l’aide de l' [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)intrinsèque du compilateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-273">With Visual C++ you can prevent compiler reordering by using the compiler intrinsic [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx).</span></span> <span data-ttu-id="9005b-274">Lorsque vous insérez **\_ ReadWriteBarrier** dans votre code, le compilateur ne déplace pas les lectures et les écritures dans celui-ci.</span><span class="sxs-lookup"><span data-stu-id="9005b-274">Where you insert **\_ReadWriteBarrier** into your code, the compiler will not move reads and writes across it.</span></span>

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

<span data-ttu-id="9005b-275">Dans le code suivant, un autre thread lit le tableau Sprite :</span><span class="sxs-lookup"><span data-stu-id="9005b-275">In the following code, another thread reads from the sprite array:</span></span>

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

<span data-ttu-id="9005b-276">Il est important de comprendre que [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) n’insère pas d’instructions supplémentaires et qu’il n’empêche pas le processeur de réorganiser les lectures et les écritures ; il empêche uniquement le compilateur de les réorganiser.</span><span class="sxs-lookup"><span data-stu-id="9005b-276">It is important to understand that [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) does not insert any additional instructions, and it does not prevent the CPU from rearranging reads and writes—it only prevents the compiler from rearranging them.</span></span> <span data-ttu-id="9005b-277">Par conséquent, **\_ ReadWriteBarrier** est suffisant quand vous implémentez une barrière d’écriture sur x86 et x64 (comme x86 et x64 ne réorganisent pas les écritures, et une écriture normale suffit pour libérer un verrou), mais dans la plupart des autres cas, il est également nécessaire d’empêcher le processeur de réorganiser les lectures et les écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-277">Thus, **\_ReadWriteBarrier** is sufficient when you implement a write-release barrier on x86 and x64 (because x86 and x64 do not reorder writes, and a normal write is sufficient for releasing a lock), but in most other cases, it is also necessary to prevent the CPU from reordering reads and writes.</span></span>

<span data-ttu-id="9005b-278">Vous pouvez également utiliser [**\_ ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) quand vous écrivez dans une mémoire allouée en écriture non mise en cache pour empêcher la réorganisation des écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-278">You can also use [**\_ReadWriteBarrier**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) when you write to non-cacheable write-combined memory to prevent reordering of writes.</span></span> <span data-ttu-id="9005b-279">Dans ce cas, **\_ ReadWriteBarrier** permet d’améliorer les performances, en garantissant que les écritures ont lieu dans l’ordre linéaire préféré du processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-279">In this case **\_ReadWriteBarrier** helps to improve performance, by guaranteeing that the writes happen in the processor's preferred linear order.</span></span>

<span data-ttu-id="9005b-280">Il est également possible d’utiliser les intrinsèques [**\_ ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) et [**\_ WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) pour un contrôle plus précis de la réorganisation du compilateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-280">It is also possible to use the [**\_ReadBarrier**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) and [**\_WriteBarrier**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) intrinsics for more precise control of compiler reordering.</span></span> <span data-ttu-id="9005b-281">Le compilateur ne déplace pas les lectures sur un **\_ ReadBarrier** et ne déplace pas les écritures dans un **\_ WriteBarrier**.</span><span class="sxs-lookup"><span data-stu-id="9005b-281">The compiler will not move reads across a **\_ReadBarrier**, and it will not move writes across a **\_WriteBarrier**.</span></span>

## <a name="preventing-cpu-reordering"></a><span data-ttu-id="9005b-282">Prévention de la réorganisation de l’UC</span><span class="sxs-lookup"><span data-stu-id="9005b-282">Preventing CPU Reordering</span></span>

<span data-ttu-id="9005b-283">La réorganisation de l’UC est plus subtile que le compilateur réorganisation.</span><span class="sxs-lookup"><span data-stu-id="9005b-283">CPU reordering is more subtle than compiler reordering.</span></span> <span data-ttu-id="9005b-284">Vous ne voyez pas que cela se produit directement, vous voyez simplement des bogues inexplicable.</span><span class="sxs-lookup"><span data-stu-id="9005b-284">You can't ever see it happen directly, you just see inexplicable bugs.</span></span> <span data-ttu-id="9005b-285">Pour empêcher la réorganisation de l’UC des lectures et des écritures, vous devez utiliser des instructions de barrière de mémoire sur certains processeurs.</span><span class="sxs-lookup"><span data-stu-id="9005b-285">In order to prevent CPU reordering of reads and writes you need to use memory barrier instructions, on some processors.</span></span> <span data-ttu-id="9005b-286">Le nom à usage général d’une instruction de barrière de mémoire, sur Xbox 360 et sur Windows, est [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span><span class="sxs-lookup"><span data-stu-id="9005b-286">The all-purpose name for a memory barrier instruction, on Xbox 360 and on Windows, is [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier).</span></span> <span data-ttu-id="9005b-287">Cette macro est implémentée de manière appropriée pour chaque plateforme.</span><span class="sxs-lookup"><span data-stu-id="9005b-287">This macro is implemented appropriately for each platform.</span></span>

<span data-ttu-id="9005b-288">Sur Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) est défini en tant que **lwsync** (Lightweight Sync), également disponible via le **\_ \_ lwsync** intrinsèque, qui est défini dans ppcintrinsics. h.</span><span class="sxs-lookup"><span data-stu-id="9005b-288">On Xbox 360, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined as **lwsync** (lightweight sync), also available through the **\_\_lwsync** intrinsic, which is defined in ppcintrinsics.h.</span></span> <span data-ttu-id="9005b-289">**\_ \_ lwsync** sert également de barrière de mémoire du compilateur, ce qui empêche la réorganisation des lectures et des écritures par le compilateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-289">**\_\_lwsync** also serves as a compiler memory barrier, preventing rearranging of reads and writes by the compiler.</span></span>

<span data-ttu-id="9005b-290">L’instruction **lwsync** est une barrière de mémoire sur Xbox 360 qui synchronise un cœur de processeur avec le cache L2.</span><span class="sxs-lookup"><span data-stu-id="9005b-290">The **lwsync** instruction is a memory barrier on Xbox 360 that synchronizes one processor core with the L2 cache.</span></span> <span data-ttu-id="9005b-291">Il garantit que toutes les écritures avant **lwsync** le font dans le cache L2 avant les écritures qui suivent.</span><span class="sxs-lookup"><span data-stu-id="9005b-291">It guarantees that all writes before **lwsync** make it to the L2 cache before any writes that follow.</span></span> <span data-ttu-id="9005b-292">Cela garantit également que toutes les lectures qui suivent **lwsync** n’obtiennent pas les données plus anciennes de L2 que les lectures précédentes.</span><span class="sxs-lookup"><span data-stu-id="9005b-292">It also guarantees that any reads that follow **lwsync** don't get older data from L2 than previous reads.</span></span> <span data-ttu-id="9005b-293">Le type de réorganisation qu’il n’empêche pas est une lecture anticipée d’une écriture vers une autre adresse.</span><span class="sxs-lookup"><span data-stu-id="9005b-293">The one type of reordering that it does not prevent is a read moving ahead of a write to a different address.</span></span> <span data-ttu-id="9005b-294">Par conséquent, **lwsync** applique l’ordonnancement de mémoire qui correspond à l’ordonnancement de mémoire par défaut sur les processeurs x86 et x64.</span><span class="sxs-lookup"><span data-stu-id="9005b-294">Thus, **lwsync** enforces memory ordering that matches the default memory ordering on x86 and x64 processors.</span></span> <span data-ttu-id="9005b-295">Pour obtenir un classement complet de la mémoire, l’instruction de synchronisation est plus coûteuse (également appelée synchronisation à haute densité), mais dans la plupart des cas, cela n’est pas obligatoire.</span><span class="sxs-lookup"><span data-stu-id="9005b-295">To get full memory ordering requires the more expensive sync instruction (also known as heavyweight sync), but in most cases, this is not required.</span></span> <span data-ttu-id="9005b-296">Les options de réorganisation de la mémoire sur Xbox 360 sont indiquées dans le tableau suivant.</span><span class="sxs-lookup"><span data-stu-id="9005b-296">The memory reordering options on Xbox 360 are shown in the following table.</span></span>



| <span data-ttu-id="9005b-297">Réorganisation de la Xbox 360</span><span class="sxs-lookup"><span data-stu-id="9005b-297">Xbox 360 Reordering</span></span>           | <span data-ttu-id="9005b-298">Aucune synchronisation</span><span class="sxs-lookup"><span data-stu-id="9005b-298">No sync</span></span> | <span data-ttu-id="9005b-299">lwsync</span><span class="sxs-lookup"><span data-stu-id="9005b-299">lwsync</span></span> | <span data-ttu-id="9005b-300">synchronisation</span><span class="sxs-lookup"><span data-stu-id="9005b-300">sync</span></span> |
|-------------------------------|---------|--------|------|
| <span data-ttu-id="9005b-301">Lectures anticipées</span><span class="sxs-lookup"><span data-stu-id="9005b-301">Reads moving ahead of reads</span></span>   | <span data-ttu-id="9005b-302">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-302">Yes</span></span>     | <span data-ttu-id="9005b-303">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-303">No</span></span>     | <span data-ttu-id="9005b-304">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-304">No</span></span>   |
| <span data-ttu-id="9005b-305">Les écritures se déplacent avant les écritures</span><span class="sxs-lookup"><span data-stu-id="9005b-305">Writes moving ahead of writes</span></span> | <span data-ttu-id="9005b-306">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-306">Yes</span></span>     | <span data-ttu-id="9005b-307">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-307">No</span></span>     | <span data-ttu-id="9005b-308">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-308">No</span></span>   |
| <span data-ttu-id="9005b-309">Les écritures se déplacent avant les lectures</span><span class="sxs-lookup"><span data-stu-id="9005b-309">Writes moving ahead of reads</span></span>  | <span data-ttu-id="9005b-310">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-310">Yes</span></span>     | <span data-ttu-id="9005b-311">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-311">No</span></span>     | <span data-ttu-id="9005b-312">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-312">No</span></span>   |
| <span data-ttu-id="9005b-313">Lectures anticipées des écritures</span><span class="sxs-lookup"><span data-stu-id="9005b-313">Reads moving ahead of writes</span></span>  | <span data-ttu-id="9005b-314">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-314">Yes</span></span>     | <span data-ttu-id="9005b-315">Oui</span><span class="sxs-lookup"><span data-stu-id="9005b-315">Yes</span></span>    | <span data-ttu-id="9005b-316">Non</span><span class="sxs-lookup"><span data-stu-id="9005b-316">No</span></span>   |



 

<span data-ttu-id="9005b-317">PowerPC possède également les instructions de synchronisation **iSync** et **EIEIO** (qui sont utilisées pour contrôler la réorganisation de la mémoire empêchant la mise en cache).</span><span class="sxs-lookup"><span data-stu-id="9005b-317">PowerPC also has the synchronization instructions **isync** and **eieio** (which is used to control reordering to caching-inhibited memory).</span></span> <span data-ttu-id="9005b-318">Ces instructions de synchronisation ne doivent pas être nécessaires à des fins de synchronisation normales.</span><span class="sxs-lookup"><span data-stu-id="9005b-318">These synchronization instructions should not be needed for normal synchronization purposes.</span></span>

<span data-ttu-id="9005b-319">Sur Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) est défini dans Winnt. h et vous donne une instruction de barrière de mémoire différente selon que vous compilez pour x86 ou x64.</span><span class="sxs-lookup"><span data-stu-id="9005b-319">On Windows, [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) is defined in Winnt.h and gives you a different memory barrier instruction depending on whether you are compiling for x86 or x64.</span></span> <span data-ttu-id="9005b-320">L’instruction de barrière de mémoire sert de barrière complète, empêchant toute réorganisation des lectures et des écritures sur le cloisonnement.</span><span class="sxs-lookup"><span data-stu-id="9005b-320">The memory barrier instruction serves as a full barrier, preventing all reordering of reads and writes across the barrier.</span></span> <span data-ttu-id="9005b-321">Par conséquent, **MemoryBarrier** sur Windows offre une garantie de réorganisation plus forte que sur la Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="9005b-321">Thus, **MemoryBarrier** on Windows gives a stronger reordering guarantee than it does on Xbox 360.</span></span>

<span data-ttu-id="9005b-322">Sur la Xbox 360 et sur de nombreux autres processeurs, il est possible d’empêcher l’utilisation de la réorganisation de la lecture par le processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-322">On Xbox 360, and on many other CPUs, there is one additional way that read-reordering by the CPU can be prevented.</span></span> <span data-ttu-id="9005b-323">Si vous lisez un pointeur, puis utilisez ce pointeur pour charger d’autres données, l’UC garantit que les lectures du pointeur ne sont pas plus anciennes que la lecture du pointeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-323">If you read a pointer and then use that pointer to load other data, the CPU guarantees that the reads off of the pointer are not older than the read of the pointer.</span></span> <span data-ttu-id="9005b-324">Si votre indicateur de verrouillage est un pointeur et que toutes les lectures de données partagées sont en dehors du pointeur, le [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) peut être omis, pour une légère économie de performances.</span><span class="sxs-lookup"><span data-stu-id="9005b-324">If your lock flag is a pointer and if all reads of shared data are off of the pointer, the [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) can be omitted, for a modest performance savings.</span></span>

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

<span data-ttu-id="9005b-325">L’instruction [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) empêche uniquement la réorganisation des lectures et des écritures dans la mémoire cache.</span><span class="sxs-lookup"><span data-stu-id="9005b-325">The [**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) instruction only prevents reordering of reads and writes to cacheable memory.</span></span> <span data-ttu-id="9005b-326">Si vous allouez de la mémoire en tant que PAGE \_ NoCache ou page \_ WRITECOMBINE, une technique courante pour les créateurs de pilote de périphérique et pour les développeurs de jeux sur Xbox 360, **MemoryBarrier** n’a aucun effet sur les accès à cette mémoire.</span><span class="sxs-lookup"><span data-stu-id="9005b-326">If you allocate memory as PAGE\_NOCACHE or PAGE\_WRITECOMBINE, a common technique for device driver authors and for game developers on Xbox 360, **MemoryBarrier** has no effect on accesses to this memory.</span></span> <span data-ttu-id="9005b-327">La plupart des développeurs n’ont pas besoin de synchroniser la mémoire qui ne peut pas être mise en cache.</span><span class="sxs-lookup"><span data-stu-id="9005b-327">Most developers don't need synchronization of non-cacheable memory.</span></span> <span data-ttu-id="9005b-328">La procédure n'entre pas dans le cadre de cet article.</span><span class="sxs-lookup"><span data-stu-id="9005b-328">That is beyond the scope of this article.</span></span>

## <a name="interlocked-functions-and-cpu-reordering"></a><span data-ttu-id="9005b-329">Fonctions verrouillées et réorganisation de l’UC</span><span class="sxs-lookup"><span data-stu-id="9005b-329">Interlocked Functions and CPU Reordering</span></span>

<span data-ttu-id="9005b-330">Parfois, la lecture ou l’écriture qui acquiert ou libère une ressource s’effectue à l’aide de l’une des fonctions **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="9005b-330">Sometimes the read or write that acquires or releases a resource is done using one of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="9005b-331">Sur Windows, cela simplifie les choses. étant donné que sur Windows, les fonctions **InterlockedXxx** sont toutes des barrières de mémoire saturée.</span><span class="sxs-lookup"><span data-stu-id="9005b-331">On Windows, this simplifies things; because on Windows, the **InterlockedXxx** functions are all full-memory barriers.</span></span> <span data-ttu-id="9005b-332">Ils disposent en fait d’une barrière de mémoire processeur à la fois avant et après, ce qui signifie qu’il s’agit d’une barrière d’accès en lecture ou d’écriture complète.</span><span class="sxs-lookup"><span data-stu-id="9005b-332">They effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.</span></span>

<span data-ttu-id="9005b-333">Sur Xbox 360, les fonctions **InterlockedXxx** ne contiennent pas de barrières de mémoire processeur.</span><span class="sxs-lookup"><span data-stu-id="9005b-333">On Xbox 360, the **InterlockedXxx** functions do not contain CPU memory barriers.</span></span> <span data-ttu-id="9005b-334">Elles empêchent la réorganisation des lectures et des écritures par le compilateur, mais pas la réorganisation de l’UC.</span><span class="sxs-lookup"><span data-stu-id="9005b-334">They prevent compiler reordering of reads and writes but not CPU reordering.</span></span> <span data-ttu-id="9005b-335">Par conséquent, dans la plupart des cas, lors de l’utilisation de fonctions **InterlockedXxx** sur Xbox 360, vous devez les précéder ou les suivre avec un **\_ \_ lwsync**, afin de leur donner une barrière d’acquisition en écriture ou de libération.</span><span class="sxs-lookup"><span data-stu-id="9005b-335">Therefore, in most cases when using **InterlockedXxx** functions on Xbox 360, you should precede or follow them with an **\_\_lwsync**, to make them a read-acquire or write-release barrier.</span></span> <span data-ttu-id="9005b-336">Pour plus de commodité et pour faciliter la lisibilité, il existe des versions d' **acquisition** et de **publication** de nombreuses fonctions **InterlockedXxx** .</span><span class="sxs-lookup"><span data-stu-id="9005b-336">For convenience and for easier readability, there are **Acquire** and **Release** versions of many of the **InterlockedXxx** functions.</span></span> <span data-ttu-id="9005b-337">Ils sont fournis avec une barrière de mémoire intégrée.</span><span class="sxs-lookup"><span data-stu-id="9005b-337">These come with a built-in memory barrier.</span></span> <span data-ttu-id="9005b-338">Par exemple, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) effectue un incrément de verrouillage suivi d’une barrière de mémoire **\_ \_ lwsync** pour fournir la fonctionnalité de lecture-acquisition complète.</span><span class="sxs-lookup"><span data-stu-id="9005b-338">For instance, [**InterlockedIncrementAcquire**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) does an interlocked increment followed by an **\_\_lwsync** memory barrier to give the full read-acquire functionality.</span></span>

<span data-ttu-id="9005b-339">Il est recommandé d’utiliser les versions **Acquire** et **Release** des fonctions **InterlockedXxx** (dont la plupart sont également disponibles sur Windows, sans aucune pénalité de performances) pour rendre votre intention plus évidente et pour faciliter l’obtention des instructions de barrière de mémoire à l’endroit approprié.</span><span class="sxs-lookup"><span data-stu-id="9005b-339">It is recommended that you use the **Acquire** and **Release** versions of the **InterlockedXxx** functions (most of which are available on Windows as well, with no performance penalty) to make your intent more obvious and to make it easier to get the memory barrier instructions in the correct place.</span></span> <span data-ttu-id="9005b-340">Toute utilisation de **InterlockedXxx** sur Xbox 360 sans barrière de mémoire doit être examinée très attentivement, car il s’agit souvent d’un bogue.</span><span class="sxs-lookup"><span data-stu-id="9005b-340">Any use of **InterlockedXxx** on Xbox 360 without a memory barrier should be examined very carefully, because it is often a bug.</span></span>

<span data-ttu-id="9005b-341">Cet exemple montre comment un thread peut passer des tâches ou d’autres données à un autre thread à l’aide des versions **Acquire** et **Release** des fonctions **InterlockedXxxSList** .</span><span class="sxs-lookup"><span data-stu-id="9005b-341">This sample demonstrates how one thread can pass tasks or other data to another thread using the **Acquire** and **Release** versions of the **InterlockedXxxSList** functions.</span></span> <span data-ttu-id="9005b-342">Les fonctions **InterlockedXxxSList** sont une famille de fonctions permettant de conserver une liste liée de façon unique et partagée sans verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-342">The **InterlockedXxxSList** functions are a family of functions for maintaining a shared singly linked list without a lock.</span></span> <span data-ttu-id="9005b-343">Notez que les variantes d' **acquisition** et de **libération** de ces fonctions ne sont pas disponibles sur Windows, mais les versions régulières de ces fonctions constituent une barrière de mémoire complète sur Windows.</span><span class="sxs-lookup"><span data-stu-id="9005b-343">Note that **Acquire** and **Release** variants of these functions are not available on Windows, but the regular versions of these functions are a full memory barrier on Windows.</span></span>

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a><span data-ttu-id="9005b-344">Variables volatiles et réorganisation</span><span class="sxs-lookup"><span data-stu-id="9005b-344">Volatile Variables and Reordering</span></span>

<span data-ttu-id="9005b-345">La norme C++ indique que les lectures de variables volatiles ne peuvent pas être mises en cache, que les écritures volatiles ne peuvent pas être retardées, et que les lectures et écritures volatiles ne peuvent pas être déplacées au-delà.</span><span class="sxs-lookup"><span data-stu-id="9005b-345">The C++ Standard says that reads of volatile variables cannot be cached, volatile writes cannot be delayed, and volatile reads and writes cannot be moved past each other.</span></span> <span data-ttu-id="9005b-346">Cela suffit pour la communication avec les périphériques matériels, qui est l’objectif du mot clé volatile dans la norme C++.</span><span class="sxs-lookup"><span data-stu-id="9005b-346">This is sufficient for communicating with hardware devices, which is the purpose of the volatile keyword in the C++ Standard.</span></span>

<span data-ttu-id="9005b-347">Toutefois, les garanties de la norme ne sont pas suffisantes pour l’utilisation de volatile pour le Multi-Threading.</span><span class="sxs-lookup"><span data-stu-id="9005b-347">However, the guarantees of the standard are not sufficient for using volatile for multi-threading.</span></span> <span data-ttu-id="9005b-348">La norme C++ n’empêche pas le compilateur de réorganiser les lectures et écritures non volatiles relatives aux lectures et écritures volatiles, et n’indique rien sur la prévention de la réorganisation de l’UC.</span><span class="sxs-lookup"><span data-stu-id="9005b-348">The C++ Standard does not stop the compiler from reordering non-volatile reads and writes relative to volatile reads and writes, and it says nothing about preventing CPU reordering.</span></span>

<span data-ttu-id="9005b-349">Visual C++ 2005 va au-delà du C++ standard pour définir la sémantique de Multi-Threading pour l’accès aux variables volatiles.</span><span class="sxs-lookup"><span data-stu-id="9005b-349">Visual C++ 2005 goes beyond standard C++ to define multi-threading-friendly semantics for volatile variable access.</span></span> <span data-ttu-id="9005b-350">À compter de Visual C++ 2005, les lectures à partir des variables volatiles sont définies pour avoir une sémantique d’acquisition en lecture, et les écritures dans des variables volatiles sont définies pour avoir une sémantique en écriture.</span><span class="sxs-lookup"><span data-stu-id="9005b-350">Starting with Visual C++ 2005, reads from volatile variables are defined to have read-acquire semantics, and writes to volatile variables are defined to have write-release semantics.</span></span> <span data-ttu-id="9005b-351">Cela signifie que le compilateur ne réorganise pas les lectures et les écritures qui se sont passées, et sous Windows, il s’assure que le processeur ne le fait pas non plus.</span><span class="sxs-lookup"><span data-stu-id="9005b-351">This means that the compiler will not rearrange any reads and writes past them, and on Windows it will ensure that the CPU does not do so either.</span></span>

<span data-ttu-id="9005b-352">Il est important de comprendre que ces nouvelles garanties s’appliquent uniquement à Visual C++ 2005 et aux futures versions de Visual C++.</span><span class="sxs-lookup"><span data-stu-id="9005b-352">It is important to understand that these new guarantees only apply to Visual C++ 2005 and future versions of Visual C++.</span></span> <span data-ttu-id="9005b-353">Les compilateurs d’autres fournisseurs implémentent généralement une sémantique différente, sans les garanties supplémentaires de Visual C++ 2005.</span><span class="sxs-lookup"><span data-stu-id="9005b-353">Compilers from other vendors will generally implement different semantics, without the extra guarantees of Visual C++ 2005.</span></span> <span data-ttu-id="9005b-354">En outre, sur Xbox 360, le compilateur n’insère aucune instruction pour empêcher le processeur de réorganiser les lectures et les écritures.</span><span class="sxs-lookup"><span data-stu-id="9005b-354">Also, on Xbox 360, the compiler does not insert any instructions to prevent the CPU from reordering reads and writes.</span></span>

## <a name="example-of-a-lock-free-data-pipe"></a><span data-ttu-id="9005b-355">Exemple de canal de données Lock-Free</span><span class="sxs-lookup"><span data-stu-id="9005b-355">Example of a Lock-Free Data Pipe</span></span>

<span data-ttu-id="9005b-356">Un canal est une construction qui permet à un ou plusieurs threads d’écrire des données qui sont ensuite lues par d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="9005b-356">A pipe is a construct that lets one or more threads write data that is then read by other threads.</span></span> <span data-ttu-id="9005b-357">Une version verrouillée d’un canal peut être un moyen élégant et efficace de passer le travail d’un thread à un thread.</span><span class="sxs-lookup"><span data-stu-id="9005b-357">A lockless version of a pipe can be an elegant and efficient way to pass work from thread to thread.</span></span> <span data-ttu-id="9005b-358">Le kit de développement logiciel (SDK) DirectX fournit des **LockFreePipe**, un seul lecteur et un canal de verrouillage à un seul enregistreur, qui est disponible dans DXUTLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="9005b-358">The DirectX SDK supplies **LockFreePipe**, a single-reader, single-writer lockless pipe that is available in DXUTLockFreePipe.h.</span></span> <span data-ttu-id="9005b-359">Le même **LockFreePipe** est disponible dans le kit de développement logiciel (SDK) Xbox 360 dans AtgLockFreePipe. h.</span><span class="sxs-lookup"><span data-stu-id="9005b-359">The same **LockFreePipe** is available in the Xbox 360 SDK in AtgLockFreePipe.h.</span></span>

<span data-ttu-id="9005b-360">**LockFreePipe** peut être utilisé lorsque deux threads ont une relation producteur/consommateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-360">**LockFreePipe** can be used when two threads have a producer/consumer relationship.</span></span> <span data-ttu-id="9005b-361">Le thread producteur peut écrire des données dans le canal pour que le thread de consommateur soit traité à une date ultérieure, sans jamais se bloquer.</span><span class="sxs-lookup"><span data-stu-id="9005b-361">The producer thread can write data to the pipe for the consumer thread to process at a later date, without ever blocking.</span></span> <span data-ttu-id="9005b-362">Si le canal est rempli, les écritures échouent et le thread producteur devra réessayer plus tard, mais cela ne se produit que si le thread producteur est en avance.</span><span class="sxs-lookup"><span data-stu-id="9005b-362">If the pipe fills up, writes fail, and the producer thread will have to try again later, but this would only happen if the producer thread is ahead.</span></span> <span data-ttu-id="9005b-363">Si le canal est vidé, les lectures échouent et le thread de consommateur devra réessayer plus tard, mais cela ne se produit que si le thread de consommateur n’a pas de travail à effectuer.</span><span class="sxs-lookup"><span data-stu-id="9005b-363">If the pipe empties, reads fail, and the consumer thread will have to try again later, but this would only happen if there is no work for the consumer thread to do.</span></span> <span data-ttu-id="9005b-364">Si les deux threads sont bien équilibrés et que le canal est suffisamment grand, le canal les permet de passer facilement des données sans aucun retard ni bloc.</span><span class="sxs-lookup"><span data-stu-id="9005b-364">If the two threads are well-balanced, and the pipe is big enough, the pipe lets them smoothly pass data along with no delays or blocks.</span></span>

## <a name="xbox-360-performance"></a><span data-ttu-id="9005b-365">Performances de la Xbox 360</span><span class="sxs-lookup"><span data-stu-id="9005b-365">Xbox 360 Performance</span></span>

<span data-ttu-id="9005b-366">Les performances des instructions de synchronisation et des fonctions sur Xbox 360 varient en fonction de l’autre code en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="9005b-366">The performance of synchronization instructions and functions on Xbox 360 will vary depending on what other code is running.</span></span> <span data-ttu-id="9005b-367">L’acquisition de verrous prendra plus de temps si un autre thread possède actuellement le verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-367">Acquiring locks will take much longer if another thread currently owns the lock.</span></span> <span data-ttu-id="9005b-368">Les opérations de section [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) et critique prendront plus de temps si d’autres threads écrivent sur la même ligne de cache.</span><span class="sxs-lookup"><span data-stu-id="9005b-368">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) and critical section operations will take much longer if other threads are writing to the same cache line.</span></span> <span data-ttu-id="9005b-369">Le contenu des files d’attente du magasin peut également avoir une incidence sur les performances.</span><span class="sxs-lookup"><span data-stu-id="9005b-369">The contents of the store queues can also affect performance.</span></span> <span data-ttu-id="9005b-370">Par conséquent, tous ces nombres sont simplement des approximations, générés à partir de tests très simples :</span><span class="sxs-lookup"><span data-stu-id="9005b-370">Therefore, all of these numbers are just approximations, generated from very simple tests:</span></span>

-   <span data-ttu-id="9005b-371">**lwsync** a été mesuré comme utilisant des cycles de 33-48.</span><span class="sxs-lookup"><span data-stu-id="9005b-371">**lwsync** was measured as taking 33-48 cycles.</span></span>
-   <span data-ttu-id="9005b-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) a été mesuré comme utilisant des cycles de 225-260.</span><span class="sxs-lookup"><span data-stu-id="9005b-372">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 225-260 cycles.</span></span>
-   <span data-ttu-id="9005b-373">L’acquisition ou la libération d’une section critique a été mesurée en prenant environ 345 cycles.</span><span class="sxs-lookup"><span data-stu-id="9005b-373">Acquiring or releasing a critical section was measured as taking about 345 cycles.</span></span>
-   <span data-ttu-id="9005b-374">L’acquisition ou la libération d’un mutex a été mesurée comme s’effectuant environ 2350 cycles.</span><span class="sxs-lookup"><span data-stu-id="9005b-374">Acquiring or releasing a mutex was measured as taking about 2350 cycles.</span></span>

## <a name="windows-performance"></a><span data-ttu-id="9005b-375">Performances Windows</span><span class="sxs-lookup"><span data-stu-id="9005b-375">Windows Performance</span></span>

<span data-ttu-id="9005b-376">Les performances des instructions de synchronisation et des fonctions sur Windows varient considérablement en fonction du type et de la configuration du processeur, et de la nature du code en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="9005b-376">The performance of synchronization instructions and functions on Windows vary widely depending on the processor type and configuration, and on what other code is running.</span></span> <span data-ttu-id="9005b-377">Les systèmes multicœurs et multisockets prennent souvent plus de temps pour exécuter des instructions de synchronisation et l’acquisition de verrous prend plus de temps si un autre thread possède actuellement le verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-377">Multi-core and multi-socket systems often take longer to execute synchronizing instructions, and acquiring locks take much longer if another thread currently owns the lock.</span></span>

<span data-ttu-id="9005b-378">Toutefois, même certaines mesures générées à partir de tests très simples sont utiles :</span><span class="sxs-lookup"><span data-stu-id="9005b-378">However, even some measurements generated from very simple tests are helpful:</span></span>

-   <span data-ttu-id="9005b-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) a été mesuré comme utilisant des cycles de 20-90.</span><span class="sxs-lookup"><span data-stu-id="9005b-379">[**MemoryBarrier**](/windows/win32/api/winnt/nf-winnt-memorybarrier) was measured as taking 20-90 cycles.</span></span>
-   <span data-ttu-id="9005b-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) a été mesuré comme utilisant des cycles de 36-90.</span><span class="sxs-lookup"><span data-stu-id="9005b-380">[**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) was measured as taking 36-90 cycles.</span></span>
-   <span data-ttu-id="9005b-381">L’acquisition ou la libération d’une section critique a été mesurée en prenant 40-100 cycles.</span><span class="sxs-lookup"><span data-stu-id="9005b-381">Acquiring or releasing a critical section was measured as taking 40-100 cycles.</span></span>
-   <span data-ttu-id="9005b-382">L’acquisition ou la libération d’un mutex a été mesurée comme s’effectuant environ 750-2500 cycles.</span><span class="sxs-lookup"><span data-stu-id="9005b-382">Acquiring or releasing a mutex was measured as taking about 750-2500 cycles.</span></span>

<span data-ttu-id="9005b-383">Ces tests ont été effectués sur Windows XP sur une gamme de processeurs différents.</span><span class="sxs-lookup"><span data-stu-id="9005b-383">These tests were done on Windows XP on a range of different processors.</span></span> <span data-ttu-id="9005b-384">Les courtes périodes étaient sur un ordinateur monoprocesseur, et plus longtemps sur un ordinateur multiprocesseur.</span><span class="sxs-lookup"><span data-stu-id="9005b-384">The short times were on a single-processor machine, and the longer times were on a multi-processor machine.</span></span>

<span data-ttu-id="9005b-385">Bien que l’acquisition et la libération de verrous soient plus coûteuses que l’utilisation de la programmation sans verrou, il est même préférable de partager les données moins fréquemment, ce qui évite le coût.</span><span class="sxs-lookup"><span data-stu-id="9005b-385">While acquiring and releasing locks is more expensive than using lockless programming, it is even better to share data less frequently, thus avoiding the cost altogether.</span></span>

## <a name="performance-thoughts"></a><span data-ttu-id="9005b-386">Réflexions sur les performances</span><span class="sxs-lookup"><span data-stu-id="9005b-386">Performance Thoughts</span></span>

<span data-ttu-id="9005b-387">L’acquisition ou la libération d’une section critique se compose d’une barrière de mémoire, d’une opération **InterlockedXxx** et d’une vérification supplémentaire pour gérer la récursivité et pour revenir à un mutex, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9005b-387">Acquiring or releasing a critical section consists of a memory barrier, an **InterlockedXxx** operation, and some extra checking to handle recursion and to fall back to a mutex, if necessary.</span></span> <span data-ttu-id="9005b-388">Vous devez faire attention à l’implémentation de votre propre section critique, car le fait de tourner dans une boucle en attendant la libération d’un verrou, sans revenir à un mutex, peut gaspiller des performances considérables.</span><span class="sxs-lookup"><span data-stu-id="9005b-388">You should be wary of implementing your own critical section, because spinning in a loop waiting for a lock to be free, without falling back to a mutex, can waste considerable performance.</span></span> <span data-ttu-id="9005b-389">Pour les sections critiques qui sont fortement sollicitées, mais qui ne sont pas détenues pendant longtemps, vous devez envisager d’utiliser [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) afin que le système d’exploitation tourne pendant un certain temps, en attendant que la section critique soit disponible au lieu d’être immédiatement différée à un mutex si la section critique est propriétaire lorsque vous essayez de l’acquérir.</span><span class="sxs-lookup"><span data-stu-id="9005b-389">For critical sections that are heavily contended but not held for long, you should consider using [**InitializeCriticalSectionAndSpinCount**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) so that the operating system will spin for a while waiting for the critical section to be available rather than immediately deferring to a mutex if the critical section is owned when you try to acquire it.</span></span> <span data-ttu-id="9005b-390">Afin d’identifier les sections critiques qui peuvent tirer parti d’un comptage de spins, il est nécessaire de mesurer la longueur de l’attente classique pour un verrou particulier.</span><span class="sxs-lookup"><span data-stu-id="9005b-390">In order to identify critical sections that can benefit from a spin count, it is necessary to measure the length of the typical wait for a particular lock.</span></span>

<span data-ttu-id="9005b-391">Si un segment de mémoire partagé est utilisé pour les allocations de mémoire (comportement par défaut), chaque allocation de mémoire et la version libre impliquent l’acquisition d’un verrou.</span><span class="sxs-lookup"><span data-stu-id="9005b-391">If a shared heap is used for memory allocations—the default behavior—every memory allocation and free involves acquiring a lock.</span></span> <span data-ttu-id="9005b-392">À mesure que le nombre de threads et le nombre d’allocations augmente, les niveaux de performances sont désactivés et la diminution finit.</span><span class="sxs-lookup"><span data-stu-id="9005b-392">As the number of threads and the number of allocations increases, performance levels off, and eventually starts to decrease.</span></span> <span data-ttu-id="9005b-393">L’utilisation de tas par thread, ou la réduction du nombre d’allocations, peut éviter ce goulot d’étranglement de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="9005b-393">Using per-thread heaps, or reducing the number of allocations, can avoid this locking bottleneck.</span></span>

<span data-ttu-id="9005b-394">Si un thread génère des données et qu’un autre thread consomme des données, il se peut qu’elles finissent par partager des données fréquemment.</span><span class="sxs-lookup"><span data-stu-id="9005b-394">If one thread is generating data and another thread is consuming data, they may end up sharing data frequently.</span></span> <span data-ttu-id="9005b-395">Cela peut se produire si un thread charge des ressources et qu’un autre thread effectue le rendu de la scène.</span><span class="sxs-lookup"><span data-stu-id="9005b-395">This can happen if one thread is loading resources and another thread is rendering the scene.</span></span> <span data-ttu-id="9005b-396">Si le thread de rendu fait référence aux données partagées à chaque appel de dessin, la surcharge de verrouillage est élevée.</span><span class="sxs-lookup"><span data-stu-id="9005b-396">If the rendering thread references the shared data on every draw call, the locking overhead will be high.</span></span> <span data-ttu-id="9005b-397">De meilleures performances peuvent être obtenues si chaque thread a des structures de données privées qui sont ensuite synchronisées une fois par Frame ou moins.</span><span class="sxs-lookup"><span data-stu-id="9005b-397">Much better performance can be realized if each thread has private data structures which are then synchronized once per frame or less.</span></span>

<span data-ttu-id="9005b-398">Il n’est pas garanti que les algorithmes sans verrou soient plus rapides que les algorithmes qui utilisent des verrous.</span><span class="sxs-lookup"><span data-stu-id="9005b-398">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</span></span> <span data-ttu-id="9005b-399">Vous devez vérifier si les verrous vous posent réellement des problèmes avant d’essayer de les éviter, et que vous devez effectuer une mesure pour voir si votre code sans verrouillage améliore réellement les performances.</span><span class="sxs-lookup"><span data-stu-id="9005b-399">You should check to see if locks are actually causing you problems before trying to avoid them, and you should measure to see if your lockless code actually improves performance.</span></span>

## <a name="platform-differences-summary"></a><span data-ttu-id="9005b-400">Résumé des différences de plateforme</span><span class="sxs-lookup"><span data-stu-id="9005b-400">Platform Differences Summary</span></span>

-   <span data-ttu-id="9005b-401">Les fonctions **InterlockedXxx** empêchent la réorganisation du processeur en lecture/écriture sur Windows, mais pas sur la Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="9005b-401">**InterlockedXxx** functions prevent CPU read/write reordering on Windows, but not on Xbox 360.</span></span>
-   <span data-ttu-id="9005b-402">La lecture et l’écriture de variables volatiles à l’aide de Visual Studio C++ 2005 empêche la réorganisation de la lecture/écriture de l’UC sur Windows, mais sur Xbox 360, elle empêche uniquement la réorganisation en lecture/écriture du compilateur.</span><span class="sxs-lookup"><span data-stu-id="9005b-402">Reading and writing of volatile variables using Visual Studio C++ 2005 prevents CPU read/write reordering on Windows, but on Xbox 360, it only prevents compiler read/write reordering.</span></span>
-   <span data-ttu-id="9005b-403">Les écritures sont réorganisées sur Xbox 360, mais pas sur x86 ou x64.</span><span class="sxs-lookup"><span data-stu-id="9005b-403">Writes are reordered on Xbox 360, but not on x86 or x64.</span></span>
-   <span data-ttu-id="9005b-404">Les lectures sont réorganisées sur Xbox 360, mais sur x86 ou x64, elles sont réorganisées uniquement par rapport aux écritures, et uniquement si les lectures et les écritures ciblent des emplacements différents.</span><span class="sxs-lookup"><span data-stu-id="9005b-404">Reads are reordered on Xbox 360, but on x86 or x64 they are only reordered relative to writes, and only if the reads and writes target different locations.</span></span>

## <a name="recommendations"></a><span data-ttu-id="9005b-405">Recommandations</span><span class="sxs-lookup"><span data-stu-id="9005b-405">Recommendations</span></span>

-   <span data-ttu-id="9005b-406">Utilisez des verrous lorsque cela est possible, car ils sont plus faciles à utiliser correctement.</span><span class="sxs-lookup"><span data-stu-id="9005b-406">Use locks when possible because they are easier to use correctly.</span></span>
-   <span data-ttu-id="9005b-407">Évitez les verrouillages trop fréquents, afin que les coûts de verrouillage ne deviennent pas significatifs.</span><span class="sxs-lookup"><span data-stu-id="9005b-407">Avoid locking too frequently, so that locking costs do not become significant.</span></span>
-   <span data-ttu-id="9005b-408">Évitez de maintenir des verrous trop longs, afin d’éviter les blocages longs.</span><span class="sxs-lookup"><span data-stu-id="9005b-408">Avoid holding locks for too long, in order to avoid long stalls.</span></span>
-   <span data-ttu-id="9005b-409">Utilisez la programmation sans blocage, le cas échéant, mais assurez-vous que les gains justifient la complexité.</span><span class="sxs-lookup"><span data-stu-id="9005b-409">Use lockless programming when appropriate, but be sure that the gains justify the complexity.</span></span>
-   <span data-ttu-id="9005b-410">Utilisez la programmation en mode de verrouillage ou les verrous de spin dans les situations où d’autres verrous sont interdits, par exemple lors du partage de données entre des appels de procédure différés et du code normal.</span><span class="sxs-lookup"><span data-stu-id="9005b-410">Use lockless programming or spin locks in situations where other locks are prohibited, such as when sharing data between deferred procedure calls and normal code.</span></span>
-   <span data-ttu-id="9005b-411">Utilisez uniquement des algorithmes de programmation de verrouillage standard qui ont été prouvés comme corrects.</span><span class="sxs-lookup"><span data-stu-id="9005b-411">Only use standard lockless programming algorithms that have been proven to be correct.</span></span>
-   <span data-ttu-id="9005b-412">Lors de la programmation sans verrouillage, veillez à utiliser des variables d’indicateur volatiles et des instructions de barrière de mémoire en fonction des besoins.</span><span class="sxs-lookup"><span data-stu-id="9005b-412">When doing lockless programming, be sure to use volatile flag variables and memory barrier instructions as needed.</span></span>
-   <span data-ttu-id="9005b-413">Lorsque vous utilisez **InterlockedXxx** sur Xbox 360, utilisez les variantes **Acquire** et **Release** .</span><span class="sxs-lookup"><span data-stu-id="9005b-413">When using **InterlockedXxx** on Xbox 360, use the **Acquire** and **Release** variants.</span></span>

## <a name="references"></a><span data-ttu-id="9005b-414">Références</span><span class="sxs-lookup"><span data-stu-id="9005b-414">References</span></span>

-   <span data-ttu-id="9005b-415">Bibliothèque MSDN.</span><span class="sxs-lookup"><span data-stu-id="9005b-415">MSDN Library.</span></span> <span data-ttu-id="9005b-416">«[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx). »</span><span class="sxs-lookup"><span data-stu-id="9005b-416">"[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)."</span></span> <span data-ttu-id="9005b-417">Référence du langage C++.</span><span class="sxs-lookup"><span data-stu-id="9005b-417">C++ Language Reference.</span></span>
-   <span data-ttu-id="9005b-418">Vance Morrison.</span><span class="sxs-lookup"><span data-stu-id="9005b-418">Vance Morrison.</span></span> <span data-ttu-id="9005b-419">«[Comprendre l’impact des techniques de Low-Lock dans les applications multithread](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)».</span><span class="sxs-lookup"><span data-stu-id="9005b-419">"[Understand the Impact of Low-Lock Techniques in Multithreaded Apps](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)."</span></span> <span data-ttu-id="9005b-420">MSDN Magazine, octobre 2005.</span><span class="sxs-lookup"><span data-stu-id="9005b-420">MSDN Magazine, October 2005.</span></span>
-   <span data-ttu-id="9005b-421">Lyons, Michael.</span><span class="sxs-lookup"><span data-stu-id="9005b-421">Lyons, Michael.</span></span> <span data-ttu-id="9005b-422">«[Modèle de stockage PowerPC et programmation Aix](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)».</span><span class="sxs-lookup"><span data-stu-id="9005b-422">"[PowerPC Storage Model and AIX Programming](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)."</span></span> <span data-ttu-id="9005b-423">IBM developerWorks, 16 novembre 2005.</span><span class="sxs-lookup"><span data-stu-id="9005b-423">IBM developerWorks, 16 Nov 2005.</span></span>
-   <span data-ttu-id="9005b-424">McKenney, Paul E». «[classement de mémoire dans les microprocesseurs modernes, partie II](https://www.linuxjournal.com/article/8212)».</span><span class="sxs-lookup"><span data-stu-id="9005b-424">McKenney, Paul E. "[Memory Ordering in Modern Microprocessors, Part II](https://www.linuxjournal.com/article/8212)."</span></span> <span data-ttu-id="9005b-425">Journal Linux, 2005 septembre.</span><span class="sxs-lookup"><span data-stu-id="9005b-425">Linux Journal, September 2005.</span></span> <span data-ttu-id="9005b-426">\[Cet article contient des informations détaillées sur x86.\]</span><span class="sxs-lookup"><span data-stu-id="9005b-426">\[This article has some x86 details.\]</span></span>
-   <span data-ttu-id="9005b-427">Intel Corporation.</span><span class="sxs-lookup"><span data-stu-id="9005b-427">Intel Corporation.</span></span> <span data-ttu-id="9005b-428">«[Commande de mémoire d’architecture Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf). »</span><span class="sxs-lookup"><span data-stu-id="9005b-428">"[Intel® 64 Architecture Memory Ordering](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)."</span></span> <span data-ttu-id="9005b-429">2007 août.</span><span class="sxs-lookup"><span data-stu-id="9005b-429">August 2007.</span></span> <span data-ttu-id="9005b-430">\[S’applique aux processeurs IA-32 et Intel 64.\]</span><span class="sxs-lookup"><span data-stu-id="9005b-430">\[Applies to both IA-32 and Intel 64 processors.\]</span></span>
-   <span data-ttu-id="9005b-431">Niebler, Eric.</span><span class="sxs-lookup"><span data-stu-id="9005b-431">Niebler, Eric.</span></span> <span data-ttu-id="9005b-432">«[Rapport de voyage : réunion ad hoc sur les threads en C++](https://www.artima.com/cppsource/threads_meeting.html)».</span><span class="sxs-lookup"><span data-stu-id="9005b-432">"[Trip Report: Ad-Hoc Meeting on Threads in C++](https://www.artima.com/cppsource/threads_meeting.html)."</span></span> <span data-ttu-id="9005b-433">Source C++, 17 octobre 2006.</span><span class="sxs-lookup"><span data-stu-id="9005b-433">The C++ Source, 17 Oct 2006.</span></span>
-   <span data-ttu-id="9005b-434">Hart, Thomas E. 2006.</span><span class="sxs-lookup"><span data-stu-id="9005b-434">Hart, Thomas E. 2006.</span></span> <span data-ttu-id="9005b-435">«[Création d’une synchronisation en toute simplicité rapide : implications sur les performances de la récupération de la mémoire](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)».</span><span class="sxs-lookup"><span data-stu-id="9005b-435">"[Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)."</span></span> <span data-ttu-id="9005b-436">Procédure du Congrès international de traitement parallèle et distribué 2006 (IPDPS 2006), île Rhodes, Grèce, avril 2006.</span><span class="sxs-lookup"><span data-stu-id="9005b-436">Proceedings of the 2006 International Parallel and Distributed Processing Symposium (IPDPS 2006), Rhodes Island, Greece, April 2006.</span></span>

 

 