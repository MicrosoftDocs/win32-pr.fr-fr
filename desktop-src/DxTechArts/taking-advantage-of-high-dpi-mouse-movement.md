---
title: Tirer parti du High-Definition mouvement de la souris
description: Cet article se concentre sur la meilleure façon d’optimiser les performances de l’entrée de souris haute définition dans un jeu comme un tir de première personne.
ms.assetid: 0138a248-e8e0-a392-564e-7a9229b94b56
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7ebe2abd9487d95b8fe12aa3c6938e21d72d8e2f
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104382338"
---
# <a name="taking-advantage-of-high-definition-mouse-movement"></a><span data-ttu-id="83d75-103">Tirer parti du High-Definition mouvement de la souris</span><span class="sxs-lookup"><span data-stu-id="83d75-103">Taking Advantage of High-Definition Mouse Movement</span></span>

<span data-ttu-id="83d75-104">Une souris d’ordinateur standard retourne des données à 400 points par pouce (DPI), tandis qu’une souris haute définition génère des données à 800 ppp ou plus.</span><span class="sxs-lookup"><span data-stu-id="83d75-104">A standard computer mouse returns data at 400 dots per inch (DPI), whereas a high-definition mouse generates data at 800 DPI or greater.</span></span> <span data-ttu-id="83d75-105">Cela rend l’entrée d’une souris de haute définition beaucoup plus précise que celle d’une souris standard.</span><span class="sxs-lookup"><span data-stu-id="83d75-105">This makes input from a high-definition mouse much more precise than that from a standard mouse.</span></span> <span data-ttu-id="83d75-106">Toutefois, les données haute définition ne peuvent pas être obtenues par le biais des messages de la souris inversée WM standard \_ .</span><span class="sxs-lookup"><span data-stu-id="83d75-106">However, high-definition data cannot be obtained through the standard WM\_MOUSEMOVE messages.</span></span> <span data-ttu-id="83d75-107">En général, les jeux tirent parti des périphériques de souris haute définition, mais les jeux qui obtiennent des données de souris à l’aide de WM \_ MOUSEMOVE ne peuvent pas accéder à la résolution complète et non filtrée de la souris.</span><span class="sxs-lookup"><span data-stu-id="83d75-107">In general, games will benefit from high-definition mouse devices but games that obtain mouse data using just WM\_MOUSEMOVE won't be able to access the full, unfiltered resolution of the mouse.</span></span>

<span data-ttu-id="83d75-108">Plusieurs sociétés fabriquent des périphériques de souris haute définition, tels que Microsoft et Logitech.</span><span class="sxs-lookup"><span data-stu-id="83d75-108">A number of companies are manufacturing high-definition mouse devices, such as Microsoft and Logitech.</span></span> <span data-ttu-id="83d75-109">Avec la popularité croissante des périphériques de souris à haute résolution, il est important que les développeurs sachent comment utiliser les informations générées par ces appareils de manière optimale.</span><span class="sxs-lookup"><span data-stu-id="83d75-109">With the increasing popularity of high-resolution mouse devices, it is important that developers understand how to use the information generated by these devices optimally.</span></span> <span data-ttu-id="83d75-110">Cet article se concentre sur la meilleure façon d’optimiser les performances de l’entrée de souris haute définition dans un jeu comme un tir de première personne.</span><span class="sxs-lookup"><span data-stu-id="83d75-110">This article focuses on the best way to optimize the performance of high-definition mouse input in a game like a first-person shooter.</span></span>

## <a name="retrieving-mouse-movement-data"></a><span data-ttu-id="83d75-111">Récupération des données de mouvement de la souris</span><span class="sxs-lookup"><span data-stu-id="83d75-111">Retrieving Mouse Movement Data</span></span>

<span data-ttu-id="83d75-112">Voici les trois principales méthodes pour récupérer des données de souris :</span><span class="sxs-lookup"><span data-stu-id="83d75-112">Here are the three primary methods to retrieve mouse data:</span></span>

-   [<span data-ttu-id="83d75-113">WM \_ MOUSEMOVE</span><span class="sxs-lookup"><span data-stu-id="83d75-113">WM\_MOUSEMOVE</span></span>](/windows)
-   [<span data-ttu-id="83d75-114">\_entrée WM</span><span class="sxs-lookup"><span data-stu-id="83d75-114">WM\_INPUT</span></span>](/windows)
-   [<span data-ttu-id="83d75-115">DirectInput</span><span class="sxs-lookup"><span data-stu-id="83d75-115">DirectInput</span></span>](#directinput)

<span data-ttu-id="83d75-116">Chaque méthode présente des avantages et des inconvénients, en fonction de la façon dont les données sont utilisées.</span><span class="sxs-lookup"><span data-stu-id="83d75-116">There are advantages and disadvantages to each method, depending on how the data will be used.</span></span>

### <a name="wm_mousemove"></a><span data-ttu-id="83d75-117">WM \_ MOUSEMOVE</span><span class="sxs-lookup"><span data-stu-id="83d75-117">WM\_MOUSEMOVE</span></span>

<span data-ttu-id="83d75-118">La méthode la plus simple pour lire les données de mouvement de la souris consiste à utiliser des \_ messages de désouris WM.</span><span class="sxs-lookup"><span data-stu-id="83d75-118">The simplest method of reading mouse movement data is through WM\_MOUSEMOVE messages.</span></span> <span data-ttu-id="83d75-119">L’exemple suivant montre comment lire les données de mouvement de la souris à partir du \_ message WM MOUSEMOVE :</span><span class="sxs-lookup"><span data-stu-id="83d75-119">The following is an example of how to read mouse movement data from the WM\_MOUSEMOVE message:</span></span>

```cpp
case WM_MOUSEMOVE:
{
    int xPosAbsolute = GET_X_PARAM(lParam); 
    int yPosAbsolute = GET_Y_PARAM(lParam);
    // ...
    break;
}
```

<span data-ttu-id="83d75-120">Le principal inconvénient des données de WM \_ MOUSEMOVE est qu’elles sont limitées à la résolution d’écran.</span><span class="sxs-lookup"><span data-stu-id="83d75-120">The primary disadvantage to data from WM\_MOUSEMOVE is that it is limited to the screen resolution.</span></span> <span data-ttu-id="83d75-121">Cela signifie que si vous déplacez légèrement la souris, mais pas assez pour faire passer le pointeur au pixel suivant, aucun \_ message WM MOUSEMOVE n’est généré.</span><span class="sxs-lookup"><span data-stu-id="83d75-121">This means that if you move the mouse slightly — but not enough to cause the pointer to move to the next pixel — then no WM\_MOUSEMOVE message is generated.</span></span> <span data-ttu-id="83d75-122">Par conséquent, l’utilisation de cette méthode pour lire le mouvement de la souris nie les avantages de l’entrée haute définition.</span><span class="sxs-lookup"><span data-stu-id="83d75-122">So, using this method to read mouse movement negates the benefits of high-definition input.</span></span>

<span data-ttu-id="83d75-123">L’avantage de WM \_ MOUSEMOVE, cependant, est que Windows applique l’accélération de pointeur (également appelée « balistiques ») aux données de souris brutes, ce qui fait que le pointeur de la souris se comporte comme les attentes des clients.</span><span class="sxs-lookup"><span data-stu-id="83d75-123">The advantage to WM\_MOUSEMOVE, however, is that Windows applies pointer acceleration (also known as ballistics) to the raw mouse data, which makes the mouse pointer behave as customers expect.</span></span> <span data-ttu-id="83d75-124">Il fait \_ en sorte que WM MOUSEMOVE l’option préférée pour le contrôle de pointeur (sur l' \_ entrée WM ou DirectInput), car il produit un comportement plus naturel pour les utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="83d75-124">This makes WM\_MOUSEMOVE the preferred option for pointer control (over WM\_INPUT or DirectInput), since it results in more natural behavior for users.</span></span> <span data-ttu-id="83d75-125">Alors que WM \_ MOUSEMOVE est idéal pour déplacer des pointeurs de souris, ce n’est pas si bon pour déplacer une caméra de première personne, puisque la précision haute définition sera perdue.</span><span class="sxs-lookup"><span data-stu-id="83d75-125">While WM\_MOUSEMOVE is ideal for moving mouse pointers, it is not so good for moving a first-person camera, since the high-definition precision will be lost.</span></span>

<span data-ttu-id="83d75-126">Pour plus d’informations sur WM \_ MouseMove, consultez [**WM \_ MouseMove**](/windows/desktop/inputdev/wm-mousemove).</span><span class="sxs-lookup"><span data-stu-id="83d75-126">For more info about WM\_MOUSEMOVE, see [**WM\_MOUSEMOVE**](/windows/desktop/inputdev/wm-mousemove).</span></span>

### <a name="wm_input"></a><span data-ttu-id="83d75-127">\_entrée WM</span><span class="sxs-lookup"><span data-stu-id="83d75-127">WM\_INPUT</span></span>

<span data-ttu-id="83d75-128">La deuxième méthode d’obtention des données de souris consiste à lire les \_ messages d’entrée WM.</span><span class="sxs-lookup"><span data-stu-id="83d75-128">The second method of obtaining mouse data is to read WM\_INPUT messages.</span></span> <span data-ttu-id="83d75-129">Le traitement des messages \_ d’entrée WM est plus complexe que le traitement des \_ messages WM MOUSEMOVE, mais les \_ messages d’entrée WM sont lus directement à partir de la pile HID (Human Interface Device) et reflètent les résultats de haute définition.</span><span class="sxs-lookup"><span data-stu-id="83d75-129">Processing WM\_INPUT messages is more complicated than processing WM\_MOUSEMOVE messages, but WM\_INPUT messages are read directly from the Human Interface Device (HID) stack and reflect high-definition results.</span></span>

<span data-ttu-id="83d75-130">Pour lire les données de mouvement de la souris à partir du \_ message d’entrée WM, l’appareil doit d’abord être enregistré. le code suivant en fournit un exemple :</span><span class="sxs-lookup"><span data-stu-id="83d75-130">To read mouse movement data from the WM\_INPUT message, the device must first be registered; the following code provides an example of this:</span></span>

```cpp
// you can #include <hidusage.h> for these defines
#ifndef HID_USAGE_PAGE_GENERIC
#define HID_USAGE_PAGE_GENERIC         ((USHORT) 0x01)
#endif
#ifndef HID_USAGE_GENERIC_MOUSE
#define HID_USAGE_GENERIC_MOUSE        ((USHORT) 0x02)
#endif

RAWINPUTDEVICE Rid[1];
Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC; 
Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE; 
Rid[0].dwFlags = RIDEV_INPUTSINK;   
Rid[0].hwndTarget = hWnd;
RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));
```

<span data-ttu-id="83d75-131">Le code suivant gère les \_ messages d’entrée WM dans le gestionnaire que winproc de l’application :</span><span class="sxs-lookup"><span data-stu-id="83d75-131">The following code handles WM\_INPUT messages in the application's WinProc handler:</span></span>

```cpp
case WM_INPUT: 
{
    UINT dwSize = sizeof(RAWINPUT);
    static BYTE lpb[sizeof(RAWINPUT)];

    GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER));

    RAWINPUT* raw = (RAWINPUT*)lpb;

    if (raw->header.dwType == RIM_TYPEMOUSE) 
    {
        int xPosRelative = raw->data.mouse.lLastX;
        int yPosRelative = raw->data.mouse.lLastY;
    } 
    break;
}
```

<span data-ttu-id="83d75-132">L’avantage d’utiliser l' \_ entrée WM est que votre jeu reçoit des données brutes de la souris au niveau le plus bas possible.</span><span class="sxs-lookup"><span data-stu-id="83d75-132">The advantage to using WM\_INPUT is that your game receives raw data from the mouse at the lowest level possible.</span></span>

<span data-ttu-id="83d75-133">L’inconvénient est que l' \_ entrée WM n’a pas de balistiques appliquée à ses données. par conséquent, si vous souhaitez diriger un curseur avec ces données, un effort supplémentaire sera nécessaire pour que le curseur se comporte comme dans Windows.</span><span class="sxs-lookup"><span data-stu-id="83d75-133">The disadvantage is that WM\_INPUT has no ballistics applied to its data, so if you want to drive a cursor with this data, extra effort will be required to make the cursor behave like it does in Windows.</span></span> <span data-ttu-id="83d75-134">Pour plus d’informations sur l’application des balistiques de pointeurs, consultez [pointeurs balistiques pour Windows XP](https://www.microsoft.com/whdc/archive/pointer-bal.mspx).</span><span class="sxs-lookup"><span data-stu-id="83d75-134">For more information about applying pointer ballistics, see [Pointer Ballistics for Windows XP](https://www.microsoft.com/whdc/archive/pointer-bal.mspx).</span></span>

<span data-ttu-id="83d75-135">Pour plus d’informations sur l' \_ entrée WM, consultez [à propos des entrées brutes](/windows/desktop/inputdev/about-raw-input).</span><span class="sxs-lookup"><span data-stu-id="83d75-135">For more info about WM\_INPUT, see [About Raw Input](/windows/desktop/inputdev/about-raw-input).</span></span>

### <a name="directinput"></a><span data-ttu-id="83d75-136">DirectInput</span><span class="sxs-lookup"><span data-stu-id="83d75-136">DirectInput</span></span>

<span data-ttu-id="83d75-137">[DirectInput](/windows-hardware/drivers/hid/directinput) est un ensemble d’appels d’API qui soustrait les périphériques d’entrée sur le système.</span><span class="sxs-lookup"><span data-stu-id="83d75-137">[DirectInput](/windows-hardware/drivers/hid/directinput) is a set of API calls that abstracts input devices on the system.</span></span> <span data-ttu-id="83d75-138">En interne, DirectInput crée un deuxième thread pour lire \_ les données d’entrée WM et l’utilisation des API DirectInput ajoute une charge mémoire supplémentaire par rapport à la simple lecture directe de l' \_ entrée WM.</span><span class="sxs-lookup"><span data-stu-id="83d75-138">Internally, DirectInput creates a second thread to read WM\_INPUT data, and using the DirectInput APIs will add more overhead than simply reading WM\_INPUT directly.</span></span> <span data-ttu-id="83d75-139">DirectInput est utile uniquement pour lire des données à partir de manettes de manche DirectInput ; Toutefois, si vous devez uniquement prendre en charge le contrôleur Xbox 360 pour Windows, utilisez [XInput](/windows/desktop/xinput/xinput-game-controller-apis-portal) à la place.</span><span class="sxs-lookup"><span data-stu-id="83d75-139">DirectInput is only useful for reading data from DirectInput joysticks; however, if you only need to support the Xbox 360 controller for Windows, use [XInput](/windows/desktop/xinput/xinput-game-controller-apis-portal) instead.</span></span> <span data-ttu-id="83d75-140">En général, l’utilisation de DirectInput n’offre aucun avantage lors de la lecture de données à partir de périphériques de souris ou de clavier, et l’utilisation d’DirectInput dans ces scénarios est déconseillée.</span><span class="sxs-lookup"><span data-stu-id="83d75-140">Overall, using DirectInput offers no advantages when reading data from mouse or keyboard devices, and the use of DirectInput in these scenarios is discouraged.</span></span>

<span data-ttu-id="83d75-141">Comparez la complexité de l’utilisation de [DirectInput](/windows-hardware/drivers/hid/directinput), illustrée dans le code suivant, aux méthodes décrites précédemment.</span><span class="sxs-lookup"><span data-stu-id="83d75-141">Compare the complexity of using [DirectInput](/windows-hardware/drivers/hid/directinput), shown in the following code, to the methods previously described.</span></span> <span data-ttu-id="83d75-142">L’ensemble d’appels suivant est nécessaire pour créer une souris DirectInput :</span><span class="sxs-lookup"><span data-stu-id="83d75-142">The following set of calls are needed to create a DirectInput mouse:</span></span>

```cpp
LPDIRECTINPUT8 pDI;
LPDIRECTINPUTDEVICE8 pMouse;

hr = DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&pDI, NULL);
if(FAILED(hr))
    return hr;

hr = pDI->CreateDevice(GUID_SysMouse, &pMouse, NULL);
if(FAILED(hr))
    return hr;

hr = pMouse->SetDataFormat(&c_dfDIMouse2);
if(FAILED(hr))
    return hr;

hr = pMouse->SetCooperativeLevel(hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
if(FAILED(hr))
    return hr;

if(!bImmediate)
{
    DIPROPDWORD dipdw;
    dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj        = 0;
    dipdw.diph.dwHow        = DIPH_DEVICE;
    dipdw.dwData            = 16; // Arbitrary buffer size

    if(FAILED(hr = pMouse->SetProperty(DIPROP_BUFFERSIZE, &dipdw.diph)))
        return hr;
}

pMouse->Acquire();
```

<span data-ttu-id="83d75-143">Puis, le périphérique de souris DirectInput peut lire chaque frame :</span><span class="sxs-lookup"><span data-stu-id="83d75-143">And then the DirectInput mouse device can be read each frame:</span></span>

```cpp
DIMOUSESTATE2 dims2; 
ZeroMemory(&dims2, sizeof(dims2));

hr = pMouse->GetDeviceState(sizeof(DIMOUSESTATE2), &dims2);
if(FAILED(hr)) 
{
    hr = pMouse->Acquire();
    while(hr == DIERR_INPUTLOST) 
        hr = pMouse->Acquire();

    return S_OK; 
}

int xPosRelative = dims2.lX;
int yPosRelative = dims2.lY;
```

## <a name="summary"></a><span data-ttu-id="83d75-144">Résumé</span><span class="sxs-lookup"><span data-stu-id="83d75-144">Summary</span></span>

<span data-ttu-id="83d75-145">Globalement, la meilleure méthode pour recevoir les données de déplacement de souris haute définition est l' \_ entrée WM.</span><span class="sxs-lookup"><span data-stu-id="83d75-145">Overall, the best method to receive high-definition mouse movement data is WM\_INPUT.</span></span> <span data-ttu-id="83d75-146">Si vos utilisateurs déplacent simplement un pointeur de souris, envisagez d’utiliser WM \_ MOUSEMOVE pour éviter d’avoir à effectuer des balistiques de pointeur.</span><span class="sxs-lookup"><span data-stu-id="83d75-146">If your users are just moving a mouse pointer, then consider using WM\_MOUSEMOVE to avoid needing to perform pointer ballistics.</span></span> <span data-ttu-id="83d75-147">Ces deux messages de fenêtre fonctionnent bien même si la souris n’est pas une souris de haute définition.</span><span class="sxs-lookup"><span data-stu-id="83d75-147">Both of these window messages will work well even if the mouse isn't a high-definition mouse.</span></span> <span data-ttu-id="83d75-148">En prenant en charge la haute définition, les jeux Windows peuvent offrir un contrôle plus précis aux utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="83d75-148">By supporting high definition, Windows games can offer more precise control to users.</span></span>