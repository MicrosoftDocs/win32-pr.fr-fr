---
title: Programmation pour le multicœur sur Xbox 360 et Windows
description: Cette rubrique fournit des conseils sur la prise en main de la programmation multithread.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/21/2020
ms.locfileid: "104383243"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a><span data-ttu-id="63d9a-103">Programmation pour le multicœur sur Xbox 360 et Windows</span><span class="sxs-lookup"><span data-stu-id="63d9a-103">Coding for multicore on Xbox 360 and Windows</span></span>

<span data-ttu-id="63d9a-104">Pendant des années, les performances des processeurs ont augmenté régulièrement, et les jeux et d’autres programmes ont profité des avantages de cette puissance croissante sans avoir à faire quoi que ce soit.</span><span class="sxs-lookup"><span data-stu-id="63d9a-104">For years the performance of processors has increased steadily, and games and other programs have reaped the benefits of this increasing power without having to do anything special.</span></span>

<span data-ttu-id="63d9a-105">Les règles ont été modifiées.</span><span class="sxs-lookup"><span data-stu-id="63d9a-105">The rules have changed.</span></span> <span data-ttu-id="63d9a-106">Les performances des cœurs de processeur unique s’améliorent à présent très lentement, si ce n’est du tout.</span><span class="sxs-lookup"><span data-stu-id="63d9a-106">The performance of single processor cores is now increasing very slowly, if at all.</span></span> <span data-ttu-id="63d9a-107">Toutefois, la puissance de calcul disponible dans un ordinateur ou une console standard continue de croître.</span><span class="sxs-lookup"><span data-stu-id="63d9a-107">However, the computing power available in a typical computer or console continues to grow.</span></span> <span data-ttu-id="63d9a-108">La différence réside dans le fait que la majeure partie de ce gain de performances provient désormais de la présence de plusieurs cœurs de processeur sur un seul ordinateur, souvent dans une seule puce.</span><span class="sxs-lookup"><span data-stu-id="63d9a-108">The difference is that most of this performance gain now comes from having multiple processor cores in a single machine, often in a single chip.</span></span> <span data-ttu-id="63d9a-109">L’UC Xbox 360 possède trois cœurs de processeur sur une seule puce et environ 70% de processeurs PC vendus dans 2006 étaient multicœurs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-109">The Xbox 360 CPU has three processor cores on one chip, and roughly 70 percent of PC processors sold in 2006 were multi-core.</span></span>

<span data-ttu-id="63d9a-110">Les augmentations de la puissance de traitement disponible sont aussi spectaculaires que dans le passé, mais désormais, les développeurs doivent écrire du code multithread afin d’utiliser cette puissance.</span><span class="sxs-lookup"><span data-stu-id="63d9a-110">The increases in available processing power are just as dramatic as in the past, but now developers have to write multithreaded code in order to use this power.</span></span> <span data-ttu-id="63d9a-111">La programmation multithread apporte un nouveau défi à la conception et à la programmation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-111">Multi-threaded programming brings with it new design and programming challenges.</span></span> <span data-ttu-id="63d9a-112">Cette rubrique fournit des conseils sur la prise en main de la programmation multithread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-112">This topic gives some advice on how to get started with multithreaded programming.</span></span>

## <a name="the-importance-of-good-design"></a><span data-ttu-id="63d9a-113">L’importance de la bonne conception</span><span class="sxs-lookup"><span data-stu-id="63d9a-113">The Importance of Good Design</span></span>

<span data-ttu-id="63d9a-114">Une bonne conception de programme multithread est essentielle, mais elle peut être très difficile.</span><span class="sxs-lookup"><span data-stu-id="63d9a-114">Good multithreaded program design is critical, but it can be very difficult.</span></span> <span data-ttu-id="63d9a-115">Si vous déplacez par hasard vos principaux systèmes de jeu vers différents threads, vous constaterez probablement que chaque thread consacre la plus grande partie de son temps à attendre les autres threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-115">If you haphazardly move your major game systems onto different threads, you will likely find that each thread spends most of its time waiting on the other threads.</span></span> <span data-ttu-id="63d9a-116">Ce type de conception implique une complexité accrue et des efforts de débogage importants, avec pratiquement aucun gain de performances.</span><span class="sxs-lookup"><span data-stu-id="63d9a-116">This type of design leads to increased complexity and significant debugging effort, with virtually no performance gain.</span></span>

<span data-ttu-id="63d9a-117">Chaque fois que les threads doivent synchroniser ou partager des données, il existe un risque d’altération des données, de surcharge des synchronisations, de blocages et de complexité.</span><span class="sxs-lookup"><span data-stu-id="63d9a-117">Every time that threads have to synchronize or share data there is the potential for data corruption, synchronization overhead, deadlocks, and complexity.</span></span> <span data-ttu-id="63d9a-118">Par conséquent, votre conception multithread doit clairement documenter chaque point de synchronisation et de communication, et elle devrait réduire autant que possible ces points.</span><span class="sxs-lookup"><span data-stu-id="63d9a-118">Therefore, your multithreaded design needs to clearly document every synchronization and communication point, and it should minimize such points as much as possible.</span></span> <span data-ttu-id="63d9a-119">Lorsque les threads ont besoin de communiquer, l’effort de codage augmente, ce qui peut réduire la productivité si elle affecte un code source trop grand.</span><span class="sxs-lookup"><span data-stu-id="63d9a-119">Where threads need to communicate, coding effort will increase, which can lower productivity if it affects too much source code.</span></span>

<span data-ttu-id="63d9a-120">L’objectif de conception le plus simple pour le multithreading consiste à scinder le code en éléments indépendants de grande taille.</span><span class="sxs-lookup"><span data-stu-id="63d9a-120">The simplest design goal for multithreading is to break up the code into large independent pieces.</span></span> <span data-ttu-id="63d9a-121">Si vous limitez ensuite ces éléments à la communication de quelques fois par trame, vous verrez une accélération significative du multithreading, sans complexité excessive.</span><span class="sxs-lookup"><span data-stu-id="63d9a-121">If you then restrict these pieces to communicating just a few times per frame, you will see significant speedup from multithreading, without undue complexity.</span></span>

## <a name="typical-threaded-tasks"></a><span data-ttu-id="63d9a-122">Tâches de thread courantes</span><span class="sxs-lookup"><span data-stu-id="63d9a-122">Typical Threaded Tasks</span></span>

<span data-ttu-id="63d9a-123">Quelques types de tâches ont prouvé qu’elles sont placées sur des threads distincts.</span><span class="sxs-lookup"><span data-stu-id="63d9a-123">A few types of tasks have proven amenable to being put onto separate threads.</span></span> <span data-ttu-id="63d9a-124">La liste suivante n’est pas destinée à être exhaustive, mais elle doit donner quelques idées.</span><span class="sxs-lookup"><span data-stu-id="63d9a-124">The following list is not intended to be exhaustive, but should give some ideas.</span></span>

### <a name="rendering"></a><span data-ttu-id="63d9a-125">Rendu</span><span class="sxs-lookup"><span data-stu-id="63d9a-125">Rendering</span></span>

<span data-ttu-id="63d9a-126">Le rendu, qui peut inclure le parcours du graphique de la scène ou, éventuellement, uniquement l’appel de fonctions D3D, est souvent un compte de 50% ou plus du temps processeur.</span><span class="sxs-lookup"><span data-stu-id="63d9a-126">Rendering — which may include walking the scene graph or, possibly, only calling D3D functions — often accounts for 50 percent or more of CPU time.</span></span> <span data-ttu-id="63d9a-127">Par conséquent, le déplacement du rendu vers un autre thread peut avoir des avantages significatifs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-127">Therefore, moving rendering to another thread can have significant benefits.</span></span> <span data-ttu-id="63d9a-128">Le thread de mise à jour peut remplir une sorte de tampon de description de rendu, que le thread de rendu peut ensuite traiter.</span><span class="sxs-lookup"><span data-stu-id="63d9a-128">The update thread can fill in some sort of render description buffer, which the rendering thread can then process.</span></span>

<span data-ttu-id="63d9a-129">Le thread de mise à jour de jeu est toujours une image à l’avance du thread de rendu, ce qui signifie qu’il faut deux frames pour que les actions de l’utilisateur s’affichent à l’écran.</span><span class="sxs-lookup"><span data-stu-id="63d9a-129">The game update thread is always one frame ahead of the render thread, which means that it takes two frames before user actions show up on the screen.</span></span> <span data-ttu-id="63d9a-130">Bien que cette latence accrue puisse être un problème, la fréquence d’images accrue du fractionnement de la charge de travail conserve généralement la latence totale acceptable.</span><span class="sxs-lookup"><span data-stu-id="63d9a-130">Although this increased latency can be a problem, the increased frame rate from splitting up the workload generally keeps the total latency acceptable.</span></span>

<span data-ttu-id="63d9a-131">Dans la plupart des cas, tout le rendu est toujours effectué sur un thread unique, mais il s’agit d’un thread différent de la mise à jour du jeu.</span><span class="sxs-lookup"><span data-stu-id="63d9a-131">In most cases all rendering is still done on a single thread, but it is a different thread from the game update.</span></span>

<span data-ttu-id="63d9a-132">L' \_ indicateur MULTITHREAD D3DCREATE est parfois utilisé pour autoriser le rendu sur un thread et la création de ressources sur d’autres threads. cet indicateur est ignoré sur la Xbox 360 et vous devez éviter de l’utiliser sur Windows.</span><span class="sxs-lookup"><span data-stu-id="63d9a-132">The D3DCREATE\_MULTITHREADED flag is sometimes used to allow rendering on one thread and resource creation on other threads; this flag is ignored on Xbox 360, and you should avoid using it on Windows.</span></span> <span data-ttu-id="63d9a-133">Sur Windows, la spécification de cet indicateur Force D3D à consacrer beaucoup de temps à la synchronisation, ce qui ralentit le thread de rendu.</span><span class="sxs-lookup"><span data-stu-id="63d9a-133">On Windows, specifying this flag forces D3D to spend a significant amount of time on synchronization, thus slowing down the render thread.</span></span>

### <a name="file-decompression"></a><span data-ttu-id="63d9a-134">Décompression de fichiers</span><span class="sxs-lookup"><span data-stu-id="63d9a-134">File Decompression</span></span>

<span data-ttu-id="63d9a-135">Les temps de chargement sont toujours trop longs et la diffusion en continu des données en mémoire sans affecter la fréquence d’images peut être difficile.</span><span class="sxs-lookup"><span data-stu-id="63d9a-135">Load times are always too long, and streaming data into memory without affecting the frame rate can be challenging.</span></span> <span data-ttu-id="63d9a-136">Si toutes les données sont compressées de façon agressive sur le disque, la vitesse de transfert des données à partir du disque dur ou du disque optique est moins susceptible d’être un facteur de limitation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-136">If all data is aggressively compressed on disc, then data transfer speed from the hard drive or optical disc is less likely to be a limiting factor.</span></span> <span data-ttu-id="63d9a-137">Sur un processeur à thread unique, il n’y a généralement pas assez de temps processeur disponible pour la compression afin d’aider à charger les temps.</span><span class="sxs-lookup"><span data-stu-id="63d9a-137">On a single-threaded processor, there is usually not enough processor time available for compression to help load times.</span></span> <span data-ttu-id="63d9a-138">Toutefois, sur un système multiprocesseur, la décompression des fichiers utilise des cycles de processeur qui, sans cela, seraient inutiles. elle améliore le temps de chargement et la diffusion en continu. et économise de l’espace sur le disque.</span><span class="sxs-lookup"><span data-stu-id="63d9a-138">On a multiprocessor system, however, file decompression uses CPU cycles that would otherwise be wasted; it improves load times and streaming; and it saves space on the disc.</span></span>

<span data-ttu-id="63d9a-139">N’utilisez pas la décompression de fichiers en remplacement du traitement qui doit être effectué pendant la production.</span><span class="sxs-lookup"><span data-stu-id="63d9a-139">Do not use file decompression as a replacement for processing that should be done during production.</span></span> <span data-ttu-id="63d9a-140">Par exemple, si vous dédiez un thread supplémentaire à l’analyse de données XML pendant le chargement de niveau, vous n’utilisez pas le multithreading pour améliorer l’expérience du joueur.</span><span class="sxs-lookup"><span data-stu-id="63d9a-140">For instance, if you devote an extra thread to parsing XML data during level loading, you are not using multithreading to improve the player's experience.</span></span>

<span data-ttu-id="63d9a-141">Quand vous utilisez un thread de décompression de fichiers, vous devez toujours utiliser des e/s de fichier asynchrones et des lectures volumineuses afin d’optimiser l’efficacité de la lecture des données.</span><span class="sxs-lookup"><span data-stu-id="63d9a-141">When using a file decompression thread, you should still use asynchronous file I/O and large reads in order to maximize data-reading efficiency.</span></span>

### <a name="graphics-fluff"></a><span data-ttu-id="63d9a-142">Attractifs Graphics</span><span class="sxs-lookup"><span data-stu-id="63d9a-142">Graphics Fluff</span></span>

<span data-ttu-id="63d9a-143">Il existe de nombreux niceties graphiques qui améliorent l’apparence du jeu, mais ne sont pas strictement nécessaires.</span><span class="sxs-lookup"><span data-stu-id="63d9a-143">There are many graphical niceties that improve the look of the game but aren't strictly necessary.</span></span> <span data-ttu-id="63d9a-144">Il s’agit notamment d’animations Cloud, de simulations de cheveux, d’ondes procédurales, de végétation procédurales, de particules supplémentaires ou d’une physique sans jeu de mesures.</span><span class="sxs-lookup"><span data-stu-id="63d9a-144">These include things like procedurally generated cloud animations, cloth and hair simulations, procedural waves, procedural vegetation, more particles, or non-gameplay physics.</span></span>

<span data-ttu-id="63d9a-145">Étant donné que ces effets n’affectent pas le jeu de résultats, ils ne provoquent pas de problèmes de synchronisation difficiles : ils peuvent se synchroniser avec les autres threads une fois par image ou moins souvent.</span><span class="sxs-lookup"><span data-stu-id="63d9a-145">Because these effects don't affect gameplay, they don't cause tricky synchronization problems—they can synchronize with the other threads once per frame or less often.</span></span> <span data-ttu-id="63d9a-146">En outre, sur les jeux pour Windows, ces effets peuvent ajouter de la valeur pour les joueurs avec des processeurs multicœurs, tout en étant omis en mode silencieux sur les ordinateurs à cœur unique, offrant ainsi un moyen facile de mettre à l’échelle sur un large éventail de fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="63d9a-146">Additionally, on games for Windows these effects can add value for gamers with multicore CPUs, while silently being omitted on single-core computers, thus giving an easy way of scaling across a wide range of capabilities.</span></span>

### <a name="physics"></a><span data-ttu-id="63d9a-147">Physique</span><span class="sxs-lookup"><span data-stu-id="63d9a-147">Physics</span></span>

<span data-ttu-id="63d9a-148">La physique ne peut souvent pas être placée sur un thread distinct pour s’exécuter en parallèle avec la mise à jour du jeu, car la mise à jour du jeu requiert généralement les résultats des calculs physiques.</span><span class="sxs-lookup"><span data-stu-id="63d9a-148">Physics often cannot be put onto a separate thread to run in parallel with the game update because the game update usually requires the results of the physics calculations immediately.</span></span> <span data-ttu-id="63d9a-149">L’alternative à la physique du multithreads consiste à l’exécuter sur plusieurs processeurs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-149">The alternative for multithreading physics is to run it on multiple processors.</span></span> <span data-ttu-id="63d9a-150">Bien que cela puisse être fait, il s’agit d’une tâche complexe nécessitant un accès fréquent aux structures de données partagées.</span><span class="sxs-lookup"><span data-stu-id="63d9a-150">Although this can be done, it is a complex task requiring frequent access to shared data structures.</span></span> <span data-ttu-id="63d9a-151">Si vous pouvez maintenir la charge de travail physique suffisamment faible pour tenir sur le thread principal, votre travail sera plus simple.</span><span class="sxs-lookup"><span data-stu-id="63d9a-151">If you can keep your physics workload low enough to fit on the main thread, your job will be simpler.</span></span>

<span data-ttu-id="63d9a-152">Les bibliothèques qui prennent en charge l’exécution physique sur plusieurs threads sont disponibles.</span><span class="sxs-lookup"><span data-stu-id="63d9a-152">Libraries that support running physics on multiple threads are available.</span></span> <span data-ttu-id="63d9a-153">Toutefois, cela peut entraîner un problème : lorsque votre jeu est en cours d’exécution physique, il utilise de nombreux threads, mais le reste du temps qu’il utilise.</span><span class="sxs-lookup"><span data-stu-id="63d9a-153">However, this can lead to a problem: when your game is running physics, it uses many threads, but the rest of the time it uses few.</span></span> <span data-ttu-id="63d9a-154">L’exécution physique sur plusieurs threads nécessite l’adressage de ce qui permet de répartir uniformément la charge de travail sur le frame.</span><span class="sxs-lookup"><span data-stu-id="63d9a-154">Running physics on multiple threads will require addressing this so that the workload is distributed evenly over the frame.</span></span> <span data-ttu-id="63d9a-155">Si vous écrivez un moteur physique multithread, vous devez prêter une attention particulière à toutes vos structures de données, points de synchronisation et équilibrage de charge.</span><span class="sxs-lookup"><span data-stu-id="63d9a-155">If you write a multithreaded physics engine, you must pay careful attention to all of your data structures, synchronization points, and load balancing.</span></span>

## <a name="example-multithreaded-designs"></a><span data-ttu-id="63d9a-156">Exemples de conceptions multithread</span><span class="sxs-lookup"><span data-stu-id="63d9a-156">Example Multithreaded Designs</span></span>

<span data-ttu-id="63d9a-157">Les jeux pour Windows doivent s’exécuter sur des ordinateurs avec différents nombres de cœurs de processeur.</span><span class="sxs-lookup"><span data-stu-id="63d9a-157">Games for Windows need to run on computers with different numbers of CPU cores.</span></span> <span data-ttu-id="63d9a-158">La plupart des ordinateurs de jeu n’ont toujours qu’un seul cœur, bien que le nombre de machines à deux cœurs augmente rapidement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-158">Most game machines still have only one core, although the number of two-core machines is growing rapidly.</span></span> <span data-ttu-id="63d9a-159">Un jeu typique pour Windows peut fractionner sa charge de travail en un thread pour la mise à jour et le rendu, avec des threads de travail facultatifs pour l’ajout de fonctionnalités supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="63d9a-159">A typical game for Windows might break its workload into one thread for update and rendering, with optional worker threads for adding extra functionality.</span></span> <span data-ttu-id="63d9a-160">En outre, certains threads d’arrière-plan pour les e/s de fichier et la mise en réseau seraient probablement utilisés.</span><span class="sxs-lookup"><span data-stu-id="63d9a-160">In addition, some background threads for doing file I/O and networking would probably be used.</span></span> <span data-ttu-id="63d9a-161">La figure 1 illustre les threads, ainsi que les principaux points de transfert de données.</span><span class="sxs-lookup"><span data-stu-id="63d9a-161">Figure 1 shows the threads, together with the main data transfer points.</span></span>

<span data-ttu-id="63d9a-162">**Figure 1. Conception de threads dans un jeu pour Windows**</span><span class="sxs-lookup"><span data-stu-id="63d9a-162">**Figure 1. Threading design in a game for Windows**</span></span>

![conception de threads dans un jeu pour Windows](images/coding-for-multiple-cores-1.gif)

<span data-ttu-id="63d9a-164">Un jeu Xbox 360 classique peut utiliser des threads logiciels nécessitant beaucoup plus de ressources processeur. il peut donc diviser sa charge de travail en thread de mise à jour, thread de rendu et trois threads de travail, comme illustré à la figure 2.</span><span class="sxs-lookup"><span data-stu-id="63d9a-164">A typical Xbox 360 game can use additional CPU-intensive software threads, so it might break up its workload into an update thread, rendering thread, and three worker threads, as shown in Figure 2.</span></span>

<span data-ttu-id="63d9a-165">**Figure 2. Conception de threads dans un jeu pour Xbox 360**</span><span class="sxs-lookup"><span data-stu-id="63d9a-165">**Figure 2. Threading design in a game for Xbox 360**</span></span>

![conception de threads dans un jeu pour Xbox 360](images/coding-for-multiple-cores-2.gif)

<span data-ttu-id="63d9a-167">À l’exception des e/s de fichier et de la mise en réseau, ces tâches ont toutes le potentiel d’être suffisamment gourmandes en ressources processeur pour tirer parti de leur propre thread matériel.</span><span class="sxs-lookup"><span data-stu-id="63d9a-167">With the exception of file I/O and networking, these tasks all have the potential to be CPU-intensive enough to benefit from being on their own hardware thread.</span></span> <span data-ttu-id="63d9a-168">Ces tâches peuvent également être suffisamment indépendantes pour pouvoir s’exécuter pour une trame entière sans communiquer.</span><span class="sxs-lookup"><span data-stu-id="63d9a-168">These tasks also have the potential to be independent enough that they can run for an entire frame without communicating.</span></span>

<span data-ttu-id="63d9a-169">Le thread de mise à jour de jeu gère l’entrée du contrôleur, l’intelligence artificielle et la physique, et prépare les instructions pour les quatre autres threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-169">The game update thread manages controller input, AI, and physics, and prepares instructions for the other four threads.</span></span> <span data-ttu-id="63d9a-170">Ces instructions sont placées dans des mémoires tampons détenues par le thread de mise à jour de jeu, donc aucune synchronisation n’est requise, car les instructions sont générées.</span><span class="sxs-lookup"><span data-stu-id="63d9a-170">These instructions are placed into buffers owned by the game update thread, so no synchronization is required as the instructions are generated.</span></span>

<span data-ttu-id="63d9a-171">À la fin du cadre, le thread de mise à jour de jeu transmet les tampons d’instructions aux quatre autres threads, puis commence à travailler sur le frame suivant, en remplissant un autre ensemble de mémoires tampons d’instructions.</span><span class="sxs-lookup"><span data-stu-id="63d9a-171">At the end of the frame, the game update thread hands off the instruction buffers to the four other threads, and then starts working on the next frame, filling in another set of instruction buffers.</span></span>

<span data-ttu-id="63d9a-172">Étant donné que les threads de mise à jour et de rendu fonctionnent dans échelons les uns avec les autres, leurs mémoires tampons de communication sont simplement doubles mises en mémoire tampon : à un moment donné, le thread de mise à jour remplit un tampon pendant que le thread de rendu lit à partir de l’autre.</span><span class="sxs-lookup"><span data-stu-id="63d9a-172">Because the update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered: at any given time, the update thread is filling one buffer while the render thread is reading from the other.</span></span>

<span data-ttu-id="63d9a-173">Les autres threads de travail ne sont pas nécessairement liés à la fréquence d’images.</span><span class="sxs-lookup"><span data-stu-id="63d9a-173">The other worker threads are not necessarily tied to the frame rate.</span></span> <span data-ttu-id="63d9a-174">La décompression d’un élément de données peut prendre beaucoup moins d’images ou prendre de nombreuses images.</span><span class="sxs-lookup"><span data-stu-id="63d9a-174">Decompressing a piece of data may take much less than a frame, or it may take many frames.</span></span> <span data-ttu-id="63d9a-175">Même la simulation de tissu et de cheveux n’a peut-être pas besoin d’être exécutée exactement à la fréquence d’images, car les mises à jour moins fréquentes peuvent être assez acceptables.</span><span class="sxs-lookup"><span data-stu-id="63d9a-175">Even the cloth and hair simulation may not need to run exactly at the frame rate because less frequent updates may be quite acceptable.</span></span> <span data-ttu-id="63d9a-176">Par conséquent, ces trois threads ont besoin de structures de données différentes pour communiquer avec le thread de mise à jour et le thread de rendu.</span><span class="sxs-lookup"><span data-stu-id="63d9a-176">Therefore, these three threads need different data structures to communicate with the update thread and the render thread.</span></span> <span data-ttu-id="63d9a-177">Ils ont chacun besoin d’une file d’attente d’entrée qui peut contenir des demandes de travail, et le thread de rendu a besoin d’une file d’attente de données qui peut contenir les résultats produits par les threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-177">They each need an input queue that can hold work requests, and the render thread needs a data queue that can hold the results produced by the threads.</span></span> <span data-ttu-id="63d9a-178">À la fin de chaque frame, le thread de mise à jour ajoute un bloc de demandes de travail aux files d’attente de threads de travail.</span><span class="sxs-lookup"><span data-stu-id="63d9a-178">At the end of each frame the update thread will add a block of work requests to worker threads' queues.</span></span> <span data-ttu-id="63d9a-179">L’ajout de à la liste une seule fois par trame garantit que le thread de mise à jour minimise la surcharge de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-179">Adding to the list just once per frame ensures that the update thread minimizes the synchronization overhead.</span></span> <span data-ttu-id="63d9a-180">Chacun des threads de travail extrait les affectations de la file d’attente de travail aussi rapidement que possible, à l’aide d’une boucle qui ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="63d9a-180">Each of the worker threads pulls assignments from the work queue as quickly as it can, using a loop that looks something like this:</span></span>


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



<span data-ttu-id="63d9a-181">Étant donné que les données passent des threads de mise à jour aux threads de travail, puis au thread de rendu, il peut y avoir un délai de trois frames ou plus avant que certaines actions l’affichent à l’écran.</span><span class="sxs-lookup"><span data-stu-id="63d9a-181">Because the data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions make it to the screen.</span></span> <span data-ttu-id="63d9a-182">Toutefois, si vous attribuez des tâches tolérantes à la latence aux threads de travail, cela ne devrait pas être un problème.</span><span class="sxs-lookup"><span data-stu-id="63d9a-182">However, if you assign latency-tolerant tasks to the worker threads, then this should not be a problem.</span></span>

<span data-ttu-id="63d9a-183">Une conception alternative consisterait à faire en sorte que plusieurs threads de travail dessinent à partir de la même file d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="63d9a-183">An alternate design would be to have several worker threads all drawing from the same work queue.</span></span> <span data-ttu-id="63d9a-184">Cela donne un équilibrage de charge automatique et rend plus probable que tous les threads de travail restent occupés.</span><span class="sxs-lookup"><span data-stu-id="63d9a-184">This would give automatic load balancing and would make it more likely that all of the worker threads would stay busy.</span></span>

<span data-ttu-id="63d9a-185">Le thread de mise à jour de jeu doit veiller à ne pas fournir trop de travail aux threads de travail, sinon les files d’attente de travail peuvent croître en permanence.</span><span class="sxs-lookup"><span data-stu-id="63d9a-185">The game update thread must take care to not give too much work to the worker threads, or else the work queues may continuously grow.</span></span> <span data-ttu-id="63d9a-186">Le mode de gestion du thread de mise à jour dépend du type de tâches effectuées par les threads de travail.</span><span class="sxs-lookup"><span data-stu-id="63d9a-186">How the update thread manages this depends on what sort of tasks the worker threads are doing.</span></span>

## <a name="simultaneous-multithreading-and-number-of-threads"></a><span data-ttu-id="63d9a-187">Multithread et nombre de threads simultanés</span><span class="sxs-lookup"><span data-stu-id="63d9a-187">Simultaneous Multithreading and Number of Threads</span></span>

<span data-ttu-id="63d9a-188">Tous les threads ne sont pas égaux.</span><span class="sxs-lookup"><span data-stu-id="63d9a-188">All threads are not created equal.</span></span> <span data-ttu-id="63d9a-189">Deux threads matériels peuvent se trouver sur des puces distinctes, sur le même processeur ou même sur le même noyau.</span><span class="sxs-lookup"><span data-stu-id="63d9a-189">Two hardware threads might be on separate chips, on the same chip, or even on the same core.</span></span> <span data-ttu-id="63d9a-190">La configuration la plus importante pour les programmeurs de jeu à prendre en compte est de deux threads matériels sur un cœur : la technologie multithreading (SMT) simultanée ou la technologie de Hyper-Threading (HT).</span><span class="sxs-lookup"><span data-stu-id="63d9a-190">The most important configuration for game programmers to be aware of is two hardware threads on one core—Simultaneous Multi-Threading (SMT) or Hyper-Threading Technology (HT Technology).</span></span>

<span data-ttu-id="63d9a-191">Les threads de technologie SMT ou HT partagent les ressources du cœur de l’UC.</span><span class="sxs-lookup"><span data-stu-id="63d9a-191">SMT or HT Technology threads share the resources of the CPU core.</span></span> <span data-ttu-id="63d9a-192">Étant donné qu’ils partagent les unités d’exécution, l’accélération maximale de l’exécution de deux threads au lieu d’une est généralement de 10 à 20%, et non pas de 100% par rapport à deux threads matériels indépendants.</span><span class="sxs-lookup"><span data-stu-id="63d9a-192">Because they share the execution units, the maximum speedup from running two threads instead of one is typically 10 to 20 percent, instead of the 100 percent that is possible from two independent hardware threads.</span></span>

<span data-ttu-id="63d9a-193">Les threads de technologie SMT ou HT partagent plus de manière significative les caches d’instructions et de données L1.</span><span class="sxs-lookup"><span data-stu-id="63d9a-193">More significantly, SMT or HT Technology threads share the L1 instruction and data caches.</span></span> <span data-ttu-id="63d9a-194">Si leurs modèles d’accès à la mémoire sont incompatibles, ils peuvent mettre un terme à la lutte contre le cache et provoquer de nombreux échecs dans le cache.</span><span class="sxs-lookup"><span data-stu-id="63d9a-194">If their memory access patterns are incompatible, they can end up fighting over the cache and causing many cache misses.</span></span> <span data-ttu-id="63d9a-195">Dans le pire des cas, les performances totales du noyau de l’UC peuvent réellement diminuer lorsqu’un deuxième thread est exécuté.</span><span class="sxs-lookup"><span data-stu-id="63d9a-195">In the worst case, the total performance for the CPU core can actually decrease when a second thread is run.</span></span> <span data-ttu-id="63d9a-196">Sur Xbox 360, il s’agit d’un problème relativement simple.</span><span class="sxs-lookup"><span data-stu-id="63d9a-196">On Xbox 360, this is a fairly simple problem.</span></span> <span data-ttu-id="63d9a-197">La configuration de la Xbox 360 est connue (trois cœurs d’UC chacun avec deux threads matériels) et les développeurs attribuent leurs threads logiciels à des threads d’UC spécifiques et peuvent mesurer pour déterminer si leur conception de threads leur donne des performances supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="63d9a-197">The configuration of the Xbox 360 is known—three CPU cores each with two hardware threads—and developers assign their software threads to specific CPU threads and can measure to see whether their threading design gives them extra performance.</span></span>

<span data-ttu-id="63d9a-198">Sur Windows, la situation est plus compliquée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-198">On Windows, the situation is more complicated.</span></span> <span data-ttu-id="63d9a-199">Le nombre de threads et leur configuration varient d’un ordinateur à l’ordinateur, et la détermination de la configuration est compliquée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-199">The number of threads and their configuration will vary from computer to computer, and determining the configuration is complicated.</span></span> <span data-ttu-id="63d9a-200">La fonction [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) fournit des informations sur la relation entre les différents threads matériels, et cette fonction est disponible sur Windows Vista, Windows 7 et Windows XP SP3.</span><span class="sxs-lookup"><span data-stu-id="63d9a-200">The function [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) gives information about the relationship between different hardware threads, and this function is available on Windows Vista, Windows 7, and Windows XP SP3.</span></span> <span data-ttu-id="63d9a-201">Par conséquent, pour l’instant, vous devez utiliser l’instruction CPUID et les algorithmes fournis par Intel et AMD pour décider du nombre de threads « réels » dont vous disposez.</span><span class="sxs-lookup"><span data-stu-id="63d9a-201">Therefore, for now you have to use the CPUID instruction and the algorithms given by Intel and AMD in order to decide how many "real" threads you have available.</span></span> <span data-ttu-id="63d9a-202">Pour plus d’informations, consultez les références.</span><span class="sxs-lookup"><span data-stu-id="63d9a-202">See the references for more information.</span></span>

<span data-ttu-id="63d9a-203">L’exemple CoreDetection dans le kit de développement logiciel (SDK) DirectX contient un exemple de code qui utilise la fonction [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) ou l’instruction CPUID pour retourner la topologie de base de l’UC.</span><span class="sxs-lookup"><span data-stu-id="63d9a-203">The CoreDetection sample in the DirectX SDK contains sample code that uses the [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) function or the CPUID instruction to return the CPU core topology.</span></span> <span data-ttu-id="63d9a-204">L’instruction CPUID est utilisée si **GetLogicalProcessorInformation** n’est pas pris en charge sur la plateforme actuelle.</span><span class="sxs-lookup"><span data-stu-id="63d9a-204">The CPUID instruction is used if **GetLogicalProcessorInformation** is not supported on the current platform.</span></span> <span data-ttu-id="63d9a-205">CoreDetection se trouve aux emplacements suivants :</span><span class="sxs-lookup"><span data-stu-id="63d9a-205">CoreDetection can be found in the following locations:</span></span>

<dl> <dt>

<span data-ttu-id="63d9a-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Code</span><span class="sxs-lookup"><span data-stu-id="63d9a-206"><span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Source:</span></span>
</dt> <dd>

<span data-ttu-id="63d9a-207">*Racine* \\ SDK DirectX Exemples \\ \\ CoreDetection divers \\ C++</span><span class="sxs-lookup"><span data-stu-id="63d9a-207">*DirectX SDK root*\\Samples\\C++\\Misc\\CoreDetection</span></span>

</dd> <dt>

<span data-ttu-id="63d9a-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Exécutable</span><span class="sxs-lookup"><span data-stu-id="63d9a-208"><span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Executable:</span></span>
</dt> <dd>

<span data-ttu-id="63d9a-209">*Racine* \\ SDK DirectX Exemples \\ de \\ \\ casiers divers C++ \\CoreDetection.exe</span><span class="sxs-lookup"><span data-stu-id="63d9a-209">*DirectX SDK root*\\Samples\\C++\\Misc\\Bin\\CoreDetection.exe</span></span>

</dd> </dl>

<span data-ttu-id="63d9a-210">L’hypothèse la plus sûre consiste à n’avoir qu’un seul thread gourmand en ressources processeur par cœur de processeur.</span><span class="sxs-lookup"><span data-stu-id="63d9a-210">The safest assumption is to have no more than one CPU-intensive thread per CPU core.</span></span> <span data-ttu-id="63d9a-211">Le fait d’avoir plus de threads nécessitant beaucoup de ressources processeur que les cœurs de processeur offre peu ou pas d’avantages, et augmente la surcharge et la complexité des threads supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="63d9a-211">Having more CPU-intensive threads than CPU cores gives little or no benefits, and brings the extra overhead and complexity of additional threads.</span></span>

## <a name="creating-threads"></a><span data-ttu-id="63d9a-212">Création de threads</span><span class="sxs-lookup"><span data-stu-id="63d9a-212">Creating Threads</span></span>

<span data-ttu-id="63d9a-213">La création de threads est une opération relativement simple, mais il existe de nombreuses erreurs potentielles.</span><span class="sxs-lookup"><span data-stu-id="63d9a-213">Creating threads is a fairly simple operation, but there are many potential errors.</span></span> <span data-ttu-id="63d9a-214">Le code ci-dessous montre la manière appropriée de créer un thread, d’attendre qu’il se termine, puis de le nettoyer.</span><span class="sxs-lookup"><span data-stu-id="63d9a-214">The code below shows the proper way of creating a thread, waiting for it to terminate, and then cleaning up.</span></span>


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



<span data-ttu-id="63d9a-215">Lorsque vous créez un thread, vous avez la possibilité de spécifier la taille de la pile pour le thread enfant, ou de spécifier zéro, auquel cas le thread enfant hérite de la taille de la pile du thread parent.</span><span class="sxs-lookup"><span data-stu-id="63d9a-215">When you create a thread, you have the option to specify the stack size for the child thread, or specify zero, in which case the child thread will inherit the parent thread's stack size.</span></span> <span data-ttu-id="63d9a-216">Sur Xbox 360, où les piles sont entièrement validées lorsque le thread démarre, la spécification de zéro risque de gaspiller de la mémoire importante, car de nombreux threads enfants n’ont pas besoin de la même pile que le parent.</span><span class="sxs-lookup"><span data-stu-id="63d9a-216">On Xbox 360, where stacks are fully committed when the thread starts, specifying zero can waste significant memory, because many child threads will not need as much stack as the parent.</span></span> <span data-ttu-id="63d9a-217">Sur la Xbox 360, il est également important que la taille de la pile soit un multiple de 64 Ko.</span><span class="sxs-lookup"><span data-stu-id="63d9a-217">On Xbox 360 it is also important that the stack size be a multiple of 64-KB.</span></span>

<span data-ttu-id="63d9a-218">Si vous utilisez la fonction [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) pour créer des threads, le runtime C/C++ (CRT) ne sera pas correctement initialisé sur Windows.</span><span class="sxs-lookup"><span data-stu-id="63d9a-218">If you use the [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) function to create threads, then the C/C++ runtime (CRT) will not get properly initialized on Windows.</span></span> <span data-ttu-id="63d9a-219">Nous vous recommandons d’utiliser à la place la fonction CRT [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) .</span><span class="sxs-lookup"><span data-stu-id="63d9a-219">We recommend that you use the CRT [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) function instead.</span></span>

<span data-ttu-id="63d9a-220">La valeur de retour de [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) ou [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) est un handle de thread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-220">The return value from [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) or [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) is a thread handle.</span></span> <span data-ttu-id="63d9a-221">Ce thread peut être utilisé pour attendre que le thread enfant se termine, ce qui est bien plus simple et bien plus efficace que la rotation dans une boucle qui vérifie l’état du thread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-221">This thread can be used to wait for the child thread to terminate, which is much simpler and much more efficient than spinning in a loop checking the thread status.</span></span> <span data-ttu-id="63d9a-222">Pour attendre que le thread se termine, appelez simplement [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) avec le handle de thread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-222">To wait for the thread to terminate, simply call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) with the thread handle.</span></span>

<span data-ttu-id="63d9a-223">Les ressources du thread ne seront pas libérées tant que le thread n’est pas terminé et que le handle de thread n’a pas été fermé.</span><span class="sxs-lookup"><span data-stu-id="63d9a-223">The resources for the thread will not be freed until the thread has terminated and the thread handle has been closed.</span></span> <span data-ttu-id="63d9a-224">Par conséquent, il est important de fermer le handle de thread avec [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) lorsque vous en avez terminé avec ce dernier.</span><span class="sxs-lookup"><span data-stu-id="63d9a-224">Therefore, it is important to close the thread handle with [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) when you are finished with it.</span></span> <span data-ttu-id="63d9a-225">Si vous devez attendre que le thread se termine par [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), veillez à ne pas fermer le descripteur tant que l’attente n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-225">If you will be waiting for the thread to terminate with [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), be sure to not close the handle until after the wait has completed.</span></span>

<span data-ttu-id="63d9a-226">Sur Xbox 360, vous devez assigner explicitement des threads logiciels à un thread matériel particulier à l’aide de **XSetThreadProcessor**.</span><span class="sxs-lookup"><span data-stu-id="63d9a-226">On Xbox 360, you must explicitly assign software threads to a particular hardware thread by using **XSetThreadProcessor**.</span></span> <span data-ttu-id="63d9a-227">Dans le cas contraire, tous les threads enfants resteront sur le même thread matériel que le parent.</span><span class="sxs-lookup"><span data-stu-id="63d9a-227">Otherwise, all child threads will stay on the same hardware thread as the parent.</span></span> <span data-ttu-id="63d9a-228">Sur Windows, vous pouvez utiliser [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) pour suggérer fortement au système d’exploitation les threads matériels sur lesquels votre thread doit s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="63d9a-228">On Windows, you can use [**SetThreadAffinityMask**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) to strongly suggest to the operating system which hardware threads your thread should run on.</span></span> <span data-ttu-id="63d9a-229">Cette technique doit généralement être évitée sur Windows, car vous ne savez pas quels autres processus sont en cours d’exécution sur le système.</span><span class="sxs-lookup"><span data-stu-id="63d9a-229">This technique should generally be avoided on Windows since you don't know what other processes might be running on the system.</span></span> <span data-ttu-id="63d9a-230">Il est généralement préférable de laisser le planificateur Windows attribuer vos threads aux threads de matériel inactifs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-230">It is typically better to let the Windows scheduler assign your threads to idle hardware threads.</span></span>

<span data-ttu-id="63d9a-231">La création de threads est une opération coûteuse.</span><span class="sxs-lookup"><span data-stu-id="63d9a-231">Creating threads is an expensive operation.</span></span> <span data-ttu-id="63d9a-232">Les threads doivent être créés et détruits rarement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-232">Threads should be created and destroyed rarely.</span></span> <span data-ttu-id="63d9a-233">Si vous souhaitez créer et détruire des threads fréquemment, utilisez un pool de threads qui attendent un travail à la place.</span><span class="sxs-lookup"><span data-stu-id="63d9a-233">If you find yourself wanting to create and destroy threads frequently, use a pool of threads that wait around for work instead.</span></span>

## <a name="synchronizing-threads"></a><span data-ttu-id="63d9a-234">Synchronisation des threads</span><span class="sxs-lookup"><span data-stu-id="63d9a-234">Synchronizing Threads</span></span>

<span data-ttu-id="63d9a-235">Pour que plusieurs threads fonctionnent ensemble, vous devez être en mesure de synchroniser des threads, de transmettre des messages et de demander un accès exclusif aux ressources.</span><span class="sxs-lookup"><span data-stu-id="63d9a-235">For multiple threads to work together, you must be able to synchronize threads, pass messages, and request exclusive access to resources.</span></span> <span data-ttu-id="63d9a-236">Windows et Xbox 360 sont fournis avec un ensemble complet de primitives de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-236">Windows and Xbox 360 come with a rich set of synchronization primitives.</span></span> <span data-ttu-id="63d9a-237">Pour plus d’informations sur ces primitives de synchronisation, consultez la documentation de la plateforme.</span><span class="sxs-lookup"><span data-stu-id="63d9a-237">For full details on these synchronization primitives, see the platform documentation.</span></span>

### <a name="exclusive-access"></a><span data-ttu-id="63d9a-238">Accès exclusif</span><span class="sxs-lookup"><span data-stu-id="63d9a-238">Exclusive Access</span></span>

<span data-ttu-id="63d9a-239">Obtenir un accès exclusif à une ressource, à une structure de données ou à un chemin de code est un besoin courant.</span><span class="sxs-lookup"><span data-stu-id="63d9a-239">Gaining exclusive access to a resource, data structure, or code path is a common need.</span></span> <span data-ttu-id="63d9a-240">Une option pour obtenir l’accès exclusif est un mutex, dont l’utilisation typique est indiquée ici.</span><span class="sxs-lookup"><span data-stu-id="63d9a-240">One option for gaining exclusive access is a mutex, whose typical usage is shown here.</span></span>


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



<span data-ttu-id="63d9a-241">Les sections critiques ont une sémantique similaire aux mutex, mais elles peuvent être utilisées pour synchroniser uniquement au sein d’un processus, et non entre les processus.</span><span class="sxs-lookup"><span data-stu-id="63d9a-241">Critical sections have similar semantics to mutexes, but they can be used to synchronize only within a process, not between processes.</span></span> <span data-ttu-id="63d9a-242">Leur principal avantage est qu’ils s’exécutent environ vingt fois plus rapidement que les mutex.</span><span class="sxs-lookup"><span data-stu-id="63d9a-242">Their main advantage is that they execute roughly twenty times faster than mutexes.</span></span>

### <a name="events"></a><span data-ttu-id="63d9a-243">Événements</span><span class="sxs-lookup"><span data-stu-id="63d9a-243">Events</span></span>

<span data-ttu-id="63d9a-244">Si deux threads (peut-être un thread de mise à jour et un thread de rendu) se mettent en forme à l’aide d’une paire de mémoires tampons de description de rendu, elles ont besoin d’un moyen d’indiquer quand elles sont effectuées avec leur mémoire tampon particulière.</span><span class="sxs-lookup"><span data-stu-id="63d9a-244">If two threads—perhaps an update thread and a render thread—are taking turns using a pair of render description buffers, they need a way to indicate when they are done with their particular buffer.</span></span> <span data-ttu-id="63d9a-245">Pour ce faire, vous pouvez associer un événement (alloué avec [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) à chaque mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="63d9a-245">This can be done by associating an event (allocated with [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) with each buffer.</span></span> <span data-ttu-id="63d9a-246">Quand un thread est effectué avec une mémoire tampon, il peut utiliser [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) pour signaler cela et peut ensuite appeler [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) sur l’événement de la mémoire tampon d’autre.</span><span class="sxs-lookup"><span data-stu-id="63d9a-246">When a thread is done with a buffer, it can use [**SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) to signal this, and can then call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) on the other buffer's event.</span></span> <span data-ttu-id="63d9a-247">Cette technique est facilement extrapolée à la triple mise en mémoire tampon des ressources.</span><span class="sxs-lookup"><span data-stu-id="63d9a-247">This technique extrapolates easily to triple buffering of resources.</span></span>

### <a name="semaphores"></a><span data-ttu-id="63d9a-248">Sémaphores</span><span class="sxs-lookup"><span data-stu-id="63d9a-248">Semaphores</span></span>

<span data-ttu-id="63d9a-249">Un sémaphore est utilisé pour contrôler le nombre de threads qui peuvent être en cours d’exécution et est couramment utilisé pour implémenter des files d’attente de travail.</span><span class="sxs-lookup"><span data-stu-id="63d9a-249">A semaphore is used to control how many threads can be running and is commonly used to implement work queues.</span></span> <span data-ttu-id="63d9a-250">Un thread ajoute du travail à une file d’attente et utilise [**ReleaseSemaphore,**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) chaque fois qu’il ajoute un nouvel élément à la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="63d9a-250">One thread adds work to a queue and uses [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) whenever it adds a new item to the queue.</span></span> <span data-ttu-id="63d9a-251">Cela permet de libérer un thread de travail à partir du pool de threads en attente.</span><span class="sxs-lookup"><span data-stu-id="63d9a-251">This allows one worker thread to be released from the pool of waiting threads.</span></span> <span data-ttu-id="63d9a-252">Les threads de travail appellent simplement [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)et, lorsqu’ils le renvoient, ils savent qu’il y a un élément de travail dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="63d9a-252">The worker threads just call [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), and when it returns they know there is a work item in the queue for them.</span></span> <span data-ttu-id="63d9a-253">En outre, une section critique ou une autre technique de synchronisation doit être utilisée afin de garantir un accès sécurisé à la file d’attente de travail partagée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-253">In addition, a critical section or other synchronization technique must be used in order to guarantee safe access to the shared work queue.</span></span>

### <a name="avoid-suspendthread"></a><span data-ttu-id="63d9a-254">Éviter SuspendThread</span><span class="sxs-lookup"><span data-stu-id="63d9a-254">Avoid SuspendThread</span></span>

<span data-ttu-id="63d9a-255">Parfois, lorsque vous souhaitez qu’un thread arrête ce qu’il fait, il est tentant d’utiliser [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) au lieu des primitives de synchronisation correctes.</span><span class="sxs-lookup"><span data-stu-id="63d9a-255">Sometimes when you want a thread to stop what it is doing, it is tempting to use [**SuspendThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) instead of the correct synchronization primitives.</span></span> <span data-ttu-id="63d9a-256">C’est toujours une mauvaise idée et peut facilement entraîner des interblocages et d’autres problèmes.</span><span class="sxs-lookup"><span data-stu-id="63d9a-256">This is always a bad idea and can easily lead to deadlocks and other problems.</span></span> <span data-ttu-id="63d9a-257">**SuspendThread** interagit également mal avec le débogueur Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="63d9a-257">**SuspendThread** also interacts badly with the Visual Studio debugger.</span></span> <span data-ttu-id="63d9a-258">Évitez le **SuspendThread**.</span><span class="sxs-lookup"><span data-stu-id="63d9a-258">Avoid **SuspendThread**.</span></span> <span data-ttu-id="63d9a-259">Utilisez à la place [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .</span><span class="sxs-lookup"><span data-stu-id="63d9a-259">Use [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) instead.</span></span>

### <a name="waitforsingleobject-and-waitformultipleobjects"></a><span data-ttu-id="63d9a-260">WaitForSingleObject et WaitForMultipleObjects</span><span class="sxs-lookup"><span data-stu-id="63d9a-260">WaitForSingleObject and WaitForMultipleObjects</span></span>

<span data-ttu-id="63d9a-261">La fonction [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) est la fonction de synchronisation la plus couramment utilisée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-261">The function [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) is the most commonly used synchronization function.</span></span> <span data-ttu-id="63d9a-262">Toutefois, parfois, vous souhaitez qu’un thread attende que plusieurs conditions soient satisfaites simultanément, ou jusqu’à ce que l’un des ensembles de conditions soit respecté.</span><span class="sxs-lookup"><span data-stu-id="63d9a-262">However, sometimes you want a thread to wait until several conditions are simultaneously satisfied, or until one of a set of conditions are satisfied.</span></span> <span data-ttu-id="63d9a-263">Dans ce cas, vous devez utiliser [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="63d9a-263">In this case, you should use [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

### <a name="interlocked-functions-and-lockless-programming"></a><span data-ttu-id="63d9a-264">Fonctions verrouillées et programmation en bloc</span><span class="sxs-lookup"><span data-stu-id="63d9a-264">Interlocked Functions and Lockless Programming</span></span>

<span data-ttu-id="63d9a-265">Il existe une famille de fonctions permettant d’effectuer des opérations thread-safe simples sans utiliser de verrous.</span><span class="sxs-lookup"><span data-stu-id="63d9a-265">There is a family of functions for performing simple thread-safe operations without using locks.</span></span> <span data-ttu-id="63d9a-266">Il s’agit de la famille de fonctions interverrouillées, telles que [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span><span class="sxs-lookup"><span data-stu-id="63d9a-266">These are the Interlocked family of functions, such as [**InterlockedIncrement**](/windows/win32/api/winnt/nf-winnt-interlockedincrement).</span></span> <span data-ttu-id="63d9a-267">Ces fonctions, ainsi que d’autres techniques qui utilisent un paramètre attentif des indicateurs, sont connues sous le nom de programmation avec verrouillage.</span><span class="sxs-lookup"><span data-stu-id="63d9a-267">These functions, plus other techniques using careful setting of flags, are together known as lockless programming.</span></span> <span data-ttu-id="63d9a-268">La programmation sans verrou peut être extrêmement difficile à effectuer correctement et est beaucoup plus difficile sur Xbox 360 que sur Windows.</span><span class="sxs-lookup"><span data-stu-id="63d9a-268">Lockless programming can be extremely tricky to do correctly, and is substantially more difficult on Xbox 360 than on Windows.</span></span>

<span data-ttu-id="63d9a-269">Pour plus d’informations sur la programmation sans verrous, consultez Considérations sur la [programmation sans blocage pour Xbox 360 et Microsoft Windows](./lockless-programming.md).</span><span class="sxs-lookup"><span data-stu-id="63d9a-269">For more information about programming without locks, see [Lockless Programming Considerations for Xbox 360 and Microsoft Windows](./lockless-programming.md).</span></span>

### <a name="minimizing-synchronization"></a><span data-ttu-id="63d9a-270">Minimisation de la synchronisation</span><span class="sxs-lookup"><span data-stu-id="63d9a-270">Minimizing Synchronization</span></span>

<span data-ttu-id="63d9a-271">Certaines méthodes de synchronisation sont plus rapides que d’autres.</span><span class="sxs-lookup"><span data-stu-id="63d9a-271">Some synchronization methods are faster than others.</span></span> <span data-ttu-id="63d9a-272">Toutefois, plutôt que d’optimiser votre code en choisissant les techniques de synchronisation les plus rapides possibles, il est généralement préférable d’effectuer une synchronisation moins fréquente.</span><span class="sxs-lookup"><span data-stu-id="63d9a-272">However, rather than optimizing your code by choosing the fastest synchronization techniques possible, it is usually better to synchronize less often.</span></span> <span data-ttu-id="63d9a-273">Cette opération est plus rapide que la synchronisation trop fréquente et facilite le débogage de code plus simple.</span><span class="sxs-lookup"><span data-stu-id="63d9a-273">This is faster than synchronizing too frequently, and it makes for simpler code that is easier to debug.</span></span>

<span data-ttu-id="63d9a-274">Certaines opérations, telles que l’allocation de mémoire, peuvent être amenées à utiliser des primitives de synchronisation pour fonctionner correctement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-274">Some operations, such as memory allocation, may have to use synchronization primitives in order to work correctly.</span></span> <span data-ttu-id="63d9a-275">Par conséquent, les allocations fréquentes à partir du segment de mémoire partagé par défaut entraînent une synchronisation fréquente, ce qui entraîne une perte de performances.</span><span class="sxs-lookup"><span data-stu-id="63d9a-275">Therefore, doing frequent allocations from the default shared heap will result in frequent synchronization, which will waste some performance.</span></span> <span data-ttu-id="63d9a-276">Éviter des allocations fréquentes ou utiliser des segments de mémoire par thread (à l’aide du segment de mémoire \_ sans \_ sérialisation si vous utilisez HeapCreate) peut éviter cette synchronisation masquée.</span><span class="sxs-lookup"><span data-stu-id="63d9a-276">Avoiding frequent allocations or using per-thread heaps (using HEAP\_NO\_SERIALIZE if you use HeapCreate) can avoid this hidden synchronization.</span></span>

<span data-ttu-id="63d9a-277">Une autre cause de la synchronisation masquée est D3DCREATE \_ multithread, ce qui entraîne l’utilisation par D3D sur Windows de la synchronisation sur de nombreuses opérations.</span><span class="sxs-lookup"><span data-stu-id="63d9a-277">Another cause of hidden synchronization is D3DCREATE\_MULTITHREADED, which causes D3D on Windows to use synchronization on many operations.</span></span> <span data-ttu-id="63d9a-278">(L’indicateur est ignoré sur la Xbox 360.)</span><span class="sxs-lookup"><span data-stu-id="63d9a-278">(The flag is ignored on Xbox 360.)</span></span>

<span data-ttu-id="63d9a-279">Les données par thread, également appelées « stockage local des threads », peuvent être un moyen important d’éviter la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-279">Per-thread data, also known as thread local storage, can be an important way of avoiding synchronization.</span></span> <span data-ttu-id="63d9a-280">Visual C++ vous permet de déclarer des variables globales comme étant par thread à l’aide de la syntaxe **\_ \_ declspec (thread)** .</span><span class="sxs-lookup"><span data-stu-id="63d9a-280">Visual C++ allows you to declare global variables as being per-thread with the **\_\_declspec(thread)** syntax.</span></span>


```C++
__declspec( thread ) int tls_i = 1;
```



<span data-ttu-id="63d9a-281">Cela permet à chaque thread du processus sa propre copie de TLS \_ i, qui peut être référencée en toute sécurité et efficacement sans nécessiter de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-281">This gives each thread in the process its own copy of tls\_i, which can be referenced safely and efficiently without requiring synchronization.</span></span>

<span data-ttu-id="63d9a-282">La technique **\_ \_ declspec (thread)** ne fonctionne pas avec les DLL chargées dynamiquement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-282">The **\_\_declspec(thread)** technique does not work with dynamically loaded DLLs.</span></span> <span data-ttu-id="63d9a-283">Si vous utilisez des DLL chargées dynamiquement, vous devez utiliser la famille de fonctions TLSAlloc pour implémenter le stockage local des threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-283">If you use dynamically loaded DLLs, you will need to use the TLSAlloc family of functions to implement thread local storage.</span></span>

## <a name="destroying-threads"></a><span data-ttu-id="63d9a-284">Destruction de threads</span><span class="sxs-lookup"><span data-stu-id="63d9a-284">Destroying Threads</span></span>

<span data-ttu-id="63d9a-285">La seule façon sûre de détruire un thread est de quitter le thread, soit en retournant à partir de la fonction de thread principale, soit en faisant en sorte que le thread appelle [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) ou [**\_ endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span><span class="sxs-lookup"><span data-stu-id="63d9a-285">The only safe way to destroy a thread is to have the thread itself exit, either by returning from the main thread function or by having the thread call [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) or [**\_endthreadex**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx).</span></span> <span data-ttu-id="63d9a-286">Si un thread est créé avec [**\_ beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), il doit utiliser **\_ endthreadex** ou retourner à partir de la fonction de thread principale, car l’utilisation de **EXITTHREAD** ne libère pas correctement les ressources CRT.</span><span class="sxs-lookup"><span data-stu-id="63d9a-286">If a thread is created with [**\_beginthreadex**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), then it should use **\_endthreadex** or return from the main thread function, since using **ExitThread** won't properly free CRT resources.</span></span> <span data-ttu-id="63d9a-287">N’appelez jamais la fonction [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , car le thread ne sera pas nettoyé correctement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-287">Never call the [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) function, because the thread will not be properly cleaned up.</span></span> <span data-ttu-id="63d9a-288">Les threads doivent toujours valider le suicide, ils ne doivent jamais être Murdered.</span><span class="sxs-lookup"><span data-stu-id="63d9a-288">Threads should always commit suicide—they should never be murdered.</span></span>

## <a name="openmp"></a><span data-ttu-id="63d9a-289">OpenMP</span><span class="sxs-lookup"><span data-stu-id="63d9a-289">OpenMP</span></span>

<span data-ttu-id="63d9a-290">OpenMP est une extension de langage qui permet d’ajouter du multithread à votre programme en utilisant des pragmas pour guider le compilateur dans les boucles de parallélisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-290">OpenMP is a language extension for adding multithreading to your program by using pragmas to guide the compiler in parallelizing loops.</span></span> <span data-ttu-id="63d9a-291">OpenMP est pris en charge par Visual C++ 2005 sur Windows et Xbox 360 et peut être utilisé conjointement avec la gestion manuelle des threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-291">OpenMP is supported by Visual C++ 2005 on Windows and Xbox 360 and can be used in conjunction with manual thread management.</span></span> <span data-ttu-id="63d9a-292">OpenMP peut être un moyen pratique d’effectuer des multithread parties de votre code, mais il est peu probable qu’il s’agit de la solution idéale, en particulier pour les jeux.</span><span class="sxs-lookup"><span data-stu-id="63d9a-292">OpenMP can be a convenient way to multithread parts of your code, but is unlikely to be the ideal solution, especially for games.</span></span> <span data-ttu-id="63d9a-293">OpenMP peut être plus applicable aux tâches de production plus longues, telles que le traitement d’art et d’autres ressources.</span><span class="sxs-lookup"><span data-stu-id="63d9a-293">OpenMP may be more applicable to longer-running production tasks such as processing art and other resources.</span></span> <span data-ttu-id="63d9a-294">Pour plus d’informations, consultez la documentation Visual C++ ou accédez au [site Web](https://www.openmp.org/)OpenMP.</span><span class="sxs-lookup"><span data-stu-id="63d9a-294">For more information, see the Visual C++ documentation or go to the OpenMP [website](https://www.openmp.org/).</span></span>

## <a name="profiling"></a><span data-ttu-id="63d9a-295">Profilage</span><span class="sxs-lookup"><span data-stu-id="63d9a-295">Profiling</span></span>

<span data-ttu-id="63d9a-296">Le profilage multithread est important.</span><span class="sxs-lookup"><span data-stu-id="63d9a-296">Multithreaded profiling is important.</span></span> <span data-ttu-id="63d9a-297">Il est facile de se retrouver avec de longues places où les threads sont en attente les uns sur les autres.</span><span class="sxs-lookup"><span data-stu-id="63d9a-297">It is easy to end up with long stalls where threads are waiting on each other.</span></span> <span data-ttu-id="63d9a-298">Ces blocages peuvent être difficiles à trouver et à diagnostiquer.</span><span class="sxs-lookup"><span data-stu-id="63d9a-298">These stalls can be difficult to find and diagnose.</span></span> <span data-ttu-id="63d9a-299">Pour faciliter leur identification, envisagez d’ajouter l’instrumentation à vos appels de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="63d9a-299">To help identify them, consider adding instrumentation to your synchronization calls.</span></span> <span data-ttu-id="63d9a-300">Un profileur d’échantillonnage peut également aider à identifier ces problèmes, car il peut enregistrer les informations de minutage sans les modifier sensiblement.</span><span class="sxs-lookup"><span data-stu-id="63d9a-300">A sampling profiler can also help identify these problems because it can record timing information without substantially altering it.</span></span>

## <a name="timing"></a><span data-ttu-id="63d9a-301">Minutage</span><span class="sxs-lookup"><span data-stu-id="63d9a-301">Timing</span></span>

<span data-ttu-id="63d9a-302">L’instruction RDTSC est un moyen d’accéder à des informations de temporisation précises sur Windows.</span><span class="sxs-lookup"><span data-stu-id="63d9a-302">The rdtsc instruction is one way to get accurate timing information on Windows.</span></span> <span data-ttu-id="63d9a-303">Malheureusement, RDTSC présente plusieurs problèmes qui en font un bon choix pour votre titre d’expédition.</span><span class="sxs-lookup"><span data-stu-id="63d9a-303">Unfortunately, rdtsc has multiple problems that make it a poor choice for your shipping title.</span></span> <span data-ttu-id="63d9a-304">Les compteurs RDTSC ne sont pas nécessairement synchronisés entre les processeurs. par conséquent, lorsque votre thread se déplace entre les threads matériels, vous pouvez recevoir des différences positives ou négatives importantes.</span><span class="sxs-lookup"><span data-stu-id="63d9a-304">The rdtsc counters are not necessarily synchronized between CPUs, so when your thread moves between hardware threads you may get large positive or negative differences.</span></span> <span data-ttu-id="63d9a-305">Selon les paramètres de gestion de l’alimentation, la fréquence à laquelle les incréments du compteur RDTSC peuvent également changer au fur et à mesure de l’exécution de votre jeu.</span><span class="sxs-lookup"><span data-stu-id="63d9a-305">Depending on power management settings, the frequency at which the rdtsc counter increments may also change as your game runs.</span></span> <span data-ttu-id="63d9a-306">Pour éviter ces difficultés, vous devez préférer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) et [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) pour une synchronisation à haute précision dans votre jeu d’expédition.</span><span class="sxs-lookup"><span data-stu-id="63d9a-306">To avoid these difficulties, you should prefer [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) and [**QueryPerformanceFrequency**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) for high-precision timing in your shipping game.</span></span> <span data-ttu-id="63d9a-307">Pour plus d’informations sur la synchronisation, consultez la page relative au [minutage des jeux et aux processeurs multicœurs](./game-timing-and-multicore-processors.md).</span><span class="sxs-lookup"><span data-stu-id="63d9a-307">For more information about timing, see [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md).</span></span>

## <a name="debugging"></a><span data-ttu-id="63d9a-308">Débogage</span><span class="sxs-lookup"><span data-stu-id="63d9a-308">Debugging</span></span>

<span data-ttu-id="63d9a-309">Visual Studio prend entièrement en charge le débogage multithread pour Windows et Xbox 360.</span><span class="sxs-lookup"><span data-stu-id="63d9a-309">Visual Studio fully supports multithreaded debugging for Windows and Xbox 360.</span></span> <span data-ttu-id="63d9a-310">La fenêtre threads Visual Studio vous permet de basculer entre les threads afin de voir les différentes piles d’appels et variables locales.</span><span class="sxs-lookup"><span data-stu-id="63d9a-310">The Visual Studio threads window lets you switch between threads in order to see the different call stacks and local variables.</span></span> <span data-ttu-id="63d9a-311">La fenêtre threads vous permet également de figer et de libérer des threads particuliers.</span><span class="sxs-lookup"><span data-stu-id="63d9a-311">The threads window also lets you freeze and thaw particular threads.</span></span>

<span data-ttu-id="63d9a-312">Sur Xbox 360, vous pouvez utiliser la variable méta **\@ hwthread** dans la fenêtre Espion pour afficher le thread matériel sur lequel le thread logiciel actuellement sélectionné est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="63d9a-312">On Xbox 360, you can use the **\@hwthread** meta-variable in the watch window to show the hardware thread on which the currently selected software thread is running.</span></span>

<span data-ttu-id="63d9a-313">La fenêtre threads est plus facile à utiliser si vous nommez vos threads de manière significative.</span><span class="sxs-lookup"><span data-stu-id="63d9a-313">The threads window is easier to use if you name your threads meaningfully.</span></span> <span data-ttu-id="63d9a-314">Visual Studio et d’autres débogueurs Microsoft vous permettent de nommer vos threads.</span><span class="sxs-lookup"><span data-stu-id="63d9a-314">Visual Studio and other Microsoft debuggers allow you to name your threads.</span></span> <span data-ttu-id="63d9a-315">Implémentez la fonction **SetThreadName** suivante et appelez-la à partir de chaque thread au démarrage.</span><span class="sxs-lookup"><span data-stu-id="63d9a-315">Implement the following **SetThreadName** function and call it from each thread as it starts up.</span></span>


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



<span data-ttu-id="63d9a-316">Le débogueur de noyau (KD) et WinDBG prennent également en charge le débogage multithread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-316">The kernel debugger (KD) and WinDBG also support multithreaded debugging.</span></span>

## <a name="testing"></a><span data-ttu-id="63d9a-317">Test</span><span class="sxs-lookup"><span data-stu-id="63d9a-317">Testing</span></span>

<span data-ttu-id="63d9a-318">La programmation multithread peut être délicate et certains bogues multithreads s’affichent rarement, ce qui les rend difficiles à trouver et à corriger.</span><span class="sxs-lookup"><span data-stu-id="63d9a-318">Multithreaded programming can be tricky, and some multithreaded bugs show up only rarely, making them difficult to find and fix.</span></span> <span data-ttu-id="63d9a-319">L’une des meilleures façons de les vider consiste à effectuer des tests sur un large éventail d’ordinateurs, en particulier ceux avec quatre processeurs ou plus.</span><span class="sxs-lookup"><span data-stu-id="63d9a-319">One of the best ways to flush them out is to test on a wide range of computers, particularly those with four or more processors.</span></span> <span data-ttu-id="63d9a-320">Le code multithread qui fonctionne parfaitement sur un ordinateur à thread unique peut échouer instantanément sur un ordinateur à quatre processeurs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-320">Multithreaded code that works perfectly on a single-threaded computer may fail instantly on a four-processor computer.</span></span> <span data-ttu-id="63d9a-321">Les caractéristiques de performances et de minutage des processeurs AMD et Intel peuvent varier considérablement. Veillez donc à tester sur les ordinateurs multiprocesseurs basés sur les processeurs des deux fournisseurs.</span><span class="sxs-lookup"><span data-stu-id="63d9a-321">The performance and timing characteristics of AMD and Intel CPUs can vary substantially, so be sure to test on multiprocessor computers based on CPUs from both vendors.</span></span>

## <a name="windows-vista-and-windows-7-improvements"></a><span data-ttu-id="63d9a-322">Améliorations apportées à Windows Vista et Windows 7</span><span class="sxs-lookup"><span data-stu-id="63d9a-322">Windows Vista and Windows 7 Improvements</span></span>

<span data-ttu-id="63d9a-323">Pour les jeux ciblant les versions plus récentes de Windows, il existe un certain nombre d’API qui peuvent simplifier la création d’applications multithread évolutives.</span><span class="sxs-lookup"><span data-stu-id="63d9a-323">For games targeting the newer versions of Windows, there are a number of APIs that can simplify the creation of scalable multithreaded applications.</span></span> <span data-ttu-id="63d9a-324">Cela est particulièrement vrai avec la nouvelle API ThreadPool et certaines primitives syncrhonziation supplémentaires (variables de condition, verrou de lecture/écriture allégé et initialisation unique).</span><span class="sxs-lookup"><span data-stu-id="63d9a-324">This is particularly true with the new ThreadPool API and some additional syncrhonziation primitives (condition variables, the slim read/writer lock, and one-time initialization).</span></span> <span data-ttu-id="63d9a-325">Vous trouverez une vue d’ensemble de ces technologies dans les articles suivants du magazine MSDN :</span><span class="sxs-lookup"><span data-stu-id="63d9a-325">You can find an overview of these technologies in the following MSDN Magazine articles:</span></span>

-   [<span data-ttu-id="63d9a-326">Améliorez l’évolutivité avec les nouvelles API de pool de threads</span><span class="sxs-lookup"><span data-stu-id="63d9a-326">Improve Scalability With New Thread Pool APIs</span></span>](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [<span data-ttu-id="63d9a-327">Nouvelles primitives de synchronisation avec Windows Vista</span><span class="sxs-lookup"><span data-stu-id="63d9a-327">Synchronization Primitives New To Windows Vista</span></span>](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

<span data-ttu-id="63d9a-328">Les applications utilisant les [fonctionnalités Direct3D 11](../direct3d11/direct3d-11-features.md) sur ces systèmes d’exploitation peuvent également tirer parti de la nouvelle conception pour la création d’objets simultanés et des listes de commandes de contexte différées pour une meilleure évolutivité pour le rendu multithread.</span><span class="sxs-lookup"><span data-stu-id="63d9a-328">Applications using [Direct3D 11 Features](../direct3d11/direct3d-11-features.md) on these operating systems can also take advantage of the new design for concurrent object creation and deferred context command lists for better scalability for multithreaded rendering.</span></span>

## <a name="summary"></a><span data-ttu-id="63d9a-329">Résumé</span><span class="sxs-lookup"><span data-stu-id="63d9a-329">Summary</span></span>

<span data-ttu-id="63d9a-330">Avec une conception minutieuse qui minimise les interactions entre les threads, vous pouvez bénéficier de gains de performances substantiels de la programmation multithread sans ajouter une complexité excessive à votre code.</span><span class="sxs-lookup"><span data-stu-id="63d9a-330">With careful design that minimizes the interactions between threads, you can get substantial performance gains from multithreaded programming without adding excessive complexity to your code.</span></span> <span data-ttu-id="63d9a-331">Cela permet à votre code de jeu d’ignorer la prochaine vague d’améliorations du processeur et de fournir des expériences de jeux plus attrayantes.</span><span class="sxs-lookup"><span data-stu-id="63d9a-331">This will let your game code ride the next wave of processor improvements and deliver ever more compelling gaming experiences.</span></span>

## <a name="references"></a><span data-ttu-id="63d9a-332">Références</span><span class="sxs-lookup"><span data-stu-id="63d9a-332">References</span></span>

-   <span data-ttu-id="63d9a-333">Jim Beveridge & Robert Weiner, *applications multithread dans Win32*, Addison-Wesley, 1997</span><span class="sxs-lookup"><span data-stu-id="63d9a-333">Jim Beveridge & Robert Weiner, *Multithreading Applications in Win32*, Addison-Wesley, 1997</span></span>
-   <span data-ttu-id="63d9a-334">Chuck Walbourn, [minutage des jeux et processeurs multicœurs](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span><span class="sxs-lookup"><span data-stu-id="63d9a-334">Chuck Walbourn, [Game Timing and Multicore Processors](./game-timing-and-multicore-processors.md), Microsoft Corporation, 2005</span></span>
-   <span data-ttu-id="63d9a-335">Bibliothèque MSDN : [ **GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span><span class="sxs-lookup"><span data-stu-id="63d9a-335">MSDN Library: [**GetLogicalProcessorInformation**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)</span></span>
-   [<span data-ttu-id="63d9a-336">OpenMP</span><span class="sxs-lookup"><span data-stu-id="63d9a-336">OpenMP</span></span>](https://www.openmp.org/)

 

 