---
description: La mémoire qui appartient à un processus est implicitement protégée par son espace d’adressage virtuel privé.
ms.assetid: 70ded07a-7be6-4189-a1ae-281917f42a1e
title: Protection de la mémoire
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bd30df8084c91a62c28414f4a8142397ee777e52
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104115919"
---
# <a name="memory-protection"></a><span data-ttu-id="67190-103">Protection de la mémoire</span><span class="sxs-lookup"><span data-stu-id="67190-103">Memory Protection</span></span>

<span data-ttu-id="67190-104">La mémoire qui appartient à un processus est implicitement protégée par son espace d’adressage virtuel privé.</span><span class="sxs-lookup"><span data-stu-id="67190-104">Memory that belongs to a process is implicitly protected by its private virtual address space.</span></span> <span data-ttu-id="67190-105">En outre, Windows fournit une protection de la mémoire à l’aide du matériel de mémoire virtuelle.</span><span class="sxs-lookup"><span data-stu-id="67190-105">In addition, Windows provides memory protection by using the virtual memory hardware.</span></span> <span data-ttu-id="67190-106">L’implémentation de cette protection varie en fonction du processeur, par exemple, les pages de codes de l’espace d’adressage d’un processus peuvent être marquées en lecture seule et protégées contre les modifications des threads en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="67190-106">The implementation of this protection varies with the processor, for example, code pages in the address space of a process can be marked read-only and protected from modification by user-mode threads.</span></span>

<span data-ttu-id="67190-107">Pour obtenir la liste complète des attributs, consultez [constantes de protection](memory-protection-constants.md)de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="67190-107">For the complete list of attributes, see [Memory Protection Constants](memory-protection-constants.md).</span></span>

## <a name="copy-on-write-protection"></a><span data-ttu-id="67190-108">Protection par copie sur écriture</span><span class="sxs-lookup"><span data-stu-id="67190-108">Copy-on-Write Protection</span></span>

<span data-ttu-id="67190-109">La protection par copie sur écriture est une optimisation qui permet à plusieurs processus de mapper leurs espaces d’adresses virtuelles de façon à ce qu’ils partagent une page physique jusqu’à ce que l’un des processus modifie la page.</span><span class="sxs-lookup"><span data-stu-id="67190-109">Copy-on-write protection is an optimization that allows multiple processes to map their virtual address spaces such that they share a physical page until one of the processes modifies the page.</span></span> <span data-ttu-id="67190-110">Cela fait partie d’une technique appelée *évaluation différée*, qui permet au système d’économiser la mémoire physique et le temps en n’effectuant pas d’opération tant qu’il n’est pas absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="67190-110">This is part of a technique called *lazy evaluation*, which allows the system to conserve physical memory and time by not performing an operation until absolutely necessary.</span></span>

<span data-ttu-id="67190-111">Par exemple, supposons que deux processus chargent des pages à partir de la même DLL dans leurs espaces de mémoire virtuelle.</span><span class="sxs-lookup"><span data-stu-id="67190-111">For example, suppose two processes load pages from the same DLL into their virtual memory spaces.</span></span> <span data-ttu-id="67190-112">Ces pages de mémoire virtuelle sont mappées aux mêmes pages de mémoire physique pour les deux processus.</span><span class="sxs-lookup"><span data-stu-id="67190-112">These virtual memory pages are mapped to the same physical memory pages for both processes.</span></span> <span data-ttu-id="67190-113">Tant qu’aucun processus n’écrit dans ces pages, ils peuvent mapper et partager les mêmes pages physiques, comme indiqué dans le diagramme suivant.</span><span class="sxs-lookup"><span data-stu-id="67190-113">As long as neither process writes to these pages, they can map to and share, the same physical pages, as shown in the following diagram.</span></span>

![zones et flèches des pages du processus 1 et 2 mappées à la même mémoire physique](images/mem1.png)

<span data-ttu-id="67190-115">Si le processus 1 écrit dans l’une de ces pages, le contenu de la page physique est copié vers une autre page physique et le mappage de mémoire virtuelle est mis à jour pour le processus 1.</span><span class="sxs-lookup"><span data-stu-id="67190-115">If Process 1 writes to one of these pages, the contents of the physical page are copied to another physical page and the virtual memory map is updated for Process 1.</span></span> <span data-ttu-id="67190-116">Les deux processus disposent désormais de leur propre instance de la page dans la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="67190-116">Both processes now have their own instance of the page in physical memory.</span></span> <span data-ttu-id="67190-117">Par conséquent, il n’est pas possible qu’un processus écrive sur une page physique partagée et que l’autre processus affiche les modifications.</span><span class="sxs-lookup"><span data-stu-id="67190-117">Therefore, it is not possible for one process to write to a shared physical page and for the other process to see the changes.</span></span>

![zones et flèches de processus et de remappage de la mémoire physique](images/mem2.png)

## <a name="loading-applications-and-dlls"></a><span data-ttu-id="67190-119">Chargement d’applications et de dll</span><span class="sxs-lookup"><span data-stu-id="67190-119">Loading Applications and DLLs</span></span>

<span data-ttu-id="67190-120">Lorsque plusieurs instances de la même application Windows sont chargées, chaque instance est exécutée dans son propre espace d’adressage virtuel protégé.</span><span class="sxs-lookup"><span data-stu-id="67190-120">When multiple instances of the same Windows-based application are loaded, each instance is run in its own protected virtual address space.</span></span> <span data-ttu-id="67190-121">Toutefois, leurs handles d’instance (*HINSTANCE*) ont généralement la même valeur.</span><span class="sxs-lookup"><span data-stu-id="67190-121">However, their instance handles (*hInstance*) typically have the same value.</span></span> <span data-ttu-id="67190-122">Cette valeur représente l’adresse de base de l’application dans son espace d’adressage virtuel.</span><span class="sxs-lookup"><span data-stu-id="67190-122">This value represents the base address of the application in its virtual address space.</span></span> <span data-ttu-id="67190-123">Si chaque instance peut être chargée dans son adresse de base par défaut, elle peut mapper et partager les mêmes pages physiques avec les autres instances, à l’aide de la protection de copie sur écriture.</span><span class="sxs-lookup"><span data-stu-id="67190-123">If each instance can be loaded into its default base address, it can map to and share the same physical pages with the other instances, using copy-on-write protection.</span></span> <span data-ttu-id="67190-124">Le système permet à ces instances de partager les mêmes pages physiques jusqu’à ce que l’une d’elles modifie une page.</span><span class="sxs-lookup"><span data-stu-id="67190-124">The system allows these instances to share the same physical pages until one of them modifies a page.</span></span> <span data-ttu-id="67190-125">Si, pour une raison quelconque, une de ces instances ne peut pas être chargée dans l’adresse de base souhaitée, elle reçoit ses propres pages physiques.</span><span class="sxs-lookup"><span data-stu-id="67190-125">If for some reason one of these instances cannot be loaded in the desired base address, it receives its own physical pages.</span></span>

<span data-ttu-id="67190-126">Les dll sont créées avec une adresse de base par défaut.</span><span class="sxs-lookup"><span data-stu-id="67190-126">DLLs are created with a default base address.</span></span> <span data-ttu-id="67190-127">Chaque processus qui utilise une DLL essaiera de charger la DLL dans son propre espace d’adressage à l’adresse virtuelle par défaut de la DLL.</span><span class="sxs-lookup"><span data-stu-id="67190-127">Every process that uses a DLL will try to load the DLL within its own address space at the default virtual address for the DLL.</span></span> <span data-ttu-id="67190-128">Si plusieurs applications peuvent charger une DLL à son adresse virtuelle par défaut, elles peuvent partager les mêmes pages physiques pour la DLL.</span><span class="sxs-lookup"><span data-stu-id="67190-128">If multiple applications can load a DLL at its default virtual address, they can share the same physical pages for the DLL.</span></span> <span data-ttu-id="67190-129">Si, pour une raison quelconque, un processus ne peut pas charger la DLL à l’adresse par défaut, il charge la DLL ailleurs.</span><span class="sxs-lookup"><span data-stu-id="67190-129">If for some reason a process cannot load the DLL at the default address, it loads the DLL elsewhere.</span></span> <span data-ttu-id="67190-130">La protection de copie sur écriture force certaines des pages de la DLL à être copiées dans différentes pages physiques pour ce processus, car les correctifs pour les instructions de saut sont écrits dans les pages de la DLL et sont différents pour ce processus.</span><span class="sxs-lookup"><span data-stu-id="67190-130">Copy-on-write protection forces some of the DLL's pages to be copied into different physical pages for this process, because the fixes for jump instructions are written within the DLL's pages, and they will be different for this process.</span></span> <span data-ttu-id="67190-131">Si la section de code contient de nombreuses références à la section de données, cela peut entraîner la copie de la section de code entière sur les nouvelles pages physiques.</span><span class="sxs-lookup"><span data-stu-id="67190-131">If the code section contains many references to the data section, this can cause the entire code section to be copied to new physical pages.</span></span>

 

 



