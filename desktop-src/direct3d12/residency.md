---
title: Résidence
description: Un objet est considéré comme résident lorsqu’il est accessible par le GPU.
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548570"
---
# <a name="residency"></a><span data-ttu-id="51d58-103">Résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-103">Residency</span></span>

<span data-ttu-id="51d58-104">Un objet est considéré comme *résident* lorsqu’il est accessible par le GPU.</span><span class="sxs-lookup"><span data-stu-id="51d58-104">An object is considered to be *resident* when it is accessible by the GPU.</span></span>

-   [<span data-ttu-id="51d58-105">Budget de la résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-105">Residency budget</span></span>](#residency-budget)
-   [<span data-ttu-id="51d58-106">Ressources du tas</span><span class="sxs-lookup"><span data-stu-id="51d58-106">Heap resources</span></span>](#heap-resources)
-   [<span data-ttu-id="51d58-107">Priorités de résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-107">Residency priorities</span></span>](#residency-priorities)
    -   [<span data-ttu-id="51d58-108">Algorithme de priorité par défaut</span><span class="sxs-lookup"><span data-stu-id="51d58-108">Default priority algorithm</span></span>](#default-priority-algorithm)
-   [<span data-ttu-id="51d58-109">Programmation de la gestion des compétences</span><span class="sxs-lookup"><span data-stu-id="51d58-109">Programming residency management</span></span>](#programming-residency-management)
-   [<span data-ttu-id="51d58-110">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="51d58-110">Related topics</span></span>](#related-topics)

## <a name="residency-budget"></a><span data-ttu-id="51d58-111">Budget de la résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-111">Residency budget</span></span>

<span data-ttu-id="51d58-112">Les GPU ne prennent pas encore en charge les pannes de page, de sorte que les applications doivent valider les données dans la mémoire physique alors que le GPU peut y accéder.</span><span class="sxs-lookup"><span data-stu-id="51d58-112">GPUs do not yet support page-faulting, so applications must commit data into physical memory while the GPU could access it.</span></span> <span data-ttu-id="51d58-113">Ce processus est appelé « créer un résident » et doit être effectué pour la mémoire système physique et la mémoire vidéo discrète physique.</span><span class="sxs-lookup"><span data-stu-id="51d58-113">This process is known as “making something resident”, and must be done for both physical system memory and physical discrete video memory.</span></span> <span data-ttu-id="51d58-114">Dans D3D12, la plupart des objets d’API encapsulent une certaine quantité de mémoire accessible par le GPU.</span><span class="sxs-lookup"><span data-stu-id="51d58-114">In D3D12, most API objects encapsulate some amount of GPU-accessible memory.</span></span> <span data-ttu-id="51d58-115">Cette mémoire accessible par GPU est rendue résidente pendant la création de l’objet API, et supprimée lors de la destruction de l’objet API.</span><span class="sxs-lookup"><span data-stu-id="51d58-115">That GPU-accessible memory is made resident during the creation of the API object, and evicted on API object destruction.</span></span>

<span data-ttu-id="51d58-116">La quantité de mémoire physique disponible pour le processus est connue sous le nom de budget de la mémoire vidéo.</span><span class="sxs-lookup"><span data-stu-id="51d58-116">The amount of physical memory available for the process is known as the video memory budget.</span></span> <span data-ttu-id="51d58-117">Le budget peut fluctuer de façon notable au fur et à mesure de l’éveil et du sommeil des processus d’arrière-plan ; et fluctuent considérablement lorsque l’utilisateur passe à une autre application.</span><span class="sxs-lookup"><span data-stu-id="51d58-117">The budget can fluctuate noticeably as background processes wake-up and sleep; and fluctuate dramatically when the user switches away to another application.</span></span> <span data-ttu-id="51d58-118">L’application peut être avertie lorsque le budget change et interroger à la fois le budget actuel et la quantité de mémoire actuellement consommée.</span><span class="sxs-lookup"><span data-stu-id="51d58-118">The application can be notified when the budget changes and poll both the current budget and the currently consumed amount of memory.</span></span> <span data-ttu-id="51d58-119">Si une application ne reste pas dans son budget, le processus sera gelé par intermittence pour permettre à d’autres applications de s’exécuter et/ou les API de création renverront un échec.</span><span class="sxs-lookup"><span data-stu-id="51d58-119">If an application doesn’t stay within its budget, the process will be intermittently frozen to allow other applications to run and/or the creation APIs will return failure.</span></span> <span data-ttu-id="51d58-120">L’interface [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) fournit les méthodes relatives à cette fonctionnalité, en particulier [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) et [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span><span class="sxs-lookup"><span data-stu-id="51d58-120">The [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) interface provides the methods pertaining to this functionality, in particular [**QueryVideoMemoryInfo**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) and [**RegisterVideoMemoryBudgetChangeNotificationEvent**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).</span></span>

<span data-ttu-id="51d58-121">Les applications sont encouragées à utiliser une réservation pour indiquer la quantité de mémoire qu’elles ne peuvent pas sans.</span><span class="sxs-lookup"><span data-stu-id="51d58-121">Applications are encouraged to use a reservation to denote the amount of memory they cannot go without.</span></span> <span data-ttu-id="51d58-122">Dans l’idéal, les paramètres graphiques « bas » spécifiés par l’utilisateur, ou encore moins, constituent la valeur appropriée pour une telle réservation.</span><span class="sxs-lookup"><span data-stu-id="51d58-122">Ideally, the user-specified “low” graphics settings, or something even lower, is the right value for such a reservation.</span></span> <span data-ttu-id="51d58-123">La définition d’une réservation ne donnera jamais à une application un budget plus élevé qu’elle ne le recevrait normalement.</span><span class="sxs-lookup"><span data-stu-id="51d58-123">Setting a reservation won’t ever give an application a higher budget than it would normally receive.</span></span> <span data-ttu-id="51d58-124">Au lieu de cela, les informations de réservation permettent au noyau du système d’exploitation de réduire rapidement l’impact d’une grande sollicitation de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="51d58-124">Instead, the reservation information helps the OS kernel quickly minimize the impact of large memory pressure situations.</span></span> <span data-ttu-id="51d58-125">Même la réservation n’est pas garantie d’être disponible pour l’application lorsque celle-ci n’est pas l’application de premier plan.</span><span class="sxs-lookup"><span data-stu-id="51d58-125">Even the reservation is not guaranteed to be available to the application when the application isn’t the foreground application.</span></span>

## <a name="heap-resources"></a><span data-ttu-id="51d58-126">Ressources du tas</span><span class="sxs-lookup"><span data-stu-id="51d58-126">Heap resources</span></span>

<span data-ttu-id="51d58-127">Bien que de nombreux objets API encapsulent une certaine mémoire accessible par GPU, les tas & ressources sont censés être les applications les plus significatives qui consomment et gèrent la mémoire physique.</span><span class="sxs-lookup"><span data-stu-id="51d58-127">While many API objects encapsulate some GPU-accessible memory, heaps & resources are expected to be the most significant way applications consume and manage physical memory.</span></span> <span data-ttu-id="51d58-128">Un segment de mémoire est l’unité de niveau le plus bas pour gérer la mémoire physique. il est donc judicieux de vous familiariser avec ses propriétés de résidence.</span><span class="sxs-lookup"><span data-stu-id="51d58-128">A heap is the lowest level unit to manage physical memory, so it’s good to have some familiarity with their residency properties.</span></span>

-   <span data-ttu-id="51d58-129">Les segments de mémoire ne peuvent pas être partiellement résidents, mais des solutions de contournement existent avec les ressources réservées.</span><span class="sxs-lookup"><span data-stu-id="51d58-129">Heaps cannot be made partially resident, but workarounds exists with reserved resources.</span></span>
-   <span data-ttu-id="51d58-130">Les segments de mémoire doivent être budgétés dans le cadre d’un pool particulier.</span><span class="sxs-lookup"><span data-stu-id="51d58-130">Heaps should be budgeted as part of a particular pool.</span></span> <span data-ttu-id="51d58-131">Les adaptateurs UMA possèdent un pool, tandis que les cartes discrètes ont deux pools.</span><span class="sxs-lookup"><span data-stu-id="51d58-131">UMA adapters have one pool, while discrete adapters have two pools.</span></span> <span data-ttu-id="51d58-132">S’il est vrai que le noyau peut déplacer certains segments de mémoire sur des cartes discrètes de la mémoire vidéo vers la mémoire système, il le fait uniquement en dernier recours extrême.</span><span class="sxs-lookup"><span data-stu-id="51d58-132">While it is true that kernel can shift some heaps on discrete adapters from video memory to system memory, it does so only as an extreme last resort.</span></span> <span data-ttu-id="51d58-133">Les applications ne doivent pas s’appuyer sur le comportement de dépassement de budget du noyau et doivent plutôt se concentrer sur une bonne gestion du budget.</span><span class="sxs-lookup"><span data-stu-id="51d58-133">Applications should not rely on the over-budget behavior of the kernel, and should focus on good budget management instead.</span></span>
-   <span data-ttu-id="51d58-134">Les segments de mémoire peuvent être supprimés de la résidence, ce qui permet de paginer leur contenu sur le disque.</span><span class="sxs-lookup"><span data-stu-id="51d58-134">Heaps can be evicted from residency, which allows their content to be paged out to disk.</span></span> <span data-ttu-id="51d58-135">Toutefois, la destruction des segments de mémoire est une technique plus fiable pour libérer la résidence sur toutes les architectures d’adaptateur.</span><span class="sxs-lookup"><span data-stu-id="51d58-135">But, destruction of heaps is a more reliable technique to free up residency across all adapter architectures.</span></span> <span data-ttu-id="51d58-136">Sur les adaptateurs où le champ *theMaxGPUVirtualAddressBitsPerProcess* de la [**\_ \_ \_ \_ \_ \_ prise en charge des adresses virtuelles du GPU des données de fonctionnalités D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) est proche de la taille du budget, la [**suppression**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) ne permet pas de récupérer de façon fiable la résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-136">On adapters where *theMaxGPUVirtualAddressBitsPerProcess* field of [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) is near the budget size, [**Evict**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) won’t reliably reclaim residency.</span></span>
-   <span data-ttu-id="51d58-137">La création du tas peut être lente ; Toutefois, il est optimisé pour le traitement des threads en arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="51d58-137">Heap creation can be slow; but it is optimized for background thread processing.</span></span> <span data-ttu-id="51d58-138">Il est recommandé de créer des tas sur les threads d’arrière-plan pour éviter de faire tourner le thread de rendu.</span><span class="sxs-lookup"><span data-stu-id="51d58-138">It’s recommended to create heaps on background threads to avoid glitching the render thread.</span></span> <span data-ttu-id="51d58-139">Dans D3D12, plusieurs threads peuvent appeler en toute sécurité des routines de création simultanément.</span><span class="sxs-lookup"><span data-stu-id="51d58-139">In D3D12, multiple threads may safely call create routines concurrently.</span></span>

<span data-ttu-id="51d58-140">D3D12 apporte plus de flexibilité et d’orthogonalité à son modèle de ressources afin d’activer davantage d’options pour les applications.</span><span class="sxs-lookup"><span data-stu-id="51d58-140">D3D12 introduces more flexibility and orthogonality into its resource model in order to enable more options for applications.</span></span> <span data-ttu-id="51d58-141">Il existe trois types de ressources de haut niveau dans D3D12 : validées, placées et réservées.</span><span class="sxs-lookup"><span data-stu-id="51d58-141">There are three high-level types of resources in D3D12: committed, placed, and reserved.</span></span>

-   <span data-ttu-id="51d58-142">Les ressources validées créent une ressource et un segment de mémoire en même temps.</span><span class="sxs-lookup"><span data-stu-id="51d58-142">Committed resources create both a resource and a heap at the same time.</span></span> <span data-ttu-id="51d58-143">Le segment de mémoire est implicite et n’est pas accessible directement.</span><span class="sxs-lookup"><span data-stu-id="51d58-143">The heap is implicit and cannot be accessed directly.</span></span> <span data-ttu-id="51d58-144">Le tas est dimensionné correctement pour localiser la ressource entière dans le segment de mémoire.</span><span class="sxs-lookup"><span data-stu-id="51d58-144">The heap is appropriately sized to locate the entire resource within the heap.</span></span>
-   <span data-ttu-id="51d58-145">Les ressources placées permettent de placer une ressource à un offset différent de zéro au sein d’un segment de mémoire.</span><span class="sxs-lookup"><span data-stu-id="51d58-145">Placed resources allow the placement of a resource at a non-zero offset within a heap.</span></span> <span data-ttu-id="51d58-146">Les décalages doivent généralement être alignés à 64 Ko ; Toutefois, certaines exceptions existent dans les deux sens.</span><span class="sxs-lookup"><span data-stu-id="51d58-146">Offsets must typically be aligned to 64KB; but some exceptions exist in both directions.</span></span> <span data-ttu-id="51d58-147">Les ressources MSAA nécessitent un alignement de décalage de 4 Mo, et 4 Ko d’alignement de décalage sont disponibles pour les petites textures.</span><span class="sxs-lookup"><span data-stu-id="51d58-147">MSAA resources require 4MB offset alignment, and 4KB offset alignment is available for small textures.</span></span> <span data-ttu-id="51d58-148">Les ressources placées ne peuvent pas être déplacées ou remappées directement à un autre segment de mémoire. mais elles permettent un déplacement simple des données de ressources entre les tas.</span><span class="sxs-lookup"><span data-stu-id="51d58-148">Placed resources cannot be relocated or remapped to another heap directly; but they enable simple relocation of the resource data between heaps.</span></span> <span data-ttu-id="51d58-149">Après la création d’une ressource passée dans un segment de mémoire différent et la copie des données de ressource, de nouveaux descripteurs de ressources doivent être utilisés pour l’emplacement des données de la nouvelle ressource.</span><span class="sxs-lookup"><span data-stu-id="51d58-149">After creating a new placed resource in a different heap and copying the resource data, new resource descriptors will have to be used for the new resource data location.</span></span>
-   <span data-ttu-id="51d58-150">Les ressources réservées sont disponibles uniquement lorsque l’adaptateur prend en charge les ressources en mosaïque niveau 1 ou supérieur.</span><span class="sxs-lookup"><span data-stu-id="51d58-150">Reserved resources are only available when the adapter supports tiled resources tier 1 or greater.</span></span> <span data-ttu-id="51d58-151">Lorsqu’ils sont disponibles, ils proposent les techniques de gestion de résidence les plus avancées disponibles. mais tous les adaptateurs ne les prennent pas en charge actuellement.</span><span class="sxs-lookup"><span data-stu-id="51d58-151">When available, they offer the most advanced residency management techniques available; but not all adapters currently support them.</span></span> <span data-ttu-id="51d58-152">Ils permettent de remapper une ressource sans avoir à régénérer les descripteurs de ressources, les dépassements partiels de la résidence du niveau MIP et les scénarios de texture éparse, etc. Les types de ressources ne sont pas tous pris en charge, même lorsque les ressources réservées sont disponibles. un gestionnaire de délégation de site entièrement général basé sur des pages n’est pas encore faisable.</span><span class="sxs-lookup"><span data-stu-id="51d58-152">They enable remapping a resource without requiring regeneration of resource descriptors, partial mip level residency, and sparse texture scenarios, etc. Not all resources types are supported even when reserved resources are available, so a fully general page-based residency manager isn’t yet feasible.</span></span>

## <a name="residency-priorities"></a><span data-ttu-id="51d58-153">Priorités de résidence</span><span class="sxs-lookup"><span data-stu-id="51d58-153">Residency priorities</span></span>

<span data-ttu-id="51d58-154">La mise à jour de Windows 10 Creators permet aux développeurs d’influencer les tas et les ressources qui seront préférés pour rester résidents lorsque la sollicitation de la mémoire nécessite que certaines de ses ressources soient rétrogradées.</span><span class="sxs-lookup"><span data-stu-id="51d58-154">The Windows 10 Creators Update enables developers to influence which heaps and resources will be prefered to stay resident when memory pressure requires that some of its resources be demoted.</span></span> <span data-ttu-id="51d58-155">Cela permet aux développeurs de créer des applications plus performantes en tirant parti de la connaissance que le runtime ne peut pas déduire de l’utilisation de l’API.</span><span class="sxs-lookup"><span data-stu-id="51d58-155">This helps developers create better performing applications by leveraging knowlege that the runtime can't infer from API usage.</span></span> <span data-ttu-id="51d58-156">Il s’attend à ce que les développeurs soient plus confortables et en mesure de spécifier des priorités lorsqu’ils passent de l’utilisation des ressources validées aux ressources réservée, et en mosaïque.</span><span class="sxs-lookup"><span data-stu-id="51d58-156">Its expected that developers will become more comfortable and capable specifying priorities as they transition from using commited resources to resereved and tiled resources.</span></span>

<span data-ttu-id="51d58-157">L’application de ces priorités doit être plus facile que la gestion de deux budgets de mémoire dynamique, la rétrogradation manuelle et la promotion des ressources bettween, car les applications peuvent déjà le faire.</span><span class="sxs-lookup"><span data-stu-id="51d58-157">Applying these priorities must be easier than manageing two dynamic memory budgets, manually demoting and promoting resources bettween them, since applications can already do that.</span></span> <span data-ttu-id="51d58-158">Par conséquent, la conception de l’API de priorité de la résidence est à la une des priorités par défaut assignées à chaque segment de mémoire ou ressource comme créé.</span><span class="sxs-lookup"><span data-stu-id="51d58-158">Therefore, the design of the residency priority API is coursely-grained with reasonable default priorities assigned to each heap or resource as its created.</span></span> <span data-ttu-id="51d58-159">Pour plus d’informations, consultez [**ID3D12Device1 :: SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) et l’énumération priorité de la [**délégation de \_ site \_ D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) .</span><span class="sxs-lookup"><span data-stu-id="51d58-159">For more information, see [**ID3D12Device1::SetResidencyPriority**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) and the [**D3D12\_RESIDENCY\_PRIORITY**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) enumeration.</span></span>

<span data-ttu-id="51d58-160">Avec les priorités, les développeurs sont censés :</span><span class="sxs-lookup"><span data-stu-id="51d58-160">With priorities, developers are expected to either:</span></span>

-   <span data-ttu-id="51d58-161">Augmentez la priorité de quelques tas exceptionnels pour mieux atténuer l’impact de ces tas sur les performances rencontrées plus tôt ou plus fréquemment que leurs modèles d’accès naturel.</span><span class="sxs-lookup"><span data-stu-id="51d58-161">Raise the priority of a few exceptional heaps to better mitigate the experienced performance impact of these heaps being demoted sooner or more frequently than their natural access patterns would demand.</span></span> <span data-ttu-id="51d58-162">Cette approche doit être exploitée par les applications portées à partir d’API graphiques telles que Direct3D 11 ou OpenGL, le modèle de gestion des ressources qui est très différent de celui de Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="51d58-162">This approach is expected to be leveraged by applications ported from graphics APIs such as Direct3D 11 or OpenGL, who's resource management model is significantly different than that of Direct3D 12.</span></span>
-   <span data-ttu-id="51d58-163">Substituez presque toutes les priorités de tas avec le schéma de compartimentage propre à l’application, résolu, en fonction de la connaissance de la fréquence d’accès du programmeur, ou dynamique. un schéma fixe est plus simple à gérer qu’un schéma dynamique, mais peut être moins efficace et nécessiter le programmeur boîte comme un changement de modèle d’utilisation au cours du développement.</span><span class="sxs-lookup"><span data-stu-id="51d58-163">Override nearly all heap priorities with the application's own bucketization scheme, either fixed, based on the programmer's knowlege of access frequency, or dynamic; a fixed scheme is simpler to manage than a dynamic one, but can be less effective and require programmer intevention as use patterns change over the course of development.</span></span> <span data-ttu-id="51d58-164">Cette approche doit être exploitée par les applications créées avec la gestion des ressources de type Direct3D 12 à l’esprit, telles que celles qui utilisent la bibliothèque de résidence (en particulier les schémas dynamiques).</span><span class="sxs-lookup"><span data-stu-id="51d58-164">This approach is expected to be leveraged by applications that are built with Direct3D 12-style resource management in mind, such as those that use the residency library (especially dynamic schemes).</span></span>

### <a name="default-priority-algorithm"></a><span data-ttu-id="51d58-165">Algorithme de priorité par défaut</span><span class="sxs-lookup"><span data-stu-id="51d58-165">Default priority algorithm</span></span>

<span data-ttu-id="51d58-166">Une application ne peut pas spécifier de priorités utiles pour un segment de mémoire qu’elle tente de gérer sans avoir au préalable utilisé l’algorithme de priorité par défaut.</span><span class="sxs-lookup"><span data-stu-id="51d58-166">An application can't specify useful priorities for any heap it attempts to manage without first understaning the default priority algorithm.</span></span> <span data-ttu-id="51d58-167">Cela est dû au fait que la valeur de l’affectation d’une priorité particulière à un segment de mémoire est dérivée de sa priorité relative à d’autres tas classés par ordre de priorité qui sont en concurrence pour la même mémoire.</span><span class="sxs-lookup"><span data-stu-id="51d58-167">This is because the value of assigning a particular priority to a heap is derived from its relative priority to other prioritized heaps that compete for the same memory.</span></span>

<span data-ttu-id="51d58-168">La stratégie choisie pour générer des priorités par défaut consiste à classer les tas en deux compartiments, en privilégiant (donnant une priorité plus élevée) les tas supposés être écrits fréquemment par le GPU sur les tas qui ne le sont pas.</span><span class="sxs-lookup"><span data-stu-id="51d58-168">The strategy chosen for generating default priorities is to categorize heaps into two buckets, favoring (giving higher priority to) heaps that are assumed to be written frequently by the GPU over heaps that aren't.</span></span>

<span data-ttu-id="51d58-169">Le compartiment haute priorité contient des tas et des ressources qui sont créés avec des indicateurs qui les identifient comme cibles de rendu, mémoires tampons de stencil de profondeur ou vues d’accès non ordonnées (UAVs).</span><span class="sxs-lookup"><span data-stu-id="51d58-169">The high-priority bucket contains heaps and resources that are created with flags that identify them as render targets, depth-stencil buffers, or Unordered Access Views (UAVs).</span></span> <span data-ttu-id="51d58-170">Il s’agit de valeurs de priorité affectées dans la plage commençant à la **priorité de délégation de D3D12 \_ \_ \_ élevée**. pour améliorer la priorité entre ces tas et les ressources, les 16 bits les plus bas de la priorité sont définis sur la taille du segment de mémoire ou de la ressource divisée par 10 Mo (en saturant à 0xFFFF pour les tas extrêmement volumineux).</span><span class="sxs-lookup"><span data-stu-id="51d58-170">These are assigned priority values in the range starting at **D3D12\_RESIDENCY\_PRIORITY\_HIGH**; to further prioritize among these heaps and resources, the lowest 16-bits of the priority are set to the size of the heap or resource divided by 10MB (saturating to 0xFFFF for extremely large heaps).</span></span> <span data-ttu-id="51d58-171">Cette définition de priorités supplémentaire favorise les tas et les ressources de plus grande taille.</span><span class="sxs-lookup"><span data-stu-id="51d58-171">This additional prioritization favors larger heaps and resources.</span></span>

<span data-ttu-id="51d58-172">Le compartiment à priorité basse contient tous les autres segments et ressources, auxquels sont affectées une valeur de priorité de la priorité de la **\_ résidence D3D12 \_ \_ normale**.</span><span class="sxs-lookup"><span data-stu-id="51d58-172">The low-priority bucket contains all other heaps and resources, which are assigned a priority value of **D3D12\_RESIDENCY\_PRIORITY\_NORMAL**.</span></span> <span data-ttu-id="51d58-173">Aucune autre définition de priorité n’est effectuée entre ces tas et les ressources.</span><span class="sxs-lookup"><span data-stu-id="51d58-173">No further prioritization among these heaps and resources is attempted.</span></span>

## <a name="programming-residency-management"></a><span data-ttu-id="51d58-174">Programmation de la gestion des compétences</span><span class="sxs-lookup"><span data-stu-id="51d58-174">Programming residency management</span></span>

<span data-ttu-id="51d58-175">Les applications simples peuvent être en mesure de créer des ressources validées uniquement jusqu’à ce qu’elles rencontrent des défaillances de mémoire insuffisante.</span><span class="sxs-lookup"><span data-stu-id="51d58-175">Simple applications may be able to get by merely creating committed resources until experiencing out-of-memory failures.</span></span> <span data-ttu-id="51d58-176">En cas de défaillance, l’application peut détruire d’autres ressources ou objets API validés pour permettre à d’autres créations de ressources de s’effectuer correctement.</span><span class="sxs-lookup"><span data-stu-id="51d58-176">Upon failure, the application can destroy other committed resources or API objects to enable further resource creations to succeed.</span></span> <span data-ttu-id="51d58-177">Toutefois, il est vivement recommandé d’utiliser des applications simples pour surveiller les modifications de budget négatives et de détruire les objets API inutilisés à peu près une fois de cadre.</span><span class="sxs-lookup"><span data-stu-id="51d58-177">But, even simple applications are strongly recommended to watch for negative budget changes and destroy unused API objects roughly once a frame.</span></span>

<span data-ttu-id="51d58-178">La complexité d’une conception de gestion des dépassements s’affiche lorsque vous essayez d’optimiser les architectures d’adaptateur ou d’incorporer des priorités de résidence.</span><span class="sxs-lookup"><span data-stu-id="51d58-178">The complexity of a residency management design will go up when trying to optimize for adapter architectures or incorporating residency priorities.</span></span> <span data-ttu-id="51d58-179">La budgétisation et la gestion discrètes de deux pools de mémoire discrète seront plus complexes que la gestion d’une seule, et l’affectation de priorités fixes sur une grande échelle peut devenir une charge de maintenance si les modèles d’utilisation évoluent.</span><span class="sxs-lookup"><span data-stu-id="51d58-179">Discretely budgeting and managing two pools of discrete memory will be more complex than managing only one, and assigning fixed priorities on a wide scale can become a maintainance burden if use patterns evolve.</span></span> <span data-ttu-id="51d58-180">Le débordement des textures dans la mémoire système augmente la complexité, car la mauvaise ressource dans la mémoire système peut avoir un impact considérable sur la fréquence d’images.</span><span class="sxs-lookup"><span data-stu-id="51d58-180">Overflowing textures into system memory adds more complexity, as the wrong resource in system-memory can severely impact frame rate.</span></span> <span data-ttu-id="51d58-181">De plus, il n’existe aucune fonctionnalité simple permettant d’identifier les ressources qui tireraient parti d’une plus grande bande passante GPU ou tolérer une faible bande passante GPU.</span><span class="sxs-lookup"><span data-stu-id="51d58-181">And, there is no simple functionality to help identify the resources that would either benefit from higher GPU bandwidth or tolerate lower GPU bandwidth.</span></span>

<span data-ttu-id="51d58-182">Des conceptions encore plus compliquées interrogeront les fonctionnalités de l’adaptateur actuel.</span><span class="sxs-lookup"><span data-stu-id="51d58-182">Even more complicated designs will query for the features of the current adapter.</span></span> <span data-ttu-id="51d58-183">Ces informations sont disponibles dans [**\_ \_ \_ \_ la \_ \_ prise en charge des adresses virtuelles du GPU de données de la fonctionnalité D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), de l' [**\_ \_ \_ architecture des données de fonctionnalités D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), du [**\_ \_ \_ niveau des ressources en mosaïque D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)et du [**\_ \_ \_ niveau du tas de ressources D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span><span class="sxs-lookup"><span data-stu-id="51d58-183">This information is available in [**D3D12\_FEATURE\_DATA\_GPU\_VIRTUAL\_ADDRESS\_SUPPORT**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**D3D12\_FEATURE\_DATA\_ARCHITECTURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**D3D12\_TILED\_RESOURCES\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier), and [**D3D12\_RESOURCE\_HEAP\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).</span></span>

<span data-ttu-id="51d58-184">Plusieurs parties d’une application sont susceptibles d’être reportées à l’aide de différentes techniques.</span><span class="sxs-lookup"><span data-stu-id="51d58-184">Multiple parts of an application will likely wind up using different techniques.</span></span> <span data-ttu-id="51d58-185">Par exemple, certaines textures volumineuses et des chemins de code rarement testés peuvent utiliser des ressources validées, tandis que de nombreuses textures peuvent être désignées avec une propriété de streaming et utiliser une technique de ressource imposée générale.</span><span class="sxs-lookup"><span data-stu-id="51d58-185">For example, some large textures and rarely exercised code paths may use committed resources, while many textures may be designated with a streaming property and use a general placed-resource technique.</span></span>

## <a name="related-topics"></a><span data-ttu-id="51d58-186">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="51d58-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="51d58-187">**ID3D12Heap**</span><span class="sxs-lookup"><span data-stu-id="51d58-187">**ID3D12Heap**</span></span>](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[<span data-ttu-id="51d58-188">Gestion de la mémoire</span><span class="sxs-lookup"><span data-stu-id="51d58-188">Memory Management</span></span>](memory-management.md)
</dt> </dl>

 

 