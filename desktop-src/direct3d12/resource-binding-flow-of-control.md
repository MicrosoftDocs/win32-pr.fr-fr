---
title: Vue d’ensemble de la liaison de ressources
description: La clé de la liaison de ressources dans DirectX 12 est l’un des concepts d’un descripteur, de tables de descripteurs, de tas de descripteurs et d’une signature racine.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bc7e78255c123777716eddb43d9443e19113b34
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104042"
---
# <a name="resource-binding-overview"></a><span data-ttu-id="f1df4-103">Vue d’ensemble de la liaison de ressources</span><span class="sxs-lookup"><span data-stu-id="f1df4-103">Resource Binding Overview</span></span>

<span data-ttu-id="f1df4-104">La clé de la liaison de ressources dans DirectX 12 est l’un des concepts d’un *descripteur*, de *tables de descripteurs*, de *tas de descripteurs* et d’une *signature racine*.</span><span class="sxs-lookup"><span data-stu-id="f1df4-104">The key to resource binding in DirectX 12 are the concepts of a *descriptor*, *descriptor tables*, *descriptor heaps*, and a *root signature*.</span></span>

-   [<span data-ttu-id="f1df4-105">Ressources et pipeline graphique</span><span class="sxs-lookup"><span data-stu-id="f1df4-105">Resources and the Graphics Pipeline</span></span>](#resources-and-the-graphics-pipeline)
-   [<span data-ttu-id="f1df4-106">Types et vues de ressources</span><span class="sxs-lookup"><span data-stu-id="f1df4-106">Resource types and views</span></span>](#resource-types-and-views)
-   [<span data-ttu-id="f1df4-107">Workflow de liaison de ressources de contrôle</span><span class="sxs-lookup"><span data-stu-id="f1df4-107">Resource Binding Flow of Control</span></span>](#resource-binding-overview)
-   [<span data-ttu-id="f1df4-108">Sous-allocation</span><span class="sxs-lookup"><span data-stu-id="f1df4-108">Suballocation</span></span>](#suballocation)
-   [<span data-ttu-id="f1df4-109">Libération des ressources</span><span class="sxs-lookup"><span data-stu-id="f1df4-109">Freeing Resources</span></span>](#freeing-resources)
-   [<span data-ttu-id="f1df4-110">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="f1df4-110">Related topics</span></span>](#related-topics)

## <a name="resources-and-the-graphics-pipeline"></a><span data-ttu-id="f1df4-111">Ressources et pipeline graphique</span><span class="sxs-lookup"><span data-stu-id="f1df4-111">Resources and the Graphics Pipeline</span></span>

<span data-ttu-id="f1df4-112">Les ressources de nuanceur (telles que les textures, les tables constantes, les images, les mémoires tampons, etc.) ne sont pas directement liées au pipeline de nuanceur. au lieu de cela, ils sont référencés via un *descripteur*.</span><span class="sxs-lookup"><span data-stu-id="f1df4-112">Shader resources (such as textures, constant tables, images, buffers and so on) are not bound directly to the shader pipeline; instead, they are referenced through a *descriptor*.</span></span> <span data-ttu-id="f1df4-113">Un descripteur est un petit objet qui contient des informations sur une ressource.</span><span class="sxs-lookup"><span data-stu-id="f1df4-113">A descriptor is a small object that contains information about one resource.</span></span>

<span data-ttu-id="f1df4-114">Les descripteurs sont regroupés en *tables* de descripteurs de formulaire.</span><span class="sxs-lookup"><span data-stu-id="f1df4-114">Descriptors are grouped together to form *descriptor tables*.</span></span> <span data-ttu-id="f1df4-115">Chaque table de descripteur stocke des informations sur une plage de types de ressources.</span><span class="sxs-lookup"><span data-stu-id="f1df4-115">Each descriptor table stores information about one range of types of resource.</span></span> <span data-ttu-id="f1df4-116">Il existe de nombreux types de ressources.</span><span class="sxs-lookup"><span data-stu-id="f1df4-116">There are many different types of resources.</span></span> <span data-ttu-id="f1df4-117">Les ressources les plus courantes sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="f1df4-117">The most common resources are:</span></span>

-   <span data-ttu-id="f1df4-118">Vues de mémoire tampon constante (CBVs)</span><span class="sxs-lookup"><span data-stu-id="f1df4-118">Constant buffer views (CBVs)</span></span>
-   <span data-ttu-id="f1df4-119">Vues d’accès non ordonnées (UAVs)</span><span class="sxs-lookup"><span data-stu-id="f1df4-119">Unordered access views (UAVs)</span></span>
-   <span data-ttu-id="f1df4-120">Vues des ressources de nuanceur (SRVs)</span><span class="sxs-lookup"><span data-stu-id="f1df4-120">Shader resource views (SRVs)</span></span>
-   <span data-ttu-id="f1df4-121">Échantillonneurs</span><span class="sxs-lookup"><span data-stu-id="f1df4-121">Samplers</span></span>

<span data-ttu-id="f1df4-122">Les descripteurs SRV, UAV et CBVs peuvent être combinés dans la même table de descripteurs.</span><span class="sxs-lookup"><span data-stu-id="f1df4-122">SRV, UAV, and CBVs descriptors can be combined into the same descriptor table.</span></span>

<span data-ttu-id="f1df4-123">Les pipelines graphiques et de calcul accèdent aux ressources en faisant référence aux tables de descripteurs par index.</span><span class="sxs-lookup"><span data-stu-id="f1df4-123">The graphics and compute pipelines gain access to resources by referencing into descriptor tables by index.</span></span>

<span data-ttu-id="f1df4-124">Les tables de descripteurs sont stockées dans un *tas de descripteur*.</span><span class="sxs-lookup"><span data-stu-id="f1df4-124">Descriptor tables are stored in a *descriptor heap*.</span></span> <span data-ttu-id="f1df4-125">Dans l’idéal, les tas de descripteurs contiennent tous les descripteurs (dans les tables de descripteurs) pour un ou plusieurs frames à restituer.</span><span class="sxs-lookup"><span data-stu-id="f1df4-125">Descriptor heaps will ideally contain all the descriptors (in descriptor tables) for one or more frames to be rendered.</span></span> <span data-ttu-id="f1df4-126">Toutes les ressources sont stockées dans des tas en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="f1df4-126">All the resources will be stored in user mode heaps.</span></span>

<span data-ttu-id="f1df4-127">Un autre concept est celui d’une *signature racine*.</span><span class="sxs-lookup"><span data-stu-id="f1df4-127">Another concept is that of a *root signature*.</span></span> <span data-ttu-id="f1df4-128">La signature racine est une convention de liaison, définie par l’application, qui est utilisée par les nuanceurs pour localiser les ressources auxquelles elle doit accéder.</span><span class="sxs-lookup"><span data-stu-id="f1df4-128">The root signature is a binding convention, defined by the application, that is used by shaders to locate the resources that they need access to.</span></span> <span data-ttu-id="f1df4-129">La signature racine peut stocker les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="f1df4-129">The root signature can store:</span></span>

-   <span data-ttu-id="f1df4-130">Indexe les tables de descripteur dans un tas de descripteur, où la disposition de la table de descripteur a été prédéfinie.</span><span class="sxs-lookup"><span data-stu-id="f1df4-130">Indexes to descriptor tables in a descriptor heap, where the layout of the descriptor table has been pre-defined.</span></span>
-   <span data-ttu-id="f1df4-131">Les constantes, afin que les applications puissent lier des constantes définies par l’utilisateur (appelées *constantes racine*) directement aux nuanceurs sans avoir à passer par des descripteurs et des tables de descripteur.</span><span class="sxs-lookup"><span data-stu-id="f1df4-131">Constants, so apps can bind user-defined constants (known as *root constants*) directly to shaders without having to go through descriptors and descriptor tables.</span></span>
-   <span data-ttu-id="f1df4-132">Un très petit nombre de descripteurs directement à l’intérieur de la signature racine, comme une vue de mémoire tampon constante (CBV) qui change par dessin, ce qui évite à l’application d’avoir à placer ces descripteurs dans un tas de descripteur.</span><span class="sxs-lookup"><span data-stu-id="f1df4-132">A very small number of descriptors directly inside the root signature, such as a constant buffer view (CBV) that changes per draw, thereby saving the application from needing to put those descriptors in a descriptor heap.</span></span>

<span data-ttu-id="f1df4-133">En d’autres termes, la signature racine fournit des optimisations de performances appropriées pour les petites quantités de données qui changent par dessin.</span><span class="sxs-lookup"><span data-stu-id="f1df4-133">In other words, the root signature provides performance optimizations suitable for small amounts of data that change per draw.</span></span>

<span data-ttu-id="f1df4-134">La conception Direct3D 12 pour la liaison la sépare des autres tâches, telles que la gestion de la mémoire, la gestion de la durée de vie des objets, le suivi de l’État et la synchronisation de la mémoire (reportez-vous aux [différences dans le modèle de liaison de Direct3D 11](binding-model.md)).</span><span class="sxs-lookup"><span data-stu-id="f1df4-134">The Direct3D 12 design for binding separates it from other tasks, such as memory management, object lifetime management, state tracking, and memory synchronization (refer to [Differences in the Binding Model from Direct3D 11](binding-model.md)).</span></span> <span data-ttu-id="f1df4-135">La liaison Direct3D 12 est conçue pour une surcharge faible et est optimisée pour les appels d’API qui sont effectués le plus fréquemment.</span><span class="sxs-lookup"><span data-stu-id="f1df4-135">Direct3D 12 binding is designed to be low overhead and optimized for the API calls that are made most frequently.</span></span> <span data-ttu-id="f1df4-136">Il est également évolutif sur un matériel de bas en bout à haut niveau, et évolutif à partir d’une version plus ancienne (pipeline Direct3D 11 plus linéaire) vers les approches plus récentes (plus parallèles) de la programmation du moteur graphique.</span><span class="sxs-lookup"><span data-stu-id="f1df4-136">It is also scalable across low end to high end hardware, and scalable from older (the more linear Direct3D 11 pipeline) to the newer (more parallel) approaches to graphics engine programming.</span></span>

## <a name="resource-types-and-views"></a><span data-ttu-id="f1df4-137">Types et vues de ressources</span><span class="sxs-lookup"><span data-stu-id="f1df4-137">Resource types and views</span></span>

<span data-ttu-id="f1df4-138">Les types de ressources sont les mêmes que Direct3D 11, à savoir :</span><span class="sxs-lookup"><span data-stu-id="f1df4-138">Resource types are the same as Direct3D 11, namely:</span></span>

-   <span data-ttu-id="f1df4-139">Texture1D et Texture1DArray</span><span class="sxs-lookup"><span data-stu-id="f1df4-139">Texture1D, and Texture1DArray</span></span>
-   <span data-ttu-id="f1df4-140">Texture2D et Texture2DArray, Texture2DMS, Texture2DMSArray</span><span class="sxs-lookup"><span data-stu-id="f1df4-140">Texture2D, and Texture2DArray, Texture2DMS, Texture2DMSArray</span></span>
-   <span data-ttu-id="f1df4-141">Texture3D</span><span class="sxs-lookup"><span data-stu-id="f1df4-141">Texture3D</span></span>
-   <span data-ttu-id="f1df4-142">Mémoires tampons (typées, structurées et brutes)</span><span class="sxs-lookup"><span data-stu-id="f1df4-142">Buffers (typed, structured and raw)</span></span>

<span data-ttu-id="f1df4-143">Les vues de ressources sont similaires, mais légèrement différentes de celles de Direct3D 11, les vues de mémoire tampon de vertex et d’index ont été ajoutées.</span><span class="sxs-lookup"><span data-stu-id="f1df4-143">Resource views are similar but slightly different from Direct3D 11, vertex and index buffer views have been added.</span></span>

-   <span data-ttu-id="f1df4-144">Affichage des mémoires tampons de constantes (CBV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-144">Constant buffer view (CBV)</span></span>
-   <span data-ttu-id="f1df4-145">Vue d’accès non triée (UAV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-145">Unordered access view (UAV)</span></span>
-   <span data-ttu-id="f1df4-146">Affichage des ressources de nuanceur (SRV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-146">Shader resource view (SRV)</span></span>
-   <span data-ttu-id="f1df4-147">Échantillonneurs</span><span class="sxs-lookup"><span data-stu-id="f1df4-147">Samplers</span></span>
-   <span data-ttu-id="f1df4-148">Affichage de la cible de rendu (RTV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-148">Render Target View (RTV)</span></span>
-   <span data-ttu-id="f1df4-149">Vue du stencil de profondeur (DSV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-149">Depth Stencil View (DSV)</span></span>
-   <span data-ttu-id="f1df4-150">Vue de la mémoire tampon d’index (IBV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-150">Index Buffer View (IBV)</span></span>
-   <span data-ttu-id="f1df4-151">Vue de la mémoire tampon de vertex (VBV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-151">Vertex Buffer View (VBV)</span></span>
-   <span data-ttu-id="f1df4-152">Vue de sortie de flux (SOV)</span><span class="sxs-lookup"><span data-stu-id="f1df4-152">Stream Output View (SOV)</span></span>

<span data-ttu-id="f1df4-153">Seules les quatre premières de ces vues sont réellement visibles pour les nuanceurs, reportez-vous aux [tas du descripteur visible du nuanceur](shader-visible-descriptor-heaps.md) et aux [tas de descripteurs visibles non nuanceur](non-shader-visible-descriptor-heaps.md).</span><span class="sxs-lookup"><span data-stu-id="f1df4-153">Only the first four of these views are actually visible to shaders, refer to [Shader Visible Descriptor Heaps](shader-visible-descriptor-heaps.md) and [Non Shader Visible Descriptor Heaps](non-shader-visible-descriptor-heaps.md).</span></span>

## <a name="resource-binding-flow-of-control"></a><span data-ttu-id="f1df4-154">Workflow de liaison de ressources de contrôle</span><span class="sxs-lookup"><span data-stu-id="f1df4-154">Resource Binding Flow of Control</span></span>

<span data-ttu-id="f1df4-155">En se concentrant uniquement sur les signatures racines, les descripteurs racine, les constantes racine, les tables de descripteurs et les tas de descripteurs, le déroulement de la logique de rendu d’une application doit être similaire à ce qui suit :</span><span class="sxs-lookup"><span data-stu-id="f1df4-155">Focusing just on root signatures, root descriptors, root constants, descriptor tables, and descriptor heaps, the flow of rendering logic for an app should be similar to the following:</span></span>

-   <span data-ttu-id="f1df4-156">Créez un ou plusieurs objets de signature racine, un pour chaque configuration de liaison différente dont une application a besoin.</span><span class="sxs-lookup"><span data-stu-id="f1df4-156">Create one or more root signature objects – one for every different binding configuration an application needs.</span></span>
-   <span data-ttu-id="f1df4-157">Créez des nuanceurs et un état de pipeline avec les objets de signature racine avec lesquels ils seront utilisés.</span><span class="sxs-lookup"><span data-stu-id="f1df4-157">Create shaders and pipeline state with the root signature objects they will be used with.</span></span>
-   <span data-ttu-id="f1df4-158">Créez un ou plusieurs tas de descripteurs (ou, le cas échéant) qui contiendront tous les descripteurs SRV, UAV et CBV pour chaque trame de rendu.</span><span class="sxs-lookup"><span data-stu-id="f1df4-158">Create one (or, if necessary, more) descriptor heaps that will contain all the SRV, UAV, and CBV descriptors for each frame of rendering.</span></span>
-   <span data-ttu-id="f1df4-159">Initialiser le ou les tas (s) de descripteur avec des descripteurs dans la mesure du possible pour les jeux de descripteurs qui seront réutilisés dans plusieurs frames.</span><span class="sxs-lookup"><span data-stu-id="f1df4-159">Initialize the descriptor heap(s) with descriptors where possible for sets of descriptors that will be reused across many frames.</span></span>
-   <span data-ttu-id="f1df4-160">Pour chaque frame à rendre :</span><span class="sxs-lookup"><span data-stu-id="f1df4-160">For each frame to be rendered:</span></span>
    -   <span data-ttu-id="f1df4-161">Pour chaque liste de commandes :</span><span class="sxs-lookup"><span data-stu-id="f1df4-161">For each command list:</span></span>
        -   <span data-ttu-id="f1df4-162">Définissez la signature racine actuelle à utiliser (et modifiez-la si nécessaire pendant le rendu, ce qui est rarement requis).</span><span class="sxs-lookup"><span data-stu-id="f1df4-162">Set the current root signature to use (and change if needed during rendering – which is rarely required).</span></span>
        -   <span data-ttu-id="f1df4-163">Mettez à jour les constantes et/ou les descripteurs de signature racine de la signature racine pour la nouvelle vue (par exemple, les projections de type World/View).</span><span class="sxs-lookup"><span data-stu-id="f1df4-163">Update some root signature’s constants and/or root signature descriptors for the new view (such as world/view projections).</span></span>
        -   <span data-ttu-id="f1df4-164">Pour chaque élément à dessiner :</span><span class="sxs-lookup"><span data-stu-id="f1df4-164">For each item to draw:</span></span>
            -   <span data-ttu-id="f1df4-165">Définissez tous les nouveaux descripteurs dans les tas de descripteurs en fonction des besoins pour le rendu par objet.</span><span class="sxs-lookup"><span data-stu-id="f1df4-165">Define any new descriptors in descriptor heaps as needed for per-object rendering.</span></span> <span data-ttu-id="f1df4-166">Pour les tas de descripteurs visibles par le nuanceur, l’application doit veiller à utiliser un espace de tas de descripteur qui n’est pas déjà référencé par un rendu pouvant être en cours d’utilisation, par exemple pour allouer de manière linéaire l’espace via le tas du descripteur pendant le rendu.</span><span class="sxs-lookup"><span data-stu-id="f1df4-166">For shader-visible descriptor heaps, the app must make sure to use descriptor heap space that isn’t already being referenced by rendering that could be in flight – for example, linearly allocating space through the descriptor heap during rendering.</span></span>
            -   <span data-ttu-id="f1df4-167">Mettez à jour la signature racine avec des pointeurs vers les régions requises des tas de descripteurs.</span><span class="sxs-lookup"><span data-stu-id="f1df4-167">Update the root signature with pointers to the required regions of the descriptor heaps.</span></span> <span data-ttu-id="f1df4-168">Par exemple, une table de descripteur peut pointer vers certains descripteurs statiques (immuables) initialisés précédemment, tandis qu’une autre table de descripteurs peut pointer vers certains descripteurs dynamiques configurés pour le rendu actuel.</span><span class="sxs-lookup"><span data-stu-id="f1df4-168">For example, one descriptor table might point to some static (unchanging) descriptors initialized earlier, while another descriptor table might point to some dynamic descriptors configured for the current rendering.</span></span>
            -   <span data-ttu-id="f1df4-169">Mettez à jour les constantes et/ou les descripteurs de signature racine de la signature racine pour le rendu par élément.</span><span class="sxs-lookup"><span data-stu-id="f1df4-169">Update some root signature’s constants and/or root signature descriptors for per-item rendering.</span></span>
            -   <span data-ttu-id="f1df4-170">Définissez l’état du pipeline pour l’élément à dessiner (uniquement si la modification est nécessaire), compatible avec la signature racine actuellement liée.</span><span class="sxs-lookup"><span data-stu-id="f1df4-170">Set the pipeline state for the item to draw (only if change needed), compatible with the currently bound root signature.</span></span>
            -   <span data-ttu-id="f1df4-171">Dessin</span><span class="sxs-lookup"><span data-stu-id="f1df4-171">Draw</span></span>
        -   <span data-ttu-id="f1df4-172">Répéter (élément suivant)</span><span class="sxs-lookup"><span data-stu-id="f1df4-172">Repeat (next item)</span></span>
    -   <span data-ttu-id="f1df4-173">Répéter (liste de commandes suivante)</span><span class="sxs-lookup"><span data-stu-id="f1df4-173">Repeat (next command list)</span></span>
    -   <span data-ttu-id="f1df4-174">Une fois que le GPU a terminé avec une mémoire qui n’est plus utilisée, il peut être libéré.</span><span class="sxs-lookup"><span data-stu-id="f1df4-174">Strictly when the GPU has finished with any memory that will no longer be used, it can be released.</span></span> <span data-ttu-id="f1df4-175">Les références aux descripteurs qu’il contient n’ont pas besoin d’être supprimées si un rendu supplémentaire qui utilise ces descripteurs n’est pas envoyé.</span><span class="sxs-lookup"><span data-stu-id="f1df4-175">Descriptors' references to it do not need to be deleted if additional rendering that uses those descriptors is not submitted.</span></span> <span data-ttu-id="f1df4-176">Ainsi, le rendu suivant peut pointer vers d’autres zones dans des tas de descripteurs, ou les descripteurs obsolètes peuvent être remplacés par des descripteurs valides pour réutiliser l’espace du tas du descripteur.</span><span class="sxs-lookup"><span data-stu-id="f1df4-176">So, subsequent rendering can point to other areas in descriptor heaps, or stale descriptors can be overwritten with valid descriptors to reuse the descriptor heap space.</span></span>
-   <span data-ttu-id="f1df4-177">Répéter (Frame suivant)</span><span class="sxs-lookup"><span data-stu-id="f1df4-177">Repeat (next frame)</span></span>

<span data-ttu-id="f1df4-178">Notez que les autres types de descripteurs, les vues de la cible de rendu (RTVs), les vues de stencil de profondeur (DSV), les vues de tampon d’index (IBVs), les vues de mémoire tampon de vertex (VBVs) et les vues d’objets de nuanceur (SOV) sont gérés différemment.</span><span class="sxs-lookup"><span data-stu-id="f1df4-178">Note that other descriptor types, render target views (RTVs), depth stencil views (DSV), index buffer views (IBVs), vertex buffer views (VBVs), and shader object views (SOV), are managed differently.</span></span> <span data-ttu-id="f1df4-179">Le pilote gère le contrôle de version de l’ensemble des descripteurs liés pour chaque dessin au cours de l’enregistrement de la liste de commandes (de la même façon que les liaisons de signature racine sont gérées par le matériel/pilote).</span><span class="sxs-lookup"><span data-stu-id="f1df4-179">The driver handles the versioning of the set of descriptors bound for each draw during recording of the command list (similar to how the root signature bindings are versioned by the hardware/driver).</span></span> <span data-ttu-id="f1df4-180">Cela diffère du contenu des tas de descripteurs visibles par le nuanceur, pour lesquels l’application doit être allouée manuellement via le tas, car elle référence des descripteurs différents entre les dessins.</span><span class="sxs-lookup"><span data-stu-id="f1df4-180">This is different from the contents of shader-visible descriptor heaps, for which the application must manually allocate through the heap as it references different descriptors between draws.</span></span> <span data-ttu-id="f1df4-181">Le contrôle de version du contenu de segment de mémoire visible par Shader est laissé à l’application, car il permet aux applications d’effectuer des opérations telles que la réutilisation de descripteurs qui ne changent pas, ou l’utilisation de grands ensembles statiques de descripteurs et l’utilisation d’une combinaison de techniques pour différents descripteurs.</span><span class="sxs-lookup"><span data-stu-id="f1df4-181">Versioning of heap content that is shader-visible is left to the application because it allows applications to do things like reuse descriptors that don’t change, or use large static sets of descriptors and use shader indexing (such as by material ID) to select descriptors to use from the descriptor heap, or use combinations of techniques for different sets of descriptors.</span></span> <span data-ttu-id="f1df4-182">Le matériel n’est pas conçu pour gérer ce type de flexibilité pour les autres types de descripteurs (RTV, DSV, IBV, VBV, SOV).</span><span class="sxs-lookup"><span data-stu-id="f1df4-182">The hardware isn’t equipped to handle this type of flexibility for the other descriptor types (RTV, DSV, IBV, VBV, SOV).</span></span>

## <a name="suballocation"></a><span data-ttu-id="f1df4-183">Sous-allocation</span><span class="sxs-lookup"><span data-stu-id="f1df4-183">Suballocation</span></span>

<span data-ttu-id="f1df4-184">Dans Direct3D 12, l’application dispose d’un contrôle de bas niveau sur la gestion de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="f1df4-184">In Direct3D 12, the app has low-level control over memory management.</span></span> <span data-ttu-id="f1df4-185">Dans les versions antérieures de Direct3D, y compris Direct3D 11, il y aurait une allocation par ressource.</span><span class="sxs-lookup"><span data-stu-id="f1df4-185">In earlier versions of Direct3D, including Direct3D 11, there would be one allocation per resource.</span></span> <span data-ttu-id="f1df4-186">Dans Direct3D 12, l’application peut utiliser l’API pour allouer un grand bloc de mémoire, ce qui est plus important que n’importe quel objet unique.</span><span class="sxs-lookup"><span data-stu-id="f1df4-186">In Direct3D 12, the app can use the API to allocate a large block of memory, larger than any single object would need.</span></span> <span data-ttu-id="f1df4-187">Une fois cette opération effectuée, l’application peut créer des descripteurs pour pointer vers les sections de ce bloc de mémoire volumineux.</span><span class="sxs-lookup"><span data-stu-id="f1df4-187">After this is done, the app can create descriptors to point to sections of that large memory block.</span></span> <span data-ttu-id="f1df4-188">Ce processus consiste à décider de l’endroit où (les plus petits blocs à l’intérieur du grand bloc) sont connus sous le nom de sous- *allocation*.</span><span class="sxs-lookup"><span data-stu-id="f1df4-188">This process of deciding what to put where (smaller blocks inside the large block) is known as *suballocation*.</span></span> <span data-ttu-id="f1df4-189">L’activation de l’application pour cela peut entraîner des gains d’utilisation efficace du calcul et de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="f1df4-189">Enabling the app to do this can yield gains in efficient use of computation and memory.</span></span> <span data-ttu-id="f1df4-190">Par exemple, le changement de nom des ressources est rendu obsolète.</span><span class="sxs-lookup"><span data-stu-id="f1df4-190">For example, resource renaming is rendered obsolete.</span></span> <span data-ttu-id="f1df4-191">Au lieu de cela, les applications peuvent utiliser des délimiteurs pour déterminer quand une ressource particulière est utilisée et lorsqu’elle ne l’est pas par des délimitations sur les exécutions de la liste de commandes où la liste de commandes requiert l’utilisation de cette ressource particulière.</span><span class="sxs-lookup"><span data-stu-id="f1df4-191">In place of this, apps can use fences to determine when a particular resource is being used and when it's not by fencing on command list executions where the command list requires the use of that particular resource.</span></span>

## <a name="freeing-resources"></a><span data-ttu-id="f1df4-192">Libération des ressources</span><span class="sxs-lookup"><span data-stu-id="f1df4-192">Freeing Resources</span></span>

<span data-ttu-id="f1df4-193">Avant de pouvoir libérer de la mémoire qui a été liée au pipeline, le GPU doit en avoir terminé.</span><span class="sxs-lookup"><span data-stu-id="f1df4-193">Before any memory that has been bound to the pipeline can be freed, the GPU must be finished with it.</span></span>

<span data-ttu-id="f1df4-194">L’attente du rendu des frames est probablement la manière la plus grossière de s’assurer que le GPU est terminé.</span><span class="sxs-lookup"><span data-stu-id="f1df4-194">Waiting for frame rendering is probably the coarsest way to be certain that the GPU has finished.</span></span> <span data-ttu-id="f1df4-195">À un niveau de granularité plus fin, vous pouvez utiliser à nouveau des délimiteurs : quand une commande est enregistrée dans une liste de commandes dont vous souhaitez effectuer le suivi, insérer une clôture immédiatement après celle-ci.</span><span class="sxs-lookup"><span data-stu-id="f1df4-195">At a finer grain, you can again use fences—when a command is recorded into a command list that you want to track the completion of, insert a fence immediately after it.</span></span> <span data-ttu-id="f1df4-196">Ensuite, vous pouvez effectuer diverses opérations de synchronisation avec la clôture.</span><span class="sxs-lookup"><span data-stu-id="f1df4-196">Then, you can do various synchronization operations with the fence.</span></span> <span data-ttu-id="f1df4-197">Vous soumettez un nouveau travail (listes de commandes) qui attend la fin d’une clôture spécifiée sur le GPU, ce qui indique que tout est terminé, ou vous pouvez demander qu’un événement de processeur soit déclenché lorsque la clôture est passée (que l’application peut attendre avec un thread en veille).</span><span class="sxs-lookup"><span data-stu-id="f1df4-197">You submit new work (command lists) that waits until a specified fence has passed on the GPU, which indicates that everything before it is complete, or you can request that a CPU event be raised when the fence has passed (which the app can be waiting on with a sleeping thread).</span></span> <span data-ttu-id="f1df4-198">Dans Direct3D 11, il s’agissait de `EnqueueSetEvent` ().</span><span class="sxs-lookup"><span data-stu-id="f1df4-198">In Direct3D 11, this was `EnqueueSetEvent`().</span></span>

## <a name="related-topics"></a><span data-ttu-id="f1df4-199">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="f1df4-199">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f1df4-200">Liaison de ressource</span><span class="sxs-lookup"><span data-stu-id="f1df4-200">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




