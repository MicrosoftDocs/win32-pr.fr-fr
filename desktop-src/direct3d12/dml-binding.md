---
title: Liaison dans DirectML
description: Dans DirectML, la liaison fait référence à l’attachement des ressources au pipeline que le GPU doit utiliser pendant l’initialisation et l’exécution de vos opérateurs Machine Learning.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548542"
---
# <a name="binding-in-directml"></a><span data-ttu-id="7038f-103">Liaison dans DirectML</span><span class="sxs-lookup"><span data-stu-id="7038f-103">Binding in DirectML</span></span>

<span data-ttu-id="7038f-104">Dans DirectML, la *liaison* fait référence à l’attachement des ressources au pipeline que le GPU doit utiliser pendant l’initialisation et l’exécution de vos opérateurs machine learning.</span><span class="sxs-lookup"><span data-stu-id="7038f-104">In DirectML, *binding* refers to the attachment of resources to the pipeline for the GPU to use during the initialization and execution of your machine learning operators.</span></span> <span data-ttu-id="7038f-105">Ces ressources peuvent être des dizaines d’entrée et de sortie, par exemple, ainsi que toutes les ressources temporaires ou persistantes dont l’opérateur a besoin.</span><span class="sxs-lookup"><span data-stu-id="7038f-105">These resources can be input and output tensors, for example, as well as any temporary or persistent resources that the operator needs.</span></span>

<span data-ttu-id="7038f-106">Cette rubrique traite des détails conceptuels et procédurals de la liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-106">This topic addresses the conceptual and procedural details of binding.</span></span> <span data-ttu-id="7038f-107">Nous vous recommandons également de lire entièrement la documentation des API que vous appelez, y compris les paramètres et les notes.</span><span class="sxs-lookup"><span data-stu-id="7038f-107">We recommend that you also fully read the documentation for the APIs that you call, including parameters and Remarks.</span></span>

## <a name="important-ideas-in-binding"></a><span data-ttu-id="7038f-108">Idées importantes en matière de liaison</span><span class="sxs-lookup"><span data-stu-id="7038f-108">Important ideas in binding</span></span>

<span data-ttu-id="7038f-109">La liste des étapes ci-dessous contient une description détaillée des tâches liées à la liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-109">The list of steps below contain a high-level description of binding-related tasks.</span></span> <span data-ttu-id="7038f-110">Vous devez suivre ces étapes chaque fois que vous exécutez un [répartiteur](/windows/desktop/api/directml/nn-directml-idmldispatchable) &mdash; un répartiteur est un initialiseur d’opérateur ou un opérateur compilé.</span><span class="sxs-lookup"><span data-stu-id="7038f-110">You need to follow these steps each time you execute a [dispatchable](/windows/desktop/api/directml/nn-directml-idmldispatchable)&mdash;a dispatchable is either an operator initializer or a compiled operator.</span></span> <span data-ttu-id="7038f-111">Ces étapes présentent les idées, structures et méthodes importantes impliquées dans la liaison DirectML.</span><span class="sxs-lookup"><span data-stu-id="7038f-111">These steps introduce the important ideas, structures, and methods involved in DirectML binding.</span></span>

<span data-ttu-id="7038f-112">Les sections suivantes de cette rubrique décrivent plus en détail ces tâches de liaison, ainsi que des extraits de code supplémentaires tirés de l’exemple de code d' [application DirectML minimal](dml-min-app.md) .</span><span class="sxs-lookup"><span data-stu-id="7038f-112">Subsequent sections in this topic dig deeper and explain these binding tasks in more detail, with illustrative code snippets taken from the [minimal DirectML application](dml-min-app.md) code example.</span></span>

- <span data-ttu-id="7038f-113">Appelez [**IDMLDispatchable :: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) sur le répartiteur pour déterminer le nombre de descripteurs dont il a besoin, ainsi que ses besoins en ressources temporaires/persistantes.</span><span class="sxs-lookup"><span data-stu-id="7038f-113">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) on the dispatchable to determine how many descriptors it needs, and also its temporary/persistent resource needs.</span></span>
- <span data-ttu-id="7038f-114">Créez un tas de descripteur Direct3D 12 suffisamment grand pour les descripteurs et liez-le au pipeline.</span><span class="sxs-lookup"><span data-stu-id="7038f-114">Create a Direct3D 12 descriptor heap large enough for the descriptors, and bind it to the pipeline.</span></span>
- <span data-ttu-id="7038f-115">Appelez [**IDMLDevice :: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) pour créer une table de liaison DirectML afin de représenter les ressources liées au pipeline.</span><span class="sxs-lookup"><span data-stu-id="7038f-115">Call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create a DirectML binding table to represent the resources bound to the pipeline.</span></span> <span data-ttu-id="7038f-116">Utilisez la structure [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) pour décrire votre table de liaison, y compris le sous-ensemble des descripteurs vers lequel elle pointe dans le tas du descripteur.</span><span class="sxs-lookup"><span data-stu-id="7038f-116">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the subset of the descriptors that it points to in the descriptor heap.</span></span>
- <span data-ttu-id="7038f-117">Créez des ressources temporaires/persistantes en tant que ressources de tampon Direct3D 12, décrivez-les avec des structures [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) et [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) , puis ajoutez-les à la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-117">Create temporary/persistent resources as Direct3D 12 buffer resources, describe them with [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) and [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structures, and add them to the binding table.</span></span>
- <span data-ttu-id="7038f-118">Si le répartiteur est un opérateur compilé, créez une mémoire tampon d’éléments tenseur en tant que ressource de mémoire tampon Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="7038f-118">If the dispatchable is a compiled operator, then create a buffer of tensor elements as a Direct3D 12 buffer resource.</span></span> <span data-ttu-id="7038f-119">Remplissez/chargez-le, décrivez-le avec les structures **DML_BUFFER_BINDING** et **DML_BINDING_DESC** , puis ajoutez-le à la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-119">Populate/upload it, describe it with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and add it to the binding table.</span></span>
- <span data-ttu-id="7038f-120">Transmettez votre table de liaison en tant que paramètre lorsque vous appelez [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="7038f-120">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a><span data-ttu-id="7038f-121">Récupérer les propriétés de liaison d’un répartiteur</span><span class="sxs-lookup"><span data-stu-id="7038f-121">Retrieve the binding properties of a dispatchable</span></span>

<span data-ttu-id="7038f-122">La structure [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) décrit les besoins de liaison d’un répartiteur (initialiseur d’opérateur ou opérateur compilé).</span><span class="sxs-lookup"><span data-stu-id="7038f-122">The [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) structure describes the binding needs of a dispatchable (operator initializer or compiled operator).</span></span> <span data-ttu-id="7038f-123">Ces propriétés liées à la liaison incluent le nombre de descripteurs que vous devez lier au répartiteur, ainsi que la taille en octets des ressources temporaires et/ou persistantes dont il a besoin.</span><span class="sxs-lookup"><span data-stu-id="7038f-123">These binding-related properties include the number of descriptors that you should bind to the dispatchable, as well as the size in bytes of any temporary and/or persistent resource that it needs.</span></span>

> [!NOTE]
> <span data-ttu-id="7038f-124">Même pour plusieurs opérateurs du même type, ne faites pas d’hypothèses à leur sujet avec les mêmes exigences de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-124">Even for multiple operators of the same type, don't make assumptions about them having the same binding requirements.</span></span> <span data-ttu-id="7038f-125">Interrogez les propriétés de liaison pour chaque initialiseur et opérateur que vous créez.</span><span class="sxs-lookup"><span data-stu-id="7038f-125">Query the binding properties for every initializer and operator that you create.</span></span>

<span data-ttu-id="7038f-126">Appelez [**IDMLDispatchable :: GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) pour récupérer un **DML_BINDING_PROPERTIES**.</span><span class="sxs-lookup"><span data-stu-id="7038f-126">Call [**IDMLDispatchable::GetBindingProperties**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) to retrieve a **DML_BINDING_PROPERTIES**.</span></span>

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

<span data-ttu-id="7038f-127">La `descriptorCount` valeur que vous récupérez ici détermine la taille (minimale) du tas du descripteur et de la table de liaison que vous créez au cours des deux étapes suivantes.</span><span class="sxs-lookup"><span data-stu-id="7038f-127">The `descriptorCount` value that you retrieve here determines the (minimum) size of the descriptor heap and of the binding table that you create in the next two steps.</span></span>

<span data-ttu-id="7038f-128">**DML_BINDING_PROPERTIES** contient également un `TemporaryResourceSize` membre, qui est la taille minimale, en octets, de la ressource temporaire qui doit être liée à la table de liaison pour cet objet pouvant être distribué.</span><span class="sxs-lookup"><span data-stu-id="7038f-128">**DML_BINDING_PROPERTIES** also contains a `TemporaryResourceSize` member, which is the minimum size in bytes of the temporary resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="7038f-129">La valeur zéro signifie qu’une ressource temporaire n’est pas requise.</span><span class="sxs-lookup"><span data-stu-id="7038f-129">A value of zero means that a temporary resource is not required.</span></span>

<span data-ttu-id="7038f-130">Et un `PersistentResourceSize` membre, qui est la taille minimale, en octets, de la ressource persistante qui doit être liée à la table de liaison pour cet objet pouvant être distribué.</span><span class="sxs-lookup"><span data-stu-id="7038f-130">And a `PersistentResourceSize` member, which is the minimum size in bytes of the persistent resource that must be bound to the binding table for this dispatchable object.</span></span> <span data-ttu-id="7038f-131">La valeur zéro signifie qu’une ressource persistante n’est pas requise.</span><span class="sxs-lookup"><span data-stu-id="7038f-131">A value of zero means that a persistent resource is not required.</span></span> <span data-ttu-id="7038f-132">Une ressource persistante, si nécessaire, doit être fournie pendant l’initialisation d’un opérateur compilé (où elle est liée en tant que sortie de l’initialiseur d’opérateur), ainsi que pendant l’exécution.</span><span class="sxs-lookup"><span data-stu-id="7038f-132">A persistent resource, if one is needed, must be supplied during initialization of a compiled operator (where it is bound as an output of the operator initializer) as well as during execution.</span></span> <span data-ttu-id="7038f-133">Vous y découvrirez plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="7038f-133">There's more about this later in this topic.</span></span> <span data-ttu-id="7038f-134">Seuls les opérateurs compilés ont des ressources persistantes : les initialiseurs d’opérateur retournent toujours la valeur 0 pour ce membre.</span><span class="sxs-lookup"><span data-stu-id="7038f-134">Only compiled operators have persistent resources—operator initializers always return a value of 0 for this member.</span></span>

<span data-ttu-id="7038f-135">Si vous appelez **IDMLDispatchable :: GetBindingProperties** sur un initialiseur d’opérateur à la fois avant et après un appel à [**IDMLOperatorInitializer :: Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), il n’est pas garanti que les deux ensembles de propriétés de liaison récupérés soient identiques.</span><span class="sxs-lookup"><span data-stu-id="7038f-135">If you call **IDMLDispatchable::GetBindingProperties** on an operator initializer both before and after a call to [**IDMLOperatorInitializer::Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), then the two sets of binding properties retrieved are not guaranteed to be identical.</span></span>

## <a name="describe-create-and-bind-a-descriptor-heap"></a><span data-ttu-id="7038f-136">Décrire, créer et lier un tas de descripteur</span><span class="sxs-lookup"><span data-stu-id="7038f-136">Describe, create, and bind a descriptor heap</span></span>

<span data-ttu-id="7038f-137">En termes de descripteurs, votre responsabilité commence et se termine par le tas du descripteur lui-même.</span><span class="sxs-lookup"><span data-stu-id="7038f-137">In terms of descriptors, your responsibility begins and ends with the descriptor heap itself.</span></span> <span data-ttu-id="7038f-138">DirectML prend en charge la création et la gestion des descripteurs à l’intérieur du tas que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="7038f-138">DirectML itself takes care of creating and managing the descriptors inside of the heap that you provide.</span></span>

<span data-ttu-id="7038f-139">Par conséquent, utilisez une structure [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) pour décrire un tas suffisamment grand pour le nombre de descripteurs dont le répartiteur est nécessaire.</span><span class="sxs-lookup"><span data-stu-id="7038f-139">So, use a [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) structure to describe a heap large enough for the number of descriptors that the dispatchable needs.</span></span> <span data-ttu-id="7038f-140">Ensuite, créez-le avec [**ID3D12Device :: CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span><span class="sxs-lookup"><span data-stu-id="7038f-140">Then create it with [**ID3D12Device::CreateDescriptorHeap**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap).</span></span> <span data-ttu-id="7038f-141">Enfin, appelez [**ID3D12GraphicsCommandList :: SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) pour lier le tas du descripteur au pipeline.</span><span class="sxs-lookup"><span data-stu-id="7038f-141">And, lastly, call [**ID3D12GraphicsCommandList::SetDescriptorHeaps**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) to bind your descriptor heap to the pipeline.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a><span data-ttu-id="7038f-142">Décrire et créer une table de liaison</span><span class="sxs-lookup"><span data-stu-id="7038f-142">Describe and create a binding table</span></span>

<span data-ttu-id="7038f-143">Une table de liaison DirectML représente les ressources que vous liez au pipeline pour un répartiteur à utiliser.</span><span class="sxs-lookup"><span data-stu-id="7038f-143">A DirectML binding table represents the resources that you bind to the pipeline for a dispatchable to use.</span></span> <span data-ttu-id="7038f-144">Ces ressources peuvent être des dizaines d’entrée et de sortie (ou d’autres paramètres) pour un opérateur, ou il peut s’agir de diverses ressources persistantes et temporaires avec lesquelles un répartiteur fonctionne.</span><span class="sxs-lookup"><span data-stu-id="7038f-144">Those resources could be input and output tensors (or other parameters) for an operator, or they could be various persistent and temporary resources that a dispatchable works with.</span></span>

<span data-ttu-id="7038f-145">Utilisez la structure [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) pour décrire votre table de liaison, y compris le répartiteur pour lequel la table de liaison représente les liaisons, et la plage de descripteurs (à partir du tas de descripteur que vous venez de créer) à laquelle vous souhaitez que la table de liaison fasse référence (et dans quels DirectML peuvent écrire des descripteurs).</span><span class="sxs-lookup"><span data-stu-id="7038f-145">Use the [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) structure to describe your binding table, including the dispatchable for which the binding table will represent the bindings, and the range of descriptors (from the descriptor heap that you just created) that you wish the binding table to refer to (and into which DirectML may write descriptors).</span></span> <span data-ttu-id="7038f-146">La `descriptorCount` valeur (l’une des propriétés de liaison que nous avons récupérées à la première étape) nous indique la taille minimale, en descripteurs, de la table de liaison requise pour l’objet pouvant être distribué.</span><span class="sxs-lookup"><span data-stu-id="7038f-146">The `descriptorCount` value (one of the binding properties that we retrieved in the first step) tells us what minimum size is, in descriptors, of the binding table required for the dispatchable object.</span></span> <span data-ttu-id="7038f-147">Ici, nous utilisons cette valeur pour indiquer le nombre maximal de descripteurs que DirectML est autorisé à écrire dans notre segment, à partir du début des handles de descripteur de processeur et GPU fournis.</span><span class="sxs-lookup"><span data-stu-id="7038f-147">Here, we use that value to indicate the maximum number of descriptors that DirectML is permitted to write into our heap, from the start of both the supplied CPU and GPU descriptor handles.</span></span>

<span data-ttu-id="7038f-148">Appelez ensuite [**IDMLDevice :: CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) pour créer la table de liaison DirectML.</span><span class="sxs-lookup"><span data-stu-id="7038f-148">Then call [**IDMLDevice::CreateBindingTable**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) to create the DirectML binding table.</span></span> <span data-ttu-id="7038f-149">Dans les étapes ultérieures, après avoir créé d’autres ressources pour le répartiteur, nous ajouterons ces ressources à la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-149">In later steps, after we've created further resources for the dispatchable, we'll add those resources to the binding table.</span></span>

<span data-ttu-id="7038f-150">Au lieu de passer un **DML_BINDING_TABLE_DESC** à cet appel, vous pouvez passer `nullptr` , indiquant une table de liaison vide.</span><span class="sxs-lookup"><span data-stu-id="7038f-150">Instead of passing a **DML_BINDING_TABLE_DESC** to this call, you can pass `nullptr`, indicating an empty binding table.</span></span>

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

<span data-ttu-id="7038f-151">L’ordre dans lequel DirectML écrit les descripteurs dans le tas n’est pas spécifié. votre application doit donc veiller à ne pas remplacer les descripteurs encapsulés par la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-151">The order in which DirectML writes descriptors into the heap is unspecified, so your application must take care not to overwrite the descriptors wrapped by the binding table.</span></span> <span data-ttu-id="7038f-152">Les handles de descripteur du processeur et du GPU fournis peuvent provenir de différents tas. Toutefois, il est de votre application de s’assurer que la plage de descripteurs entière référencée par le handle de descripteur de l’UC est copiée dans la plage référencée par le handle du descripteur GPU avant l’exécution à l’aide de cette table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-152">The supplied CPU and GPU descriptor handles may come from different heaps, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span> <span data-ttu-id="7038f-153">Le tas de descripteur à partir duquel les handles sont fournis doit avoir un type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span><span class="sxs-lookup"><span data-stu-id="7038f-153">The descriptor heap from which the handles are supplied must have type **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**.</span></span> <span data-ttu-id="7038f-154">En outre, le tas référencé par `GPUDescriptorHandle` doit être un tas de descripteur visible par le nuanceur.</span><span class="sxs-lookup"><span data-stu-id="7038f-154">Additionally, the heap referred to by the `GPUDescriptorHandle` must be a shader-visible descriptor heap.</span></span>

<span data-ttu-id="7038f-155">Vous pouvez réinitialiser une table de liaison pour supprimer toutes les ressources que vous y avez ajoutées, tout en modifiant la propriété que vous avez définie sur son **DML_BINDING_TABLE_DESC** initial (pour encapsuler une nouvelle plage de descripteurs ou pour la réutiliser pour un autre répartiteur).</span><span class="sxs-lookup"><span data-stu-id="7038f-155">You can reset a binding table to remove any resources that you've added to it, while at the same time changing any property that you set on its initial **DML_BINDING_TABLE_DESC** (to wrap a new range of descriptors, or to re-use it for a different dispatchable).</span></span> <span data-ttu-id="7038f-156">Apportez simplement les modifications à la structure de la description et appelez [**IDMLBindingTable :: Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span><span class="sxs-lookup"><span data-stu-id="7038f-156">Just make the changes to the description structure, and call [**IDMLBindingTable::Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).</span></span>

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a><span data-ttu-id="7038f-157">Décrire et lier des ressources temporaires/persistantes</span><span class="sxs-lookup"><span data-stu-id="7038f-157">Describe and bind any temporary/persistent resources</span></span>

<span data-ttu-id="7038f-158">La structure **DML_BINDING_PROPERTIES** que nous avons renseignée lorsque nous avons [récupéré les propriétés de liaison](#retrieve-the-binding-properties-of-a-dispatchable) de notre répartiteur contient la taille en octets des ressources temporaires et/ou persistantes dont le répartiteur a besoin.</span><span class="sxs-lookup"><span data-stu-id="7038f-158">The **DML_BINDING_PROPERTIES** structure that we populated when we [retrieved the binding properties](#retrieve-the-binding-properties-of-a-dispatchable) of our dispatchable contains the size in bytes of any temporary and/or persistent resource that the dispatchable needs.</span></span> <span data-ttu-id="7038f-159">Si l’une de ces tailles est différente de zéro, créez une ressource de mémoire tampon Direct3D 12 et ajoutez-la à la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-159">If either of these sizes is non-zero, then create a Direct3D 12 buffer resource and add it to the binding table.</span></span>

<span data-ttu-id="7038f-160">Dans l’exemple de code ci-dessous, nous créons une ressource temporaire ( `temporaryResourceSize` octets en taille) pour le répartiteur.</span><span class="sxs-lookup"><span data-stu-id="7038f-160">In the code example below, we create a temporary resource (`temporaryResourceSize` bytes in size) for the dispatchable.</span></span> <span data-ttu-id="7038f-161">Nous décrivons la façon dont nous souhaitons lier la ressource, puis nous ajoutons cette liaison à la table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-161">We describe how we wish to bind the resource, and then we add that binding to the binding table.</span></span>

<span data-ttu-id="7038f-162">Puisque nous créons une liaison avec une seule ressource de mémoire tampon, nous décrivons notre liaison avec une structure de [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) .</span><span class="sxs-lookup"><span data-stu-id="7038f-162">Since we're binding a single buffer resource, we describe our binding with a [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) structure.</span></span> <span data-ttu-id="7038f-163">Dans cette structure, nous spécifions la ressource de mémoire tampon Direct3D 12 (la ressource doit avoir une dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), ainsi qu’un décalage et une taille dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7038f-163">In that structure, we specify the Direct3D 12 buffer resource (the resource must have dimension [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), as well as an offset-and-size into the buffer.</span></span> <span data-ttu-id="7038f-164">Il est également possible de décrire une liaison pour un tableau de mémoires tampons (plutôt que pour une seule mémoire tampon), et la structure [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) existe à cet effet.</span><span class="sxs-lookup"><span data-stu-id="7038f-164">It's also possible to describe a binding for an array of buffers (rather than for a single buffer), and the [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) structure exists for that purpose.</span></span>

<span data-ttu-id="7038f-165">Pour soustraire la distinction entre une liaison de mémoire tampon et une liaison de tableau de mémoires tampons, nous utilisons la structure  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) .</span><span class="sxs-lookup"><span data-stu-id="7038f-165">To abstract away the distinction between a buffer binding and a buffer array binding, we use the  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) structure.</span></span> <span data-ttu-id="7038f-166">Vous pouvez définir le `Type` membre du **DML_BINDING_DESC** sur [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) ou **DML_BINDING_TYPE_BUFFER_ARRAY**.</span><span class="sxs-lookup"><span data-stu-id="7038f-166">You can set the `Type` member of the **DML_BINDING_DESC** to either [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) or **DML_BINDING_TYPE_BUFFER_ARRAY**.</span></span> <span data-ttu-id="7038f-167">Vous pouvez ensuite définir le membre de façon à ce qu’il `Desc` pointe vers un **DML_BUFFER_BINDING** ou vers un **DML_BUFFER_ARRAY_BINDING**, en fonction de `Type` .</span><span class="sxs-lookup"><span data-stu-id="7038f-167">And you can then set the `Desc` member to point to either a **DML_BUFFER_BINDING** or to a **DML_BUFFER_ARRAY_BINDING**, depending on `Type`.</span></span>

<span data-ttu-id="7038f-168">Nous nous contenterons de la ressource temporaire dans cet exemple, nous l’ajoutons donc à la table de liaison avec un appel à [**IDMLBindingTable :: BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span><span class="sxs-lookup"><span data-stu-id="7038f-168">We're dealing with the temporary resource in this example, so we add it to the binding table with a call to [**IDMLBindingTable::BindTemporaryResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).</span></span>

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

<span data-ttu-id="7038f-169">Une ressource temporaire (si nécessaire) est une mémoire de travail qui est utilisée en interne lors de l’exécution de l’opérateur. vous n’avez donc pas à vous soucier de son contenu.</span><span class="sxs-lookup"><span data-stu-id="7038f-169">A temporary resource (if one is needed) is scratch memory that's used internally during the execution of the operator, so you don't need to be concerned with its contents.</span></span> <span data-ttu-id="7038f-170">Vous n’avez pas non plus besoin de le garder à l’issue de l’appel de [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="7038f-170">Nor do you need to keep it around after your call to [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) has completed on the GPU.</span></span> <span data-ttu-id="7038f-171">Cela signifie que votre application peut libérer ou remplacer la ressource temporaire entre les distributions de l’opérateur compilé.</span><span class="sxs-lookup"><span data-stu-id="7038f-171">This means that your application may release or overwrite the temporary resource in between dispatches of the compiled operator.</span></span> <span data-ttu-id="7038f-172">Le décalage de début de la plage de mémoire tampon fournie pour la ressource temporaire doit être aligné sur [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="7038f-172">The supplied buffer range to be bound as the temporary resource must have its start offset aligned to [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="7038f-173">Le type du tas sous-jacent à la mémoire tampon doit être **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="7038f-173">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

<span data-ttu-id="7038f-174">Toutefois, si le répartiteur signale une taille différente de zéro pour sa ressource persistante à long terme, la procédure est légèrement différente.</span><span class="sxs-lookup"><span data-stu-id="7038f-174">If the dispatchable reports a non-zero size for its more long-lived persistent resource, though, then the procedure is a little different.</span></span> <span data-ttu-id="7038f-175">Vous devez créer une mémoire tampon et décrire une liaison à la suite du même modèle, comme indiqué ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="7038f-175">You should create a buffer and describe a binding following the same pattern as shown above.</span></span> <span data-ttu-id="7038f-176">Toutefois, ajoutez-le à la table de liaison de l’initialiseur d’opérateur à l’aide d’un appel à [**IDMLBindingTable :: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), car il s’agit du travail de l’initialiseur d’opérateur pour initialiser la ressource persistante.</span><span class="sxs-lookup"><span data-stu-id="7038f-176">But add it to your operator initializer's binding table with a call to [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), because it's the operator initializer's job to initialize the persistent resource.</span></span> <span data-ttu-id="7038f-177">Ensuite, ajoutez-le à la table de liaison de votre opérateur compilé à l’aide d’un appel à [**IDMLBindingTable :: BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span><span class="sxs-lookup"><span data-stu-id="7038f-177">Then add it to your compiled operator's binding table with a call to [**IDMLBindingTable::BindPersistentResource**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource).</span></span> <span data-ttu-id="7038f-178">Consultez l’exemple de code d' [application DirectML minimal](dml-min-app.md) pour voir ce flux de travail en action.</span><span class="sxs-lookup"><span data-stu-id="7038f-178">See the [minimal DirectML application](dml-min-app.md) code example to see this workflow in action.</span></span> <span data-ttu-id="7038f-179">Le contenu et la durée de vie de la ressource persistante doivent persister tant que l’opérateur compilé en a la valeur.</span><span class="sxs-lookup"><span data-stu-id="7038f-179">The persistent resource's contents and lifetime must persist as long as the compiled operator does.</span></span> <span data-ttu-id="7038f-180">Autrement dit, si un opérateur requiert une ressource persistante, votre application doit le fournir au cours de l’initialisation et la fournir ensuite à toutes les exécutions ultérieures de l’opérateur sans modifier son contenu.</span><span class="sxs-lookup"><span data-stu-id="7038f-180">That is, if an operator requires a persistent resource, then your application must supply it during initialization and subsequently also supply it to all future executes of the operator without modifying its contents.</span></span> <span data-ttu-id="7038f-181">La ressource persistante est généralement utilisée par DirectML pour stocker des tables de recherche ou d’autres données de longue durée qui sont calculées pendant l’initialisation d’un opérateur et réutilisées lors des exécutions ultérieures de cet opérateur.</span><span class="sxs-lookup"><span data-stu-id="7038f-181">The persistent resource is typically used by DirectML to store lookup tables or other long-lived data that is computed during initialization of an operator and reused on future executions of that operator.</span></span> <span data-ttu-id="7038f-182">L’offset de début de la plage de mémoire tampon fournie à lier en tant que mémoire tampon persistante doit être aligné sur [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span><span class="sxs-lookup"><span data-stu-id="7038f-182">The supplied buffer range to be bound as the persistent buffer must have its start offset aligned to [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md).</span></span> <span data-ttu-id="7038f-183">Le type du tas sous-jacent à la mémoire tampon doit être **D3D12_HEAP_TYPE_DEFAULT**.</span><span class="sxs-lookup"><span data-stu-id="7038f-183">The type of the heap underlying the buffer must be **D3D12_HEAP_TYPE_DEFAULT**.</span></span>

## <a name="describe-and-bind-any-tensors"></a><span data-ttu-id="7038f-184">Décrire et lier des dizaines</span><span class="sxs-lookup"><span data-stu-id="7038f-184">Describe and bind any tensors</span></span>

<span data-ttu-id="7038f-185">Si vous travaillez avec un opérateur compilé (plutôt qu’avec un initialiseur d’opérateur), vous devez lier les ressources d’entrée et de sortie (pour les dizaines et les autres paramètres) à la table de liaison de l’opérateur.</span><span class="sxs-lookup"><span data-stu-id="7038f-185">If you're dealing with a compiled operator (rather than with an operator initializer), then you need to bind input and output resources (for tensors and other parameters) to the operator's binding table.</span></span> <span data-ttu-id="7038f-186">Le nombre de liaisons doit correspondre exactement au nombre d’entrées de l’opérateur, y compris les dizaines facultatifs.</span><span class="sxs-lookup"><span data-stu-id="7038f-186">The number of bindings must exactly match the number of inputs of the operator, including optional tensors.</span></span> <span data-ttu-id="7038f-187">Les dizaines de temps d’entrée et de sortie et les autres paramètres qu’un opérateur prend sont documentés dans la rubrique de cet opérateur (par exemple, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span><span class="sxs-lookup"><span data-stu-id="7038f-187">The particular input and output tensors and other parameters that an operator takes are documented in the topic for that operator (for example, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).</span></span>

<span data-ttu-id="7038f-188">Une ressource tenseur est une mémoire tampon qui contient les valeurs d’élément individuelles du tenseur.</span><span class="sxs-lookup"><span data-stu-id="7038f-188">A tensor resource is a buffer that contains the individual element values of the tensor.</span></span> <span data-ttu-id="7038f-189">Vous téléchargez et lisez ce type de mémoire tampon vers/à partir du GPU à l’aide des techniques Direct3D 12 standard ([charger des ressources](/windows/desktop/direct3d12/uploading-resources) et [lire des données via une mémoire tampon](/windows/desktop/direct3d12/readback-data-using-heaps)).</span><span class="sxs-lookup"><span data-stu-id="7038f-189">You upload and read back such a buffer to/from the GPU using the regular Direct3D 12 techniques ([Upload resources](/windows/desktop/direct3d12/uploading-resources) and [Read back data via a buffer](/windows/desktop/direct3d12/readback-data-using-heaps)).</span></span> <span data-ttu-id="7038f-190">Consultez l’exemple de code d' [application DirectML minimal](dml-min-app.md) pour voir ces techniques en action.</span><span class="sxs-lookup"><span data-stu-id="7038f-190">See the [minimal DirectML application](dml-min-app.md) code example to see these techniques in action.</span></span>

<span data-ttu-id="7038f-191">Enfin, décrivez vos liaisons de ressource d’entrée et de sortie avec des structures **DML_BUFFER_BINDING** et **DML_BINDING_DESC** , puis ajoutez-les à la table de liaison de l’opérateur compilé avec des appels à [**IDMLBindingTable :: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) et [**IDMLBindingTable :: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="7038f-191">Lastly, describe your input and output resource bindings with **DML_BUFFER_BINDING** and **DML_BINDING_DESC** structures, and then add them to the compiled operator's binding table with calls to [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span> <span data-ttu-id="7038f-192">Quand vous appelez une méthode \**IDMLBindingTable :: \* Bind* _, DirectML écrit un ou plusieurs descripteurs dans la plage de descripteurs de l’UC.</span><span class="sxs-lookup"><span data-stu-id="7038f-192">When you call an \**IDMLBindingTable::Bind\** _ method, DirectML writes one or more descriptors into the range of CPU descriptors.</span></span>

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

<span data-ttu-id="7038f-193">L’une des étapes de la création d’un opérateur DirectML (consultez [_ *IDMLDevice :: CreateOperator* \*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) consiste à déclarer une ou plusieurs structures [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) pour décrire les mémoires tampons de données tenseur que l’opérateur prend et retourne.</span><span class="sxs-lookup"><span data-stu-id="7038f-193">One of the steps in creating a DirectML operator (see [_ *IDMLDevice::CreateOperator*\*](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) is to declare one or more [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) structures to describe the tensor data buffers that the operator takes and returns.</span></span> <span data-ttu-id="7038f-194">Ainsi que le type et la taille de la mémoire tampon tenseur, vous pouvez éventuellement spécifier l’indicateur [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) .</span><span class="sxs-lookup"><span data-stu-id="7038f-194">As well as the tensor buffer's type and size, you can optionally specify the [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) flag.</span></span>

<span data-ttu-id="7038f-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indique que les données tenseur doivent être détenues et gérées par DirectML.</span><span class="sxs-lookup"><span data-stu-id="7038f-195">**DML_TENSOR_FLAG_OWNED_BY_DML** indicates that the tensor data should be owned and managed by DirectML.</span></span> <span data-ttu-id="7038f-196">DirectML effectue une copie des données tenseur pendant l’initialisation de l’opérateur et les stocke dans la ressource persistante.</span><span class="sxs-lookup"><span data-stu-id="7038f-196">DirectML makes a copy of the tensor data during initialization of the operator, and stores it in the persistent resource.</span></span> <span data-ttu-id="7038f-197">Cela permet à DirectML d’effectuer un reformatage des données tenseur dans d’autres formes plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="7038f-197">This allows DirectML to perform reformatting of the tensor data into other, more efficient forms.</span></span> <span data-ttu-id="7038f-198">La définition de cet indicateur peut améliorer les performances, mais elle est généralement utile uniquement pour les dizaines de dizaines dont les données ne changent pas pendant la durée de vie de l’opérateur (par exemple, des dizaines de poids).</span><span class="sxs-lookup"><span data-stu-id="7038f-198">Setting this flag may increase performance, but it's typically only useful for tensors whose data doesn't change for the lifetime of the operator (for example, weight tensors).</span></span> <span data-ttu-id="7038f-199">Et l’indicateur ne peut être utilisé que sur des dizaines d’entrées.</span><span class="sxs-lookup"><span data-stu-id="7038f-199">And the flag may only be used on input tensors.</span></span> <span data-ttu-id="7038f-200">Lorsque l’indicateur est défini sur une description de tenseur particulière, le tenseur correspondant doit être lié à la table de liaison pendant l’initialisation de l’opérateur, et non lors de l’exécution (ce qui génère une erreur).</span><span class="sxs-lookup"><span data-stu-id="7038f-200">When the flag is set on a particular tensor description, the corresponding tensor must be bound to the binding table during operator initialization, and not during execution (which will result in an error).</span></span> <span data-ttu-id="7038f-201">C’est l’inverse du comportement par défaut (comportement sans l’indicateur DML_TENSOR_FLAG_OWNED_BY_DML), où le tenseur est supposé être lié pendant l’exécution, et non pendant l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="7038f-201">That's the opposite of the default behavior (the behavior without the DML_TENSOR_FLAG_OWNED_BY_DML flag), where the tensor is expected to be bound during execution, and not during initialization.</span></span> <span data-ttu-id="7038f-202">Lorsque vous fournissez les données tenseur à un initialiseur d’opérateur, il est légal de lier un téléchargement plutôt qu’un segment de mémoire par défaut, car DirectML effectue une copie des données.</span><span class="sxs-lookup"><span data-stu-id="7038f-202">When you supply the tensor data to an operator initializer, it's legal to bind an UPLOAD rather than a DEFAULT heap, because DirectML makes a copy of the data.</span></span> <span data-ttu-id="7038f-203">Dans tous les autres cas, toutes les ressources liées à DirectML doivent être des ressources de tas par défaut.</span><span class="sxs-lookup"><span data-stu-id="7038f-203">In all other cases, all resources bound to DirectML must be DEFAULT heap resources.</span></span>

<span data-ttu-id="7038f-204">Pour plus d’informations, consultez [**IDMLBindingTable :: BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) et [**IDMLBindingTable :: BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span><span class="sxs-lookup"><span data-stu-id="7038f-204">For more info, see [**IDMLBindingTable::BindInputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**IDMLBindingTable::BindOutputs**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).</span></span>

## <a name="execute-the-dispatchable"></a><span data-ttu-id="7038f-205">Exécuter le répartiteur</span><span class="sxs-lookup"><span data-stu-id="7038f-205">Execute the dispatchable</span></span>

<span data-ttu-id="7038f-206">Transmettez votre table de liaison en tant que paramètre lorsque vous appelez [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span><span class="sxs-lookup"><span data-stu-id="7038f-206">Pass your binding table as a parameter when you call [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).</span></span>

<span data-ttu-id="7038f-207">Lorsque vous utilisez la table de liaison pendant un appel à **IDMLCommandRecorder :: RecordDispatch**, DirectML lie les descripteurs GPU correspondants au pipeline.</span><span class="sxs-lookup"><span data-stu-id="7038f-207">When you use the binding table during a call to **IDMLCommandRecorder::RecordDispatch**, DirectML binds the corresponding GPU descriptors to the pipeline.</span></span> <span data-ttu-id="7038f-208">Les handles de descripteur du processeur et du GPU ne sont pas requis pour pointer vers les mêmes entrées dans un tas de descripteur. Toutefois, il est alors que votre application est chargée de s’assurer que l’intégralité de la plage de descripteur référencée par le handle de descripteur de processeur est copiée dans la plage référencée par le handle de descripteur</span><span class="sxs-lookup"><span data-stu-id="7038f-208">The CPU and GPU descriptor handles aren't required to point to the same entries in a descriptor heap, however it is then your application's responsibility to ensure that the entire descriptor range referred to by the CPU descriptor handle is copied into the range referred to by the GPU descriptor handle prior to execution using this binding table.</span></span>

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

<span data-ttu-id="7038f-209">Enfin, fermez votre liste de commandes Direct3D 12, puis soumettez-la en vue de son exécution, comme vous le feriez pour toute autre liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="7038f-209">Finally, close your Direct3D 12 command list, and submit it for execution as you would any other command list.</span></span>

<span data-ttu-id="7038f-210">Avant l’exécution de **RecordDispatch** sur le GPU, vous devez faire passer toutes les ressources liées à l’état **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** ou à un État pouvant être promu implicitement en **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, tel que **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="7038f-210">Prior to execution of **RecordDispatch** on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="7038f-211">Une fois cet appel terminé, les ressources restent à l’état **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="7038f-211">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="7038f-212">La seule exception à cela concerne les tas de chargement liés lors de l’exécution d’un initialiseur d’opérateur et lorsqu’un ou plusieurs dizaines ont l’indicateur **DML_TENSOR_FLAG_OWNED_BY_DML** défini.</span><span class="sxs-lookup"><span data-stu-id="7038f-212">The only exception to this is for upload heaps bound when executing an operator initializer and while one or more tensors has the **DML_TENSOR_FLAG_OWNED_BY_DML** flag set.</span></span> <span data-ttu-id="7038f-213">Dans ce cas, tous les tas de chargement liés à l’entrée doivent être dans l’état **D3D12_RESOURCE_STATE_GENERIC_READ** et sont conservés dans cet État, comme requis par tous les tas de chargement.</span><span class="sxs-lookup"><span data-stu-id="7038f-213">In that case, any upload heaps bound for input must be in the **D3D12_RESOURCE_STATE_GENERIC_READ** state and will remain in that state, as required by all upload heaps.</span></span> <span data-ttu-id="7038f-214">Si **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** n’a pas été défini lors de la compilation de l’opérateur, toutes les liaisons doivent être définies sur la table de liaison avant l’appel de **RecordDispatch** ; sinon, le comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="7038f-214">If **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** was not set when compiling the operator, then all bindings must be set on the binding table before **RecordDispatch** is called, otherwise the behavior is undefined.</span></span> <span data-ttu-id="7038f-215">Dans le cas contraire, si un opérateur prend en charge la [liaison tardive](#optionally-specify-late-bound-operator-bindings), la liaison de ressources peut être différée jusqu’à ce que la liste de commandes Direct3D 12 soit envoyée à la file d’attente de commandes pour être exécutée.</span><span class="sxs-lookup"><span data-stu-id="7038f-215">Otherwise, if an operator supports [late binding](#optionally-specify-late-bound-operator-bindings), then binding of resources may be deferred until the Direct3D 12 command list is submitted to the command queue for execution.</span></span>

<span data-ttu-id="7038f-216">**RecordDispatch** agit logiquement comme un appel à [**ID3D12GraphicsCommandList ::D ispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span><span class="sxs-lookup"><span data-stu-id="7038f-216">**RecordDispatch** acts logically like a call to [**ID3D12GraphicsCommandList::Dispatch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch).</span></span> <span data-ttu-id="7038f-217">Ainsi, les barrières de vue d’accès non ordonnées (UAV) sont nécessaires pour garantir un classement correct s’il existe des dépendances de données entre les distributions.</span><span class="sxs-lookup"><span data-stu-id="7038f-217">As such, unordered access view (UAV) barriers are necessary to ensure correct ordering if there are data dependencies between dispatches.</span></span> <span data-ttu-id="7038f-218">Cette méthode n’insère pas de barrières UAV sur les ressources d’entrée ou de sortie.</span><span class="sxs-lookup"><span data-stu-id="7038f-218">This method does not insert UAV barriers on input nor output resources.</span></span> <span data-ttu-id="7038f-219">Votre application doit s’assurer que les barrières UAV correctes sont effectuées sur toutes les entrées si leur contenu dépend d’une distribution en amont, et sur toutes les sorties si des distributions en aval dépendent de ces sorties.</span><span class="sxs-lookup"><span data-stu-id="7038f-219">Your application must ensure that the correct UAV barriers are performed on any inputs if their contents depend on an upstream dispatch, and on any outputs if there are downstream dispatches that depend on those outputs.</span></span>

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a><span data-ttu-id="7038f-220">Durée de vie et synchronisation des descripteurs et de la table de liaison</span><span class="sxs-lookup"><span data-stu-id="7038f-220">Lifetime and synchronization of descriptors and binding table</span></span>

<span data-ttu-id="7038f-221">Un bon modèle mental de liaison dans DirectML est que, en arrière-plan, la table de liaison DirectML crée et gère des descripteurs de vue d’accès non ordonnés (UAV) à l’intérieur du tas de descripteur que vous fournissez.</span><span class="sxs-lookup"><span data-stu-id="7038f-221">A good mental model of binding in DirectML is that behind the scenes the DirectML binding table itself is creating and managing unordered access view (UAV) descriptors inside the descriptor heap that you provide.</span></span> <span data-ttu-id="7038f-222">Ainsi, toutes les règles Direct3D 12 habituelles s’appliquent autour de la synchronisation de l’accès à ce tas et à ses descripteurs.</span><span class="sxs-lookup"><span data-stu-id="7038f-222">So, all of the usual Direct3D 12 rules apply around synchronizing access to that heap and to its descriptors.</span></span> <span data-ttu-id="7038f-223">Il est de la responsabilité de votre application d’effectuer une synchronisation correcte entre le processeur et le travail GPU qui utilise une table de liaison.</span><span class="sxs-lookup"><span data-stu-id="7038f-223">It's your application's responsibility to perform correct synchronization between the CPU and GPU work that uses a binding table.</span></span>

<span data-ttu-id="7038f-224">Une table de liaison ne peut pas remplacer un descripteur pendant que le descripteur est en cours d’utilisation (par exemple, par une trame antérieure).</span><span class="sxs-lookup"><span data-stu-id="7038f-224">A binding table can't overwrite a descriptor while the descriptor is in use (by a prior frame, for example).</span></span> <span data-ttu-id="7038f-225">Par conséquent, si vous souhaitez réutiliser un tas de descripteur déjà lié (par exemple, en appelant à nouveau bind \* sur une table de liaison qui pointe vers celui-ci, ou en remplaçant manuellement le tas du descripteur), vous devez attendre que le répartiteur qui utilise actuellement le tas du descripteur termine l’exécution sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="7038f-225">So, if you want to reuse an already-bound descriptor heap (for example, by calling Bind\* again on a binding table that points to it, or by overwriting the descriptor heap manually), then you should wait for the dispatchable that's currently using the descriptor heap to finish executing on the GPU.</span></span> <span data-ttu-id="7038f-226">Une table de liaison ne conservera pas une référence forte sur le tas de descripteur dans lequel elle écrit. vous ne doit pas donc la libération du tas de descripteur visible par le nuanceur de sauvegarde jusqu’à ce que tout le travail qui utilise cette table de liaison ait terminé l’exécution sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="7038f-226">A binding table doesn't maintain a strong reference on the descriptor heap that it writes into, so you mustn't release the backing shader-visible descriptor heap until all work using that binding table has completed execution on the GPU.</span></span>

<span data-ttu-id="7038f-227">En revanche, si une table de liaison spécifie et gère un tas de descripteur, la table ne *contient* pas elle-même de mémoire.</span><span class="sxs-lookup"><span data-stu-id="7038f-227">On the other hand, while a binding table does specify and manage a descriptor heap, the table doesn't itself *contain* any of that memory.</span></span> <span data-ttu-id="7038f-228">Ainsi, vous pouvez publier ou réinitialiser une table de liaison à tout moment après avoir appelé [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) (vous n’avez pas besoin d’attendre que cet appel se termine sur le GPU, tant que les descripteurs sous-jacents restent valides).</span><span class="sxs-lookup"><span data-stu-id="7038f-228">So, you may release or reset a binding table any time after you've called [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) with it (you don't need to wait for that call to complete on the GPU, so long as the underlying descriptors remain valid).</span></span>

<span data-ttu-id="7038f-229">La table de liaison ne conserve pas de références fortes sur les ressources liées à l’aide de cette dernière &mdash; . votre application doit s’assurer que les ressources ne sont pas supprimées pendant qu’elle est en cours d’utilisation par le GPU.</span><span class="sxs-lookup"><span data-stu-id="7038f-229">The binding table doesn't keep strong references on any resources bound using it&mdash;your application must ensure that resources are not deleted while still in use by the GPU.</span></span> <span data-ttu-id="7038f-230">En outre, une table de liaison n’est pas thread-safe. &mdash; votre application ne doit pas appeler des méthodes sur une table de liaison simultanément à partir de différents threads sans synchronisation.</span><span class="sxs-lookup"><span data-stu-id="7038f-230">Also, a binding table isn't thread safe&mdash;your application must not call methods on a binding table simultaneously from different threads without synchronization.</span></span>

<span data-ttu-id="7038f-231">Et considérez que dans tous les cas, la reliaison est nécessaire uniquement lorsque vous modifiez les ressources liées.</span><span class="sxs-lookup"><span data-stu-id="7038f-231">And consider that in any case rebinding is necessary only when you change which resources are bound.</span></span> <span data-ttu-id="7038f-232">Si vous n’avez pas besoin de modifier les ressources liées, vous pouvez lier une seule fois au démarrage et transmettre la même table de liaison chaque fois que vous appelez **RecordDispatch**.</span><span class="sxs-lookup"><span data-stu-id="7038f-232">If you don't need to change the bound resources, then you can bind once at startup, and pass the same binding table each time you call **RecordDispatch**.</span></span>

<span data-ttu-id="7038f-233">Pour entrelacer les charges de travail de Machine Learning et de rendu, assurez-vous simplement que les tables de liaison de chaque frame pointent vers des plages du tas de descripteurs qui ne sont pas déjà utilisées sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="7038f-233">For interleaving machine learning and rendering workloads, just ensure that each frame's binding tables points to ranges of the descriptor heap that are not already in use on the GPU.</span></span>

## <a name="optionally-specify-late-bound-operator-bindings"></a><span data-ttu-id="7038f-234">Spécifier éventuellement des liaisons d’opérateur à liaison tardive</span><span class="sxs-lookup"><span data-stu-id="7038f-234">Optionally specify late-bound operator bindings</span></span>

<span data-ttu-id="7038f-235">Si vous travaillez avec un opérateur compilé (plutôt qu’avec un initialiseur d’opérateur), vous avez la possibilité de spécifier la liaison tardive pour l’opérateur.</span><span class="sxs-lookup"><span data-stu-id="7038f-235">If you're dealing with a compiled operator (rather than with an operator initializer), then you have the option to specify late binding for the operator.</span></span> <span data-ttu-id="7038f-236">Sans liaison tardive, vous devez définir toutes les liaisons sur la table de liaison avant d’enregistrer un opérateur dans une liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="7038f-236">Without late binding, you must set all bindings on the binding table before you record an operator into a command list.</span></span> <span data-ttu-id="7038f-237">Avec la liaison tardive, vous pouvez définir (ou modifier) des liaisons sur les opérateurs que vous avez déjà enregistrés dans une liste de commandes avant qu’elle ait été envoyée à la file d’attente de commandes.</span><span class="sxs-lookup"><span data-stu-id="7038f-237">With late binding, you can set (or change) bindings on operators that you've already recorded into a command list, before it has been submitted to the command queue.</span></span>

<span data-ttu-id="7038f-238">Pour spécifier la liaison tardive, appelez [**IDMLDevice :: CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) avec un `flags` argument de [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span><span class="sxs-lookup"><span data-stu-id="7038f-238">To specify late binding, call [**IDMLDevice::CompileOperator**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) with a `flags` argument of [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).</span></span>