---
title: Modifications importantes de Direct3D 11 à Direct3D 12
description: Direct3D 12 représente un écart significatif par rapport au modèle de programmation Direct3D 11. Direct3D 12 permet aux applications d’être plus proches du matériel que jamais.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5be891d71d6c1f3a12d8d5aac3ec46785207ed31
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548506"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a><span data-ttu-id="2d8dc-104">Modifications importantes de Direct3D 11 à Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="2d8dc-104">Important Changes from Direct3D 11 to Direct3D 12</span></span>

<span data-ttu-id="2d8dc-105">Direct3D 12 représente un écart significatif par rapport au modèle de programmation Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-105">Direct3D 12 represents a significant departure from the Direct3D 11 programming model.</span></span> <span data-ttu-id="2d8dc-106">Direct3D 12 permet aux applications d’être plus proches du matériel que jamais.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-106">Direct3D 12 lets apps get closer to hardware than ever before.</span></span> <span data-ttu-id="2d8dc-107">En étant plus proche du matériel, Direct3D 12 est plus rapide et plus efficace.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-107">By being closer to hardware, Direct3D 12 is faster and more efficient.</span></span> <span data-ttu-id="2d8dc-108">Toutefois, le compromis de votre application ayant une rapidité et une efficacité accrues avec Direct3D 12 est que vous êtes responsable des tâches supplémentaires que vous étiez avec Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-108">But, the trade-off of your app having increased speed and efficiency with Direct3D 12 is that you are responsible for more tasks than you were with Direct3D 11.</span></span>

-   [<span data-ttu-id="2d8dc-109">Synchronisation explicite</span><span class="sxs-lookup"><span data-stu-id="2d8dc-109">Explicit Synchronization</span></span>](#explicit-synchronization)
-   [<span data-ttu-id="2d8dc-110">Gestion de la résidence de la mémoire physique</span><span class="sxs-lookup"><span data-stu-id="2d8dc-110">Physical Memory Residency Management</span></span>](#physical-memory-residency-management)
-   [<span data-ttu-id="2d8dc-111">Objets d’état de pipeline</span><span class="sxs-lookup"><span data-stu-id="2d8dc-111">Pipeline state objects</span></span>](#pipeline-state-objects)
-   [<span data-ttu-id="2d8dc-112">Listes de commandes et offres groupées</span><span class="sxs-lookup"><span data-stu-id="2d8dc-112">Command lists and bundles</span></span>](#command-lists-and-bundles)
-   [<span data-ttu-id="2d8dc-113">Tas et tables de descripteurs</span><span class="sxs-lookup"><span data-stu-id="2d8dc-113">Descriptor heaps and tables</span></span>](#descriptor-heaps-and-tables)
-   [<span data-ttu-id="2d8dc-114">Portage à partir de Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="2d8dc-114">Porting from Direct3D 11</span></span>](#porting-from-direct3d-11)
-   [<span data-ttu-id="2d8dc-115">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="2d8dc-115">Related topics</span></span>](#related-topics)

<span data-ttu-id="2d8dc-116">Direct3D 12 est un retour à la programmation de bas niveau. il vous donne davantage de contrôle sur les éléments graphiques de vos jeux et applications en introduisant ces nouvelles fonctionnalités : les objets pour représenter l’état global du pipeline, les listes de commandes et les offres groupées pour l’envoi de travail, ainsi que les tas et les tables de descripteurs pour l’accès aux ressources.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-116">Direct3D 12 is a return to low-level programming; it gives you more control over the graphical elements of your games and apps by introducing these new features: objects to represent the overall state of the pipeline, command lists and bundles for work submission, and descriptor heaps and tables for resource access.</span></span>

<span data-ttu-id="2d8dc-117">Votre application a augmenté la vitesse et l’efficacité avec Direct3D 12, mais vous êtes responsable des tâches supplémentaires que vous étiez avec Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-117">Your app has increased speed and efficiency with Direct3D 12, but you are responsible for more tasks than you were with Direct3D 11.</span></span>

## <a name="explicit-synchronization"></a><span data-ttu-id="2d8dc-118">Synchronisation explicite</span><span class="sxs-lookup"><span data-stu-id="2d8dc-118">Explicit Synchronization</span></span>

-   <span data-ttu-id="2d8dc-119">Dans Direct3D 12, la synchronisation processeur-GPU est désormais la responsabilité explicite de l’application et n’est plus implicitement effectuée par le runtime, comme c’est le cas dans Direct3D 11.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-119">In Direct3D 12, CPU-GPU synchronization is now the explicit responsibility of the app and is no longer implicitly performed by the runtime, as it is in Direct3D 11.</span></span> <span data-ttu-id="2d8dc-120">Cela signifie également qu’aucune vérification automatique des risques de pipeline n’est effectuée par Direct3D 12. il s’agit donc de la responsabilité des applications.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-120">This fact also means that no automatic checking for pipeline hazards is performed by Direct3D 12, so again this is the apps responsibility.</span></span>
-   <span data-ttu-id="2d8dc-121">Dans Direct3D 12, les applications sont responsables du traitement par pipeline des mises à jour des données.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-121">In Direct3D 12, apps are responsible for pipelining data updates.</span></span> <span data-ttu-id="2d8dc-122">Autrement dit, le modèle « mapper/verrouiller-ignorer » dans Direct3D 11 doit être effectué manuellement dans Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-122">That is, the "Map/Lock-DISCARD" pattern in Direct3D 11 must be performed manually in Direct3D 12.</span></span> <span data-ttu-id="2d8dc-123">Dans Direct3D 11, si le GPU utilise toujours la mémoire tampon quand vous appelez [**ID3D11DeviceContext :: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) avec [**d3d11 \_ mapper \_ Write \_ ignore**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), le runtime retourne un pointeur vers une nouvelle région de mémoire au lieu des anciennes données de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-123">In Direct3D 11, if the GPU is still using the buffer when you call [**ID3D11DeviceContext::Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) with [**D3D11\_MAP\_WRITE\_DISCARD**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), the runtime returns a pointer to a new region of memory instead of the old buffer data.</span></span> <span data-ttu-id="2d8dc-124">Cela permet au GPU de continuer à utiliser les anciennes données pendant que l’application place les données dans la nouvelle mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-124">This allows the GPU to continue using the old data while the app places data in the new buffer.</span></span> <span data-ttu-id="2d8dc-125">Aucune gestion supplémentaire de la mémoire n’est nécessaire dans l’application. l’ancienne mémoire tampon est réutilisée ou détruite automatiquement lorsque le GPU en a terminé avec celle-ci.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-125">No additional memory management is required in the app; the old buffer is reused or destroyed automatically when the GPU is finished with it.</span></span>
-   <span data-ttu-id="2d8dc-126">Dans Direct3D 12, toutes les mises à jour dynamiques (y compris les mémoires tampons constantes, les mémoires tampons de vertex dynamiques, les textures dynamiques, etc.) sont explicitement contrôlées par l’application.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-126">In Direct3D 12, all dynamic updates (including constant buffers, dynamic vertex buffers, dynamic textures, and so on) are explicitly controlled by the app.</span></span> <span data-ttu-id="2d8dc-127">Ces mises à jour dynamiques incluent toutes les délimitations GPU nécessaires ou la mise en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-127">These dynamic updates include any required GPU fences or buffering.</span></span> <span data-ttu-id="2d8dc-128">L’application est chargée de conserver la mémoire disponible jusqu’à ce qu’elle ne soit plus nécessaire.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-128">The app is responsible for keeping the memory available until it is no longer needed.</span></span>
-   <span data-ttu-id="2d8dc-129">Direct3D 12 utilise le comptage de références de style COM uniquement pour les durées de vie des interfaces (en utilisant le modèle de référence faible de Direct3D lié à la durée de vie de l’appareil).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-129">Direct3D 12 uses COM-style reference counting only for the lifetimes of interfaces (by using the weak reference model of Direct3D tied to the lifetime of the device).</span></span> <span data-ttu-id="2d8dc-130">Toutes les durées de vie de la mémoire des ressources et des descriptions sont le seul responsable de l’application à maintenir pour la durée appropriée, et ne sont pas comptés comme des références.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-130">All resource and description memory lifetimes are the sole responsibly of the app to maintain for the proper duration, and are not reference counted.</span></span> <span data-ttu-id="2d8dc-131">Direct3D 11 utilise le décompte de références pour gérer également les durées de vie des dépendances d’interface.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-131">Direct3D 11 uses reference counting to manage the lifetimes of interface dependencies as well.</span></span>

## <a name="physical-memory-residency-management"></a><span data-ttu-id="2d8dc-132">Gestion de la résidence de la mémoire physique</span><span class="sxs-lookup"><span data-stu-id="2d8dc-132">Physical Memory Residency Management</span></span>

<span data-ttu-id="2d8dc-133">Une application Direct3D 12 doit empêcher les conditions de concurrence entre plusieurs files d’attente, plusieurs adaptateurs et les threads de l’UC.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-133">A Direct3D 12 application must prevent race-conditions between multiple queues, multiple adapters, and the CPU threads.</span></span> <span data-ttu-id="2d8dc-134">D3D12 ne synchronise plus le processeur et le GPU, ni ne prend en charge des mécanismes pratiques pour le changement de nom des ressources ou la mise en mémoire tampon multiple.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-134">D3D12 no longer synchronizes the CPU and GPU, nor supports convenient mechanisms for resource renaming or multi-buffering.</span></span> <span data-ttu-id="2d8dc-135">Les délimitations doivent être utilisées pour éviter que plusieurs unités de traitement n’écrivent de la mémoire au-delà d’une autre unité de traitement.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-135">Fences must be used to avoid multiple processing units from over-writing memory before another processing unit finishes using it.</span></span>

<span data-ttu-id="2d8dc-136">L’application Direct3D 12 doit s’assurer que les données résident dans la mémoire pendant que le GPU les lit.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-136">The Direct3D 12 application must ensure data is resident in memory while the GPU reads it.</span></span> <span data-ttu-id="2d8dc-137">La mémoire utilisée par chaque objet est rendue résidente pendant la création de l’objet.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-137">Memory used by each object is made resident during the creation of the object.</span></span> <span data-ttu-id="2d8dc-138">Les applications qui appellent ces méthodes doivent utiliser des délimiteurs pour garantir que le GPU n’accède pas aux objets qui ont été supprimés.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-138">Applications which call these methods must use fences to ensure the GPU doesn't access objects which have been evicted.</span></span>

<span data-ttu-id="2d8dc-139">Les barrières de ressources sont un autre type de synchronisation nécessaire, utilisé pour synchroniser des transitions de ressources et de sous-ressources à un niveau très granulaire.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-139">Resource barriers are another type of synchronization needed, used to synchronize resource and subresource transitions at a very granular level.</span></span>

<span data-ttu-id="2d8dc-140">Reportez-vous à [gestion de la mémoire dans Direct3D 12](memory-management.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-140">Refer to [Memory Management in Direct3D 12](memory-management.md).</span></span>

## <a name="pipeline-state-objects"></a><span data-ttu-id="2d8dc-141">Objets d’état de pipeline</span><span class="sxs-lookup"><span data-stu-id="2d8dc-141">Pipeline state objects</span></span>

<span data-ttu-id="2d8dc-142">Direct3D 11 permet la manipulation de l’état du pipeline via un grand ensemble d’objets indépendants.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-142">Direct3D 11 allows pipeline state manipulation through a large set of independent objects.</span></span> <span data-ttu-id="2d8dc-143">Par exemple, l’état de l’assembleur d’entrée, l’état du nuanceur de pixels, l’état du rastériseur et l’état de fusion des sorties peuvent tous être modifiés indépendamment.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-143">For example, input assembler state, pixel shader state, rasterizer state, and output merger state can all be independently modified.</span></span> <span data-ttu-id="2d8dc-144">Cette conception fournit une représentation pratique et relativement générale du pipeline Graphics, mais elle n’utilise pas les fonctionnalités du matériel moderne, principalement parce que les différents États sont souvent interdépendants.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-144">This design provides a convenient and relatively high-level representation of the graphics pipeline, but it doesn’t utilize the capabilities of modern hardware, primarily because the various states are often interdependent.</span></span> <span data-ttu-id="2d8dc-145">Par exemple, de nombreuses GPU associent un nuanceur de pixels et un état de fusion de sortie en une seule représentation matérielle.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-145">For example, many GPUs combine pixel shader and output merger state into a single hardware representation.</span></span> <span data-ttu-id="2d8dc-146">Toutefois, étant donné que l’API Direct3D 11 permet de définir séparément ces étapes de pipeline, le pilote d’affichage ne peut pas résoudre les problèmes d’état de pipeline tant que l’État n’est pas finalisé, ce qui n’est pas jusqu’à l’heure de création.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-146">But because the Direct3D 11 API allows these pipeline stages to be set separately, the display driver can't resolve issues of pipeline state until the state is finalized, which isn’t until draw time.</span></span> <span data-ttu-id="2d8dc-147">Ce schéma retarde la configuration de l’état du matériel, ce qui signifie une surcharge supplémentaire et un nombre d’appels de dessin maximum par trame.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-147">This scheme delays hardware state setup, which means extra overhead and fewer maximum draw calls per frame.</span></span>

<span data-ttu-id="2d8dc-148">Direct3D 12 traite ce schéma en unifiant une grande partie de l’état du pipeline en objets d’état de pipeline immuables (objets PSO), qui sont finalisés lors de la création.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-148">Direct3D 12 addresses this scheme by unifying much of the pipeline state into immutable pipeline state objects (PSOs), which are finalized upon creation.</span></span> <span data-ttu-id="2d8dc-149">Le matériel et les pilotes peuvent ensuite convertir immédiatement l’PSO en un état matériel et des instructions natives pour exécuter le travail GPU.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-149">Hardware and drivers can then immediately convert the PSO into whatever hardware native instructions and state are required to execute GPU work.</span></span> <span data-ttu-id="2d8dc-150">Vous pouvez toujours changer de manière dynamique l’PSO en cours d’utilisation, mais pour ce faire, le matériel doit uniquement copier la quantité minimale d’État précalculé directement dans les registres matériels, plutôt que de calculer l’état du matériel à la volée.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-150">You can still dynamically change which PSO is in use, but to do so, the hardware only needs to copy the minimal amount of pre-computed state directly to the hardware registers, rather than computing the hardware state on the fly.</span></span> <span data-ttu-id="2d8dc-151">En utilisant objets PSO, la surcharge des appels de dessin est considérablement réduite, et beaucoup d’appels de dessin peuvent se produire par trame.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-151">By using PSOs, draw call overhead is reduced significantly, and many more draw calls can occur per frame.</span></span> <span data-ttu-id="2d8dc-152">Pour plus d’informations sur objets PSO, consultez [gestion de l’état des pipelines graphiques dans Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-152">For more information about PSOs, see [Managing graphics pipeline state in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="command-lists-and-bundles"></a><span data-ttu-id="2d8dc-153">Listes de commandes et offres groupées</span><span class="sxs-lookup"><span data-stu-id="2d8dc-153">Command lists and bundles</span></span>

<span data-ttu-id="2d8dc-154">Dans Direct3D 11, toute la soumission de travail s’effectue via le [contexte immédiat](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), qui représente un flux unique de commandes qui sont dirigées vers le GPU.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-154">In Direct3D 11, all work submission is done via the [immediate context](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), which represents a single stream of commands that go to the GPU.</span></span> <span data-ttu-id="2d8dc-155">Pour obtenir une mise à l’échelle multithread, des [contextes différés](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) sont également disponibles pour les jeux.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-155">To achieve multithreaded scaling, games also have [deferred contexts](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) available to them.</span></span> <span data-ttu-id="2d8dc-156">Les contextes différés dans Direct3D 11 ne sont pas parfaitement mappés sur le matériel, donc relativement peu de travail peut être effectué dans ces derniers.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-156">Deferred contexts in Direct3D 11 don't map perfectly to hardware, so relatively little work can be done in them.</span></span>

<span data-ttu-id="2d8dc-157">Direct3D 12 introduit un nouveau modèle d’envoi de travail basé sur des listes de commandes qui contiennent l’intégralité des informations nécessaires à l’exécution d’une charge de travail particulière sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-157">Direct3D 12 introduces a new model for work submission based on command lists that contain the entirety of information needed to execute a particular workload on the GPU.</span></span> <span data-ttu-id="2d8dc-158">Chaque nouvelle liste de commandes contient des informations telles que l’PSO à utiliser, la texture et les ressources de mémoire tampon nécessaires, ainsi que les arguments de tous les appels de dessin.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-158">Each new command list contains information such as which PSO to use, what texture and buffer resources are needed, and the arguments to all draw calls.</span></span> <span data-ttu-id="2d8dc-159">Étant donné que chaque liste de commandes est autonome et n’hérite d’aucun État, le pilote peut précalculer toutes les commandes GPU nécessaires à l’avance et en mode thread libre.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-159">Because each command list is self-contained and inherits no state, the driver can pre-compute all necessary GPU commands up-front and in a free-threaded manner.</span></span> <span data-ttu-id="2d8dc-160">Le seul processus en série nécessaire est la soumission finale des listes de commandes au GPU via la file d’attente de commandes.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-160">The only serial process necessary is the final submission of command lists to the GPU via the command queue.</span></span>

<span data-ttu-id="2d8dc-161">En plus des listes de commandes, Direct3D 12 introduit également un deuxième niveau de précalcul de travail : *bundles*.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-161">In addition to command lists, Direct3D 12 also introduces a second level of work pre-computation: *bundles*.</span></span> <span data-ttu-id="2d8dc-162">À la différence des listes de commandes, qui sont entièrement autonomes et sont généralement construites, soumises une seule fois et ignorées, les offres groupées fournissent une forme d’héritage d’État qui permet la réutilisation.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-162">Unlike command lists, which are completely self-contained and are typically constructed, submitted once, and discarded, bundles provide a form of state inheritance that permits reuse.</span></span> <span data-ttu-id="2d8dc-163">Par exemple, si un jeu souhaite dessiner deux modèles de caractères avec différentes textures, une approche consiste à enregistrer une liste de commandes avec deux ensembles d’appels de dessin identiques.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-163">For example, if a game wants to draw two character models with different textures, one approach is to record a command list with two sets of identical draw calls.</span></span> <span data-ttu-id="2d8dc-164">Toutefois, une autre approche consiste à « enregistrer » un bundle qui dessine un modèle à un seul caractère, puis à « lire » le bundle à deux reprises sur la liste des commandes à l’aide de différentes ressources.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-164">But another approach is to "record" one bundle that draws a single character model, then "play back" the bundle twice on the command list using different resources.</span></span> <span data-ttu-id="2d8dc-165">Dans ce dernier cas, le pilote d’affichage doit uniquement calculer les instructions appropriées une seule fois, et la création de la liste de commandes est essentiellement de deux appels de fonction à faible coût.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-165">In the latter case, the display driver only has to compute the appropriate instructions once, and creating the command list essentially amounts to two low-cost function calls.</span></span>

<span data-ttu-id="2d8dc-166">Pour plus d’informations sur les listes de commandes et les offres groupées, consultez [soumission de travail dans Direct3D 12](command-queues-and-command-lists.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-166">For more information about command lists and bundles, see [Work Submission in Direct3D 12](command-queues-and-command-lists.md).</span></span>

## <a name="descriptor-heaps-and-tables"></a><span data-ttu-id="2d8dc-167">Tas et tables de descripteurs</span><span class="sxs-lookup"><span data-stu-id="2d8dc-167">Descriptor heaps and tables</span></span>

<span data-ttu-id="2d8dc-168">La liaison de ressources dans Direct3D 11 est très abstraite et pratique, mais laisse de nombreuses capacités matérielles modernes sous-exploitées.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-168">Resource binding in Direct3D 11 is highly abstracted and convenient, but leaves many modern hardware capabilities underutilized.</span></span> <span data-ttu-id="2d8dc-169">Dans Direct3D 11, les jeux créent des objets de *vue* de ressources, puis lient ces vues à plusieurs *emplacements* à différentes étapes de nuanceur dans le pipeline.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-169">In Direct3D 11, games create *view* objects of resources, then bind those views to several *slots* at various shader stages in the pipeline.</span></span> <span data-ttu-id="2d8dc-170">À leur tour, les nuanceurs lisent les données à partir de ces emplacements de liaison explicites, qui sont fixes au moment du tracé.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-170">Shaders, in turn, read data from those explicit bind slots, which are fixed at draw time.</span></span> <span data-ttu-id="2d8dc-171">Ce modèle signifie que chaque fois qu’un jeu dessine à l’aide de différentes ressources, il doit lier de nouveau des vues différentes à des emplacements différents et appeler à nouveau Draw.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-171">This model means that whenever a game will draw using different resources, it must re-bind different views to different slots, and call draw again.</span></span> <span data-ttu-id="2d8dc-172">Ce cas représente également une surcharge qui peut être éliminée en utilisant pleinement les fonctionnalités matérielles modernes.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-172">This case also represents overhead that can be eliminated by fully utilizing modern hardware capabilities.</span></span>

<span data-ttu-id="2d8dc-173">Direct3D 12 modifie le modèle de liaison pour qu’il corresponde au matériel moderne et améliore considérablement les performances.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-173">Direct3D 12 changes the binding model to match modern hardware and significantly improves performance.</span></span> <span data-ttu-id="2d8dc-174">Au lieu de demander des vues de ressources autonomes et un mappage explicite aux emplacements, Direct3D 12 fournit un tas de descripteurs dans lequel les jeux créent leurs différents affichages de ressources.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-174">Instead of requiring standalone resource views and explicit mapping to slots, Direct3D 12 provides a descriptor heap into which games create their various resource views.</span></span> <span data-ttu-id="2d8dc-175">Ce schéma fournit un mécanisme permettant au GPU d’écrire directement la description de la ressource matérielle (descripteur) sur la mémoire à l’avance.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-175">This scheme provides a mechanism for the GPU to directly write the hardware-native resource description (descriptor) to memory up-front.</span></span> <span data-ttu-id="2d8dc-176">Pour déclarer les ressources qui doivent être utilisées par le pipeline pour un appel de dessin particulier, les jeux spécifient une ou plusieurs tables de descripteurs qui représentent des sous-plages du tas de descripteur complet.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-176">To declare which resources are to be used by the pipeline for a particular draw call, games specify one or more descriptor tables that represent sub-ranges of the full descriptor heap.</span></span> <span data-ttu-id="2d8dc-177">Comme le tas du descripteur a déjà été rempli avec les données de descripteur spécifiques au matériel appropriées, la modification des tables de descripteurs est une opération extrêmement économique.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-177">As the descriptor heap has already been populated with the appropriate hardware-specific descriptor data, changing descriptor tables is an extremely low-cost operation.</span></span>

<span data-ttu-id="2d8dc-178">En plus des performances améliorées offertes par les tas et les tables de descripteurs, Direct3D 12 permet également l’indexation dynamique des ressources dans les nuanceurs, ce qui offre une flexibilité sans précédent et déverrouille les nouvelles techniques de rendu.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-178">In addition to the improved performance offered by descriptor heaps and tables, Direct3D 12 also allows resources to be dynamically indexed in shaders, which provides unprecedented flexibility and unlocks new rendering techniques.</span></span> <span data-ttu-id="2d8dc-179">À titre d’exemple, les moteurs de rendu différé modernes encodent généralement un matériau ou un identificateur d’objet d’un certain type dans la mémoire tampon g intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-179">As an example, modern deferred rendering engines typically encode a material or object identifier of some kind to the intermediate g-buffer.</span></span> <span data-ttu-id="2d8dc-180">Dans Direct3D 11, ces moteurs doivent être vigilants pour éviter d’utiliser un trop grand nombre de documents, comme le nombre trop important d’une mémoire tampon g peut considérablement ralentir la passe de rendu finale.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-180">In Direct3D 11, these engines must be careful to avoid using too many materials, as including too many in one g-buffer can significantly slow down the final render pass.</span></span> <span data-ttu-id="2d8dc-181">Avec les ressources indexables de manière dynamique, une scène avec mille documents peut être finalisée tout aussi rapidement qu’une seule avec dix.</span><span class="sxs-lookup"><span data-stu-id="2d8dc-181">With dynamically indexable resources, a scene with a thousand materials can be finalized just as quickly as one with only ten.</span></span>

<span data-ttu-id="2d8dc-182">Pour plus d’informations sur les tables et les tas de descripteurs, consultez [liaison de ressources](resource-binding.md)et [différences dans le modèle de liaison de Direct3D 11](binding-model.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-182">For more information about descriptor heaps and tables, see [Resource Binding](resource-binding.md), and [Differences in the Binding Model from Direct3D 11](binding-model.md).</span></span>

## <a name="porting-from-direct3d-11"></a><span data-ttu-id="2d8dc-183">Portage à partir de Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="2d8dc-183">Porting from Direct3D 11</span></span>

<span data-ttu-id="2d8dc-184">Le portage à partir de Direct3D 11 est un processus impliqué, décrit dans [Portage de Direct3D 11 vers Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-184">Porting from Direct3D 11 is an involved process, described in [Porting from Direct3D 11 to Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md).</span></span> <span data-ttu-id="2d8dc-185">Reportez-vous également à la gamme d’options disponibles dans [utilisation de Direct3D 11, Direct3D 10 et Direct2D](direct3d-12-interop.md).</span><span class="sxs-lookup"><span data-stu-id="2d8dc-185">Also refer to the range of options in [Working with Direct3D 11, Direct3D 10 and Direct2D](direct3d-12-interop.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="2d8dc-186">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="2d8dc-186">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2d8dc-187">Comprendre Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="2d8dc-187">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
</dt> </dl>

 

 