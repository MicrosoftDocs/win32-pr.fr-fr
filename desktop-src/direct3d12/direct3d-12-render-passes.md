---
title: Passes de rendu Direct3D 12
description: La fonctionnalité de passes de rendu permet à votre convertisseur d’améliorer l’efficacité du GPU en réduisant le trafic de mémoire vers/à partir de la mémoire hors puce. pour ce faire, il permet à votre application d’identifier plus facilement les exigences de classement de rendu des ressources et les dépendances de données.
ms.localizationpriority: high
ms.topic: article
ms.date: 11/15/2018
ms.openlocfilehash: f776729f17ac0017d713c6f37bc71de7302a7c08
ms.sourcegitcommit: 780d4b1601c45658ef0b799b80d13f45a53d808d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/26/2020
ms.locfileid: "104548491"
---
# <a name="direct3d-12-render-passes"></a><span data-ttu-id="1261e-103">Passes de rendu Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="1261e-103">Direct3D 12 render passes</span></span>

<span data-ttu-id="1261e-104">La fonctionnalité de passes de rendu est nouvelle pour Windows 10, version 1809 (10,0 ; Build 17763), et introduit le concept d’une passe de rendu Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="1261e-104">The render passes feature is new for Windows 10, version 1809 (10.0; Build 17763), and it introduces the concept of a Direct3D 12 render pass.</span></span> <span data-ttu-id="1261e-105">Une passe de rendu se compose d’un sous-ensemble des commandes que vous enregistrez dans une liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="1261e-105">A render pass consists of a subset of the commands that you record into a command list.</span></span>

<span data-ttu-id="1261e-106">Pour déclarer où chaque passe de rendu commence et se termine, vous imbriquez les commandes appartenant à cette passe dans les appels à [**ID3D12GraphicsCommandList4 :: BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) et [**EndRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass).</span><span class="sxs-lookup"><span data-stu-id="1261e-106">To declare where each render pass begins and ends, you nest the commands belonging to that pass inside calls to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass) and [**EndRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-endrenderpass).</span></span> <span data-ttu-id="1261e-107">Par conséquent, toute liste de commandes contient zéro, une ou plusieurs passes de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-107">Consequently, any command list contains zero, one, or more render passes.</span></span>

## <a name="scenarios"></a><span data-ttu-id="1261e-108">Scénarios</span><span class="sxs-lookup"><span data-stu-id="1261e-108">Scenarios</span></span>

<span data-ttu-id="1261e-109">Les passes de rendu peuvent améliorer les performances de votre convertisseur s’il est basé sur Tile-Based le rendu différé (TBDR), entre autres techniques.</span><span class="sxs-lookup"><span data-stu-id="1261e-109">Render passes can improve the performance of your renderer if it's based on Tile-Based Deferred Rendering (TBDR), among other techniques.</span></span> <span data-ttu-id="1261e-110">Plus précisément, la technique permet à votre convertisseur d’améliorer l’efficacité du GPU en réduisant le trafic de mémoire vers/à partir de la mémoire hors puce en permettant à votre application d’identifier plus facilement les exigences de classement des ressources et les dépendances de données.</span><span class="sxs-lookup"><span data-stu-id="1261e-110">More specifically, the technique helps your renderer to improve GPU efficiency by reducing memory traffic to/from off-chip memory by enabling your application to better identify resource rendering ordering requirements and data dependencies.</span></span>

<span data-ttu-id="1261e-111">Un pilote d’affichage écrit expressément pour tirer parti de la fonctionnalité de passes de rendu donne les meilleurs résultats.</span><span class="sxs-lookup"><span data-stu-id="1261e-111">A display driver written expressly to leverage the render passes feature gives the best results.</span></span> <span data-ttu-id="1261e-112">Toutefois, les API de tests de rendu peuvent s’exécuter même sur des pilotes préexistants (mais pas nécessairement avec des améliorations de performances).</span><span class="sxs-lookup"><span data-stu-id="1261e-112">But render passes APIs can run even on pre-existing drivers (although, not necessarily with performance improvements).</span></span>

<span data-ttu-id="1261e-113">Voici les scénarios dans lesquels les passes de rendu sont conçues pour fournir de la valeur.</span><span class="sxs-lookup"><span data-stu-id="1261e-113">These are the scenarios in which render passes is designed to provide value.</span></span>

### <a name="allow-your-application-to-avoid-unnecessary-loadsstores-of-resources-fromto-main-memory-on-a-tile-based-deferred-rendering-tbdr-architecture"></a><span data-ttu-id="1261e-114">Autoriser votre application à éviter les chargements/magasins de ressources inutiles de/vers la mémoire principale sur une Tile-Based architecture de rendu différée (TBDR)</span><span class="sxs-lookup"><span data-stu-id="1261e-114">Allow your application to avoid unnecessary loads/stores of resources from/to main memory on a Tile-Based Deferred Rendering (TBDR) architecture</span></span>

<span data-ttu-id="1261e-115">L’une des propositions de valeur des passes de rendu est qu’elle vous fournit un emplacement central pour indiquer les dépendances de données de votre application pour un ensemble d’opérations de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-115">One of the value propositions of render passes is that it provides you with a central location to indicate your application's data dependencies for a set of rendering operations.</span></span> <span data-ttu-id="1261e-116">Ces dépendances de données permettent au pilote d’affichage d’inspecter ces données au moment de la liaison ou de la barrière, et d’émettre des instructions qui réduisent les chargements/magasins de ressources de/vers la mémoire principale.</span><span class="sxs-lookup"><span data-stu-id="1261e-116">These data dependencies allow the display driver to inspect this data at bind/barrier time, and to issue instructions that minimize resource loads/stores from/to main memory.</span></span>

### <a name="allow-your-tbdr-architecture-to-opportunistically-persistent-resources-in-on-chip-cache-across-render-passes-even-in-separate-command-lists"></a><span data-ttu-id="1261e-117">Autoriser votre architecture TBDR à associer façon opportuniste des ressources persistantes dans le cache sur puce sur les passes de rendu (même dans des listes de commandes distinctes)</span><span class="sxs-lookup"><span data-stu-id="1261e-117">Allow your TBDR architecture to opportunistically persistent resources in on-chip cache across render passes (even in separate Command Lists)</span></span>

> [!NOTE]
> <span data-ttu-id="1261e-118">Plus précisément, ce scénario est limité aux cas où vous écrivez dans les mêmes cibles de rendu sur plusieurs listes de commandes.</span><span class="sxs-lookup"><span data-stu-id="1261e-118">Specifically, this scenario is limited to the cases where you're writing to the same render target(s) across multiple command lists.</span></span>

<span data-ttu-id="1261e-119">Un modèle de rendu courant permet à votre application de s’afficher en série sur les mêmes cibles de rendu sur plusieurs listes de commandes, même si les commandes de rendu sont générées en parallèle.</span><span class="sxs-lookup"><span data-stu-id="1261e-119">A common rendering pattern is for your application to render to the same render target(s) across multiple command lists serially, even though the rendering commands are generated in parallel.</span></span> <span data-ttu-id="1261e-120">Grâce à l’utilisation des passes de rendu dans ce scénario, ces passes sont combinées de manière à ce que le pilote d’affichage puisse éviter de vider la mémoire principale sur les limites de la liste de commandes, ce qui permet de les combiner.</span><span class="sxs-lookup"><span data-stu-id="1261e-120">Your use of render passes in this scenario allows these passes to be combined in such a way (since the application knows that it will resume rendering on the immediate succeeding command list) that the display driver can avoid a flush to main memory on command list boundaries.</span></span>

## <a name="your-applications-responsibilities"></a><span data-ttu-id="1261e-121">Responsabilités de votre application</span><span class="sxs-lookup"><span data-stu-id="1261e-121">Your application's responsibilities</span></span>

<span data-ttu-id="1261e-122">Même avec la fonctionnalité de passes de rendu, le runtime Direct3D 12 et le pilote d’affichage ne prennent pas la responsabilité de déduire les opportunités de réorganisation et d’éviter les chargements et les magasins.</span><span class="sxs-lookup"><span data-stu-id="1261e-122">Even with the render passes feature, neither the Direct3D 12 runtime nor the display driver take on the responsibility of deducing opportunities to re-order/avoid loads and stores.</span></span> <span data-ttu-id="1261e-123">Pour tirer correctement parti de la fonctionnalité de passes de rendu, votre application a ces responsabilités.</span><span class="sxs-lookup"><span data-stu-id="1261e-123">To correctly leverage the render passes feature, your application has these responsibilities.</span></span>

- <span data-ttu-id="1261e-124">Identifiez correctement les dépendances de classement et de données pour ses opérations.</span><span class="sxs-lookup"><span data-stu-id="1261e-124">Properly identify data/ordering dependencies for its operations.</span></span>
- <span data-ttu-id="1261e-125">Commandez ses soumissions d’une manière qui minimise les vidages (par conséquent, réduisez l’utilisation des indicateurs de **_PRESERVE** ).</span><span class="sxs-lookup"><span data-stu-id="1261e-125">Order its submissions in a way that minimizes flushes (so, minimize your use of **_PRESERVE** flags).</span></span>
- <span data-ttu-id="1261e-126">Utilisez correctement les barrières des ressources et suivez l’état des ressources.</span><span class="sxs-lookup"><span data-stu-id="1261e-126">Correctly make use of resource barriers, and track resource state.</span></span>
- <span data-ttu-id="1261e-127">Évitez les copies/effaces inutiles.</span><span class="sxs-lookup"><span data-stu-id="1261e-127">Avoid unneeded copies/clears.</span></span> <span data-ttu-id="1261e-128">Pour vous aider à les identifier, vous pouvez utiliser les avertissements de performances automatisés à partir de l' [outil pix sur Windows](https://devblogs.microsoft.com/pix/).</span><span class="sxs-lookup"><span data-stu-id="1261e-128">To help identify these, you can make use of the automated performance warnings from the [PIX on Windows tool](https://devblogs.microsoft.com/pix/).</span></span>

## <a name="using-the-render-pass-feature"></a><span data-ttu-id="1261e-129">Utilisation de la fonctionnalité de réussite de rendu</span><span class="sxs-lookup"><span data-stu-id="1261e-129">Using the render pass feature</span></span>

### <a name="what-is-a-render-pass"></a><span data-ttu-id="1261e-130">Qu’est-ce qu’une *passe de rendu*?</span><span class="sxs-lookup"><span data-stu-id="1261e-130">What is a *render pass*?</span></span>

<span data-ttu-id="1261e-131">Une passe de rendu est définie par ces éléments.</span><span class="sxs-lookup"><span data-stu-id="1261e-131">A render pass is defined by these elements.</span></span>

- <span data-ttu-id="1261e-132">Ensemble de liaisons de sortie qui sont fixes pour la durée de la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-132">A set of output bindings that are fixed for the duration of the render pass.</span></span> <span data-ttu-id="1261e-133">Ces liaisons sont vers une ou plusieurs vues de la cible de rendu (RTVs), et/ou vers une vue de stencil de profondeur (DSV).</span><span class="sxs-lookup"><span data-stu-id="1261e-133">These bindings are to one or more render target views (RTVs), and/or to a depth stencil view (DSV).</span></span>
- <span data-ttu-id="1261e-134">Liste des opérations GPU qui ciblent cet ensemble de liaisons de sortie.</span><span class="sxs-lookup"><span data-stu-id="1261e-134">A list of GPU operations that target that set of output bindings.</span></span>
- <span data-ttu-id="1261e-135">Métadonnées qui décrivent les dépendances de chargement/stockage pour toutes les liaisons de sortie ciblées par la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-135">Metadata that describes the load/store dependencies for all output bindings targeted by the render pass.</span></span>

### <a name="declare-your-output-bindings"></a><span data-ttu-id="1261e-136">Déclarer vos liaisons de sortie</span><span class="sxs-lookup"><span data-stu-id="1261e-136">Declare your output bindings</span></span>

<span data-ttu-id="1261e-137">Au début d’une passe de rendu, vous déclarez des liaisons à vos cibles de rendu et/ou à votre mémoire tampon de stencil/profondeur.</span><span class="sxs-lookup"><span data-stu-id="1261e-137">At the start of a render pass, you declare bindings to your render target(s) and/or to your depth/stencil buffer.</span></span> <span data-ttu-id="1261e-138">Il est facultatif de lier à la ou les cibles de rendu, et il est facultatif de lier à une mémoire tampon de stencil/profondeur.</span><span class="sxs-lookup"><span data-stu-id="1261e-138">It's optional to bind to render target(s), and it's optional to bind to a depth/stencil buffer.</span></span> <span data-ttu-id="1261e-139">Toutefois, vous devez établir une liaison avec au moins l’un des deux, et dans l’exemple de code ci-dessous, nous créons une liaison vers les deux.</span><span class="sxs-lookup"><span data-stu-id="1261e-139">But you must bind to at least one of the two, and in the code example below we bind to both.</span></span>

<span data-ttu-id="1261e-140">Vous déclarez ces liaisons dans un appel à [**ID3D12GraphicsCommandList4 :: BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass).</span><span class="sxs-lookup"><span data-stu-id="1261e-140">You declare these bindings in a call to [**ID3D12GraphicsCommandList4::BeginRenderPass**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass).</span></span>

```cppwinrt
void render_passes(::ID3D12GraphicsCommandList4 * pIGCL4,
    D3D12_CPU_DESCRIPTOR_HANDLE const& rtvCPUDescriptorHandle,
    D3D12_CPU_DESCRIPTOR_HANDLE const& dsvCPUDescriptorHandle)
{
    const float clearColor4[]{ 0.f, 0.f, 0.f, 0.f };
    CD3DX12_CLEAR_VALUE clearValue{ DXGI_FORMAT_R32G32B32_FLOAT, clearColor4 };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessClear{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR, { clearValue } };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessPreserve{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE, {} };
    D3D12_RENDER_PASS_RENDER_TARGET_DESC renderPassRenderTargetDesc{ rtvCPUDescriptorHandle, renderPassBeginningAccessClear, renderPassEndingAccessPreserve };

    D3D12_RENDER_PASS_BEGINNING_ACCESS renderPassBeginningAccessNoAccess{ D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_ENDING_ACCESS renderPassEndingAccessNoAccess{ D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS, {} };
    D3D12_RENDER_PASS_DEPTH_STENCIL_DESC renderPassDepthStencilDesc{ dsvCPUDescriptorHandle, renderPassBeginningAccessNoAccess, renderPassBeginningAccessNoAccess, renderPassEndingAccessNoAccess, renderPassEndingAccessNoAccess };

    pIGCL4->BeginRenderPass(1, &renderPassRenderTargetDesc, &renderPassDepthStencilDesc, D3D12_RENDER_PASS_FLAG_NONE);
    // Record command list.
    pIGCL4->EndRenderPass();
    // Begin/End further render passes and then execute the command list(s).
}
```

<span data-ttu-id="1261e-141">Vous définissez le premier champ de la structure [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) sur le handle de descripteur de processeur correspondant à une ou plusieurs vues de la cible de rendu (RTVs).</span><span class="sxs-lookup"><span data-stu-id="1261e-141">You set the first field of the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) structure to the CPU descriptor handle corresponding to one or more render target views (RTVs).</span></span> <span data-ttu-id="1261e-142">De même, [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) contient le handle de descripteur de processeur correspondant à une vue de stencil de profondeur (DSV).</span><span class="sxs-lookup"><span data-stu-id="1261e-142">Similarly, [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) contains the CPU descriptor handle corresponding to a depth stencil view (DSV).</span></span> <span data-ttu-id="1261e-143">Ces handles de descripteur de processeur sont les mêmes que ceux que vous transmettez autrement à [**ID3D12GraphicsCommandList :: OMSetRenderTargets**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets).</span><span class="sxs-lookup"><span data-stu-id="1261e-143">Those CPU descriptor handles are the same ones that you would otherwise pass to [**ID3D12GraphicsCommandList::OMSetRenderTargets**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets).</span></span> <span data-ttu-id="1261e-144">Et, comme avec **OMSetRenderTargets**, les descripteurs d’UC sont *alignés* à partir de leurs tas (descripteur de processeur) respectifs au moment de l’appel à **BeginRenderPass**.</span><span class="sxs-lookup"><span data-stu-id="1261e-144">And, just as with **OMSetRenderTargets**, the CPU descriptors are *snapped* from their respective (CPU descriptor) heaps at the time of the call to **BeginRenderPass**.</span></span>

<span data-ttu-id="1261e-145">Les RTVs et DSV ne sont pas hérités dans la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-145">The RTVs and DSV are not inherited in to the render pass.</span></span> <span data-ttu-id="1261e-146">Au lieu de cela, elles doivent être définies.</span><span class="sxs-lookup"><span data-stu-id="1261e-146">Rather, they must be set.</span></span> <span data-ttu-id="1261e-147">Par ailleurs, les RTVs et DSV déclarés dans **BeginRenderPass** sont propagés à la liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="1261e-147">Nor are the RTVs and DSV declared in **BeginRenderPass** propagated out to the command list.</span></span> <span data-ttu-id="1261e-148">Au lieu de cela, ils sont dans un État non défini après la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-148">Rather, they are in an undefined state following the render pass.</span></span>

### <a name="render-passes-and-workloads"></a><span data-ttu-id="1261e-149">Rendu des passes et des charges de travail</span><span class="sxs-lookup"><span data-stu-id="1261e-149">Render passes and workloads</span></span>

<span data-ttu-id="1261e-150">Vous ne pouvez pas imbriquer des passes de rendu et vous ne pouvez pas avoir une passe de rendu sur plusieurs listes de commandes (elles doivent commencer et se terminer lors de l’enregistrement dans une liste de commandes unique).</span><span class="sxs-lookup"><span data-stu-id="1261e-150">You can't nest render passes, and you can't have a render pass straddle more than one command list (they must begin and end while recording into a single command list).</span></span> <span data-ttu-id="1261e-151">Les optimisations conçues pour permettre une génération multithread efficace de passes de rendu sont présentées dans la section [ indicateurs de réussite de rendu](#render-pass-flags), ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="1261e-151">Optimizations designed to enable efficient multi-threaded generation of render passes are discussed in the section [ render pass Flags](#render-pass-flags), below.</span></span>

<span data-ttu-id="1261e-152">Une écriture que vous effectuez à partir d’une passe de rendu n’est pas *valide* pour la lecture jusqu’à la réussite d’un rendu suivant.</span><span class="sxs-lookup"><span data-stu-id="1261e-152">A write that you do from within a render pass isn't *valid* for you to read from until a subsequent render pass.</span></span> <span data-ttu-id="1261e-153">Cela exclut certains types de barrières de la passe de rendu &mdash; , par exemple, la barrière de **RENDER_TARGET** à **SHADER_RESOURCE** sur la cible de rendu actuellement liée.</span><span class="sxs-lookup"><span data-stu-id="1261e-153">That precludes some types of barriers from within the render pass&mdash;for example, barriering from **RENDER_TARGET** to **SHADER_RESOURCE** on the currently-bound render target.</span></span> <span data-ttu-id="1261e-154">Pour plus d’informations, consultez la section [tests de réussite et barrières des ressources](#render-passes-and-resource-barriers), ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="1261e-154">For more info, see the section [Render passes and resource barriers](#render-passes-and-resource-barriers), below.</span></span>

<span data-ttu-id="1261e-155">La seule exception à la contrainte d’écriture/lecture qui vient d’être mentionnée implique les lectures implicites qui se produisent dans le cadre du test de profondeur et de la fusion de cibles de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-155">The one exception to the write-read constraint just mentioned involves the implicit reads that occur as part of depth-testing and render target blending.</span></span>
<span data-ttu-id="1261e-156">Par conséquent, ces API ne sont pas autorisées dans une passe de rendu (le runtime principal supprime la liste de commandes si l’une d’elles est appelée lors de l’enregistrement).</span><span class="sxs-lookup"><span data-stu-id="1261e-156">So, these APIs are disallowed within a render pass (the core runtime removes the command list if any of them are called during recording).</span></span>

- [<span data-ttu-id="1261e-157">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT**</span><span class="sxs-lookup"><span data-stu-id="1261e-157">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint)
- [<span data-ttu-id="1261e-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span><span class="sxs-lookup"><span data-stu-id="1261e-158">**ID3D12GraphicsCommandList1::AtomicCopyBufferUINT64**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-atomiccopybufferuint64)
- [<span data-ttu-id="1261e-159">**ID3D12GraphicsCommandList4::BeginRenderPass**</span><span class="sxs-lookup"><span data-stu-id="1261e-159">**ID3D12GraphicsCommandList4::BeginRenderPass**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist4-beginrenderpass)
- [<span data-ttu-id="1261e-160">**ID3D12GraphicsCommandList::ClearDepthStencilView**</span><span class="sxs-lookup"><span data-stu-id="1261e-160">**ID3D12GraphicsCommandList::ClearDepthStencilView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview)
- [<span data-ttu-id="1261e-161">**ID3D12GraphicsCommandList::ClearRenderTargetView**</span><span class="sxs-lookup"><span data-stu-id="1261e-161">**ID3D12GraphicsCommandList::ClearRenderTargetView**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearrendertargetview)
- [<span data-ttu-id="1261e-162">**ID3D12GraphicsCommandList::ClearState**</span><span class="sxs-lookup"><span data-stu-id="1261e-162">**ID3D12GraphicsCommandList::ClearState**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate)
- [<span data-ttu-id="1261e-163">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat**</span><span class="sxs-lookup"><span data-stu-id="1261e-163">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewFloat**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewfloat)
- [<span data-ttu-id="1261e-164">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint**</span><span class="sxs-lookup"><span data-stu-id="1261e-164">**ID3D12GraphicsCommandList::ClearUnorderedAccessViewUint**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearunorderedaccessviewuint)
- [<span data-ttu-id="1261e-165">**ID3D12GraphicsCommandList::CopyBufferRegion**</span><span class="sxs-lookup"><span data-stu-id="1261e-165">**ID3D12GraphicsCommandList::CopyBufferRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copybufferregion)
- [<span data-ttu-id="1261e-166">**ID3D12GraphicsCommandList::CopyResource**</span><span class="sxs-lookup"><span data-stu-id="1261e-166">**ID3D12GraphicsCommandList::CopyResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copyresource)
- [<span data-ttu-id="1261e-167">**ID3D12GraphicsCommandList::CopyTextureRegion**</span><span class="sxs-lookup"><span data-stu-id="1261e-167">**ID3D12GraphicsCommandList::CopyTextureRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytextureregion)
- [<span data-ttu-id="1261e-168">**ID3D12GraphicsCommandList::CopyTiles**</span><span class="sxs-lookup"><span data-stu-id="1261e-168">**ID3D12GraphicsCommandList::CopyTiles**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-copytiles)
- [<span data-ttu-id="1261e-169">**ID3D12GraphicsCommandList ::D iscardResource**</span><span class="sxs-lookup"><span data-stu-id="1261e-169">**ID3D12GraphicsCommandList::DiscardResource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource)
- [<span data-ttu-id="1261e-170">**ID3D12GraphicsCommandList ::D ispatch**</span><span class="sxs-lookup"><span data-stu-id="1261e-170">**ID3D12GraphicsCommandList::Dispatch**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch)
- [<span data-ttu-id="1261e-171">**ID3D12GraphicsCommandList::OMSetRenderTargets**</span><span class="sxs-lookup"><span data-stu-id="1261e-171">**ID3D12GraphicsCommandList::OMSetRenderTargets**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-omsetrendertargets)
- [<span data-ttu-id="1261e-172">**ID3D12GraphicsCommandList::ResolveQueryData**</span><span class="sxs-lookup"><span data-stu-id="1261e-172">**ID3D12GraphicsCommandList::ResolveQueryData**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvequerydata)
- [<span data-ttu-id="1261e-173">**ID3D12GraphicsCommandList::ResolveSubresource**</span><span class="sxs-lookup"><span data-stu-id="1261e-173">**ID3D12GraphicsCommandList::ResolveSubresource**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resolvesubresource)
- [<span data-ttu-id="1261e-174">**ID3D12GraphicsCommandList1::ResolveSubresourceRegion**</span><span class="sxs-lookup"><span data-stu-id="1261e-174">**ID3D12GraphicsCommandList1::ResolveSubresourceRegion**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-resolvesubresourceregion)
- [<span data-ttu-id="1261e-175">**ID3D12GraphicsCommandList3::SetProtectedResourceSession**</span><span class="sxs-lookup"><span data-stu-id="1261e-175">**ID3D12GraphicsCommandList3::SetProtectedResourceSession**</span></span>](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist3-setprotectedresourcesession)

### <a name="render-passes-and-resource-barriers"></a><span data-ttu-id="1261e-176">Tests de rendu et barrières des ressources</span><span class="sxs-lookup"><span data-stu-id="1261e-176">Render passes and resource barriers</span></span>

<span data-ttu-id="1261e-177">Vous ne pouvez pas lire ou consommer une écriture qui s’est produite dans la même passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-177">You may not read from, or consume, a write that occurred within the same render pass.</span></span> <span data-ttu-id="1261e-178">Certains obstacles ne sont pas conformes à cette contrainte, par exemple de **D3D12_RESOURCE_STATE_RENDER_TARGET** à **\* _SHADER_RESOURCE** sur la cible de rendu actuellement liée (et la couche de débogage génère une erreur).</span><span class="sxs-lookup"><span data-stu-id="1261e-178">Certain barriers don't conform to this constraint, for example from **D3D12_RESOURCE_STATE_RENDER_TARGET** to **\*_SHADER_RESOURCE** on the currently-bound render target (and the debug layer will error to that effect).</span></span> <span data-ttu-id="1261e-179">Toutefois, ce même cloisonnement sur une cible de rendu qui a été écrite *en dehors* de la passe de rendu actuelle est conforme, car les écritures se terminent avant le démarrage de la passe de rendu en cours.</span><span class="sxs-lookup"><span data-stu-id="1261e-179">But, that same barrier on a render target that was written *outside* the current render pass is conformant, because the writes will complete ahead of the current render pass starting.</span></span>
<span data-ttu-id="1261e-180">Il peut être utile de connaître certaines optimisations qu’un pilote d’affichage peut effectuer à cet égard.</span><span class="sxs-lookup"><span data-stu-id="1261e-180">You might benefit from knowing about certain optimizations that a display driver can make in this regard.</span></span> <span data-ttu-id="1261e-181">Dans le cas d’une charge de travail conforme, un pilote d’affichage peut déplacer les barrières rencontrées dans votre passe de rendu vers le début de la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-181">Given a conformant workload, a display driver might move any barriers encountered in your render pass to the beginning of the render pass.</span></span> <span data-ttu-id="1261e-182">À partir de là, ils peuvent être fusionnés (et ne pas interférer avec les opérations de mosaïque/compartimentage).</span><span class="sxs-lookup"><span data-stu-id="1261e-182">There, they can be coalesced (and not interfere with any tiling/binning operations).</span></span> <span data-ttu-id="1261e-183">Il s’agit d’une optimisation valide, à condition que toutes vos écritures soient terminées avant le démarrage de la passe de rendu en cours.</span><span class="sxs-lookup"><span data-stu-id="1261e-183">This is a valid optimization provided that all of your writes have finished before the current render pass starts.</span></span>

<span data-ttu-id="1261e-184">Voici un exemple plus complet d’optimisation de pilote, qui suppose que vous disposez d’un moteur de rendu qui a une conception de liaison de ressources de type pré-Direct3D à 12, qui fait &mdash; *des obstacles à la demande* en fonction de la façon dont les ressources sont liées.</span><span class="sxs-lookup"><span data-stu-id="1261e-184">Here's a more complete driver-optimization example, which assumes that you have a rendering engine that has a pre-Direct3D 12-style resource-binding design&mdash;doing barriers *on demand* based on how resources are bound.</span></span> <span data-ttu-id="1261e-185">Lors de l’écriture dans un affichage d’accès non ordonné (UAV) vers la fin d’un frame (à consommer dans le frame suivant), il peut arriver que le moteur laisse la ressource dans l’état **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** à la fin du frame.</span><span class="sxs-lookup"><span data-stu-id="1261e-185">When writing into an unordered access view (UAV) toward the end of a frame (to be consumed in the following frame), the engine might happen to leave the resource in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state at the conclusion of the frame.</span></span> <span data-ttu-id="1261e-186">Dans le frame qui suit, lorsque le moteur se lie à la ressource en tant que vue de ressource de nuanceur (SRV), il détecte que la ressource n’est pas dans l’état correct, et il émet une barrière de **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** à **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE**.</span><span class="sxs-lookup"><span data-stu-id="1261e-186">In the frame that follows, when the engine goes to bind the resource as a shader resource view (SRV), it will find that the resource is not in the correct state, and it will issue a barrier from **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE**.</span></span> <span data-ttu-id="1261e-187">Si cette barrière se produit au cours de la passe de rendu, le pilote d’affichage est justifié en supposant que toutes les écritures ont déjà eu lieu *en dehors* de cette passe de rendu actuelle. par conséquent, le pilote d’affichage peut *déplacer* le cloisonnement jusqu’au début de la passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-187">If that barrier occurs within the render pass, then the display driver is justified in assuming that all writes have already occurred *outside* of this current render pass, and consequently (and here's where the optimization comes in) the display driver might *move* the barrier up to the start of the render pass.</span></span> <span data-ttu-id="1261e-188">Là encore, cela est valide, à condition que votre code soit conforme à la contrainte d’écriture/lecture décrite dans cette section et dans la dernière.</span><span class="sxs-lookup"><span data-stu-id="1261e-188">Again, this is valid, as long as your code is conforming to the write-read constraint described in this section and the last.</span></span>


<span data-ttu-id="1261e-189">Voici des exemples de barrières conformes.</span><span class="sxs-lookup"><span data-stu-id="1261e-189">These are examples of conformant barriers.</span></span>
- <span data-ttu-id="1261e-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** à **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**.</span><span class="sxs-lookup"><span data-stu-id="1261e-190">**D3D12_RESOURCE_STATE_UNORDERED_ACCESS** to **D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT**.</span></span>
- <span data-ttu-id="1261e-191">**D3D12_RESOURCE_STATE_COPY_DEST** à **\* _SHADER_RESOURCE**.</span><span class="sxs-lookup"><span data-stu-id="1261e-191">**D3D12_RESOURCE_STATE_COPY_DEST** to **\*_SHADER_RESOURCE**.</span></span>

<span data-ttu-id="1261e-192">Et il s’agit d’exemples de barrières non conformes.</span><span class="sxs-lookup"><span data-stu-id="1261e-192">And these are examples of non-conformant barriers.</span></span>

- <span data-ttu-id="1261e-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** à n’importe quel état de lecture sur les RTVs/DSV actuellement liés.</span><span class="sxs-lookup"><span data-stu-id="1261e-193">**D3D12_RESOURCE_STATE_RENDER_TARGET** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="1261e-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** à n’importe quel état de lecture sur les RTVs/DSV actuellement liés.</span><span class="sxs-lookup"><span data-stu-id="1261e-194">**D3D12_RESOURCE_STATE_DEPTH_WRITE** to any read state on currently-bound RTVs/DSVs.</span></span>
- <span data-ttu-id="1261e-195">Toute barrière d’alias.</span><span class="sxs-lookup"><span data-stu-id="1261e-195">Any aliasing barrier.</span></span>
- <span data-ttu-id="1261e-196">Barrières de vue d’accès non triée (UAV).</span><span class="sxs-lookup"><span data-stu-id="1261e-196">Unordered access view (UAV) barriers.</span></span> 

### <a name="resource-access-declaration"></a><span data-ttu-id="1261e-197">Déclaration d’accès aux ressources</span><span class="sxs-lookup"><span data-stu-id="1261e-197">Resource access declaration</span></span>

<span data-ttu-id="1261e-198">Au moment de la **BeginRenderPass** , ainsi que de la déclaration de toutes les ressources qui servent de RTVs et/ou de DSV dans le cadre de cette étape, vous devez également spécifier leurs caractéristiques d' *accès* de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="1261e-198">At **BeginRenderPass** time, as well as declaring all resources that are serving as RTVs and/or DSV within that pass, you must also specify their beginning and ending *access* characteristics.</span></span> <span data-ttu-id="1261e-199">Comme vous pouvez le voir dans l’exemple de code de la section [déclarer vos liaisons de sortie](#declare-your-output-bindings) ci-dessus, vous le faites avec les structures [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) et [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) .</span><span class="sxs-lookup"><span data-stu-id="1261e-199">As you can see in the code example in the [Declare your output bindings](#declare-your-output-bindings) section above, you do this with the [**D3D12_RENDER_PASS_RENDER_TARGET_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_render_target_desc) and [**D3D12_RENDER_PASS_DEPTH_STENCIL_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_depth_stencil_desc) structures.</span></span>

<span data-ttu-id="1261e-200">Pour plus d’informations, consultez les structures [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) et [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) , ainsi que les énumérations [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) et [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) .</span><span class="sxs-lookup"><span data-stu-id="1261e-200">For more details, see the [**D3D12_RENDER_PASS_BEGINNING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_beginning_access) and [**D3D12_RENDER_PASS_ENDING_ACCESS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_render_pass_ending_access) structures, and the [**D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_beginning_access_type) and [**D3D12_RENDER_PASS_ENDING_ACCESS_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_ending_access_type) enumerations.</span></span>

### <a name="render-pass-flags"></a><span data-ttu-id="1261e-201">Indicateurs de passe de rendu</span><span class="sxs-lookup"><span data-stu-id="1261e-201">Render pass flags</span></span>

<span data-ttu-id="1261e-202">Le dernier paramètre passé à **BeginRenderPass** est un indicateur de passe de rendu (une valeur de l’énumération [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) ).</span><span class="sxs-lookup"><span data-stu-id="1261e-202">The last parameter passed to **BeginRenderPass** is a render pass flag (a value from the [**D3D12_RENDER_PASS_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_render_pass_flags) enumeration).</span></span>

```cppwinrt
enum D3D12_RENDER_PASS_FLAGS
{
    D3D12_RENDER_PASS_FLAG_NONE = 0,
    D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES = 0x1,
    D3D12_RENDER_PASS_FLAG_SUSPENDING_PASS = 0x2,
    D3D12_RENDER_PASS_FLAG_RESUMING_PASS = 0x4
};
```

#### <a name="uav-writes-within-a-render-pass"></a><span data-ttu-id="1261e-203">UAV écrit dans une passe de rendu</span><span class="sxs-lookup"><span data-stu-id="1261e-203">UAV writes within a render pass</span></span>

<span data-ttu-id="1261e-204">Les écritures de vue d’accès non triée (UAV) sont autorisées dans une passe de rendu, mais vous devez spécifiquement indiquer que vous enverrez des écritures UAV dans la passe de rendu en spécifiant **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES**, afin que le pilote d’affichage puisse refuser la mosaïque si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="1261e-204">Unordered access view (UAV) writes are permitted within a render pass, but you must specifically indicate that you'll be issuing UAV writes within the render pass by specifying **D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES**, so that the display driver can opt out of tiling if necessary.</span></span>

<span data-ttu-id="1261e-205">Les accès UAV doivent suivre la contrainte d’écriture/lecture décrite ci-dessus (les écritures dans une passe de rendu ne sont pas valides pour la lecture jusqu’à une réussite de rendu ultérieure).</span><span class="sxs-lookup"><span data-stu-id="1261e-205">UAV accesses must follow the write-read constraint described above (writes in a render pass are not valid to read until a subsequent render pass).</span></span> <span data-ttu-id="1261e-206">Les barrières UAV ne sont pas autorisées dans une passe de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-206">UAV barriers are not permitted within a render pass.</span></span>

<span data-ttu-id="1261e-207">Les liaisons UAV (via les tables racines ou les descripteurs racine) sont héritées dans les passes de rendu et sont propagées en dehors des passes de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-207">UAV bindings (via root tables or root descriptors) are inherited into render passes, and are propagated out of render passes.</span></span>

#### <a name="suspending-passes-and-resuming-passes"></a><span data-ttu-id="1261e-208">Interruption-passe et reprise-passes</span><span class="sxs-lookup"><span data-stu-id="1261e-208">Suspending-passes, and resuming-passes</span></span>

<span data-ttu-id="1261e-209">Vous pouvez indiquer qu’une réussite de rendu entière est une passe de suspension et/ou une passe de reprise.</span><span class="sxs-lookup"><span data-stu-id="1261e-209">You can indicate an entire render pass as being a suspending-pass and/or a resuming-pass.</span></span> <span data-ttu-id="1261e-210">Une paire d’interruptions suivies d’une pause doit avoir des indicateurs de vues/d’accès identiques entre les passes. et peuvent ne pas avoir d’opérations GPU intervenues (par exemple, des opérations de dessin, de distribution, de suppression, d’effacement, de copie, de mise à jour-vignette-mappage, d’écriture-mémoire tampon, de requêtes, de résolution de requêtes) entre le test de rendu de suspension et la réussite de reprise.</span><span class="sxs-lookup"><span data-stu-id="1261e-210">A suspending-followed-by-a-resuming pair must have identical views/access flags between the passes, and may not have any intervening GPU operations (for example, draws, dispatches, discards, clears, copies, update-tile-mappings, write-buffer-immediates, queries, query resolves) between the suspending render pass and the resuming render pass.</span></span>

<span data-ttu-id="1261e-211">Le cas d’usage prévu est le rendu multithread, où quatre listes de commandes (chacune avec leurs propres passes de rendu) peuvent cibler les mêmes cibles de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-211">The intended use case is multi-threaded rendering, where say four command lists (each with their own render passes) can target the same render targets.</span></span> <span data-ttu-id="1261e-212">Lorsque les passes de rendu sont suspendues/reprises dans les listes de commandes, les listes de commandes doivent être exécutées dans le même appel à [**ID3D12CommandQueue :: ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists).</span><span class="sxs-lookup"><span data-stu-id="1261e-212">When render passes are suspended/resumed across command lists, the command lists must be executed in the same call to [**ID3D12CommandQueue::ExecuteCommandLists**](/windows/desktop/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists).</span></span>

<span data-ttu-id="1261e-213">Une réussite de rendu peut être à la fois reprise et suspendue.</span><span class="sxs-lookup"><span data-stu-id="1261e-213">A render pass can be both resuming and suspending.</span></span> <span data-ttu-id="1261e-214">Dans l’exemple multithread qui vient d’être donné, les listes de commandes 2 et 3 se reprennent respectivement de 1 et 2.</span><span class="sxs-lookup"><span data-stu-id="1261e-214">In the multi-threaded example just given, command lists 2 and 3 would be resuming from 1 and 2, respectively.</span></span> <span data-ttu-id="1261e-215">Et, en même temps, 2 et 3 s’interrompent respectivement à 3 et 4.</span><span class="sxs-lookup"><span data-stu-id="1261e-215">And at the same time 2 and 3 would be suspending to 3 and 4, respectively.</span></span>

## <a name="query-for-render-passes-feature-support"></a><span data-ttu-id="1261e-216">Requête de prise en charge des fonctionnalités de réussite de rendu</span><span class="sxs-lookup"><span data-stu-id="1261e-216">Query for render passes feature support</span></span>

<span data-ttu-id="1261e-217">Vous pouvez appeler [**ID3D12Device :: CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) pour rechercher dans quelle mesure un pilote de périphérique et/ou le matériel prend en charge efficacement les passes de rendu.</span><span class="sxs-lookup"><span data-stu-id="1261e-217">You can call [**ID3D12Device::CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to query the extent to which a device driver and/or the hardware efficiently supports render passes.</span></span>

```cppwinrt
D3D12_RENDER_PASS_TIER get_render_passes_tier(::ID3D12Device * pIDevice)
{
    D3D12_FEATURE_DATA_D3D12_OPTIONS5 featureSupport{};
    winrt::check_hresult(
        pIDevice->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS5, &featureSupport, sizeof(featureSupport))
    );
    return featureSupport.RenderPassesTier;
}
...
    D3D12_RENDER_PASS_TIER renderPassesTier{ get_render_passes_tier(pIDevice) };
```

<span data-ttu-id="1261e-218">En raison de la logique de mappage du runtime, les passes de rendu fonctionnent toujours.</span><span class="sxs-lookup"><span data-stu-id="1261e-218">Because of the runtime's mapping logic, render passes always function.</span></span> <span data-ttu-id="1261e-219">Toutefois, en fonction de la prise en charge des fonctionnalités, elles ne fournissent pas toujours un avantage.</span><span class="sxs-lookup"><span data-stu-id="1261e-219">But, depending on feature support, they won't always provide a benefit.</span></span> <span data-ttu-id="1261e-220">Vous pouvez utiliser du code semblable à l’exemple de code ci-dessus pour déterminer si/à quel moment il vaut mieux émettre des commandes en tant que passes de rendu, et quand il ne s’agit pas vraiment d’un avantage (autrement dit, lorsque le runtime est simplement mappé à la surface d’API existante).</span><span class="sxs-lookup"><span data-stu-id="1261e-220">You can use code similar to the code example above to determine whether/when it is worth your while to issue commands as render passes, and when it is definitely not a benefit (that is, when the runtime is just mapping to the existing API surface).</span></span> <span data-ttu-id="1261e-221">L’exécution de cette vérification est particulièrement importante si vous utilisez [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)).</span><span class="sxs-lookup"><span data-stu-id="1261e-221">Performing this check is particularly important if you're using [D3D11On12](/windows/desktop/direct3d12/direct3d-11-on-12)).</span></span>

<span data-ttu-id="1261e-222">Pour obtenir une description des trois niveaux de prise en charge, consultez l’énumération [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) .</span><span class="sxs-lookup"><span data-stu-id="1261e-222">For a description of the three tiers of support, see the [**D3D12_RENDER_PASS_TIER**](/windows/win32/api/d3d12/ne-d3d12-d3d12_render_pass_tier) enumeration.</span></span>
