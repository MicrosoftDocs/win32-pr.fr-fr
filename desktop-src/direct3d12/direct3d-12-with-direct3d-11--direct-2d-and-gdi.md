---
title: Interopérabilité Direct3D 12
description: D3D12 peut être utilisé pour écrire des applications de composants.
ms.assetid: 51F7E715-82B6-48D8-A06A-CBBEDF6968F5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3b5fcfe2adf756c12f034031675d0c3ac5571b44
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548604"
---
# <a name="direct3d-12-interop"></a><span data-ttu-id="5d134-103">Interopérabilité Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="5d134-103">Direct3D 12 interop</span></span>

<span data-ttu-id="5d134-104">D3D12 peut être utilisé pour écrire des applications de composants.</span><span class="sxs-lookup"><span data-stu-id="5d134-104">D3D12 can be used to write componentized applications.</span></span>

-   [<span data-ttu-id="5d134-105">Vue d’ensemble de l’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-105">Interop overview</span></span>](#interop-overview)
-   [<span data-ttu-id="5d134-106">Raisons de l’utilisation de l’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-106">Reasons for using interop</span></span>](#reasons-for-using-interop)
    -   [<span data-ttu-id="5d134-107">Partage d’une liste de commandes</span><span class="sxs-lookup"><span data-stu-id="5d134-107">Sharing a command list</span></span>](#sharing-a-command-list)
    -   [<span data-ttu-id="5d134-108">Partage d’une file d’attente de commandes</span><span class="sxs-lookup"><span data-stu-id="5d134-108">Sharing a command queue</span></span>](#sharing-a-command-queue)
    -   [<span data-ttu-id="5d134-109">Partage de primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="5d134-109">Sharing sync primitives</span></span>](#sharing-sync-primitives)
    -   [<span data-ttu-id="5d134-110">Partage des ressources</span><span class="sxs-lookup"><span data-stu-id="5d134-110">Sharing resources</span></span>](#sharing-resources)
    -   [<span data-ttu-id="5d134-111">Choix d’un modèle d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-111">Choosing an interop model</span></span>](#choosing-an-interop-model)
-   [<span data-ttu-id="5d134-112">API d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-112">Interop APIs</span></span>](#interop-apis)
-   [<span data-ttu-id="5d134-113">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="5d134-113">Related topics</span></span>](#related-topics)

## <a name="interop-overview"></a><span data-ttu-id="5d134-114">Vue d’ensemble de l’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-114">Interop overview</span></span>

<span data-ttu-id="5d134-115">D3D12 peut être très puissant et permettre aux applications d’écrire du code graphique avec l’efficacité de la console, mais toutes les applications n’ont pas besoin de réinventer la roue et d’écrire l’intégralité du moteur de rendu à partir de zéro.</span><span class="sxs-lookup"><span data-stu-id="5d134-115">D3D12 can be very powerful, and allow applications to write graphics code with console-like efficiency, but not every application needs to reinvent the wheel and write the entirety of their rendering engine from scratch.</span></span> <span data-ttu-id="5d134-116">Dans certains cas, un autre composant ou une autre bibliothèque l’a déjà fait mieux, ou dans d’autres cas, les performances d’une partie du code ne sont pas aussi critiques que l’exactitude et la lisibilité.</span><span class="sxs-lookup"><span data-stu-id="5d134-116">In some cases, another component or library has already done it better, or in other cases, the performance of a portion of code is not as critical as its correctness and readability.</span></span>

<span data-ttu-id="5d134-117">Cette section traite des techniques d’interopérabilité suivantes :</span><span class="sxs-lookup"><span data-stu-id="5d134-117">This section covers the following interop techniques:</span></span>

-   <span data-ttu-id="5d134-118">D3D12 et D3D12, sur le même appareil</span><span class="sxs-lookup"><span data-stu-id="5d134-118">D3D12 and D3D12, on the same device</span></span>
-   <span data-ttu-id="5d134-119">D3D12 et D3D12, sur différents appareils</span><span class="sxs-lookup"><span data-stu-id="5d134-119">D3D12 and D3D12, on different devices</span></span>
-   <span data-ttu-id="5d134-120">D3D12 et toute combinaison de D3D11, D3D10 ou D2D, sur le même appareil</span><span class="sxs-lookup"><span data-stu-id="5d134-120">D3D12 and any combination of D3D11, D3D10, or D2D, on the same device</span></span>
-   <span data-ttu-id="5d134-121">D3D12 et toute combinaison de D3D11, D3D10 ou D2D sur différents appareils</span><span class="sxs-lookup"><span data-stu-id="5d134-121">D3D12 and any combination of D3D11, D3D10, or D2D, on different devices</span></span>
-   <span data-ttu-id="5d134-122">D3D12 et GDI, ou D3D12 et D3D11 et GDI</span><span class="sxs-lookup"><span data-stu-id="5d134-122">D3D12 and GDI, or D3D12 and D3D11 and GDI</span></span>

## <a name="reasons-for-using-interop"></a><span data-ttu-id="5d134-123">Raisons de l’utilisation de l’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-123">Reasons for using interop</span></span>

<span data-ttu-id="5d134-124">Une application peut souhaiter D3D12 Interop avec d’autres API pour plusieurs raisons.</span><span class="sxs-lookup"><span data-stu-id="5d134-124">There are several reasons an application would want D3D12 interop with other APIs.</span></span> <span data-ttu-id="5d134-125">Exemples :</span><span class="sxs-lookup"><span data-stu-id="5d134-125">Some examples:</span></span>

-   <span data-ttu-id="5d134-126">Portage incrémentiel : souhaitant déplacer une application entière à partir de D3D10 ou D3D11 vers D3D12, tout en ayant la possibilité de fonctionner aux étapes intermédiaires du processus de Portage (pour activer le test et le débogage).</span><span class="sxs-lookup"><span data-stu-id="5d134-126">Incremental porting: wanting to port an entire application from D3D10 or D3D11 to D3D12, while having it functional at intermediate stages of the porting process (to enable testing and debugging).</span></span>
-   <span data-ttu-id="5d134-127">Code de boîte noire : souhaitant laisser une partie spécifique d’une application telle quelle lors du Portage du reste du code.</span><span class="sxs-lookup"><span data-stu-id="5d134-127">Black box code: wanting to leave a particular portion of an application as-is while porting the rest of the code.</span></span> <span data-ttu-id="5d134-128">Par exemple, il est possible que vous n’ayez pas besoin de déplacer les éléments d’interface utilisateur d’un jeu.</span><span class="sxs-lookup"><span data-stu-id="5d134-128">For example, there might be no need to port UI elements of a game.</span></span>
-   <span data-ttu-id="5d134-129">Composants non modifiables : vous devez utiliser des composants qui ne sont pas détenus par l’application, qui ne sont pas écrits dans la D3D12 cible.</span><span class="sxs-lookup"><span data-stu-id="5d134-129">Unchangeable components: needing to use components which are not owned by the application, which are not written to target D3D12.</span></span>
-   <span data-ttu-id="5d134-130">Un nouveau composant : il ne souhaite pas porter sur l’ensemble de l’application, mais souhaite utiliser un nouveau composant écrit à l’aide de D3D12.</span><span class="sxs-lookup"><span data-stu-id="5d134-130">A new component: not wanting to port the entire application, but wanting to use a new component which is written using D3D12.</span></span>

<span data-ttu-id="5d134-131">Il existe quatre techniques principales pour l’interopérabilité dans D3D12 :</span><span class="sxs-lookup"><span data-stu-id="5d134-131">There are four main techniques for interop in D3D12:</span></span>

-   <span data-ttu-id="5d134-132">Une application peut choisir de fournir une liste de commandes ouverte à un composant, qui enregistre certaines commandes de rendu supplémentaires sur une cible de rendu déjà liée.</span><span class="sxs-lookup"><span data-stu-id="5d134-132">An app can choose to provide an open command list to a component, which records some additional rendering commands to an already-bound render target.</span></span> <span data-ttu-id="5d134-133">Cela revient à fournir un contexte de périphérique préparé à un autre composant dans D3D11, et est parfait pour des opérations telles que l’ajout d’une interface utilisateur/texte à une mémoire tampon d’arrière-plan déjà liée.</span><span class="sxs-lookup"><span data-stu-id="5d134-133">This is equivalent to providing a prepared device context to another component in D3D11, and is great for things like adding UI/text to an already bound back buffer.</span></span>
-   <span data-ttu-id="5d134-134">Une application peut choisir de fournir une file d’attente de commandes à un composant, ainsi qu’une ressource de destination souhaitée.</span><span class="sxs-lookup"><span data-stu-id="5d134-134">An app can choose to provide a command queue to a component, along with a desired destination resource.</span></span> <span data-ttu-id="5d134-135">Cela revient à utiliser des API [**ClearState**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) ou [**DeviceContextState**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) dans d3d11 pour fournir un contexte de périphérique propre à un autre composant.</span><span class="sxs-lookup"><span data-stu-id="5d134-135">This is equivalent to using [**ClearState**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate) or [**DeviceContextState**](/windows/desktop/api/d3d11_1/nn-d3d11_1-id3ddevicecontextstate) APIs in D3D11 to provide a clean device context to another component.</span></span> <span data-ttu-id="5d134-136">C’est ainsi que les composants tels que D2D fonctionnent.</span><span class="sxs-lookup"><span data-stu-id="5d134-136">This is how components like D2D operate.</span></span>
-   <span data-ttu-id="5d134-137">Un composant peut choisir un modèle dans lequel il produit une liste de commandes, éventuellement en parallèle, que l’application est responsable de l’envoi ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="5d134-137">A component may opt for a model where it produces a command list, potentially in parallel, which the app is responsible for submission at a later time.</span></span> <span data-ttu-id="5d134-138">Au moins une ressource doit être fournie au-delà des limites du composant.</span><span class="sxs-lookup"><span data-stu-id="5d134-138">At least one resource must be provided across component boundaries.</span></span> <span data-ttu-id="5d134-139">Cette même technique est disponible dans D3D11 à l’aide de contextes différés, bien que les performances dans D3D12 soient plus souhaitables.</span><span class="sxs-lookup"><span data-stu-id="5d134-139">This same technique is available in D3D11 using deferred contexts, though the performance in D3D12 is more desirable.</span></span>
-   <span data-ttu-id="5d134-140">Chaque composant possède ses propres files d’attente et/ou périphériques, et l’application et les composants doivent partager des informations de ressources et de synchronisation entre les limites des composants.</span><span class="sxs-lookup"><span data-stu-id="5d134-140">Each component has its own queue(s) and/or device(s), and the app and components need to share resources and synchronization information across component boundaries.</span></span> <span data-ttu-id="5d134-141">Cela est similaire à l’héritage `ISurfaceQueue` et à la [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex)plus moderne.</span><span class="sxs-lookup"><span data-stu-id="5d134-141">This is similar to the legacy `ISurfaceQueue`, and the more modern [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex).</span></span>

<span data-ttu-id="5d134-142">Les différences entre ces scénarios sont les suivantes : exactement partagé entre les limites du composant.</span><span class="sxs-lookup"><span data-stu-id="5d134-142">The differences between these scenarios is what exactly is shared between the component boundaries.</span></span> <span data-ttu-id="5d134-143">L’appareil est supposé être partagé, mais puisqu’il est fondamentalement sans État, il n’est pas vraiment pertinent.</span><span class="sxs-lookup"><span data-stu-id="5d134-143">The device is assumed to be shared, but since it is basically stateless, it is not really relevant.</span></span> <span data-ttu-id="5d134-144">Les objets clés sont la liste de commandes, la file d’attente de commandes, les objets de synchronisation et les ressources.</span><span class="sxs-lookup"><span data-stu-id="5d134-144">The key objects are the command list, the command queue, the sync objects, and the resources.</span></span> <span data-ttu-id="5d134-145">Chacun de ces éléments a leurs propres complications lors de leur partage.</span><span class="sxs-lookup"><span data-stu-id="5d134-145">Each of these have their own complications when sharing them.</span></span>

### <a name="sharing-a-command-list"></a><span data-ttu-id="5d134-146">Partage d’une liste de commandes</span><span class="sxs-lookup"><span data-stu-id="5d134-146">Sharing a command list</span></span>

<span data-ttu-id="5d134-147">La méthode d’interopérabilité la plus simple requiert le partage d’une liste de commandes avec une partie du moteur.</span><span class="sxs-lookup"><span data-stu-id="5d134-147">The simplest method of interop requires sharing only a command list with a portion of the engine.</span></span> <span data-ttu-id="5d134-148">Une fois les opérations de rendu terminées, la propriété de la liste de commandes revient à l’appelant.</span><span class="sxs-lookup"><span data-stu-id="5d134-148">Once the rendering operations have completed, the command list ownership goes back to the caller.</span></span> <span data-ttu-id="5d134-149">La propriété de la liste de commandes peut être tracée dans la pile.</span><span class="sxs-lookup"><span data-stu-id="5d134-149">The ownership of the command list can be traced through the stack.</span></span> <span data-ttu-id="5d134-150">Étant donné que les listes de commandes sont à thread unique, il n’existe aucun moyen pour une application d’effectuer une opération unique ou novatrice à l’aide de cette technique.</span><span class="sxs-lookup"><span data-stu-id="5d134-150">Since command lists are single threaded, there’s no way for an app to do something unique or innovative using this technique.</span></span>

### <a name="sharing-a-command-queue"></a><span data-ttu-id="5d134-151">Partage d’une file d’attente de commandes</span><span class="sxs-lookup"><span data-stu-id="5d134-151">Sharing a command queue</span></span>

<span data-ttu-id="5d134-152">C’est probablement la technique la plus courante pour plusieurs composants qui partagent un appareil dans le même processus.</span><span class="sxs-lookup"><span data-stu-id="5d134-152">Probably the most common technique for multiple components sharing a device in the same process.</span></span>

<span data-ttu-id="5d134-153">Lorsque la file d’attente de commandes est l’unité de partage, il doit y avoir un appel au composant pour lui indiquer que toutes les listes de commandes en suspens doivent être envoyées immédiatement à la file d’attente de commandes (et que toutes les files d’attente de commandes internes doivent être synchronisées).</span><span class="sxs-lookup"><span data-stu-id="5d134-153">When the command queue is the unit of sharing, there needs to be a call to the component to let it know that all outstanding command lists need to be submitted to the command queue immediately (and any internal command queues need to be synchronized).</span></span> <span data-ttu-id="5d134-154">Cela est équivalent à l’API de [**vidage**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) d3d11 et est la seule façon dont l’application peut envoyer ses propres listes de commandes ou primitives de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="5d134-154">This is equivalent to the D3D11 [**Flush**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-flush) API, and is the only way that the application can submit its own command lists or sync primitives.</span></span>

### <a name="sharing-sync-primitives"></a><span data-ttu-id="5d134-155">Partage de primitives de synchronisation</span><span class="sxs-lookup"><span data-stu-id="5d134-155">Sharing sync primitives</span></span>

<span data-ttu-id="5d134-156">Le modèle attendu pour un composant qui s’exécute sur ses propres périphériques et/ou files d’attente de commandes est d’accepter un handle [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) ou partagé, et UInt64 pair au début de son travail, qu’il attendra, puis à un deuxième descripteur ID3D12Fence ou partagé, et à une paire UInt64 qu’il signalera lorsque tout le travail sera terminé.</span><span class="sxs-lookup"><span data-stu-id="5d134-156">The expected pattern for a component which operates on its own devices and/or command queues will be to accept an [**ID3D12Fence**](/windows/desktop/api/d3d12/nn-d3d12-id3d12fence) or shared handle, and UINT64 pair upon beginning its work, which it will wait on, and then a second ID3D12Fence or shared handle, and UINT64 pair which it will signal when all work is complete.</span></span> <span data-ttu-id="5d134-157">Ce modèle correspond à l’implémentation actuelle de [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) et de la conception de la synchronisation du modèle de retournement DWM/DXGI.</span><span class="sxs-lookup"><span data-stu-id="5d134-157">This pattern matches the current implementation of both [**IDXGIKeyedMutex**](/windows/desktop/api/dxgi/nn-dxgi-idxgikeyedmutex) and the DWM/DXGI flip model synchronization design.</span></span>

### <a name="sharing-resources"></a><span data-ttu-id="5d134-158">Partage des ressources</span><span class="sxs-lookup"><span data-stu-id="5d134-158">Sharing resources</span></span>

<span data-ttu-id="5d134-159">La partie la plus complexe de l’écriture d’une application D3D12 qui tire parti de plusieurs composants est de savoir comment gérer les ressources partagées au-delà des limites des composants.</span><span class="sxs-lookup"><span data-stu-id="5d134-159">By far the most complicated part of writing a D3D12 app which leverages multiple components is how to deal with the resources which are shared across component boundaries.</span></span> <span data-ttu-id="5d134-160">Cela est principalement dû au concept d’États des ressources.</span><span class="sxs-lookup"><span data-stu-id="5d134-160">This is mostly due to the concept of resource states.</span></span> <span data-ttu-id="5d134-161">Bien que certains aspects de la conception de l’état des ressources soient destinés à gérer la synchronisation intra-commande, les autres ont un impact sur les listes de commandes, affectant la disposition des ressources et des ensembles valides d’opérations ou des caractéristiques de performances d’accès aux données des ressources.</span><span class="sxs-lookup"><span data-stu-id="5d134-161">While some aspects of the resource state design are meant to deal with intra-command-list synchronization, others do have impact between command lists, affecting resource layout and either valid sets of operations or performance characteristics of accessing the resource data.</span></span>

<span data-ttu-id="5d134-162">Il existe deux modèles de gestion de cette compliquation, qui impliquent essentiellement un contrat entre les composants.</span><span class="sxs-lookup"><span data-stu-id="5d134-162">There are two patterns of dealing with this complication, both of which involve essentially a contract between components.</span></span>

-   <span data-ttu-id="5d134-163">Le contrat peut être défini par le développeur du composant et documenté.</span><span class="sxs-lookup"><span data-stu-id="5d134-163">The contract can be defined by the component developer and documented.</span></span> <span data-ttu-id="5d134-164">Cela peut être aussi simple que « la ressource doit être dans l’État par défaut lorsque le travail est démarré, et sera rétablie à l’État par défaut lorsque le travail est terminé » ou peut avoir des règles plus compliquées pour permettre des opérations telles que le partage d’une mémoire tampon de profondeur sans forcer les résolutions de profondeur intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="5d134-164">This could be as simple as “the resource must be in the default state when work is started, and will be put back in the default state when work is done” or could have more complicated rules to allow things like sharing a depth buffer without forcing intermediate depth resolves.</span></span>
-   <span data-ttu-id="5d134-165">Le contrat peut être défini par l’application lors de l’exécution, au moment où la ressource est partagée au-delà des limites du composant.</span><span class="sxs-lookup"><span data-stu-id="5d134-165">The contract can be defined by the application at runtime, at the time when the resource is shared across component boundaries.</span></span> <span data-ttu-id="5d134-166">Il se compose des deux mêmes informations : l’État dans lequel se trouve la ressource lorsque le composant commence à l’utiliser, et l’État dans lequel le composant doit le conserver lorsqu’il se termine.</span><span class="sxs-lookup"><span data-stu-id="5d134-166">It consists of the same two pieces of information – the state the resource will be in when the component starts using it, and the state the component should leave it in when it finishes.</span></span>

### <a name="choosing-an-interop-model"></a><span data-ttu-id="5d134-167">Choix d’un modèle d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-167">Choosing an interop model</span></span>

<span data-ttu-id="5d134-168">Pour la plupart des applications D3D12, le partage d’une file d’attente de commandes est probablement le modèle idéal.</span><span class="sxs-lookup"><span data-stu-id="5d134-168">For most D3D12 applications, sharing a command queue is probably the ideal model.</span></span> <span data-ttu-id="5d134-169">Il permet la propriété complète de la création et de l’envoi de travaux, sans surcharge de mémoire supplémentaire due à l’utilisation de files d’attente redondantes et sans l’impact des performances sur les primitives de synchronisation GPU.</span><span class="sxs-lookup"><span data-stu-id="5d134-169">It allows complete ownership of work creation and submission, without the additional memory overhead from having redundant queues, and without the perf impact of dealing with the GPU sync primitives.</span></span>

<span data-ttu-id="5d134-170">Le partage de primitives de synchronisation est nécessaire une fois que les composants doivent traiter des propriétés de file d’attente différentes, telles que le type ou la priorité, ou une fois que le partage doit couvrir les limites du processus.</span><span class="sxs-lookup"><span data-stu-id="5d134-170">Sharing sync primitives is required once the components need to deal with different queue properties, such as type or priority, or once the sharing needs to span process boundaries.</span></span>

<span data-ttu-id="5d134-171">Le partage ou la génération de listes de commandes n’est pas largement utilisé en externe par les composants tiers, mais peut être largement utilisé dans les composants internes à un moteur de jeu.</span><span class="sxs-lookup"><span data-stu-id="5d134-171">Sharing or producing command lists are not widely used externally by third party components, but might be widely used in components which are internal to a game engine.</span></span>

## <a name="interop-apis"></a><span data-ttu-id="5d134-172">API d’interopérabilité</span><span class="sxs-lookup"><span data-stu-id="5d134-172">Interop APIs</span></span>

<span data-ttu-id="5d134-173">La rubrique [Direct3D 11 sur 12](./direct3d-11-on-12.md) vous guide tout au long de l’utilisation d’une grande partie de la surface de l’API en rapport avec les types d’interopérabilité décrits dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="5d134-173">The [Direct3D 11 on 12](./direct3d-11-on-12.md) topic walks you through the usage of much of the API surface related to the kinds of interoperation described in this topic.</span></span>

<span data-ttu-id="5d134-174">Consultez également la méthode [ID3D12Device :: CreateSharedHandle](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) , que vous pouvez utiliser pour partager des surfaces entre des API graphiques Windows.</span><span class="sxs-lookup"><span data-stu-id="5d134-174">Also see the [ID3D12Device::CreateSharedHandle](/windows/win32/api/d3d12/nf-d3d12-id3d12device-createsharedhandle) method, which you can use to share surfaces between Windows graphics APIs.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5d134-175">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="5d134-175">Related topics</span></span>

* [<span data-ttu-id="5d134-176">Comprendre Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="5d134-176">Understanding Direct3D 12</span></span>](directx-12-getting-started.md)
* [<span data-ttu-id="5d134-177">Utilisation de Direct3D 11, Direct3D 10 et Direct2D</span><span class="sxs-lookup"><span data-stu-id="5d134-177">Working with Direct3D 11, Direct3D 10 and Direct2D</span></span>](direct3d-12-interop.md)
* [<span data-ttu-id="5d134-178">Direct3D 11 sur 12</span><span class="sxs-lookup"><span data-stu-id="5d134-178">Direct3D 11 on 12</span></span>](./direct3d-11-on-12.md)