---
title: Signature racine version 1.1
description: L’objectif de la version de signature racine 1,1 est de permettre aux applications d’indiquer aux pilotes quand les descripteurs d’un tas de descripteur ne changeront pas ou que les descripteurs de données ne changeront pas.
ms.assetid: 8FE42C1C-7F1D-4E70-A7EE-D5EC67237327
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 04a7a32576efa4d93a8d26aa57282f06e0d5a02f
ms.sourcegitcommit: b40a986d5ded926ae7617119cdd35d99b533bad9
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/24/2021
ms.locfileid: "110343664"
---
# <a name="root-signature-version-11"></a><span data-ttu-id="170f4-103">Signature racine version 1.1</span><span class="sxs-lookup"><span data-stu-id="170f4-103">Root Signature Version 1.1</span></span>

<span data-ttu-id="170f4-104">L’objectif de la version de signature racine 1,1 est de permettre aux applications d’indiquer aux pilotes quand les descripteurs d’un tas de descripteur ne changeront pas ou que les descripteurs de données ne changeront pas.</span><span class="sxs-lookup"><span data-stu-id="170f4-104">The purpose of Root Signature version 1.1 is to enable applications to indicate to drivers when descriptors in a descriptor heap won’t change or the data descriptors point to won’t change.</span></span> <span data-ttu-id="170f4-105">Cela permet aux pilotes d’effectuer des optimisations qui peuvent être possibles, sachant qu’un descripteur ou la mémoire vers laquelle il pointe est statique pendant un certain temps.</span><span class="sxs-lookup"><span data-stu-id="170f4-105">This allows the option for drivers to make optimizations that might be possible knowing that a descriptor or the memory it points to is static for some period of time.</span></span>

-   [<span data-ttu-id="170f4-106">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="170f4-106">Overview</span></span>](#overview)
-   [<span data-ttu-id="170f4-107">Indicateurs statiques et volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-107">Static and Volatile Flags</span></span>](#static-and-volatile-flags)
    -   [<span data-ttu-id="170f4-108">descripteurs \_ volatils</span><span class="sxs-lookup"><span data-stu-id="170f4-108">DESCRIPTORS\_VOLATILE</span></span>](#descriptors_volatile)
    -   [<span data-ttu-id="170f4-109">DONNÉES \_ volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-109">DATA\_VOLATILE</span></span>](#data_volatile)
    -   [<span data-ttu-id="170f4-110">données \_ statiques quand elles sont \_ \_ définies \_ lors de l' \_ exécution</span><span class="sxs-lookup"><span data-stu-id="170f4-110">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>](#data_static_while_set_at_execute)
    -   [<span data-ttu-id="170f4-111">DONNÉES \_ statiques</span><span class="sxs-lookup"><span data-stu-id="170f4-111">DATA\_STATIC</span></span>](#data_static)
    -   [<span data-ttu-id="170f4-112">Combinaison d’indicateurs</span><span class="sxs-lookup"><span data-stu-id="170f4-112">Combining Flags</span></span>](#combining-flags)
    -   [<span data-ttu-id="170f4-113">Résumé de l’indicateur</span><span class="sxs-lookup"><span data-stu-id="170f4-113">Flag Summary</span></span>](#flag-summary)
-   [<span data-ttu-id="170f4-114">Résumé de l’API version 1,1</span><span class="sxs-lookup"><span data-stu-id="170f4-114">Version 1.1 API Summary</span></span>](#version-11-api-summary)
    -   [<span data-ttu-id="170f4-115">Énumérations</span><span class="sxs-lookup"><span data-stu-id="170f4-115">Enums</span></span>](#enums)
    -   [<span data-ttu-id="170f4-116">Structures</span><span class="sxs-lookup"><span data-stu-id="170f4-116">Structures</span></span>](#helper-structures)
    -   [<span data-ttu-id="170f4-117">Fonctions</span><span class="sxs-lookup"><span data-stu-id="170f4-117">Functions</span></span>](#functions)
    -   [<span data-ttu-id="170f4-118">Méthodes</span><span class="sxs-lookup"><span data-stu-id="170f4-118">Methods</span></span>](#methods)
    -   [<span data-ttu-id="170f4-119">Structures d’assistance</span><span class="sxs-lookup"><span data-stu-id="170f4-119">Helper structures</span></span>](#helper-structures)
-   [<span data-ttu-id="170f4-120">Conséquences de la violation des indicateurs de caractère statique</span><span class="sxs-lookup"><span data-stu-id="170f4-120">Consequences of violating static-ness flags</span></span>](#consequences-of-violating-static-ness-flags)
-   [<span data-ttu-id="170f4-121">Gestion des versions</span><span class="sxs-lookup"><span data-stu-id="170f4-121">Version management</span></span>](#version-management)
-   [<span data-ttu-id="170f4-122">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="170f4-122">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="170f4-123">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="170f4-123">Overview</span></span>

<span data-ttu-id="170f4-124">La version de signature racine 1,0 autorise le contenu des tas de descripteurs et la mémoire qu’ils pointent à être librement modifiés par les applications chaque fois que les listes de commandes/regroupements qui les référencent sont potentiellement en vol sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="170f4-124">Root Signature version 1.0 allows the contents of descriptor heaps and the memory they point at to be freely changed by applications any time that command lists / bundles referencing them are potentially in flight on the GPU.</span></span> <span data-ttu-id="170f4-125">Très souvent, cependant, les applications n’ont pas besoin de la flexibilité nécessaire pour modifier les descripteurs ou la mémoire une fois que les commandes qui les référencent ont été enregistrées.</span><span class="sxs-lookup"><span data-stu-id="170f4-125">Very often, however, applications don’t actually need the flexibility to change descriptors or memory after commands that reference them have been recorded.</span></span>

<span data-ttu-id="170f4-126">Les applications sont souvent en mesure de :</span><span class="sxs-lookup"><span data-stu-id="170f4-126">Applications are often trivially able to:</span></span>

-   <span data-ttu-id="170f4-127">Configurez les descripteurs (et éventuellement la mémoire à laquelle ils pointent) avant de lier les tables de descripteurs ou les descripteurs racine sur une liste de commandes ou un bundle.</span><span class="sxs-lookup"><span data-stu-id="170f4-127">Set up descriptors (and possible the memory they point to) before binding descriptor tables or root descriptors on a command list or bundle.</span></span>
-   <span data-ttu-id="170f4-128">Veillez à ce que ces descripteurs ne changent pas jusqu’à ce que la liste de commandes/bundles qui les référence aient fini de s’exécuter pour la dernière fois.</span><span class="sxs-lookup"><span data-stu-id="170f4-128">Ensure that these descriptors will not change until the command list /bundles referencing them have finished executing for the last time.</span></span>
-   <span data-ttu-id="170f4-129">Vérifiez que les données vers lesquelles pointent les descripteurs ne changent pas pour la même durée complète.</span><span class="sxs-lookup"><span data-stu-id="170f4-129">Ensure the data the descriptors point to does not change for the same full duration.</span></span>

<span data-ttu-id="170f4-130">En guise d’alternative, une application peut uniquement être en mesure de faire en sorte que les données ne changent pas pour une durée plus petite dans le temps.</span><span class="sxs-lookup"><span data-stu-id="170f4-130">Alternatively, an application may only be able to honor that data doesn’t change for a shorter duration in time.</span></span> <span data-ttu-id="170f4-131">En particulier, les données peuvent être statiques pour la fenêtre dans le temps lors de l’exécution de la liste de commandes qu’une liaison de paramètre racine (table de descripteurs ou descripteur racine) pointe actuellement vers les données.</span><span class="sxs-lookup"><span data-stu-id="170f4-131">In particular data might be static for the window in time during command list execution that a root parameter binding (descriptor table or root descriptor) currently points to the data.</span></span> <span data-ttu-id="170f4-132">En d’autres termes, une application peut souhaiter exécuter l’exécution sur la chronologie GPU qui met à jour des données entre les périodes où elles sont définies via un paramètre racine, sachant que lorsqu’elle est définie, elle est statique.</span><span class="sxs-lookup"><span data-stu-id="170f4-132">In other words, an application may wish to perform execution on the GPU timeline that updates some data in between time periods where it is set via a root parameter, knowing that when it is set it will be static.</span></span>

<span data-ttu-id="170f4-133">Si les descripteurs ou les descripteurs de données pointent vers, ne changeront pas, les pilotes d’optimisations spécifiques peuvent être spécifiques à un fabricant de matériel et, de manière importante, ils ne modifient pas le comportement, sauf pour améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="170f4-133">If descriptors, or the data descriptors point to, will not change, then the specific optimizations drivers might do are hardware vendor specific, and importantly they do not change behavior other than possibly improving performance.</span></span> <span data-ttu-id="170f4-134">Conserver le plus grand nombre d’informations sur l’intention de l’application que possible n’entraîne pas de charge sur les applications.</span><span class="sxs-lookup"><span data-stu-id="170f4-134">Preserving as much knowledge about application intent as possible does not put a burden on applications.</span></span>

<span data-ttu-id="170f4-135">L’une des optimisations est que de nombreux pilotes peuvent produire des accès mémoire plus efficaces par les nuanceurs s’ils savent les promesses qu’une application peut faire sur la nature statique des descripteurs et des données.</span><span class="sxs-lookup"><span data-stu-id="170f4-135">One optimization is that many drivers can produce more efficient memory accesses by shaders if they know the promises an application can make about the static-ness of descriptors and data.</span></span> <span data-ttu-id="170f4-136">Par exemple, les pilotes peuvent supprimer un niveau d’indirection pour accéder à un descripteur dans un segment de mémoire en le convertissant en descripteur racine si le matériel particulier n’est pas sensible à la taille de l’argument racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-136">For example, drivers could remove a level of indirection for accessing a descriptor in a heap by converting it into a root descriptor if the particular hardware is not sensitive to root argument size.</span></span>

<span data-ttu-id="170f4-137">La tâche supplémentaire pour le développeur qui utilise la version 1,1 consiste à faire des promesses quant à la volatilité et à la nature statique des données, dans la mesure du possible, afin que les pilotes puissent effectuer les optimisations nécessaires.</span><span class="sxs-lookup"><span data-stu-id="170f4-137">The additional task for developer using Version 1.1 is to make promises about the volatility and static-ness of data wherever possible, so that drivers can make the optimizations that make sense.</span></span> <span data-ttu-id="170f4-138">Les développeurs n’ont pas à prendre de promesses quant à la nature statique.</span><span class="sxs-lookup"><span data-stu-id="170f4-138">Developers do not have to make any promises about static-ness.</span></span>

<span data-ttu-id="170f4-139">La version de signature racine 1,0 continue à fonctionner sans modification, bien que les applications qui recompilent les signatures racines aient la signature racine 1,1 maintenant (avec une option permettant de forcer la version 1,0, si vous le souhaitez).</span><span class="sxs-lookup"><span data-stu-id="170f4-139">Root Signature version 1.0 continues to function unchanged, though applications that recompile root signatures will default to Root Signature 1.1 now (with an option to force version 1.0 if desired).</span></span>

## <a name="static-and-volatile-flags"></a><span data-ttu-id="170f4-140">Indicateurs statiques et volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-140">Static and Volatile Flags</span></span>

<span data-ttu-id="170f4-141">Les indicateurs suivants font partie de la signature racine pour permettre aux pilotes de choisir une stratégie permettant de mieux gérer les arguments racine individuels lorsqu’ils sont définis, et d’incorporer également les mêmes hypothèses dans les objets d’état de pipeline (objets PSO) quand ils sont compilés à l’origine, car la signature racine fait partie d’un objet PSO.</span><span class="sxs-lookup"><span data-stu-id="170f4-141">The following flags are part of the root signature to allow drivers to choose a strategy for how to best handle individual root arguments when they are set, and also embed the same assumptions into Pipeline State Objects (PSOs) when they are originally compiled - since the root signature is part of a PSO.</span></span>

<span data-ttu-id="170f4-142">Les indicateurs suivants sont définis par l’application et s’appliquent aux descripteurs ou aux données.</span><span class="sxs-lookup"><span data-stu-id="170f4-142">The following flags are set by the app and apply to descriptors or data.</span></span>

``` syntax
typedef enum D3D12_DESCRIPTOR_RANGE_FLAGS
{
    D3D12_DESCRIPTOR_RANGE_FLAG_NONE    = 0,
    D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE    = 0x1,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE   = 0x2,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE    = 0x4,
    D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC = 0x8
} D3D12_DESCRIPTOR_RANGE_FLAGS;

typedef enum D3D12_ROOT_DESCRIPTOR_FLAGS
{
    D3D12_ROOT_DESCRIPTOR_FLAG_NONE = 0,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE    = 0x2,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
    D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC  = 0x8
} D3D12_ROOT_DESCRIPTOR_FLAGS;
```

### <a name="descriptors_volatile"></a><span data-ttu-id="170f4-143">descripteurs \_ volatils</span><span class="sxs-lookup"><span data-stu-id="170f4-143">DESCRIPTORS\_VOLATILE</span></span>

<span data-ttu-id="170f4-144">Avec cet indicateur défini, les descripteurs d’un tas de descripteurs vers lequel pointe une table de descripteurs racine peuvent être modifiés par l’application à tout moment, sauf pendant que la liste de commandes/bottes qui lient la table de descripteur ont été soumises et n’ont pas terminé leur exécution.</span><span class="sxs-lookup"><span data-stu-id="170f4-144">With this flag set, the descriptors in a descriptor heap pointed to by a root descriptor table can be changed by the application any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="170f4-145">Par exemple, l’enregistrement d’une liste de commandes et la modification des descripteurs dans un tas de descripteurs auquel elle fait référence *avant* d’envoyer la liste de commandes pour qu’elle soit exécutée sont valides.</span><span class="sxs-lookup"><span data-stu-id="170f4-145">For instance, recording a command list and subsequently changing descriptors in a descriptor heap it refers to *before* submitting the command list for execution is valid.</span></span> <span data-ttu-id="170f4-146">Il s’agit du seul comportement pris en charge pour la signature racine version 1,0.</span><span class="sxs-lookup"><span data-stu-id="170f4-146">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="170f4-147">Si l' \_ indicateur volatiles DEscripteurs n’est *pas* défini, les descripteurs sont statiques.</span><span class="sxs-lookup"><span data-stu-id="170f4-147">If the DESCRIPTORS\_VOLATILE flag is *not* set then descriptors are static.</span></span> <span data-ttu-id="170f4-148">Il n’existe aucun indicateur pour ce mode.</span><span class="sxs-lookup"><span data-stu-id="170f4-148">There is no flag for this mode.</span></span> <span data-ttu-id="170f4-149">Les descripteurs statiques signifient que les descripteurs d’un tas de descripteur désigné par une table de descripteurs racine ont été initialisés au moment où la table du descripteur est définie sur une liste de commandes/un bundle (lors de l’enregistrement), et les descripteurs ne peuvent pas être modifiés tant que l’exécution de la liste de commandes/Bundle</span><span class="sxs-lookup"><span data-stu-id="170f4-149">Static descriptors mean the descriptors in a descriptor heap pointed to by a root descriptor table have been initialized by the time the descriptor table is set on a command list / bundle (during recording), and the descriptors cannot be changed until the command list / bundle has finished executing for the last time.</span></span> <span data-ttu-id="170f4-150">*Pour la signature racine version 1,1, les descripteurs statiques sont l’hypothèse par défaut*, et l’application doit spécifier l’indicateur volatil descripteurs lorsque cela est \_ nécessaire.</span><span class="sxs-lookup"><span data-stu-id="170f4-150">*For Root Signature version 1.1, static descriptors are the default assumption*, and the application has to specify the DESCRIPTORS\_VOLATILE flag when needed.</span></span>

<span data-ttu-id="170f4-151">Pour les regroupements utilisant des tables de descripteurs avec des descripteurs statiques, les descripteurs doivent être prêts à partir du moment où l’offre groupée est enregistrée (par opposition au fait que le bundle est appelé), et non changer jusqu’à ce que l’offre groupée ait fini de s’exécuter pour la dernière fois.</span><span class="sxs-lookup"><span data-stu-id="170f4-151">For bundles using descriptor tables with static descriptors, the descriptors have to be ready starting at the time the bundle is recorded (as opposed to when the bundle is called), and not change until the bundle has finished executing for the last time.</span></span> <span data-ttu-id="170f4-152">Les tables de descripteurs qui pointent vers des descripteurs statiques doivent être définies lors de l’enregistrement de Bundle et ne pas être héritées dans le bundle.</span><span class="sxs-lookup"><span data-stu-id="170f4-152">Descriptor tables pointing to static descriptors have to be set during bundle recording and not inherited into the bundle.</span></span> <span data-ttu-id="170f4-153">Il est possible pour une liste de commandes d’utiliser une table de descripteur avec des descripteurs statiques qui a été définie dans un bundle et renvoyée à la liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="170f4-153">It is valid for a command list to use a descriptor table with static descriptors that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="170f4-154">Lorsque les descripteurs sont statiques, il existe un autre changement de comportement qui requiert la \_ définition de l’indicateur volatil DEscripteurs.</span><span class="sxs-lookup"><span data-stu-id="170f4-154">When descriptors are static there is another change in behavior that requires the DESCRIPTORS\_VOLATILE flag to be set.</span></span> <span data-ttu-id="170f4-155">Les accès hors limites aux vues de mémoire tampon (par opposition aux affichages Texture1D/2D/3D/cube) ne sont pas valides et produisent des résultats indéfinis, y compris la réinitialisation d’appareil possible, au lieu de retourner des valeurs par défaut pour les écritures de lecture ou de suppression.</span><span class="sxs-lookup"><span data-stu-id="170f4-155">Out of bounds accesses to any Buffer views (as opposed to Texture1D/2D/3D/Cube views) are invalid and produce undefined results, including possible device reset, rather than returning default values for reads or dropping writes.</span></span> <span data-ttu-id="170f4-156">L’objectif de la suppression de la capacité des applications à dépendre du matériel en dehors des limites d’accès est de permettre aux pilotes de choisir de promouvoir les accès au descripteur statique en accès au descripteur racine s’ils estiment qu’ils sont plus efficaces.</span><span class="sxs-lookup"><span data-stu-id="170f4-156">The purpose for removing the ability for applications to depend on hardware out of bounds access checking is to allow drivers to choose to promote static descriptor accesses to root descriptor accesses if they deem that more efficient.</span></span> <span data-ttu-id="170f4-157">Les descripteurs racine ne prennent pas en charge la vérification hors limites.</span><span class="sxs-lookup"><span data-stu-id="170f4-157">Root descriptors don’t support any out of bounds checking.</span></span>

<span data-ttu-id="170f4-158">Si les applications dépendent du comportement d’accès à la mémoire en dehors des limites lors de l’accès aux descripteurs, ils doivent marquer les plages du descripteur qui accèdent à ces descripteurs en tant que descripteurs \_ volatils.</span><span class="sxs-lookup"><span data-stu-id="170f4-158">If applications depend on safe out of bounds memory access behavior when accessing descriptors, they need to mark the descriptor ranges that access those descriptors as DESCRIPTORS\_VOLATILE.</span></span>

### <a name="data_volatile"></a><span data-ttu-id="170f4-159">DONNÉES \_ volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-159">DATA\_VOLATILE</span></span>

<span data-ttu-id="170f4-160">Lorsque cet indicateur est défini, les données vers lesquelles pointent les descripteurs peuvent être modifiées par l’UC à tout moment, sauf lorsque la liste de commandes/les offres groupées qui lient la table de descripteur ont été soumises et n’ont pas terminé leur exécution.</span><span class="sxs-lookup"><span data-stu-id="170f4-160">With this flag set, the data pointed to by descriptors can be changed by the CPU any time except while the command list / bundles that bind the descriptor table have been submitted and have not finished executing.</span></span> <span data-ttu-id="170f4-161">Il s’agit du seul comportement pris en charge pour la signature racine version 1,0.</span><span class="sxs-lookup"><span data-stu-id="170f4-161">This is the only supported behavior of Root Signature version 1.0.</span></span>

<span data-ttu-id="170f4-162">L’indicateur est disponible dans les indicateurs de plage de descripteurs et les indicateurs de descripteur racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-162">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static_while_set_at_execute"></a><span data-ttu-id="170f4-163">données \_ statiques quand elles sont \_ \_ définies \_ lors de l' \_ exécution</span><span class="sxs-lookup"><span data-stu-id="170f4-163">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>

<span data-ttu-id="170f4-164">Lorsque cet indicateur est défini, les données pointées par les descripteurs ne peuvent pas changer à partir du moment où le descripteur racine ou la table de descripteur sous-jacent est défini sur une liste de commandes/un bundle lors de l’exécution sur la chronologie GPU, et se termine lorsque les tirages/distributions suivants ne font plus référence aux données.</span><span class="sxs-lookup"><span data-stu-id="170f4-164">With this flag set, the data pointed to by descriptors cannot change starting from when the underlying root descriptor or descriptor table is set on a command list / bundle during execution on the GPU timeline, and ending when subsequent draws/dispatches will no longer reference the data.</span></span>

<span data-ttu-id="170f4-165">Pour qu’un descripteur ou une table de descripteur racine ait été défini sur le GPU, ces données *peuvent* être modifiées même par la même liste de commandes/regroupement.</span><span class="sxs-lookup"><span data-stu-id="170f4-165">Before a root descriptor or descriptor table has been set on the GPU, this data *can* be changed even by the same command list / bundle.</span></span> <span data-ttu-id="170f4-166">Les données peuvent également être modifiées lorsqu’un descripteur ou une table de descripteur racine pointant sur celle-ci est toujours défini sur la liste de commandes/le bundle, à condition que les dessins/distributions qui y font référence soient terminés.</span><span class="sxs-lookup"><span data-stu-id="170f4-166">The data can also be changed while a root descriptor or descriptor table pointing to it is still set on the command list / bundle, as long as draw/dispatches referencing it have completed.</span></span> <span data-ttu-id="170f4-167">Toutefois, cette opération nécessite que la table de descripteurs soit à nouveau reliée à la liste de commandes avant la prochaine déréférencement du descripteur racine ou de la table de descripteur.</span><span class="sxs-lookup"><span data-stu-id="170f4-167">However, doing so requires the descriptor table be rebound to the command list again before the next time the root descriptor or descriptor table is dereferenced.</span></span> <span data-ttu-id="170f4-168">Cela permet au pilote de savoir que les données vers lesquelles pointe un descripteur racine ou une table de descripteur ont été modifiées.</span><span class="sxs-lookup"><span data-stu-id="170f4-168">This allows the driver to know that data pointed to by a root descriptor or descriptor table has changed.</span></span>

<span data-ttu-id="170f4-169">La principale différence entre les données \_ statiques lorsque celles- \_ ci sont définies lors de l' \_ \_ \_ exécution et la \_ volatilité des données est avec des données \_ volatiles. un pilote ne peut pas déterminer si les copies de données dans une liste de commandes ont modifié les données pointées par un descripteur, sans effectuer de suivi d’État supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="170f4-169">The essential difference between DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE and DATA\_VOLATILE is with DATA\_VOLATILE a driver can’t tell whether data copies in a command list have changed the data pointed to by a descriptor, without doing extra state tracking.</span></span> <span data-ttu-id="170f4-170">Par conséquent, si, par exemple, un pilote peut insérer une sorte de commandes de pré-extraction de données dans sa liste de commandes (pour améliorer l’accès des nuanceurs aux données connues, par exemple, \_ les données statiques \_ quand elles sont définies au moment de l' \_ \_ \_ exécution permettent au pilote de savoir qu’il n’a besoin d’effectuer la prérécupération des données qu’au moment où il est défini via [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable), [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) ou l’une des méthodes permettant de définir la vue de la mémoire tampon constante, la vue des ressources du nuanceur ou la vue d’accès non triée.</span><span class="sxs-lookup"><span data-stu-id="170f4-170">So if, for instance, a driver can insert any sort of data pre-fetching commands into their command list (to make shader access to known data more efficient, for example), DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE lets the driver know it only needs to perform data pre-fetching at the moment it is set via [**SetGraphicsRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootdescriptortable), [**SetComputeRootDescriptorTable**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootdescriptortable) or one of the methods to set the constant buffer view, shader resource view, or unordered access view.</span></span>

<span data-ttu-id="170f4-171">Pour les offres groupées, la promesse selon laquelle les données sont statiques lorsqu’elles sont définies lors de l’exécution s’applique de façon unique à chaque exécution de l’offre groupée.</span><span class="sxs-lookup"><span data-stu-id="170f4-171">For bundles, the promise that data is static while set at execute applies uniquely to each execution of the bundle.</span></span>

<span data-ttu-id="170f4-172">L’indicateur est disponible dans les indicateurs de plage de descripteurs et les indicateurs de descripteur racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-172">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="data_static"></a><span data-ttu-id="170f4-173">DONNÉES \_ statiques</span><span class="sxs-lookup"><span data-stu-id="170f4-173">DATA\_STATIC</span></span>

<span data-ttu-id="170f4-174">Si cet indicateur est défini, les données pointées par descripteurs ont été initialisées au moment où une table de descripteurs ou un descripteur racine référençant la mémoire a été définie sur une liste de commandes/un bundle lors de l’enregistrement, et les données ne peuvent pas être modifiées tant que l’exécution de la liste de commandes/Bundle n’a pas été terminée.</span><span class="sxs-lookup"><span data-stu-id="170f4-174">If this flag is set, the data pointed to by descriptors has been initialized by the time a root descriptor or descriptor table referencing the memory has been set on a command list / bundle during recording, and the data cannot be changed until the command list / bundle has finished executing for the last time.</span></span>

<span data-ttu-id="170f4-175">Pour les offres groupées, la durée statique commence au descripteur racine ou au paramètre de table du descripteur lors de l’enregistrement du bundle, par opposition à l’enregistrement d’une liste de commandes appelante.</span><span class="sxs-lookup"><span data-stu-id="170f4-175">For bundles, the static duration starts at root descriptor or descriptor table setting during the recording of the bundle, as opposed to recording of a calling command list.</span></span> <span data-ttu-id="170f4-176">En outre, une table de descripteurs pointant vers des données statiques doit être définie dans le bundle et non héritée.</span><span class="sxs-lookup"><span data-stu-id="170f4-176">In addition, a descriptor table pointing to static data must be set in the bundle and not inherited.</span></span> <span data-ttu-id="170f4-177">Il est possible pour une liste de commandes d’utiliser une table de descripteurs pointant vers des données statiques qui a été définie dans un bundle et renvoyée à la liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="170f4-177">It is valid for a command list to use a descriptor table pointing to static data that has been set in a bundle and returned back to the command list.</span></span>

<span data-ttu-id="170f4-178">L’indicateur est disponible dans les indicateurs de plage de descripteurs et les indicateurs de descripteur racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-178">The flag is available in both descriptor range flags and root descriptor flags.</span></span>

### <a name="combining-flags"></a><span data-ttu-id="170f4-179">Combinaison d’indicateurs</span><span class="sxs-lookup"><span data-stu-id="170f4-179">Combining Flags</span></span>

<span data-ttu-id="170f4-180">Au plus l’un des indicateurs de données peut être spécifié à la fois, à l’exception des plages de descripteurs d’échantillonnage qui ne prennent pas en charge les indicateurs de données, car les échantillonneurs ne pointent pas vers les données.</span><span class="sxs-lookup"><span data-stu-id="170f4-180">At most one of the DATA flags can be specified at a time, except for Sampler descriptor ranges which do not support DATA flags at all since samplers do not point to data.</span></span>

<span data-ttu-id="170f4-181">L’absence de tout indicateur de données pour les plages de descripteurs SRV et CBV signifie qu’il s’agit d’une valeur par défaut de DATA \_ static \_ alors que \_ Set \_ at \_ Execute Behavior est supposé.</span><span class="sxs-lookup"><span data-stu-id="170f4-181">The absence of any DATA flags for SRV and CBV descriptor ranges means a default of DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE behavior is assumed.</span></span> <span data-ttu-id="170f4-182">La raison pour laquelle cette valeur par défaut est choisie au lieu de données \_ statiques est que les données \_ statiques définies lors de l' \_ \_ \_ \_ exécution sont bien plus susceptibles d’être une valeur par défaut sécurisée pour la plupart des cas, tout en continuant à améliorer l’opportunité d’optimisation par rapport aux données \_ volatiles par défaut.</span><span class="sxs-lookup"><span data-stu-id="170f4-182">The reason this default is chosen rather than DATA\_STATIC is that DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is much more likely to be a safe default for a majority of cases, while still yielding some optimization opportunity better than defaulting to DATA\_VOLATILE.</span></span>

<span data-ttu-id="170f4-183">L’absence d’indicateurs de données pour les plages de descripteurs UAV signifie qu’une valeur par défaut de données \_ volatiles est supposée, étant donné que les UAVs sont écrits en général.</span><span class="sxs-lookup"><span data-stu-id="170f4-183">The absence of DATA flags for UAV descriptor ranges means a default of DATA\_VOLATILE behavior is assumed, given typically UAVs are written to.</span></span>

<span data-ttu-id="170f4-184">Les descripteurs \_ volatiles *ne peuvent pas* être associés à des données \_ statiques, mais *peuvent* être combinés avec d’autres indicateurs de données.</span><span class="sxs-lookup"><span data-stu-id="170f4-184">DESCRIPTORS\_VOLATILE *cannot* be combined with DATA\_STATIC, but *can* be combined with the other DATA flags.</span></span> <span data-ttu-id="170f4-185">Les descripteurs \_ de raison volatile peuvent être combinés avec des données \_ statiques \_ alors qu’ils sont définis lors de l’exécution. \_ \_ \_ les descripteurs volatils requièrent toujours que les descripteurs soient prêts pendant l’exécution de la liste de commandes/de l’offre groupée, et les données \_ statiques \_ quand elles sont définies au moment de l’exécution ne \_ \_ \_ sont que des promesses sur le caractère statique</span><span class="sxs-lookup"><span data-stu-id="170f4-185">The reason DESCRIPTORS\_VOLATILE can be combined with DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is that volatile descriptors still require the descriptors be ready during command list / bundle execution, and DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE is only making promises about the static-ness within a subset of command list / bundle execution.</span></span>

### <a name="flag-summary"></a><span data-ttu-id="170f4-186">Résumé de l’indicateur</span><span class="sxs-lookup"><span data-stu-id="170f4-186">Flag Summary</span></span>

<span data-ttu-id="170f4-187">Les tableaux suivants résument les combinaisons d’indicateurs qui peuvent être utilisées.</span><span class="sxs-lookup"><span data-stu-id="170f4-187">The following tables summarize the flag combinations that might be employed.</span></span>



| <span data-ttu-id="170f4-188">Paramètres valides des \_ indicateurs de plage du descripteur D3D12 \_ \_</span><span class="sxs-lookup"><span data-stu-id="170f4-188">Valid D3D12\_DESCRIPTOR\_RANGE\_FLAGS settings</span></span>                                                               | <span data-ttu-id="170f4-189">Description</span><span class="sxs-lookup"><span data-stu-id="170f4-189">Description</span></span>                                                                                                                                                                                                                                                                                                                                                     |
|----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="170f4-190">Aucun indicateur défini</span><span class="sxs-lookup"><span data-stu-id="170f4-190">No flags set</span></span>                                                   | <span data-ttu-id="170f4-191">Les descripteurs sont statiques (valeur par défaut).</span><span class="sxs-lookup"><span data-stu-id="170f4-191">Descriptors are static (the default).</span></span> <span data-ttu-id="170f4-192">Hypothèses par défaut pour les données : pour SRV/CBV : données \_ statiques définies lors de l' \_ \_ \_ \_ exécution, et pour UAV : données \_ volatiles.</span><span class="sxs-lookup"><span data-stu-id="170f4-192">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="170f4-193">Ces valeurs par défaut pour SRV/CBV s’adaptent en toute sécurité aux modèles d’utilisation pour la majorité des signatures racines.</span><span class="sxs-lookup"><span data-stu-id="170f4-193">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span>                                                                                              |
| <span data-ttu-id="170f4-194">DONNÉES \_ statiques</span><span class="sxs-lookup"><span data-stu-id="170f4-194">DATA\_STATIC</span></span>                                                   | <span data-ttu-id="170f4-195">Les descripteurs et les données sont statiques.</span><span class="sxs-lookup"><span data-stu-id="170f4-195">Both descriptors and data are static.</span></span> <span data-ttu-id="170f4-196">Cela optimise le potentiel d’optimisation du pilote.</span><span class="sxs-lookup"><span data-stu-id="170f4-196">This maximizes the potential for driver optimization.</span></span>                                                                                                                                                                                                                                                          |
| <span data-ttu-id="170f4-197">DONNÉES \_ volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-197">DATA\_VOLATILE</span></span>                                                 | <span data-ttu-id="170f4-198">Les descripteurs sont statiques et les données sont volatiles.</span><span class="sxs-lookup"><span data-stu-id="170f4-198">Descriptors are static and the data is volatile.</span></span>                                                                                                                                                                                                                                                                                                     |
| <span data-ttu-id="170f4-199">données \_ statiques quand elles sont \_ \_ définies \_ lors de l' \_ exécution</span><span class="sxs-lookup"><span data-stu-id="170f4-199">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>                          | <span data-ttu-id="170f4-200">Les descripteurs sont statiques et les données sont statiques quand elles sont définies lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="170f4-200">Descriptors are static and data is static while set at execute.</span></span>                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="170f4-201">descripteurs \_ volatils</span><span class="sxs-lookup"><span data-stu-id="170f4-201">DESCRIPTORS\_VOLATILE</span></span>                                          | <span data-ttu-id="170f4-202">Les descripteurs sont volatiles, et les hypothèses par défaut sont effectuées sur les données : pour SRV/CBV : données statiques quand elles sont définies lors de l' \_ \_ \_ \_ \_ exécution, et pour UAV : données \_ volatiles.</span><span class="sxs-lookup"><span data-stu-id="170f4-202">Descriptors are volatile, and default assumptions are made about data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span>                                                                                                                                                                                              |
| <span data-ttu-id="170f4-203">descripteurs \_ volatiles \| données \_ volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-203">DESCRIPTORS\_VOLATILE \| DATA\_VOLATILE</span></span>                        | <span data-ttu-id="170f4-204">Les descripteurs et les données sont volatils, ce qui équivaut à la signature racine 1,0.</span><span class="sxs-lookup"><span data-stu-id="170f4-204">Both descriptors and data are volatile, equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="170f4-205">descripteurs \_ volatiles \| Data \_ static \_ quand elles sont \_ définies \_ lors de l' \_ exécution</span><span class="sxs-lookup"><span data-stu-id="170f4-205">DESCRIPTORS\_VOLATILE \| DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span> | <span data-ttu-id="170f4-206">Les descripteurs sont volatiles, mais notez qu’ils ne peuvent toujours pas changer au cours de l’exécution de la liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="170f4-206">Descriptors are volatile, but note that still doesn’t allow them to change during command list execution.</span></span> <span data-ttu-id="170f4-207">Par conséquent, il est possible de combiner la déclaration supplémentaire selon laquelle les données sont statiques quand elles sont définies via la table de descripteurs racine au cours de l’exécution. les descripteurs sous-jacents sont effectivement statiques pendant plus longtemps que les données sont promis d’être statiques.</span><span class="sxs-lookup"><span data-stu-id="170f4-207">So it is valid to combine the additional declaration that data is static while set via root descriptor table during execution – the underlying descriptors are effectively static for longer than the data is being promised to be static.</span></span> |



 



| <span data-ttu-id="170f4-208">Paramètres valides des \_ \_ indicateurs de descripteurs racine D3D12 \_</span><span class="sxs-lookup"><span data-stu-id="170f4-208">Valid D3D12\_ROOT\_DESCRIPTOR\_FLAGS settings</span></span>                                                  |  <span data-ttu-id="170f4-209">Description</span><span class="sxs-lookup"><span data-stu-id="170f4-209">Description</span></span>                                                                                                                                                                                                                 |
|---------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="170f4-210">Aucun indicateur défini</span><span class="sxs-lookup"><span data-stu-id="170f4-210">No flags set</span></span>                                      | <span data-ttu-id="170f4-211">Hypothèses par défaut pour les données : pour SRV/CBV : données \_ statiques définies lors de l' \_ \_ \_ \_ exécution, et pour UAV : données \_ volatiles.</span><span class="sxs-lookup"><span data-stu-id="170f4-211">Default assumptions for data: for SRV/CBV: DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE, and for UAV: DATA\_VOLATILE.</span></span> <span data-ttu-id="170f4-212">Ces valeurs par défaut pour SRV/CBV s’adaptent en toute sécurité aux modèles d’utilisation pour la majorité des signatures racines.</span><span class="sxs-lookup"><span data-stu-id="170f4-212">These defaults for SRV/CBV will safely fit the usage patterns for the majority of root signatures.</span></span> |
| <span data-ttu-id="170f4-213">DONNÉES \_ statiques</span><span class="sxs-lookup"><span data-stu-id="170f4-213">DATA\_STATIC</span></span>                                      | <span data-ttu-id="170f4-214">Les données sont statiques, ce qui constitue le meilleur risque pour l’optimisation des pilotes.</span><span class="sxs-lookup"><span data-stu-id="170f4-214">Data is static, the best potential for driver optimization.</span></span>                                                                                                                                                       |
| <span data-ttu-id="170f4-215">données \_ statiques quand elles sont \_ \_ définies \_ lors de l' \_ exécution</span><span class="sxs-lookup"><span data-stu-id="170f4-215">DATA\_STATIC\_WHILE\_SET\_AT\_EXECUTE</span></span>             | <span data-ttu-id="170f4-216">Les données sont statiques lorsqu’elles sont définies lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="170f4-216">Data is static while set at execute.</span></span>                                                                                                                                                                              |
| <span data-ttu-id="170f4-217">DONNÉES \_ volatiles</span><span class="sxs-lookup"><span data-stu-id="170f4-217">DATA\_VOLATILE</span></span>                                    | <span data-ttu-id="170f4-218">Équivalent à la signature racine 1,0.</span><span class="sxs-lookup"><span data-stu-id="170f4-218">Equivalent to Root Signature 1.0.</span></span>                                                                                                                                                                                 |



 

## <a name="version-11-api-summary"></a><span data-ttu-id="170f4-219">Résumé de l’API version 1,1</span><span class="sxs-lookup"><span data-stu-id="170f4-219">Version 1.1 API Summary</span></span>

<span data-ttu-id="170f4-220">Les appels d’API suivants activent la version 1,1.</span><span class="sxs-lookup"><span data-stu-id="170f4-220">The following API calls enable version 1.1.</span></span>

### <a name="enums"></a><span data-ttu-id="170f4-221">Énumérations</span><span class="sxs-lookup"><span data-stu-id="170f4-221">Enums</span></span>

<span data-ttu-id="170f4-222">Ces énumérations contiennent les indicateurs de clé pour spécifier le descripteur et la volatilité des données.</span><span class="sxs-lookup"><span data-stu-id="170f4-222">These enumerations contain the key flags to specify descriptor and data volatility.</span></span>

-   <span data-ttu-id="170f4-223">[**D3D \_ \_ \_ Version de la signature racine**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) : ID de version.</span><span class="sxs-lookup"><span data-stu-id="170f4-223">[**D3D\_ROOT\_SIGNATURE\_VERSION**](/windows/desktop/api/d3d12/ne-d3d12-d3d_root_signature_version) : version ids.</span></span>
-   <span data-ttu-id="170f4-224">[**D3D12 \_ \_ \_ Indicateurs de plage du descripteur**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) : plage d’indicateurs déterminant si les descripteurs ou les données sont volatiles ou statiques.</span><span class="sxs-lookup"><span data-stu-id="170f4-224">[**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags) : a range of flags determining if descriptors or data are volatile or static.</span></span>
-   <span data-ttu-id="170f4-225">[**D3D12 \_ \_ \_ Indicateurs de descripteur racine**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) : une plage similaire d’indicateurs aux [**indicateurs de \_ \_ plage \_ de descripteurs D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags), sauf que seuls les indicateurs de données s’appliquent aux descripteurs racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-225">[**D3D12\_ROOT\_DESCRIPTOR\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_root_descriptor_flags) : a similar range of flags to [**D3D12\_DESCRIPTOR\_RANGE\_FLAGS**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_descriptor_range_flags), except that only data flags apply to root descriptors.</span></span>

### <a name="structures"></a><span data-ttu-id="170f4-226">Structures</span><span class="sxs-lookup"><span data-stu-id="170f4-226">Structures</span></span>

<span data-ttu-id="170f4-227">Les structures mises à jour (à partir de la version 1,0) contiennent des références aux indicateurs volatiles/statiques.</span><span class="sxs-lookup"><span data-stu-id="170f4-227">Updated structures (from version 1.0) contain references to the volatility/static flags.</span></span>

-   <span data-ttu-id="170f4-228">[**D3D12 \_ \_ \_ \_ Signature**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) de la racine des données de fonctionnalité : transmettez cette structure à [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) pour vérifier la prise en charge de la version 1,1 de la signature racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-228">[**D3D12\_FEATURE\_DATA\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_root_signature) : pass this structure to [**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) to check for Root Signature Version 1.1 support.</span></span>
-   <span data-ttu-id="170f4-229">[**D3D12 \_ Description de \_ la \_ signature \_ racine avec version**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) : peut contenir n’importe quelle version d’une description de signature racine et est conçue pour être utilisée avec les fonctions de sérialisation/désérialisation listées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="170f4-229">[**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) : can hold any version of a root signature description, and is designed to be used with the serialization/deserialization functions listed below.</span></span>
-   <span data-ttu-id="170f4-230">Ces structures sont équivalentes à celles utilisées dans la version 1,0, avec l’ajout de nouveaux champs d’indicateurs pour les plages de descripteurs et les descripteurs racines :</span><span class="sxs-lookup"><span data-stu-id="170f4-230">These structures are equivalent to those used in version 1.0, with the addition of new flags fields for descriptor ranges and root descriptors:</span></span>

    -   [<span data-ttu-id="170f4-231">**\_Signature racine \_ D3D12 \_ DESC1**</span><span class="sxs-lookup"><span data-stu-id="170f4-231">**D3D12\_ROOT\_SIGNATURE\_DESC1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_signature_desc1)
    -   [<span data-ttu-id="170f4-232">**\_Descripteur D3D12 \_ RANGE1**</span><span class="sxs-lookup"><span data-stu-id="170f4-232">**D3D12\_DESCRIPTOR\_RANGE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_range1)
    -   [<span data-ttu-id="170f4-233">**\_Descripteur racine D3D12 \_ \_ table1**</span><span class="sxs-lookup"><span data-stu-id="170f4-233">**D3D12\_ROOT\_DESCRIPTOR\_TABLE1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor_table1)
    -   [<span data-ttu-id="170f4-234">**D3D12 \_ racine \_ DESCRIPTOR1**</span><span class="sxs-lookup"><span data-stu-id="170f4-234">**D3D12\_ROOT\_DESCRIPTOR1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_descriptor1)
    -   [<span data-ttu-id="170f4-235">**D3D12 \_ racine \_ paramètre1**</span><span class="sxs-lookup"><span data-stu-id="170f4-235">**D3D12\_ROOT\_PARAMETER1**</span></span>](/windows/desktop/api/d3d12/ns-d3d12-d3d12_root_parameter1)

### <a name="functions"></a><span data-ttu-id="170f4-236">Fonctions</span><span class="sxs-lookup"><span data-stu-id="170f4-236">Functions</span></span>

<span data-ttu-id="170f4-237">Les méthodes répertoriées ici remplacent les fonctions [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) et [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) d’origine, car elles sont conçues pour fonctionner sur n’importe quelle version de signature racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-237">The methods listed here supersede the original [**D3D12SerializeRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializerootsignature) and [**D3D12CreateRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createrootsignaturedeserializer) functions, as they are designed to work on any version of root signature.</span></span> <span data-ttu-id="170f4-238">La forme sérialisée est celle qui est transmise à l’API [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) .</span><span class="sxs-lookup"><span data-stu-id="170f4-238">The serialized form is what is passed into the [**CreateRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createrootsignature) API.</span></span> <span data-ttu-id="170f4-239">Si un nuanceur a été créé avec une signature racine dans celui-ci, le nuanceur compilé contient déjà une signature racine sérialisée.</span><span class="sxs-lookup"><span data-stu-id="170f4-239">If a shader has been authored with a root signature in it, the compiled shader will contain a serialized root signature in it already.</span></span>

-   <span data-ttu-id="170f4-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) : si une application génère de manière procédurale la structure des données de [**\_ \_ \_ signature racine avec version D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) , elle doit faire de la forme sérialisée à l’aide de cette fonction.</span><span class="sxs-lookup"><span data-stu-id="170f4-240">[**D3D12SerializeVersionedRootSignature**](/windows/desktop/api/d3d12/nf-d3d12-d3d12serializeversionedrootsignature) : if an application procedurally generates the [**D3D12\_VERSIONED\_ROOT\_SIGNATURE**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) data structure, it must make the serialized form using this function.</span></span>
-   <span data-ttu-id="170f4-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) : génère une interface qui peut retourner la structure de données désérialisée, via [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc).</span><span class="sxs-lookup"><span data-stu-id="170f4-241">[**D3D12CreateVersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createversionedrootsignaturedeserializer) : generates an interface that can return the deserialized data structure, via [**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc).</span></span>

### <a name="methods"></a><span data-ttu-id="170f4-242">Méthodes</span><span class="sxs-lookup"><span data-stu-id="170f4-242">Methods</span></span>

<span data-ttu-id="170f4-243">L’interface [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) est créée pour désérialiser la structure de données de la signature racine.</span><span class="sxs-lookup"><span data-stu-id="170f4-243">The [**ID3D12VersionedRootSignatureDeserializer**](/windows/desktop/api/d3d12/nn-d3d12-id3d12versionedrootsignaturedeserializer) interface is created to deserialize the root signature data structure.</span></span>

-   <span data-ttu-id="170f4-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) : convertit les structures de description de signature racine en une version demandée.</span><span class="sxs-lookup"><span data-stu-id="170f4-244">[**GetRootSignatureDescAtVersion**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getrootsignaturedescatversion) : converts root signature description structures to a requested version.</span></span>
-   <span data-ttu-id="170f4-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) : retourne un pointeur vers une [**structure \_ \_ \_ \_ desc de signature racine avec version D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) .</span><span class="sxs-lookup"><span data-stu-id="170f4-245">[**GetUnconvertedRootSignatureDesc**](/windows/desktop/api/d3d12/nf-d3d12-id3d12versionedrootsignaturedeserializer-getunconvertedrootsignaturedesc) : returns a pointer to a [**D3D12\_VERSIONED\_ROOT\_SIGNATURE\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_versioned_root_signature_desc) structure.</span></span>

### <a name="helper-structures"></a><span data-ttu-id="170f4-246">Structures d’assistance</span><span class="sxs-lookup"><span data-stu-id="170f4-246">Helper structures</span></span>

<span data-ttu-id="170f4-247">Des structures d’assistance ont été ajoutées pour faciliter l’initialisation de certaines structures de la version 1,1.</span><span class="sxs-lookup"><span data-stu-id="170f4-247">Helper structures have been added to aid in the initialization of some of the version 1.1 structures.</span></span>

-   <span data-ttu-id="170f4-248">\_Descripteur CD3DX12 \_ RANGE1</span><span class="sxs-lookup"><span data-stu-id="170f4-248">CD3DX12\_DESCRIPTOR\_RANGE1</span></span>
-   <span data-ttu-id="170f4-249">CD3DX12 \_ racine \_ paramètre1</span><span class="sxs-lookup"><span data-stu-id="170f4-249">CD3DX12\_ROOT\_PARAMETER1</span></span>
-   <span data-ttu-id="170f4-250">CD3DX12 \_ statique \_ SAMPLER1</span><span class="sxs-lookup"><span data-stu-id="170f4-250">CD3DX12\_STATIC\_SAMPLER1</span></span>
-   <span data-ttu-id="170f4-251">Description de la \_ signature racine avec version CD3DX12 \_ \_ \_ desc</span><span class="sxs-lookup"><span data-stu-id="170f4-251">CD3DX12\_VERSIONED\_ROOT\_SIGNATURE\_DESC</span></span>

<span data-ttu-id="170f4-252">Reportez-vous aux [structures et fonctions d’assistance pour D3D12](helper-structures-and-functions-for-d3d12.md).</span><span class="sxs-lookup"><span data-stu-id="170f4-252">Refer to [Helper Structures and Functions for D3D12](helper-structures-and-functions-for-d3d12.md).</span></span>

## <a name="consequences-of-violating-static-ness-flags"></a><span data-ttu-id="170f4-253">Conséquences de la violation des indicateurs de caractère statique</span><span class="sxs-lookup"><span data-stu-id="170f4-253">Consequences of violating static-ness flags</span></span>

<span data-ttu-id="170f4-254">Les indicateurs de descripteur et de données décrits ci-dessus (ainsi que les valeurs par défaut implicites en l’absence d’indicateurs particuliers) définissent une promesse par l’application au pilote sur la manière dont il va se comporter.</span><span class="sxs-lookup"><span data-stu-id="170f4-254">The descriptor and data flags described above (as well as the defaults implied by the absence of particular flags) define a promise by the application to the driver about how it is going to behave.</span></span> <span data-ttu-id="170f4-255">Si une application ne respecte pas la promesse, le comportement n’est pas valide : les résultats ne sont pas définis et peuvent être différents sur différents pilotes et matériels.</span><span class="sxs-lookup"><span data-stu-id="170f4-255">If an application violates the promise, this is invalid behavior: results are undefined and might be different across different drivers and hardware.</span></span>

<span data-ttu-id="170f4-256">La couche de débogage offre des options pour valider que les applications respectent leurs promesses, y compris les promesses par défaut qui sont fournies avec l’utilisation de la signature racine version 1,1 sans définir d’indicateurs.</span><span class="sxs-lookup"><span data-stu-id="170f4-256">The debug layer has options for validating that applications honor their promises, including the default promises that come with using Root Signature version 1.1 without setting any flags.</span></span>

## <a name="version-management"></a><span data-ttu-id="170f4-257">Gestion des versions</span><span class="sxs-lookup"><span data-stu-id="170f4-257">Version management</span></span>

<span data-ttu-id="170f4-258">Lors de la compilation des signatures racines attachées aux nuanceurs, les nouveaux compilateurs HLSL compilent par défaut la signature racine à la version 1,1, alors que les anciens compilateurs HLSL prennent uniquement en charge 1,0.</span><span class="sxs-lookup"><span data-stu-id="170f4-258">When compiling root signatures attached to shaders, newer HLSL compilers will default to compiling the root signature at version 1.1, whereas old HLSL compilers only support 1.0.</span></span> <span data-ttu-id="170f4-259">Notez que les signatures racines 1,1 ne fonctionneront pas sur les systèmes d’exploitation qui ne prennent pas en charge la signature racine 1,1.</span><span class="sxs-lookup"><span data-stu-id="170f4-259">Note that 1.1 root signatures will not work on OS’s that don’t support root signature 1.1.</span></span>

<span data-ttu-id="170f4-260">La version de signature racine compilée avec un nuanceur peut être forcée à une version particulière à l’aide de `/force_rootsig_ver <version>` .</span><span class="sxs-lookup"><span data-stu-id="170f4-260">The root signature version compiled with a shader can be forced to a particular version using `/force_rootsig_ver <version>`.</span></span> <span data-ttu-id="170f4-261">Forcer la version échoue si le compilateur peut conserver le comportement de la signature racine qui est compilée dans la version forcée, par exemple en supprimant les indicateurs non pris en charge dans la signature racine qui servent uniquement à des fins d’optimisation, mais n’affectent pas le comportement.</span><span class="sxs-lookup"><span data-stu-id="170f4-261">Forcing the version will succeed if the compiler can preserve the behavior of the root signature being compiled at the forced version, for example by dropping unsupported flags in the root signature that serve only for optimization purposes but do not affect behavior.</span></span>

<span data-ttu-id="170f4-262">Ainsi, une application peut, par exemple, compiler une signature racine 1,1 à 1,0 et 1,1 lors de la génération de l’application et sélectionner la version appropriée au moment de l’exécution en fonction du niveau de prise en charge du système d’exploitation.</span><span class="sxs-lookup"><span data-stu-id="170f4-262">This way an application can, for instance, compile a 1.1 root signature to both 1.0 and 1.1 when building the application and select the appropriate version at runtime depending on the level of OS support.</span></span> <span data-ttu-id="170f4-263">Toutefois, l’espace est plus efficace pour une application de compiler des signatures racines individuellement (surtout si plusieurs versions sont nécessaires), séparément des nuanceurs.</span><span class="sxs-lookup"><span data-stu-id="170f4-263">It would be most space efficient, however, for an application to compile root signatures individually (particularly if multiple versions are needed), separately from shaders.</span></span> <span data-ttu-id="170f4-264">Même si les nuanceurs ne sont pas initialement compilés avec une signature racine jointe, l’avantage de la validation par le compilateur de la compatibilité de signature racine avec un nuanceur peut être préservé à l’aide de l' `/verifyrootsignature` option du compilateur.</span><span class="sxs-lookup"><span data-stu-id="170f4-264">Even if shaders aren’t initially compiled with a root signature attached, the benefit of compiler validation of root signature compatibility with a shader can be preserved by using the `/verifyrootsignature` compiler option.</span></span> <span data-ttu-id="170f4-265">Plus tard, lors de l’exécution, objets PSO peut être créé à l’aide de nuanceurs qui n’ont pas de signature racine dans ces derniers, tout en transmettant la signature racine souhaitée (peut-être la version appropriée prise en charge par le système d’exploitation) en tant que paramètre distinct.</span><span class="sxs-lookup"><span data-stu-id="170f4-265">Later at runtime, PSOs can be created using shaders that don’t have root signatures in them while passing the desired root signature (perhaps the appropriate version supported by the OS) as a separate parameter.</span></span>

## <a name="related-topics"></a><span data-ttu-id="170f4-266">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="170f4-266">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="170f4-267">Création d’une signature racine</span><span class="sxs-lookup"><span data-stu-id="170f4-267">Creating a Root Signature</span></span>](creating-a-root-signature.md)
</dt> <dt>

[<span data-ttu-id="170f4-268">Signatures racine</span><span class="sxs-lookup"><span data-stu-id="170f4-268">Root Signatures</span></span>](root-signatures.md)
</dt> <dt>

[<span data-ttu-id="170f4-269">Spécification de signatures racine en langage HLSL</span><span class="sxs-lookup"><span data-stu-id="170f4-269">Specifying Root Signatures in HLSL</span></span>](specifying-root-signatures-in-hlsl.md)
</dt> </dl>

 

 




