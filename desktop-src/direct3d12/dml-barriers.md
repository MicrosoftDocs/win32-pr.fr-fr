---
title: Barrières UAV et barrières de l’état des ressources dans DirectML
description: Décrit les avantages de l’exactitude des barrières et comment vous pouvez les utiliser dans DirectML.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 9bfc93d4fb28cff5d7d196287c6573e3e494d1d5
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548543"
---
# <a name="uav-barriers-and-resource-state-barriers-in-directml"></a><span data-ttu-id="1b385-103">Barrières UAV et barrières de l’état des ressources dans DirectML</span><span class="sxs-lookup"><span data-stu-id="1b385-103">UAV barriers and resource state barriers in DirectML</span></span>

## <a name="unordered-access-view-uav-barrier-requirements"></a><span data-ttu-id="1b385-104">Exigences en matière de barrière de vue d’accès non ordonné (UAV)</span><span class="sxs-lookup"><span data-stu-id="1b385-104">Unordered Access View (UAV) barrier requirements</span></span>

### <a name="uav-barriers-in-direct3d-12"></a><span data-ttu-id="1b385-105">Obstacles UAV dans Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="1b385-105">UAV barriers in Direct3D 12</span></span>

<span data-ttu-id="1b385-106">Dans Direct3D 12, les distributions de nuanceur de calcul adjacentes dans la même liste de commandes sont autorisées à s’exécuter en parallèle sur le GPU, sauf s’ils sont synchronisés avec un cloisonnement UAV (non ordonnéed Access View) intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="1b385-106">In Direct3D 12, adjacent compute shader dispatches within the same command list are permitted to execute in parallel on the GPU unless they're synchronized with an intervening unordered access view (UAV) barrier.</span></span> <span data-ttu-id="1b385-107">Cela peut améliorer les performances en renforçant l’utilisation du matériel GPU.</span><span class="sxs-lookup"><span data-stu-id="1b385-107">This can improve performance by increasing utilization of GPU hardware.</span></span> <span data-ttu-id="1b385-108">Toutefois, par défaut, sans l’utilisation d’un cloisonnement UAV, l’exécution parallèle de deux distributions adjacentes peut provoquer une condition de concurrence s’il existe une dépendance de données entre les deux distributions ; ou si les deux distributions effectuent des écritures UAV dans les mêmes régions de mémoire.</span><span class="sxs-lookup"><span data-stu-id="1b385-108">However, by default, without the use of a UAV barrier, the parallel execution of two adjacent dispatches can cause a race condition if there exists a data dependency between the two dispatches; or if both dispatches perform UAV writes to the same regions of memory.</span></span>

<span data-ttu-id="1b385-109">Une barrière UAV force tous les distributions précédemment envoyées à terminer l’exécution de l’opération sur le GPU avant que les distributions suivantes puissent commencer.</span><span class="sxs-lookup"><span data-stu-id="1b385-109">A UAV barrier forces all previously-submitted dispatches to complete exection on the GPU before subsequent dispatches may begin.</span></span> <span data-ttu-id="1b385-110">Les barrières UAV sont utilisées pour la synchronisation entre les distributions sur la même liste de commandes afin d’éviter les concurrences de données.</span><span class="sxs-lookup"><span data-stu-id="1b385-110">UAV barriers are used to synchronize between dispatches on the same command list to avoid data races.</span></span> <span data-ttu-id="1b385-111">Vous pouvez émettre un cloisonnement UAV à l’aide de la [méthode **ID3D12GraphicsCommandList :: ResourceBarrier**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span><span class="sxs-lookup"><span data-stu-id="1b385-111">You can issue a UAV barrier by using the [**ID3D12GraphicsCommandList::ResourceBarrier** method](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).</span></span>

### <a name="uav-barriers-in-directml"></a><span data-ttu-id="1b385-112">Barrières UAV dans DirectML</span><span class="sxs-lookup"><span data-stu-id="1b385-112">UAV barriers in DirectML</span></span>

<span data-ttu-id="1b385-113">Dans DirectML, les opérateurs sont distribués d’une manière similaire à la façon dont les nuanceurs de calcul sont distribués dans Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="1b385-113">In DirectML, operators are dispatched in a way that's similar to the way compute shaders are dispatched in Direct3D 12.</span></span> <span data-ttu-id="1b385-114">Autrement dit, les distributions adjacentes des opérateurs sont autorisées à s’exécuter en parallèle sur le GPU, sauf s’il existe une barrière UAV entre eux.</span><span class="sxs-lookup"><span data-stu-id="1b385-114">That is, adjacent dispatches of operators are permitted to execute in parallel on the GPU unless there exists an intervening UAV barrier between them.</span></span> <span data-ttu-id="1b385-115">Un modèle de Machine Learning classique contient des dépendances de données entre ses opérateurs. par exemple, la sortie d’un opérateur alimente l’entrée d’un autre.</span><span class="sxs-lookup"><span data-stu-id="1b385-115">A typical machine learning model contains data dependencies between its operators; for instance, the output of one operator feeds into the input of another.</span></span> <span data-ttu-id="1b385-116">Il est donc important d’utiliser des barrières UAV pour synchroniser correctement les distributions.</span><span class="sxs-lookup"><span data-stu-id="1b385-116">It's therefore important to use UAV barriers to correctly synchronize dispatches.</span></span>

<span data-ttu-id="1b385-117">DirectML garantit qu’il lira uniquement les dizaines d’entrées (et n’écrit jamais).</span><span class="sxs-lookup"><span data-stu-id="1b385-117">DirectML guarantees that it will only ever read from (and never write to) input tensors.</span></span> <span data-ttu-id="1b385-118">Il garantit également qu’il ne fabriquera jamais d’écritures dans un tenseur de sortie en dehors de la plage du membre [**DML_BUFFER_TENSOR_DESC :: TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) de tenseur.</span><span class="sxs-lookup"><span data-stu-id="1b385-118">It also guarantees that it will never manufacture writes to an output tensor outside the range of the tensor's [**DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) member.</span></span> <span data-ttu-id="1b385-119">Cela signifie que les dépendances de données entre les opérateurs dans DirectML peuvent être motivées en examinant uniquement les liaisons d’entrée et de sortie d’un opérateur.</span><span class="sxs-lookup"><span data-stu-id="1b385-119">This means that data dependencies between operators in DirectML can be reasoned about by looking only at an operator's input and output bindings.</span></span>

<span data-ttu-id="1b385-120">Par exemple, ces garanties vous permettent de distribuer deux opérateurs qui lient la même région d’une ressource en tant qu’entrée, sans avoir à émettre une barrière UAV intermédiaire.</span><span class="sxs-lookup"><span data-stu-id="1b385-120">For example, these guarantees allow you to dispatch two operators that bind the same region of a resource as an input, without having to issue an intervening UAV barrier.</span></span> <span data-ttu-id="1b385-121">Cela est toujours sûr, car DirectML n’écrit jamais dans des dizaines d’entrées.</span><span class="sxs-lookup"><span data-stu-id="1b385-121">This is always safe because DirectML never writes to input tensors.</span></span> <span data-ttu-id="1b385-122">Autre exemple : il est toujours possible de lier les dizaines de sortie de deux distributions d’opérateur simultanés à la même ressource Direct3D 12 (tant que leurs dizaines ne se chevauchent pas), car DirectML n’écrit jamais en dehors des limites d’un tenseur (comme défini par le DML_BUFFER_TENSOR_DESC de tenseur **:: TotalTensorSizeInBytes**).</span><span class="sxs-lookup"><span data-stu-id="1b385-122">As another example, it's always safe to bind the output tensors of two concurrent operator dispatches to the same Direct3D 12 resource (so long as their tensors don't overlap), because DirectML never writes outside the bounds of a tensor (as defined by the tensor's **DML_BUFFER_TENSOR_DESC::TotalTensorSizeInBytes**).</span></span>

<span data-ttu-id="1b385-123">Comme les barrières UAV sont une forme de synchronisation, l’utilisation inutile de barrières UAV peut avoir un impact négatif sur les performances.</span><span class="sxs-lookup"><span data-stu-id="1b385-123">As UAV barriers are a form of synchronization, unnecessary use of UAV barriers might negatively impact performance.</span></span> <span data-ttu-id="1b385-124">Par conséquent, il est préférable d’utiliser le nombre minimal de barrières UAV nécessaires pour synchroniser correctement les distributions dans une liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="1b385-124">Therefore, it's best for you to use the minimum number of UAV barriers necessary to correctly synchronize the dispatches within a command list.</span></span>

### <a name="example-1"></a><span data-ttu-id="1b385-125">Exemple 1</span><span class="sxs-lookup"><span data-stu-id="1b385-125">Example 1</span></span>

<span data-ttu-id="1b385-126">Dans l’exemple suivant, la sortie d’un opérateur de convolution est alimentée dans une activation ReLU, suivie d’une normalisation par lots.</span><span class="sxs-lookup"><span data-stu-id="1b385-126">In the following example, a convolution operator's output is fed into a ReLU activation, followed by a batch normalization.</span></span>

```console
    CONVOLUTION (conv1)
         |
  ACTIVATION_RELU (relu1)
         |
BATCH_NORMALIZATION (batch1)
```

<span data-ttu-id="1b385-127">Étant donné qu’il existe une dépendance de données entre les trois opérateurs, vous aurez besoin d’une barrière UAV entre chaque Dispatch successif (voir [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span><span class="sxs-lookup"><span data-stu-id="1b385-127">Since a data dependency exists between all three operators, you'll need a UAV barrier between each successive dispatch (see [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).</span></span>

1. <span data-ttu-id="1b385-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-128">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
2. <span data-ttu-id="1b385-129">`d3d12CommandList->ResourceBarrier(`**Barrière UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-129">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="1b385-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-130">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`</span></span>
4. <span data-ttu-id="1b385-131">`d3d12CommandList->ResourceBarrier(`**Barrière UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-131">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
5. <span data-ttu-id="1b385-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-132">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`</span></span>

### <a name="example-2"></a><span data-ttu-id="1b385-133">Exemple 2</span><span class="sxs-lookup"><span data-stu-id="1b385-133">Example 2</span></span>

```console
     MAX_POOLING (pool1)
        /    \
CONVOLUTION  CONVOLUTION
  (conv1)      (conv2)
        \    /
         JOIN (join1)
```

<span data-ttu-id="1b385-134">Ici, la sortie du regroupement est alimentée en deux convolutions, dont les sorties sont ensuite concaténées à l’aide de l’opérateur de jointure.</span><span class="sxs-lookup"><span data-stu-id="1b385-134">Here the output of pooling is fed into two convolutions, whose outputs are then concatenated together using the JOIN operator.</span></span> <span data-ttu-id="1b385-135">Une dépendance de données existe entre et les deux et, ainsi qu' `pool1` `conv1` `conv2` entre `conv1` et `conv2` et `join1` .</span><span class="sxs-lookup"><span data-stu-id="1b385-135">A data dependency exists between `pool1` and both `conv1` and `conv2`; as well as between both `conv1` and `conv2` and `join1`.</span></span> <span data-ttu-id="1b385-136">Voici une méthode valide pour exécuter ce graphique.</span><span class="sxs-lookup"><span data-stu-id="1b385-136">Here's one valid way to execute this graph.</span></span>

1. <span data-ttu-id="1b385-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-137">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`</span></span>
2. <span data-ttu-id="1b385-138">`d3d12CommandList->ResourceBarrier(`**Barrière UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-138">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
3. <span data-ttu-id="1b385-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-139">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`</span></span>
4. <span data-ttu-id="1b385-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**Conv2**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-140">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`</span></span>
5. <span data-ttu-id="1b385-141">`d3d12CommandList->ResourceBarrier(`**Barrière UAV**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-141">`d3d12CommandList->ResourceBarrier(`**UAV barrier**`)`</span></span>
6. <span data-ttu-id="1b385-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**Join1**`)`</span><span class="sxs-lookup"><span data-stu-id="1b385-142">`dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`</span></span>

<span data-ttu-id="1b385-143">Dans ce cas, `conv1` et `conv2` sont en mesure de s’exécuter simultanément sur le GPU, ce qui peut améliorer les performances.</span><span class="sxs-lookup"><span data-stu-id="1b385-143">In this case, `conv1` and `conv2` are able to execute concurrently on the GPU, which may improve performance.</span></span>

## <a name="resource-barrier-state-requirements"></a><span data-ttu-id="1b385-144">Exigences relatives à l’état de la barrière des ressources</span><span class="sxs-lookup"><span data-stu-id="1b385-144">Resource barrier state requirements</span></span>

<span data-ttu-id="1b385-145">En tant qu’appelant, il vous incombe de vous assurer que toutes les ressources Direct3D 12 se trouvent dans l’état de barrière de ressources approprié avant d’exécuter des distributions DirectML sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="1b385-145">As the caller, it's your responsibility to ensure that all Direct3D 12 resources are in the correct resource barrier state prior to executing DirectML dispatches on the GPU.</span></span> <span data-ttu-id="1b385-146">DirectML n’effectue pas de barrières de transition en votre nom.</span><span class="sxs-lookup"><span data-stu-id="1b385-146">DirectML doesn't perform any transition barriers on your behalf.</span></span>

<span data-ttu-id="1b385-147">Avant l’exécution de [**IDMLCommandRecorder :: RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) sur le GPU, vous devez faire passer toutes les ressources liées à l’état **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** ou à un État pouvant être promu implicitement en **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, tel que **D3D12_RESOURCE_STATE_COMMON**.</span><span class="sxs-lookup"><span data-stu-id="1b385-147">Prior to execution of [**IDMLCommandRecorder::RecordDispatch**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) on the GPU, you must transition all bound resources to the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state, or to a state implicitly promotable to **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, such as **D3D12_RESOURCE_STATE_COMMON**.</span></span> <span data-ttu-id="1b385-148">Une fois cet appel terminé, les ressources restent à l’état **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** .</span><span class="sxs-lookup"><span data-stu-id="1b385-148">After this call completes, the resources remain in the **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** state.</span></span> <span data-ttu-id="1b385-149">Pour plus d’informations, consultez [liaison dans DirectML](dml-binding.md).</span><span class="sxs-lookup"><span data-stu-id="1b385-149">For more details, see [Binding in DirectML](dml-binding.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1b385-150">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="1b385-150">See also</span></span>

* [<span data-ttu-id="1b385-151">Utilisation de barrières de ressources pour synchroniser les États des ressources dans Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="1b385-151">Using resource barriers to synchronize resource states in Direct3D 12</span></span>](/windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12)
* [<span data-ttu-id="1b385-152">Liaison dans DirectML</span><span class="sxs-lookup"><span data-stu-id="1b385-152">Binding in DirectML</span></span>](dml-binding.md)
