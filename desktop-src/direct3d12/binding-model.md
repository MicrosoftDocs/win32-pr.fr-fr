---
title: Différences dans le modèle de liaison de Direct3D 11
description: L’une des principales décisions de conception derrière la liaison DirectX12 est de la séparer des autres tâches de gestion. Cela impose des exigences sur l’application pour gérer certains dangers potentiels.
ms.assetid: 3EE7E9AE-203D-40D4-9F12-4313ED179035
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 43b2785da6497fd4e775d9f88847928e7c4c08e8
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104224"
---
# <a name="differences-in-the-binding-model-from-direct3d-11"></a><span data-ttu-id="15c3c-104">Différences dans le modèle de liaison de Direct3D 11</span><span class="sxs-lookup"><span data-stu-id="15c3c-104">Differences in the Binding Model from Direct3D 11</span></span>

<span data-ttu-id="15c3c-105">L’une des principales décisions de conception derrière la liaison DirectX12 est de la séparer des autres tâches de gestion.</span><span class="sxs-lookup"><span data-stu-id="15c3c-105">One of the main design decisions behind DirectX12 binding is to separate it from other management tasks.</span></span> <span data-ttu-id="15c3c-106">Cela impose des exigences sur l’application pour gérer certains dangers potentiels.</span><span class="sxs-lookup"><span data-stu-id="15c3c-106">This places some requirements on the app to manage certain potential hazards.</span></span>

<span data-ttu-id="15c3c-107">Le principal avantage du modèle de liaison D3D12 est qu’il permet aux applications de modifier fréquemment les liaisons de texture, sans coût énorme de performances de l’UC.</span><span class="sxs-lookup"><span data-stu-id="15c3c-107">The main advantage of the D3D12 Binding Model is that it enables apps to change texture bindings frequently, without a huge CPU performance cost.</span></span> <span data-ttu-id="15c3c-108">D’autres avantages sont que les nuanceurs ont accès à un très grand nombre de ressources, que les nuanceurs n’ont pas besoin de savoir à l’avance le nombre de ressources qui seront liées et qu’un modèle de liaison de ressources unifiées peut être utilisé indépendamment du matériel ou du contenu du contenu des applications.</span><span class="sxs-lookup"><span data-stu-id="15c3c-108">Other benefits are that shaders have access to a very large number of resources, shaders need not know in advance how many resources will be bound, and that a unified resource binding model can be used regardless of hardware or the apps content flow.</span></span>

<span data-ttu-id="15c3c-109">Pour améliorer les performances, le modèle de liaison ne requiert pas que le système effectue le suivi des liaisons qu’une application a demandées pour l’utilisation du GPU et qu’il existe une propre intégration entre la liaison et les listes de commandes multithread.</span><span class="sxs-lookup"><span data-stu-id="15c3c-109">To improve performance, the binding model does not require the system to keep track of what bindings an app has requested the GPU to use, and there is a clean integration between binding and multi-threaded command lists.</span></span>

<span data-ttu-id="15c3c-110">Les sections suivantes répertorient certaines des modifications apportées au modèle de liaison de ressources depuis D3D11.</span><span class="sxs-lookup"><span data-stu-id="15c3c-110">The following sections list some of the changes to the resource binding model since D3D11.</span></span>

-   [<span data-ttu-id="15c3c-111">Gestion de la résidence de la mémoire séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-111">Memory Residency Management Separated From Binding</span></span>](#memory-residency-management-separated-from-binding)
-   [<span data-ttu-id="15c3c-112">Gestion de la durée de vie des objets séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-112">Object Lifetime Management Separated From Binding</span></span>](#object-lifetime-management-separated-from-binding)
-   [<span data-ttu-id="15c3c-113">Suivi de l’état des ressources du pilote séparé de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-113">Driver Resource State Tracking Separated From Binding</span></span>](#driver-resource-state-tracking-separated-from-binding)
-   [<span data-ttu-id="15c3c-114">Synchronisation de la mémoire mappée du GPU de l’UC séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-114">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>](#cpu-gpu-mapped-memory-synchronization-separated-from-binding)
-   [<span data-ttu-id="15c3c-115">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="15c3c-115">Related topics</span></span>](#related-topics)

## <a name="memory-residency-management-separated-from-binding"></a><span data-ttu-id="15c3c-116">Gestion de la résidence de la mémoire séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-116">Memory Residency Management Separated From Binding</span></span>

<span data-ttu-id="15c3c-117">Les applications ont un contrôle explicite sur les surfaces qu’elles doivent être disponibles pour que le GPU soit directement utilisé (appelé « résident »).</span><span class="sxs-lookup"><span data-stu-id="15c3c-117">Applications have explicit control over which surfaces they need to be available for the GPU to use directly (called being "resident").</span></span> <span data-ttu-id="15c3c-118">Inversement, ils peuvent appliquer d’autres États sur les ressources, par exemple les rendre explicitement inrésidents ou laisser le système d’exploitation choisir pour certaines classes d’applications qui nécessitent un encombrement minimal de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="15c3c-118">Conversely, they can apply other states on resources such as explicitly making them not resident, or letting the OS choose for certain classes of applications that require a minimal memory footprint.</span></span> <span data-ttu-id="15c3c-119">Le point important ici est que la gestion de l’application de ce qui est résident est entièrement dissociée de la façon dont elle donne accès aux ressources aux nuanceurs.</span><span class="sxs-lookup"><span data-stu-id="15c3c-119">The important point here is that the application's management of what is resident is completely decoupled from how it gives access to resources to shaders.</span></span>

<span data-ttu-id="15c3c-120">Le découplage de la gestion de la résidence à partir du mécanisme permettant aux nuanceurs d’accéder aux ressources réduit le coût du système/matériel pour le rendu, car le système d’exploitation n’a pas besoin d’inspecter constamment l’état de la liaison locale pour savoir ce qu’il faut faire résident.</span><span class="sxs-lookup"><span data-stu-id="15c3c-120">The decoupling of residency management from the mechanism for giving shaders access to resources reduces the system/hardware cost for rendering since the OS doesn't have to constantly inspect the local binding state to know what to make resident.</span></span> <span data-ttu-id="15c3c-121">En outre, les nuanceurs n’ont plus à connaître les surfaces exactes qu’ils devront peut-être référencer, à condition que l’ensemble des ressources éventuellement accessibles ait été mis en attente à l’avance.</span><span class="sxs-lookup"><span data-stu-id="15c3c-121">Furthermore, shaders no longer have to know which exact surfaces they may need to reference, as long as the entire set of possibly accessible resources has been made resident ahead of time.</span></span>

## <a name="object-lifetime-management-separated-from-binding"></a><span data-ttu-id="15c3c-122">Gestion de la durée de vie des objets séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-122">Object Lifetime Management Separated From Binding</span></span>

<span data-ttu-id="15c3c-123">Contrairement aux API précédentes, le système n’effectue plus le suivi des liaisons des ressources avec le pipeline.</span><span class="sxs-lookup"><span data-stu-id="15c3c-123">Unlike previous APIs, the system no longer tracks bindings of resources to the pipeline.</span></span> <span data-ttu-id="15c3c-124">Utilisé pour permettre au système de conserver les ressources actives que l’application a publiées parce qu’elles sont toujours référencées par un travail GPU en suspens.</span><span class="sxs-lookup"><span data-stu-id="15c3c-124">This used to enable the system to keep alive resources that the application has released because they are still referenced by outstanding GPU work.</span></span>

<span data-ttu-id="15c3c-125">Avant de libérer une ressource, telle qu’une texture, les applications doivent maintenant s’assurer que le GPU a terminé de la référencer.</span><span class="sxs-lookup"><span data-stu-id="15c3c-125">Before freeing any resource, such as a texture, applications now must make sure the GPU has completed referencing it.</span></span> <span data-ttu-id="15c3c-126">Cela signifie qu’avant qu’une application puisse libérer en toute sécurité une ressource, le GPU doit avoir terminé l’exécution de la liste de commandes référençant la ressource.</span><span class="sxs-lookup"><span data-stu-id="15c3c-126">This means before an application can safely free a resource the GPU must have completed execution of the command list referencing the resource.</span></span>

## <a name="driver-resource-state-tracking-separated-from-binding"></a><span data-ttu-id="15c3c-127">Suivi de l’état des ressources du pilote séparé de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-127">Driver Resource State Tracking Separated From Binding</span></span>

<span data-ttu-id="15c3c-128">Le système n’inspecte plus les liaisons de ressources pour comprendre le moment où des transitions de ressources ont eu lieu, ce qui nécessite un fonctionnement supplémentaire du pilote ou du GPU.</span><span class="sxs-lookup"><span data-stu-id="15c3c-128">The system no longer inspects resource bindings to understand when resource transitions have occurred which require additional driver or GPU work.</span></span> <span data-ttu-id="15c3c-129">Un exemple courant d’un grand nombre de processeurs graphiques et de pilotes doit savoir quand une surface passe d’être utilisée en tant que vue de la cible de rendu (RTV) sur le Affichage des ressources de nuanceur (SRV).</span><span class="sxs-lookup"><span data-stu-id="15c3c-129">A common example for many GPUs and drivers is having to know when a surface transitions from being used as a Render Target View (RTV) to Shader Resource View (SRV).</span></span> <span data-ttu-id="15c3c-130">Les applications elles-mêmes doivent maintenant déterminer à quel moment les transitions de ressources auxquelles le système peut s’intéresser se produisent via des API dédiées.</span><span class="sxs-lookup"><span data-stu-id="15c3c-130">Applications themselves must now identify when any resource transitions that the system might care about are happening via dedicated APIs.</span></span>

## <a name="cpu-gpu-mapped-memory-synchronization-separated-from-binding"></a><span data-ttu-id="15c3c-131">Synchronisation de la mémoire mappée du GPU de l’UC séparée de la liaison</span><span class="sxs-lookup"><span data-stu-id="15c3c-131">CPU GPU Mapped Memory Synchronization Separated From Binding</span></span>

<span data-ttu-id="15c3c-132">Le système n’inspecte plus les liaisons de ressources pour comprendre si le rendu doit être retardé, car il dépend d’une ressource qui a été mappée pour l’accès de l’UC mais qui n’a pas encore été annulée.</span><span class="sxs-lookup"><span data-stu-id="15c3c-132">The system no longer inspects resource bindings to understand if rendering needs to be delayed because it depends on a resource that has been mapped for CPU access but has not been unmapped yet.</span></span> <span data-ttu-id="15c3c-133">Les applications ont maintenant la responsabilité de synchroniser les accès à la mémoire de l’UC et du GPU.</span><span class="sxs-lookup"><span data-stu-id="15c3c-133">Applications now have the responsibility to synchronize CPU and GPU memory accesses.</span></span> <span data-ttu-id="15c3c-134">Pour faciliter cette opération, le système fournit des mécanismes permettant à l’application de demander le sommeil d’un thread d’UC jusqu’à ce que le travail soit terminé.</span><span class="sxs-lookup"><span data-stu-id="15c3c-134">To help with this, the system provides mechanisms for the application to request the sleeping of a CPU thread until work completes.</span></span> <span data-ttu-id="15c3c-135">L’interrogation peut également être effectuée, mais elle peut être moins efficace.</span><span class="sxs-lookup"><span data-stu-id="15c3c-135">Polling could also be done, but can be less efficient.</span></span>

## <a name="related-topics"></a><span data-ttu-id="15c3c-136">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="15c3c-136">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="15c3c-137">Liaison de ressource</span><span class="sxs-lookup"><span data-stu-id="15c3c-137">Resource Binding</span></span>](resource-binding.md)
</dt> </dl>

 

 




