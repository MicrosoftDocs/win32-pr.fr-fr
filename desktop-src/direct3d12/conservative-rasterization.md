---
title: Pixellisation de Direct3D 12
description: La pixellisation conservatrice apporte une certaine certitude au rendu des pixels, ce qui est utile en particulier pour les algorithmes de détection des collisions.
ms.assetid: 081199AD-1702-4EC8-95AD-B1148C676199
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4e4fae3489d54ab7b6b7abfda56f54dd8d970962
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548611"
---
# <a name="direct3d-12-conservative-rasterization"></a><span data-ttu-id="3f204-103">Pixellisation de Direct3D 12</span><span class="sxs-lookup"><span data-stu-id="3f204-103">Direct3D 12 Conservative Rasterization</span></span>

<span data-ttu-id="3f204-104">La pixellisation conservatrice apporte une certaine certitude au rendu des pixels, ce qui est utile en particulier pour les algorithmes de détection des collisions.</span><span class="sxs-lookup"><span data-stu-id="3f204-104">Conservative Rasterization adds some certainty to pixel rendering, which is helpful in particular to collision detection algorithms.</span></span>

-   [<span data-ttu-id="3f204-105">Vue d'ensemble</span><span class="sxs-lookup"><span data-stu-id="3f204-105">Overview</span></span>](#overview)
-   [<span data-ttu-id="3f204-106">Interactions avec le pipeline</span><span class="sxs-lookup"><span data-stu-id="3f204-106">Interactions with the pipeline</span></span>](#interactions-with-the-pipeline)
    -   [<span data-ttu-id="3f204-107">Interaction des règles de pixellisation</span><span class="sxs-lookup"><span data-stu-id="3f204-107">Rasterization Rules interaction</span></span>](#rasterization-rules-interaction)
    -   [<span data-ttu-id="3f204-108">Interaction d’échantillonnage multiple</span><span class="sxs-lookup"><span data-stu-id="3f204-108">Multisampling interaction</span></span>](#multisampling-interaction)
    -   [<span data-ttu-id="3f204-109">Interaction SampleMask</span><span class="sxs-lookup"><span data-stu-id="3f204-109">SampleMask interaction</span></span>](#samplemask-interaction)
    -   [<span data-ttu-id="3f204-110">Interaction de test de profondeur/stencil</span><span class="sxs-lookup"><span data-stu-id="3f204-110">Depth/Stencil Test interaction</span></span>](#depthstencil-test-interaction)
    -   [<span data-ttu-id="3f204-111">Interaction des pixels d’assistance</span><span class="sxs-lookup"><span data-stu-id="3f204-111">Helper Pixel interaction</span></span>](#helper-pixel-interaction)
    -   [<span data-ttu-id="3f204-112">Interaction de couverture de sortie</span><span class="sxs-lookup"><span data-stu-id="3f204-112">Output Coverage interaction</span></span>](#output-coverage-interaction)
    -   [<span data-ttu-id="3f204-113">Interaction InputCoverage</span><span class="sxs-lookup"><span data-stu-id="3f204-113">InputCoverage interaction</span></span>](#inputcoverage-interaction)
    -   [<span data-ttu-id="3f204-114">Interaction InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="3f204-114">InnerCoverage interaction</span></span>](#innercoverage-interaction)
    -   [<span data-ttu-id="3f204-115">Interaction d’interpolation d’attribut</span><span class="sxs-lookup"><span data-stu-id="3f204-115">Attribute Interpolation interaction</span></span>](#attribute-interpolation-interaction)
    -   [<span data-ttu-id="3f204-116">Interaction du découpage</span><span class="sxs-lookup"><span data-stu-id="3f204-116">Clipping interaction</span></span>](#clipping-interaction)
    -   [<span data-ttu-id="3f204-117">Interaction de la distance du clip</span><span class="sxs-lookup"><span data-stu-id="3f204-117">Clip Distance interaction</span></span>](#clip-distance-interaction)
    -   [<span data-ttu-id="3f204-118">Interaction de pixellisation indépendante cible</span><span class="sxs-lookup"><span data-stu-id="3f204-118">Target Independent Rasterization interaction</span></span>](#target-independent-rasterization-interaction)
    -   [<span data-ttu-id="3f204-119">Interaction de la topologie de la primitive IA</span><span class="sxs-lookup"><span data-stu-id="3f204-119">IA Primitive Topology interaction</span></span>](#ia-primitive-topology-interaction)
    -   [<span data-ttu-id="3f204-120">Interroger l’interaction</span><span class="sxs-lookup"><span data-stu-id="3f204-120">Query interaction</span></span>](#query-interaction)
    -   [<span data-ttu-id="3f204-121">Élimination de l’interaction de l’État</span><span class="sxs-lookup"><span data-stu-id="3f204-121">Cull State interaction</span></span>](#cull-state-interaction)
    -   [<span data-ttu-id="3f204-122">Interaction IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="3f204-122">IsFrontFace interaction</span></span>](#isfrontface-interaction)
    -   [<span data-ttu-id="3f204-123">Interaction des modes de remplissage</span><span class="sxs-lookup"><span data-stu-id="3f204-123">Fill Modes interaction</span></span>](#fill-modes-interaction)
-   [<span data-ttu-id="3f204-124">Détails de l’implémentation</span><span class="sxs-lookup"><span data-stu-id="3f204-124">Implementation details</span></span>](#implementation-details)
-   [<span data-ttu-id="3f204-125">API summary</span><span class="sxs-lookup"><span data-stu-id="3f204-125">API summary</span></span>](#api-summary)
-   [<span data-ttu-id="3f204-126">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="3f204-126">Related topics</span></span>](#related-topics)

## <a name="overview"></a><span data-ttu-id="3f204-127">Vue d’ensemble</span><span class="sxs-lookup"><span data-stu-id="3f204-127">Overview</span></span>

<span data-ttu-id="3f204-128">La pixellisation conservatrice signifie que tous les pixels qui sont au moins partiellement couverts par une primitive rendue sont pixellisés, ce qui signifie que le nuanceur de pixels est appelé.</span><span class="sxs-lookup"><span data-stu-id="3f204-128">Conservative Rasterization means that all pixels that are at least partially covered by a rendered primitive are rasterized, which means that the pixel shader is invoked.</span></span> <span data-ttu-id="3f204-129">Le comportement normal est l’échantillonnage, qui n’est pas utilisé si la pixellisation conservatrice est activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-129">Normal behavior is sampling, which is not used if Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="3f204-130">La pixellisation conservatrice est utile dans un certain nombre de situations, notamment pour garantir la détection des collisions, l’élimination des occlusions et le rendu en mosaïque.</span><span class="sxs-lookup"><span data-stu-id="3f204-130">Conservative Rasterization is useful in a number of situations, including for certainty in collision detection, occlusion culling, and tiled rendering.</span></span>

<span data-ttu-id="3f204-131">Par exemple, l’illustration suivante montre un triangle vert rendu à l’aide de la pixellisation conservatrice, tel qu’il apparaîtrait dans le rastériseur (autrement dit, en utilisant des coordonnées de sommets à virgule fixe 16,8).</span><span class="sxs-lookup"><span data-stu-id="3f204-131">For example, the following figure shows a green triangle rendered using Conservative Rasterization, as it would appear in the rasterizer (that is, using 16.8 fixed point vertex coordinates).</span></span> <span data-ttu-id="3f204-132">La zone brune est connue sous le nom de « région d’incertitude », une région conceptuelle qui représente les limites étendues du triangle, nécessaires pour garantir que la primitive dans le rastériseur est conservatrice en ce qui concerne les coordonnées de vertex à virgule flottante d’origine.</span><span class="sxs-lookup"><span data-stu-id="3f204-132">The brown area is known as an "uncertainty region" - a conceptual region that represents the extended bounds of the triangle, required to ensure the primitive in the rasterizer is conservative with respect to the original floating point vertex coordinates.</span></span> <span data-ttu-id="3f204-133">Les carrés rouges à chaque vertex montrent comment la région d’incertitude est calculée : sous la forme d’un carré balayé.</span><span class="sxs-lookup"><span data-stu-id="3f204-133">The red squares at each vertex shows how the uncertainty region is calculated: as a swept square.</span></span>

<span data-ttu-id="3f204-134">Les grands carrés gris affichent les pixels qui seront rendus.</span><span class="sxs-lookup"><span data-stu-id="3f204-134">The large gray squares show the pixels that will be rendered.</span></span> <span data-ttu-id="3f204-135">Les carrés roses affichent les pixels affichés à l’aide de la « règle de haut en bas », qui entre en lecture lorsque le bord du triangle traverse le bord des pixels.</span><span class="sxs-lookup"><span data-stu-id="3f204-135">The pink squares show pixels rendered using the "Top-Left Rule", which comes into play as the edge of the triangle crosses the edge of the pixels.</span></span> <span data-ttu-id="3f204-136">Il peut y avoir des faux positifs (pixels définis qui ne devraient pas avoir été) que le système va normalement, mais pas toujours.</span><span class="sxs-lookup"><span data-stu-id="3f204-136">There can be false positives (pixels set that should not have been) which the system will normally but not always cull.</span></span>

![règle en haut à gauche](images/conservative-rasterization-0.png)

## <a name="interactions-with-the-pipeline"></a><span data-ttu-id="3f204-138">Interactions avec le pipeline</span><span class="sxs-lookup"><span data-stu-id="3f204-138">Interactions with the pipeline</span></span>

### <a name="rasterization-rules-interaction"></a><span data-ttu-id="3f204-139">Interaction des règles de pixellisation</span><span class="sxs-lookup"><span data-stu-id="3f204-139">Rasterization Rules interaction</span></span>

<span data-ttu-id="3f204-140">En mode de pixellisation conservateur, les règles de pixellisation s’appliquent de la même façon que lorsque le mode de pixellisation conservateur n’est pas activé avec des exceptions pour la règle de Top-Left, décrite ci-dessus et la couverture des pixels.</span><span class="sxs-lookup"><span data-stu-id="3f204-140">In Conservative Rasterization mode, Rasterization Rules apply the same way as when Conservative Rasterization mode is not enabled with exceptions for the Top-Left Rule, described above, and Pixel Coverage.</span></span> <span data-ttu-id="3f204-141">16,8 Fixed-Point la précision du rastériseur doit être utilisée.</span><span class="sxs-lookup"><span data-stu-id="3f204-141">16.8 Fixed-Point Rasterizer precision must be used.</span></span>

<span data-ttu-id="3f204-142">Les pixels qui ne seraient pas couverts si le matériel utilisait des coordonnées de vertex à virgule flottante complètes ne peuvent être inclus que s’ils se trouvent dans une région d’incertitude ne dépassant pas la moitié d’un pixel dans le domaine à virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="3f204-142">Pixels that would not be covered if hardware was using full floating point vertex coordinates may only be included if they are within an uncertainty region no larger half a pixel in the fixed point domain.</span></span> <span data-ttu-id="3f204-143">Le matériel futur devrait atteindre la région d’incertitude renforcée spécifiée dans le niveau 2.</span><span class="sxs-lookup"><span data-stu-id="3f204-143">Future hardware is expected to reach the tightened uncertainty region specified in Tier 2.</span></span> <span data-ttu-id="3f204-144">Notez que cette exigence empêche les triangles d’éclats de s’étendre davantage que nécessaire.</span><span class="sxs-lookup"><span data-stu-id="3f204-144">Note that this requirement prevents sliver triangles from extending further than necessary.</span></span>

<span data-ttu-id="3f204-145">Une région d’incertitude valide similaire s’applique `InnerCoverage` également à, mais elle est plus stricte, car aucune implémentation ne nécessite une région d’incertitude plus importante pour ce cas.</span><span class="sxs-lookup"><span data-stu-id="3f204-145">A similar valid uncertainty region applies to `InnerCoverage` as well, but it is tighter since no implementations require a larger uncertainty region for this case.</span></span> <span data-ttu-id="3f204-146">Pour plus d’informations, consultez [interaction InnerCoverage](#innercoverage-interaction) .</span><span class="sxs-lookup"><span data-stu-id="3f204-146">See [InnerCoverage interaction](#innercoverage-interaction) for more detail.</span></span>

<span data-ttu-id="3f204-147">Les régions d’incertitude interne et externe doivent être supérieures ou égales à la taille de la moitié de la grille de sous-pixel, ou 1/512 d’un pixel, dans le domaine à virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="3f204-147">Inner and outer uncertainty regions must be greater than or equal to the size of half the sub-pixel grid, or 1/512 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="3f204-148">Il s’agit de la région d’incertitude minimale valide.</span><span class="sxs-lookup"><span data-stu-id="3f204-148">This is the minimum valid uncertainty region.</span></span> <span data-ttu-id="3f204-149">1/512 provient de la représentation de la coordonnée du rastériseur à virgule fixe 16,8 et de la règle d’arrondi à la valeur la plus proche qui s’applique lors de la conversion de coordonnées de vertex à virgule flottante à 16,8 coordonnées en virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="3f204-149">1/512 comes from the 16.8 fixed point Rasterizer coordinate representation and the round-to-nearest rule that applies when converting floating point vertex coordinates to 16.8 fixed point coordinates.</span></span> <span data-ttu-id="3f204-150">1/512 peut changer si la précision du rastériseur change.</span><span class="sxs-lookup"><span data-stu-id="3f204-150">1/512 can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="3f204-151">Si une implémentation implémente cette zone d’incertitude minimale, elle doit suivre la règle Top-Left lorsqu’un bord ou un angle de la région d’incertitude se situe le long du bord ou de l’angle d’un pixel.</span><span class="sxs-lookup"><span data-stu-id="3f204-151">If an implementation implements this minimum uncertainty region, then they must follow the Top-Left Rule when an edge or corner of the uncertainty region falls along the edge or corner of a pixel.</span></span> <span data-ttu-id="3f204-152">Les bords détourés de la région d’incertitude doivent être traités comme le sommet le plus proche, ce qui signifie qu’elle est comptabilisée comme deux arêtes : les deux qui se joignent au vertex associé.</span><span class="sxs-lookup"><span data-stu-id="3f204-152">The clipped edges of the uncertainty region should be treated as the closest vertex, meaning that it counts as two edges: the two that join at the associated vertex.</span></span> <span data-ttu-id="3f204-153">Top-Left règle est nécessaire lorsque la région d’incertitude minimale est utilisée car si elle ne l’est pas, une implémentation de pixellisation conservatrice ne parviendrait pas à pixelliser les pixels qui pourraient être couverts lorsque le mode de pixellisation conservateur est désactivé.</span><span class="sxs-lookup"><span data-stu-id="3f204-153">Top-Left Rule is required when the minimum uncertainty region is used because if it is not, then a Conservative Rasterization implementation would fail to rasterize pixels that could be covered when Conservative Rasterization mode is disabled.</span></span>

<span data-ttu-id="3f204-154">Le diagramme suivant illustre une région d’incertitude externe valide produite en balayant un carré autour des bords de la primitive dans le domaine à virgule fixe (c’est-à-dire que les vertex ont été quantifiés par la représentation à virgule fixe 16,8).</span><span class="sxs-lookup"><span data-stu-id="3f204-154">The following diagram illustrates a valid outer uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="3f204-155">Les dimensions de ce carré sont basées sur la taille de la région d’incertitude externe valide : pour le 1/2 d’un pixel, le carré est de 1 pixel en largeur et en hauteur, pour 1/512 de pixel, le carré est 1/256 d’un pixel en largeur et en hauteur.</span><span class="sxs-lookup"><span data-stu-id="3f204-155">The dimensions of this square are based on the valid outer uncertainty region size: for the 1/2 of a pixel, the square is 1 pixel in width and height, for 1/512 of a pixel, the square is 1/256 of a pixel in width and height.</span></span> <span data-ttu-id="3f204-156">Le triangle vert représente une primitive donnée, la ligne en pointillés rouge représente la limite d’une pixellisation conservatrice surestimée, les carrés noirs pleins représentent le carré qui est balayé le long des arêtes primitives, et la zone de vérification bleue représente la région d’incertitude externe :</span><span class="sxs-lookup"><span data-stu-id="3f204-156">The green triangle represents a given primitive, the red dotted line represents the bound on Overestimated Conservative Rasterization, the solid black squares represent the square that is swept along the primitive edges, and the blue checkered area is the outer uncertainty region:</span></span>

![région d’incertitude externe.](images/outercoverage.jpg)

### <a name="multisampling-interaction"></a><span data-ttu-id="3f204-158">Interaction d’échantillonnage multiple</span><span class="sxs-lookup"><span data-stu-id="3f204-158">Multisampling interaction</span></span>

<span data-ttu-id="3f204-159">Quel que soit le nombre d’échantillons dans / les surfaces renderTarget **DepthStencil** (ou si *ForcedSampleCount* est utilisé ou non), tous les échantillons sont couverts par des pixels pixellisés par une pixellisation conservatrice.</span><span class="sxs-lookup"><span data-stu-id="3f204-159">Regardless of the number of samples in **RenderTarget**/**DepthStencil** surfaces (or whether *ForcedSampleCount* is being used or not), all samples are covered for pixels rasterized by Conservative Rasterization.</span></span> <span data-ttu-id="3f204-160">Les exemples d’emplacements individuels ne sont pas testés pour déterminer s’ils sont dans la primitive ou non.</span><span class="sxs-lookup"><span data-stu-id="3f204-160">Individual sample locations are not tested for whether they fall in the primitive or not.</span></span>

### <a name="samplemask-interaction"></a><span data-ttu-id="3f204-161">Interaction SampleMask</span><span class="sxs-lookup"><span data-stu-id="3f204-161">SampleMask interaction</span></span>

<span data-ttu-id="3f204-162">L’état du rastériseur *SampleMask* s’applique de la même façon que lorsque la pixellisation conservatrice n’est pas activée pour `InputCoverage` , mais n’affecte pas `InnerCoverage` (c’est-à-dire qu’elle n’est pas AND’ed dans une entrée déclarée avec `InnerCoverage` ).</span><span class="sxs-lookup"><span data-stu-id="3f204-162">The *SampleMask* Rasterizer State applies the same way as when Conservative Rasterization is not enabled for `InputCoverage`, but does not affect `InnerCoverage` (i.e. it is not AND’ed into an input declared with `InnerCoverage`).</span></span> <span data-ttu-id="3f204-163">Cela est dû `InnerCoverage` au fait que n’est pas lié au fait que les exemples MSAA sont masqués : 0 `InnerCoverage` signifie que le pixel n’est pas garanti être entièrement couvert, pas qu’aucun échantillon ne sera mis à jour.</span><span class="sxs-lookup"><span data-stu-id="3f204-163">This is because `InnerCoverage` is unrelated to whether MSAA samples are masked out: 0 `InnerCoverage` only means that the pixel is not guaranteed to be fully covered, not that no samples will be updated.</span></span>

### <a name="depthstencil-test-interaction"></a><span data-ttu-id="3f204-164">Interaction de test de profondeur/stencil</span><span class="sxs-lookup"><span data-stu-id="3f204-164">Depth/Stencil Test interaction</span></span>

<span data-ttu-id="3f204-165">Le test de profondeur/gabarit se poursuit par un pixel pixellisé de la même façon que si tous les échantillons sont couverts lorsque la pixellisation conservatrice n’est pas activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-165">Depth/Stencil Testing proceeds for a conservatively rasterized pixel the same way as if all samples are covered when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="3f204-166">La poursuite de tous les exemples couverts peut entraîner une extrapolation de profondeur, qui est valide et doit être ancrée dans la fenêtre d’affichage comme spécifié lorsque la pixellisation conservatrice n’est pas activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-166">Proceeding with all samples covered can cause Depth Extrapolation, which is valid and must be clamped to the viewport as specified when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="3f204-167">Cela est similaire au moment où les modes d’interpolation de fréquence en pixels sont utilisés sur un **renderTarget** avec un nombre d’échantillons supérieur à 1, bien que dans le cas d’une pixellisation conservatrice, il s’agit de la valeur de profondeur entrant dans le test de profondeur de fonction fixe qui peut être extrapolée.</span><span class="sxs-lookup"><span data-stu-id="3f204-167">This is similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1, although in the case of Conservative Rasterization, it is the depth value going into the fixed function depth test that can be extrapolated.</span></span>

<span data-ttu-id="3f204-168">Le comportement d’élimination des détails précoces avec l’extrapolation de profondeur n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="3f204-168">Early Depth culling behavior with Depth Extrapolation is undefined.</span></span> <span data-ttu-id="3f204-169">Cela est dû au fait que certains matériels de réforme de profondeur précoce ne peuvent pas prendre en charge correctement les valeurs de profondeur extrapolées.</span><span class="sxs-lookup"><span data-stu-id="3f204-169">This is because some Early Depth culling hardware cannot properly support extrapolated depth values.</span></span> <span data-ttu-id="3f204-170">Toutefois, le comportement de l’élimination précoce des détails en présence d’une extrapolation de profondeur est problématique même avec le matériel capable de prendre en charge des valeurs de profondeur extrapolées.</span><span class="sxs-lookup"><span data-stu-id="3f204-170">However, Early Depth culling behavior in the presence of Depth Extrapolation is problematic even with hardware that can support extrapolated depth values.</span></span> <span data-ttu-id="3f204-171">Ce problème peut être contourné en conservant la profondeur d’entrée de nuanceur de pixels aux valeurs de profondeur minimale et maximale de la primitive en cours de pixellisation et en écrivant cette valeur sur `oDepth` (registre de profondeur de sortie du nuanceur de pixels).</span><span class="sxs-lookup"><span data-stu-id="3f204-171">This issue can be worked around by clamping the Pixel Shader input depth to the min and max depth values of the primitive being rasterized and writing that value to `oDepth` (the pixel shader output depth register).</span></span> <span data-ttu-id="3f204-172">Les implémentations sont nécessaires pour désactiver l’élimination des détails précoces dans ce cas, en raison de l' `oDepth` écriture.</span><span class="sxs-lookup"><span data-stu-id="3f204-172">Implementations are required to disable Early Depth culling in this case, due to the `oDepth` write.</span></span>

### <a name="helper-pixel-interaction"></a><span data-ttu-id="3f204-173">Interaction des pixels d’assistance</span><span class="sxs-lookup"><span data-stu-id="3f204-173">Helper Pixel interaction</span></span>

<span data-ttu-id="3f204-174">Les règles de pixels d’assistance s’appliquent de la même façon que lorsque la pixellisation conservatrice n’est pas activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-174">Helper Pixel rules apply the same way as when Conservative Rasterization is not enabled.</span></span> <span data-ttu-id="3f204-175">Dans ce cas, tous les pixels, y compris les pixels d’assistance, doivent signaler `InputCoverage` correctement comme indiqué dans la `InputCoverage` section interaction.</span><span class="sxs-lookup"><span data-stu-id="3f204-175">As part of this, all pixels including Helper Pixels must report `InputCoverage` accurately as specified in the `InputCoverage` interaction section.</span></span> <span data-ttu-id="3f204-176">Par conséquent, les pixels entièrement non couverts sont couverts par le rapport 0.</span><span class="sxs-lookup"><span data-stu-id="3f204-176">So fully non-covered pixels report 0 coverage.</span></span>

### <a name="output-coverage-interaction"></a><span data-ttu-id="3f204-177">Interaction de couverture de sortie</span><span class="sxs-lookup"><span data-stu-id="3f204-177">Output Coverage interaction</span></span>

<span data-ttu-id="3f204-178">La couverture de sortie ( `oMask` ) se comporte pour un pixel pixellisé de manière conservatrice comme c’est le cas lorsque la pixellisation conservatrice n’est pas activée avec tous les exemples couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-178">Output Coverage (`oMask`) behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

### <a name="inputcoverage-interaction"></a><span data-ttu-id="3f204-179">Interaction InputCoverage</span><span class="sxs-lookup"><span data-stu-id="3f204-179">InputCoverage interaction</span></span>

<span data-ttu-id="3f204-180">En mode de pixellisation conservateur, ce registre d’entrée est rempli comme si tous les échantillons étaient couverts lorsque la pixellisation conservatrice n’est pas activée pour un pixel pixellisé de manière conservatrice.</span><span class="sxs-lookup"><span data-stu-id="3f204-180">In Conservative Rasterization mode, this input register is populated as if all samples are covered when Conservative Rasterization is not enabled for a given conservatively rasterized pixel.</span></span> <span data-ttu-id="3f204-181">Autrement dit, toutes les interactions existantes s’appliquent (par exemple, *SampleMask* est appliqué), et les n premiers bits dans `InputCoverage` à partir du LSB sont définis sur 1 pour un pixel pixellisé de manière conservatrice, à partir d’un échantillon n par pixel **renderTarget** et/ou de la mémoire tampon **DepthStencil** liée à la **fusion de sortie**, ou d’un exemple n *ForcedSampleCount*.</span><span class="sxs-lookup"><span data-stu-id="3f204-181">That is to say, all existing interactions apply (e.g. *SampleMask* is applied), and the first n bits in `InputCoverage` from the LSB are set to 1 for a conservatively rasterized pixel, given an n sample per pixel **RenderTarget** and/or **DepthStencil** buffer bound at the **Output Merger**, or an n sample *ForcedSampleCount*.</span></span> <span data-ttu-id="3f204-182">Le reste des bits est 0.</span><span class="sxs-lookup"><span data-stu-id="3f204-182">The rest of the bits are 0.</span></span>

<span data-ttu-id="3f204-183">Cette entrée est disponible dans un nuanceur, indépendamment de l’utilisation de la pixellisation conservatrice, bien que la pixellisation conservatrice modifie son comportement pour afficher uniquement tous les échantillons couverts (ou aucun pour les pixels d’assistance).</span><span class="sxs-lookup"><span data-stu-id="3f204-183">This input is available in a shader regardless of the use of Conservative Rasterization, though Conservative Rasterization changes its behavior to only show all samples covered (or none for Helper Pixels).</span></span>

### <a name="innercoverage-interaction"></a><span data-ttu-id="3f204-184">Interaction InnerCoverage</span><span class="sxs-lookup"><span data-stu-id="3f204-184">InnerCoverage interaction</span></span>

<span data-ttu-id="3f204-185">Cette fonctionnalité est requise par et uniquement disponible dans le niveau 3.</span><span class="sxs-lookup"><span data-stu-id="3f204-185">This feature is required by, and only available in, Tier 3.</span></span> <span data-ttu-id="3f204-186">Le runtime ne peut pas créer de nuanceur pour les nuanceurs qui utilisent ce mode lorsqu’une implémentation prend en charge un niveau inférieur au niveau 3.</span><span class="sxs-lookup"><span data-stu-id="3f204-186">The runtime will fail shader creation for shaders that use this mode when an implementation supports a Tier less than Tier 3.</span></span>

<span data-ttu-id="3f204-187">Le nuanceur de pixels a un système entier scalaire 32 bits générer une valeur disponible : `InnerCoverage` .</span><span class="sxs-lookup"><span data-stu-id="3f204-187">The Pixel Shader has a 32-bit scalar integer System Generate Value available: `InnerCoverage`.</span></span> <span data-ttu-id="3f204-188">Il s’agit d’un champ de bits dont le bit 0 de la LSB a la valeur 1 pour un pixel pixellisé de façon conservatrice, uniquement lorsque ce pixel est garanti être entièrement à l’intérieur de la primitive actuelle.</span><span class="sxs-lookup"><span data-stu-id="3f204-188">This is a bit-field that has bit 0 from the LSB set to 1 for a given conservatively rasterized pixel, only when that pixel is guaranteed to be entirely inside the current primitive.</span></span> <span data-ttu-id="3f204-189">Tous les autres bits de registre d’entrée doivent avoir la valeur 0 lorsque le bit 0 n’est pas défini, mais qu’ils ne sont pas définis lorsque le bit 0 a la valeur 1 (fondamentalement, ce champ de bits représente une valeur booléenne où false doit être exactement 0, mais true peut être n’importe quelle valeur non nulle).</span><span class="sxs-lookup"><span data-stu-id="3f204-189">All other input register bits must be set to 0 when bit 0 is not set, but are undefined when bit 0 is set to 1 (essentially, this bit-field represents a Boolean value where false must be exactly 0, but true can be any odd (i.e. bit 0 set) non-zero value).</span></span> <span data-ttu-id="3f204-190">Cette entrée est utilisée pour les informations de pixellisation conservatrice sous-estimées.</span><span class="sxs-lookup"><span data-stu-id="3f204-190">This input is used for underestimated Conservative Rasterization information.</span></span> <span data-ttu-id="3f204-191">Il informe le nuanceur de pixels si le pixel actuel se trouve entièrement à l’intérieur de la géométrie.</span><span class="sxs-lookup"><span data-stu-id="3f204-191">It informs the Pixel Shader whether the current pixel lies completely inside the geometry.</span></span>

<span data-ttu-id="3f204-192">Cela doit tenir compte de l’erreur d’alignement au niveau de la résolution supérieure ou égale à celle du dessin actuel.</span><span class="sxs-lookup"><span data-stu-id="3f204-192">This must account for snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating.</span></span> <span data-ttu-id="3f204-193">Il ne doit pas y avoir de faux positifs (en définissant `InnerCoverage` les bits lorsque le pixel n’est pas entièrement couvert par une erreur d’alignement au niveau de la résolution supérieure ou égale à la résolution à laquelle le dessin actuel fonctionne), mais les faux négatifs sont autorisés.</span><span class="sxs-lookup"><span data-stu-id="3f204-193">There must not be false positives (setting `InnerCoverage` bits when the pixel is not fully covered for any snapping error at resolutions greater than or equal to the resolution at which the current Draw is operating), but false negatives are allowed.</span></span> <span data-ttu-id="3f204-194">En résumé, l’implémentation ne doit pas identifier de manière incorrecte les pixels comme étant entièrement couverts, ce qui ne serait pas le cas des coordonnées de vertex à virgule flottante complètes dans le rastériseur.</span><span class="sxs-lookup"><span data-stu-id="3f204-194">In summary, the implementation must not incorrectly identify pixels as fully covered that would not be with full floating point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="3f204-195">Les pixels qui seraient entièrement couverts si le matériel utilisait des coordonnées de vertex à virgule flottante complètes ne peuvent être omis que s’ils croisent la région d’incertitude interne, qui ne doit pas être supérieure à la taille de la grille de sous-pixel, ou 1/256 d’un pixel, dans le domaine à virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="3f204-195">Pixels that would be fully covered if hardware was using full floating point vertex coordinates may only be omitted if they intersect the inner uncertainty region, which must be no larger than the size of the sub-pixel grid, or 1/256 of a pixel, in the fixed point domain.</span></span> <span data-ttu-id="3f204-196">Autrement dit, les pixels entièrement situés à l’intérieur de la limite interne de la région d’incertitude interne doivent être marqués comme étant entièrement couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-196">Said another way, pixels entirely within the inner boundary of the inner uncertainty region must be marked as fully covered.</span></span> <span data-ttu-id="3f204-197">La limite interne de la région d’incertitude est illustrée dans le diagramme ci-dessous par la ligne en pointillés noires en gras.</span><span class="sxs-lookup"><span data-stu-id="3f204-197">The inner boundary of the uncertainty region is illustrated in the diagram below by the bold black dotted line.</span></span> <span data-ttu-id="3f204-198">1/256 provient de la représentation de coordonnées de rastériseur à virgule fixe 16,8, qui peut changer si la précision du rastériseur change.</span><span class="sxs-lookup"><span data-stu-id="3f204-198">1/256 comes from the 16.8 fixed point Rasterizer coordinate representation, which can change if the Rasterizer precision changes.</span></span> <span data-ttu-id="3f204-199">Cette région d’incertitude est suffisante pour tenir compte de l’erreur d’alignement provoquée par la conversion de coordonnées de vertex à virgule flottante en coordonnées de vertex point fixe dans le rastériseur.</span><span class="sxs-lookup"><span data-stu-id="3f204-199">This uncertainty region is enough to account for snapping error caused by the conversion of floating point vertex coordinates to fixed point vertex coordinates in the Rasterizer.</span></span>

<span data-ttu-id="3f204-200">Les mêmes exigences de région d’incertitude minimale 1/512 définies dans l’interaction des règles de pixellisation s’appliquent également ici.</span><span class="sxs-lookup"><span data-stu-id="3f204-200">The same 1/512 minimum uncertainty region requirements defined in Rasterization Rules interaction apply here as well.</span></span>

<span data-ttu-id="3f204-201">Le diagramme suivant illustre une région d’incertitude interne valide produite en balayant un carré autour des bords de la primitive dans le domaine à virgule fixe (c’est-à-dire que les vertex ont été quantifiés par la représentation à virgule fixe 16,8).</span><span class="sxs-lookup"><span data-stu-id="3f204-201">The following diagram illustrates a valid inner uncertainty region produced by sweeping a square around the edges of the primitive in the fixed point domain (i.e. the vertices have been quantized by the 16.8 fixed point representation).</span></span> <span data-ttu-id="3f204-202">Les dimensions de ce carré sont basées sur la taille de la région d’incertitude interne valide : pour 1/256 d’un pixel, le carré est 1/128 d’un pixel en largeur et en hauteur.</span><span class="sxs-lookup"><span data-stu-id="3f204-202">The dimensions of this square are based on the valid inner uncertainty region size: for 1/256 of a pixel, the square is 1/128 of a pixel in width and height.</span></span> <span data-ttu-id="3f204-203">Le triangle vert représente une primitive donnée, la ligne en pointillés noires en gras représente la limite de la région d’incertitude interne, les carrés noirs pleins représentent le carré qui est balayé le long des arêtes primitives, et la zone de vérification orange est la région d’incertitude interne :</span><span class="sxs-lookup"><span data-stu-id="3f204-203">The green triangle represents a given primitive, the bold black dotted line represents the boundary of the inner uncertainty region, the solid black squares represent the square that is swept along the primitive edges, and the orange checkered area is the inner uncertainty region:</span></span>

![incertitude interne reqion.](images/innercoverage.jpg)

<span data-ttu-id="3f204-205">L’utilisation de `InnerCoverage` n’a pas d’incidence sur la pixellisation prudente d’un pixel, c’est-à-dire que l’utilisation de l’un de ces `InputCoverage` modes n’affecte pas les pixels pixellisés lorsque le mode de pixellisation conservateur est activé.</span><span class="sxs-lookup"><span data-stu-id="3f204-205">The use of `InnerCoverage` does not affect whether a pixel is conservatively rasterized, i.e. using one of these `InputCoverage` modes does not affect which pixels are rasterized when Conservative Rasterization mode is enabled.</span></span> <span data-ttu-id="3f204-206">Par conséquent, lorsque `InnerCoverage` est utilisé et que le nuanceur de pixels traite un pixel qui n’est pas entièrement couvert par la géométrie, sa valeur est 0, mais l’appel du nuanceur de pixels aura des exemples mis à jour.</span><span class="sxs-lookup"><span data-stu-id="3f204-206">Therefore, when `InnerCoverage` is used and the Pixel Shader is processing a pixel that is not completely covered by the geometry its value will be 0, but the Pixel Shader invocation will have samples updated.</span></span> <span data-ttu-id="3f204-207">Cela diffère de lorsque `InputCoverage` a la valeur 0, ce qui signifie qu’aucun échantillon ne sera mis à jour.</span><span class="sxs-lookup"><span data-stu-id="3f204-207">This is different from when `InputCoverage` is 0, meaning that no samples will be updated.</span></span>

<span data-ttu-id="3f204-208">Cette entrée s’exclut mutuellement avec `InputCoverage` : les deux ne peuvent pas être utilisés.</span><span class="sxs-lookup"><span data-stu-id="3f204-208">This input is mutually exclusive with `InputCoverage` : both cannot be used.</span></span>

<span data-ttu-id="3f204-209">Pour accéder à `InnerCoverage` , il doit être déclaré en tant que composant unique de l’un des registres d’entrée de nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="3f204-209">To access `InnerCoverage`, it must be declared as a single component out of one of the Pixel Shader input registers.</span></span> <span data-ttu-id="3f204-210">Le mode d’interpolation sur la déclaration doit être constant (l’interpolation ne s’applique pas).</span><span class="sxs-lookup"><span data-stu-id="3f204-210">The interpolation mode on the declaration must be constant (interpolation does not apply).</span></span>

<span data-ttu-id="3f204-211">Le `InnerCoverage` champ de bits n’est pas affecté par les tests de profondeur/stencil et n’est pas non plus liés avec l’état du rastériseur *SampleMask* .</span><span class="sxs-lookup"><span data-stu-id="3f204-211">The `InnerCoverage` bit-field is not affected by depth/stencil tests, nor is it ANDed with the *SampleMask* Rasterizer state.</span></span>

<span data-ttu-id="3f204-212">Cette entrée est valide uniquement en mode de pixellisation conservateur.</span><span class="sxs-lookup"><span data-stu-id="3f204-212">This input is only valid in Conservative Rasterization mode.</span></span> <span data-ttu-id="3f204-213">Lorsque la pixellisation conservatrice n’est pas activée, `InnerCoverage` produit une valeur non définie.</span><span class="sxs-lookup"><span data-stu-id="3f204-213">When Conservative Rasterization is not enabled, `InnerCoverage` produces an undefined value.</span></span>

<span data-ttu-id="3f204-214">Les appels de nuanceur de pixels provoqués par le besoin de pixels d’assistance, mais non couverts par la primitive, doivent avoir le `InnerCoverage` Registre défini sur 0.</span><span class="sxs-lookup"><span data-stu-id="3f204-214">Pixel Shader invocations caused by the need for Helper Pixels, but otherwise not covered by the primitive, must have the `InnerCoverage` register set to 0.</span></span>

### <a name="attribute-interpolation-interaction"></a><span data-ttu-id="3f204-215">Interaction d’interpolation d’attribut</span><span class="sxs-lookup"><span data-stu-id="3f204-215">Attribute Interpolation interaction</span></span>

<span data-ttu-id="3f204-216">Les modes d’interpolation d’attribut sont inchangés et se poursuivent de la même façon que lorsque la pixellisation conservatrice n’est pas activée, où les sommets de la fenêtre d’affichage et les vertex convertis à virgule fixe sont utilisés.</span><span class="sxs-lookup"><span data-stu-id="3f204-216">Attribute interpolation modes are unchanged and proceed the same way as when Conservative Rasterization is not enabled, where the viewport-scaled and fixed-point-converted vertices are used.</span></span> <span data-ttu-id="3f204-217">Étant donné que tous les échantillons dans un pixel pixellisé de manière conservatrice sont considérés comme couverts, il est valide pour les valeurs qui sont extrapolées, comme lorsque les modes d’interpolation de fréquence des pixels sont utilisés sur un **renderTarget** avec un nombre d’échantillons supérieur à 1.</span><span class="sxs-lookup"><span data-stu-id="3f204-217">Because all samples in a conservatively rasterized pixel are considered covered, it is valid for values to be extrapolated, similar to when pixel-frequency interpolation modes are used on a **RenderTarget** with sample count greater than 1.</span></span> <span data-ttu-id="3f204-218">Les modes d’interpolation de l’un de ces types produisent des résultats identiques au mode d’interpolation non-Centre de gravité correspondant. la notion de centre de gravité n’a pas de sens dans ce scénario, où la couverture de l’échantillon est uniquement complète ou 0.</span><span class="sxs-lookup"><span data-stu-id="3f204-218">Centroid interpolation modes produce results identical to the corresponding non-centroid interpolation mode; the notion of centroid is meaningless in this scenario – where sample coverage is only either full or 0.</span></span>

<span data-ttu-id="3f204-219">La pixellisation conservatrice permet de dégénérer des triangles pour produire des appels de nuanceur de pixels. par conséquent, les triangles dégénérées doivent utiliser les valeurs assignées au vertex 0 pour toutes les valeurs interpolées.</span><span class="sxs-lookup"><span data-stu-id="3f204-219">Conservative Rasterization allows for degenerate triangles to produce Pixel Shader invocations, therefore, degenerate triangles must use the values assigned to Vertex 0 for all interpolated values.</span></span>

### <a name="clipping-interaction"></a><span data-ttu-id="3f204-220">Interaction du découpage</span><span class="sxs-lookup"><span data-stu-id="3f204-220">Clipping interaction</span></span>

<span data-ttu-id="3f204-221">Lorsque le mode de pixellisation conservateur est activé et que le clip de profondeur est désactivé (lorsque l’état du rastériseur *DepthClipEnable* est défini sur false), il peut y avoir des variances dans l’interpolation d’attribut pour les segments d’une primitive qui se trouvent en dehors de la plage 0 <= z <= w, en fonction de l’implémentation : les valeurs constantes sont utilisées à partir d’un point où la primitive croise le plan approprié (proche ou loin), ou l’interpolation d’attribut se comporte comme lorsque le mode de pixellisation conservateur est désactivé</span><span class="sxs-lookup"><span data-stu-id="3f204-221">When Conservative Rasterization mode is enabled and depth clip is disabled (when the *DepthClipEnable* Rasterizer State is set to FALSE), there may be variances in attribute interpolation for segments of a primitive that fall outside the 0 <= z <= w range, depending on implementation: either constant values are used from a point where the primitive intersects the relevant plane (near or far), or attribute interpolation behaves as when Conservative Rasterization mode is disabled.</span></span> <span data-ttu-id="3f204-222">Toutefois, le comportement de la valeur de profondeur est le même quel que soit le mode de pixellisation conservateur, c’est-à-dire que les primitives qui se trouvent en dehors de la plage de profondeur doivent toujours recevoir la valeur de la limite la plus proche de la plage de profondeur de la fenêtre d’affichage.</span><span class="sxs-lookup"><span data-stu-id="3f204-222">However, the depth value behavior is the same regardless of Conservative Rasterization mode, i.e. primitives that fall outside of the depth range must still be given the value of the nearest limit of the viewport depth range.</span></span> <span data-ttu-id="3f204-223">Le comportement d’interpolation d’attribut à l’intérieur de la plage 0 <= z <= w doit rester inchangé.</span><span class="sxs-lookup"><span data-stu-id="3f204-223">Attribute interpolation behavior inside the 0 <= z <= w range must remain unchanged.</span></span>

### <a name="clip-distance-interaction"></a><span data-ttu-id="3f204-224">Interaction de la distance du clip</span><span class="sxs-lookup"><span data-stu-id="3f204-224">Clip Distance interaction</span></span>

<span data-ttu-id="3f204-225">La distance du clip est valide lorsque le mode de pixellisation conservateur est activé et qu’il se comporte pour un pixel pixellisé de manière conservatrice, comme c’est le cas lorsque la pixellisation conservatrice n’est pas activée avec tous les exemples couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-225">Clip Distance is valid when Conservative Rasterization mode is enabled, and behaves for a conservatively rasterized pixel as it does when Conservative Rasterization is not enabled with all samples covered.</span></span>

<span data-ttu-id="3f204-226">Notez que la pixellisation conservatrice peut entraîner l’extrapolation de la coordonnée de sommet W, ce qui peut entraîner une <= 0.</span><span class="sxs-lookup"><span data-stu-id="3f204-226">Note that Conservative Rasterization can cause extrapolation of the W vertex coordinate, which may cause W <= 0.</span></span> <span data-ttu-id="3f204-227">Cela peut entraîner des implémentations de distance par point par pixel sur une distance de découpage qui a été divisée par une valeur W non valide.</span><span class="sxs-lookup"><span data-stu-id="3f204-227">This could cause per-pixel Clip Distance implementations to operate on a Clip Distance that has been Perspective Divided by an invalid W value.</span></span> <span data-ttu-id="3f204-228">Les implémentations de distance de découpage doivent empêcher l’appel de la pixellisation pour les pixels où la coordonnée de vertex W <= 0 (par exemple, en raison de l’extrapolation en mode de pixellisation conservateur).</span><span class="sxs-lookup"><span data-stu-id="3f204-228">Clip Distance implementations must guard against invoking rasterization for pixels where vertex coordinate W <= 0 (e.g. due to extrapolation when in Conservative Rasterization mode).</span></span>

### <a name="target-independent-rasterization-interaction"></a><span data-ttu-id="3f204-229">Interaction de pixellisation indépendante cible</span><span class="sxs-lookup"><span data-stu-id="3f204-229">Target Independent Rasterization interaction</span></span>

<span data-ttu-id="3f204-230">Le mode de pixellisation conservateur est compatible avec le mode de rastérisation cible (TIR).</span><span class="sxs-lookup"><span data-stu-id="3f204-230">Conservative Rasterization mode is compatible with Target Independent Rasterization (TIR).</span></span> <span data-ttu-id="3f204-231">Les règles et restrictions TIR s’appliquent à un pixel pixellisé de manière conservatrice comme si tous les échantillons sont couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-231">TIR rules and restrictions apply, behaving for a conservatively rasterized pixel as if all samples are covered.</span></span>

### <a name="ia-primitive-topology-interaction"></a><span data-ttu-id="3f204-232">Interaction de la topologie de la primitive IA</span><span class="sxs-lookup"><span data-stu-id="3f204-232">IA Primitive Topology interaction</span></span>

<span data-ttu-id="3f204-233">La pixellisation conservatrice n’est pas définie pour les primitives de ligne ou de point.</span><span class="sxs-lookup"><span data-stu-id="3f204-233">Conservative Rasterization is not defined for line or point primitives.</span></span> <span data-ttu-id="3f204-234">Par conséquent, les topologies de primitive qui spécifient des points ou des lignes produisent un comportement indéfini s’ils sont acheminés vers l’unité de rastérisation lorsque la pixellisation conservatrice est activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-234">Therefore, Primitive Topologies that specify points or lines produce undefined behavior if they are fed to the rasterizer unit when Conservative Rasterization is enabled.</span></span>

<span data-ttu-id="3f204-235">La validation de la couche de débogage vérifie que les applications n’utilisent pas ces topologies de Primitives.</span><span class="sxs-lookup"><span data-stu-id="3f204-235">The debug layer validation verifies applications do not use these Primitive Topologies.</span></span>

### <a name="query-interaction"></a><span data-ttu-id="3f204-236">Interroger l’interaction</span><span class="sxs-lookup"><span data-stu-id="3f204-236">Query interaction</span></span>

<span data-ttu-id="3f204-237">Pour un pixel pixellisé de manière conservatrice, les requêtes se comportent comme elles le font quand la pixellisation conservatrice n’est pas activée lorsque tous les échantillons sont couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-237">For a conservatively rasterized pixel, queries behave as they do when Conservative Rasterization is not enabled when all samples are covered.</span></span> <span data-ttu-id="3f204-238">Par exemple, pour un pixel pixellisé, le \_ type de requête D3D12 \_ \_ occlusion et les \_ \_ \_ statistiques de pipeline \_ de type de requête D3D12 (à partir du [**\_ \_ type de requête D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) doivent se comporter comme lorsque la pixellisation conservatrice n’est pas activée lorsque tous les échantillons sont couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-238">For example, for a conservatively rasterized pixel, D3D12\_QUERY\_TYPE\_OCCLUSION and D3D12\_QUERY\_TYPE\_PIPELINE\_STATISTICS (from [**D3D12\_QUERY\_TYPE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_query_type)) must behave as they would when Conservative Rasterization is not enabled when all samples are covered.</span></span>

<span data-ttu-id="3f204-239">Les appels de nuanceur de pixels doivent être incrémentés pour chaque pixel pixellisé de manière conservatrice en mode de pixellisation conservateur.</span><span class="sxs-lookup"><span data-stu-id="3f204-239">Pixel Shader invocations should increment for every conservatively rasterized pixel in Conservative Rasterization mode.</span></span>

### <a name="cull-state-interaction"></a><span data-ttu-id="3f204-240">Élimination de l’interaction de l’État</span><span class="sxs-lookup"><span data-stu-id="3f204-240">Cull State interaction</span></span>

<span data-ttu-id="3f204-241">Tous les États de réforme sont valides en mode de pixellisation prudent et suivent les mêmes règles que lorsque la pixellisation conservatrice n’est pas activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-241">All Cull States are valid in Conservative Rasterization mode and follow the same rules as when Conservative Rasterization is not enabled.</span></span>

<span data-ttu-id="3f204-242">Lorsque vous comparez la pixellisation conservatrice entre les résolutions à elle-même ou si la pixellisation conservatrice n’est pas activée, il est possible que certaines primitives soient incompatibles (c’est-à-dire une face arrière, l’autre face avant).</span><span class="sxs-lookup"><span data-stu-id="3f204-242">When comparing Conservative Rasterization across resolutions to itself or without Conservative Rasterization enabled, there is the possibility that some primitives may have mismatched facedness (i.e. one back facing, the other front facing).</span></span> <span data-ttu-id="3f204-243">Les applications peuvent éviter cette incertitude en utilisant \_ \_ le mode \_ d’élimination D3D12 aucun ( [**\_ \_ en mode d’élimination D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) et sans utiliser la valeur générée par le `IsFrontFace` système.</span><span class="sxs-lookup"><span data-stu-id="3f204-243">Applications can avoid this uncertainty by using D3D12\_CULL\_MODE\_NONE (from [**D3D12\_CULL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_cull_mode)) and not using the `IsFrontFace` System Generated Value.</span></span>

### <a name="isfrontface-interaction"></a><span data-ttu-id="3f204-244">Interaction IsFrontFace</span><span class="sxs-lookup"><span data-stu-id="3f204-244">IsFrontFace interaction</span></span>

<span data-ttu-id="3f204-245">La `IsFrontFace` valeur générée par le système est valide pour une utilisation en mode de pixellisation prudent et suit le comportement défini lorsque la pixellisation conservatrice n’est pas activée.</span><span class="sxs-lookup"><span data-stu-id="3f204-245">The `IsFrontFace` System Generated Value is valid to use in Conservative Rasterization mode, and follows the behavior defined when Conservative Rasterization is not enabled.</span></span>

### <a name="fill-modes-interaction"></a><span data-ttu-id="3f204-246">Interaction des modes de remplissage</span><span class="sxs-lookup"><span data-stu-id="3f204-246">Fill Modes interaction</span></span>

<span data-ttu-id="3f204-247">Le seul [**mode de \_ remplissage \_ D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) valide pour la pixellisation conservatrice est D3D12 \_ Fill \_ Solid, tout autre mode de remplissage est un paramètre non valide pour l’état du rastériseur.</span><span class="sxs-lookup"><span data-stu-id="3f204-247">The only valid [**D3D12\_FILL\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_fill_mode) for Conservative Rasterization is D3D12\_FILL\_SOLID, any other fill mode is an invalid parameter for the Rasterizer State.</span></span>

<span data-ttu-id="3f204-248">Cela est dû au fait que la spécification fonctionnelle D3D12 spécifie que le mode de remplissage filaire doit convertir les bords de triangle en lignes et suivre les règles de pixellisation de ligne et le comportement de pixellisation de ligne conservateur n’a pas été défini.</span><span class="sxs-lookup"><span data-stu-id="3f204-248">This is because D3D12 functional specification specifies that wireframe fill mode should convert triangle edges to lines and follow the line rasterization rules and conservative line rasterization behavior has not been defined.</span></span>

## <a name="implementation-details"></a><span data-ttu-id="3f204-249">Informations d’implémentation</span><span class="sxs-lookup"><span data-stu-id="3f204-249">Implementation details</span></span>

<span data-ttu-id="3f204-250">Le type de pixellisation pris en charge dans Direct3D 12 est parfois appelé « pixellisation conservatrice préestimée ».</span><span class="sxs-lookup"><span data-stu-id="3f204-250">The type of rasterization supported in Direct3D 12 is sometimes referred to as "Overestimated Conservative Rasterization".</span></span> <span data-ttu-id="3f204-251">Il existe également le concept de « pixellisation conservatrice sous-estimée », ce qui signifie que seuls les pixels entièrement couverts par une primitive rendue sont pixellisés.</span><span class="sxs-lookup"><span data-stu-id="3f204-251">There is also the concept of "Underestimated Conservative Rasterization", which means that only pixels that are fully covered by a rendered primitive are rasterized.</span></span> <span data-ttu-id="3f204-252">Les informations de pixellisation conservatrice sous-estimée sont disponibles via le nuanceur de pixels par le biais de l’utilisation de données de couverture d’entrée, et seule une pixellisation conservatrice surestimée est disponible en mode de pixellisation.</span><span class="sxs-lookup"><span data-stu-id="3f204-252">Underestimated Conservative Rasterization information is available through the pixel shader through the use of input coverage data, and only overestimated Conservative Rasterization is available as a rasterizing mode.</span></span>

<span data-ttu-id="3f204-253">Si une partie d’une primitive chevauche un pixel, ce pixel est considéré comme couvert et est ensuite pixellisé.</span><span class="sxs-lookup"><span data-stu-id="3f204-253">If any part of a primitive overlaps a pixel, then that pixel is considered covered and is then rasterized.</span></span> <span data-ttu-id="3f204-254">Lorsqu’un bord ou un angle d’une primitive se trouve le long du bord ou de l’angle d’un pixel, l’application de la « règle de haut en bas » est spécifique à l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="3f204-254">When an edge or corner of a primitive falls along the edge or corner of a pixel, the application of the "top-left rule" is implementation-specific.</span></span> <span data-ttu-id="3f204-255">Toutefois, pour les implémentations qui prennent en charge les triangles dégénérées, un triangle dégenerate sur un bord ou un angle doit couvrir au moins un pixel.</span><span class="sxs-lookup"><span data-stu-id="3f204-255">However, for implementations that support degenerate triangles, a degenerate triangle along an edge or corner must cover at least one pixel.</span></span>

<span data-ttu-id="3f204-256">Les implémentations de pixellisation conservatrices peuvent varier sur un matériel différent et produisent des faux positifs, ce qui signifie qu’ils peuvent incorrectement décider que les pixels sont couverts.</span><span class="sxs-lookup"><span data-stu-id="3f204-256">Conservative Rasterization implementations can vary on different hardware, and do produce false positives, meaning that they can incorrectly decide that pixels are covered.</span></span> <span data-ttu-id="3f204-257">Cela peut être dû à des détails spécifiques à l’implémentation, tels que des erreurs de culture ou d’accrochage primitives inhérentes aux coordonnées de vertex à virgule fixe utilisées dans la pixellisation.</span><span class="sxs-lookup"><span data-stu-id="3f204-257">This can occur because of implementation-specific details like primitive growing or snapping errors inherent in the fixed-point vertex coordinates used in rasterization.</span></span> <span data-ttu-id="3f204-258">La raison pour laquelle les faux positifs (en ce qui concerne les coordonnées de vertex à virgule fixe) sont valides est parce qu’une certaine quantité de faux positifs sont nécessaires pour permettre à une implémentation d’effectuer une évaluation de la couverture sur des sommets postérieurs à l’alignement (c’est-à-dire des coordonnées de vertex qui ont été converties de la virgule flottante en virgule flottante de 16,8</span><span class="sxs-lookup"><span data-stu-id="3f204-258">The reason false positives (with respect to fixed point vertex coordinates) are valid is because some amount of false positives are needed to allow an implementation to do coverage evaluation against post-snapped vertices (i.e. vertex coordinates that have been converted from floating point to the 16.8 fixed-point used in the rasterizer), but honor the coverage produced by the original floating point vertex coordinates.</span></span>

<span data-ttu-id="3f204-259">Les implémentations de pixellisation conservatrice ne produisent pas de faux négatifs en ce qui concerne les coordonnées de vertex à virgule flottante pour les primitives postérieures à la dégénération : si une partie d’une primitive chevauche une partie d’un pixel, ce pixel est pixellisé.</span><span class="sxs-lookup"><span data-stu-id="3f204-259">Conservative Rasterization implementations do not produce false negatives with respect to the floating-point vertex coordinates for non-degenerate post-snap primitives: if any part of a primitive overlaps any part of a pixel, then that pixel is rasterized.</span></span>

<span data-ttu-id="3f204-260">Les triangles dégénérées (doublons d’index dans une mémoire tampon d’index ou colinéaire en 3D) ou dégénérées après la conversion à virgule fixe (vertex colinéaires dans le rastériseur) peuvent être éliminés ou non ; les deux sont des comportements valides.</span><span class="sxs-lookup"><span data-stu-id="3f204-260">Triangles that are degenerate (duplicate indices in an index buffer or collinear in 3D), or become degenerate after fixed-point conversion (collinear vertices in the rasterizer), may or may not be culled; both are valid behaviors.</span></span> <span data-ttu-id="3f204-261">Les triangles dégénérées doivent être considérés comme étant en arrière. ainsi, si un comportement spécifique est requis par une application, il peut utiliser l’élimination des faces arrière ou les tests pour les faces avant.</span><span class="sxs-lookup"><span data-stu-id="3f204-261">Degenerate triangles must be considered back facing, so if a specific behavior is required by an application, it can use back-face culling or test for front facing.</span></span> <span data-ttu-id="3f204-262">Les triangles dégénérées utilisent les valeurs affectées au vertex 0 pour toutes les valeurs interpolées.</span><span class="sxs-lookup"><span data-stu-id="3f204-262">Degenerate triangles use the values assigned to Vertex 0 for all interpolated values.</span></span>

<span data-ttu-id="3f204-263">Il existe trois niveaux de prise en charge matérielle, en plus de la possibilité que le matériel ne prenne pas en charge cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="3f204-263">There are three tiers of hardware support, in addition to the possibility that the hardware does not support this feature.</span></span>

-   <span data-ttu-id="3f204-264">Le niveau 1 applique une région d’incertitude maximale de 1/2 pixels et ne prend pas en charge les Dégénérations postérieures à l’accrochage.</span><span class="sxs-lookup"><span data-stu-id="3f204-264">Tier 1 enforces a maximum 1/2 pixel uncertainty region and does not support post-snap degenerates.</span></span> <span data-ttu-id="3f204-265">Cela est utile pour le rendu en mosaïque, un Atlas de textures, la génération de cartes de lumière et les mappages d’ombre sous-pixel.</span><span class="sxs-lookup"><span data-stu-id="3f204-265">This is good for tiled rendering, a texture atlas, light map generation and sub-pixel shadow maps.</span></span>
-   <span data-ttu-id="3f204-266">Le niveau 2 réduit la zone d’incertitude maximale à 1/256 et nécessite que les Dégénérations postérieures à l’accrochage ne soient pas éliminées.</span><span class="sxs-lookup"><span data-stu-id="3f204-266">Tier 2 reduces the maximum uncertainty region to 1/256 and requires post-snap degenerates not be culled.</span></span> <span data-ttu-id="3f204-267">Ce niveau est utile pour l’accélération de l’algorithme basé sur le processeur (par exemple, voxelization).</span><span class="sxs-lookup"><span data-stu-id="3f204-267">This tier is helpful for CPU-based algorithm acceleration (such as voxelization).</span></span>
-   <span data-ttu-id="3f204-268">Le niveau 3 conserve une région d’incertitude maximale de 1/256 et ajoute la prise en charge de la couverture d’entrée interne.</span><span class="sxs-lookup"><span data-stu-id="3f204-268">Tier 3 maintains a maximum 1/256 uncertainty region and adds support for inner input coverage.</span></span> <span data-ttu-id="3f204-269">La couverture d’entrée interne ajoute la nouvelle valeur `SV_InnerCoverage` au langage HLSL (High Level Shading Language).</span><span class="sxs-lookup"><span data-stu-id="3f204-269">Inner input coverage adds the new value `SV_InnerCoverage` to High Level Shading Language (HLSL).</span></span> <span data-ttu-id="3f204-270">Il s’agit d’un entier scalaire 32 bits qui peut être spécifié à l’entrée d’un nuanceur de pixels, et représente les informations de pixellisation conservatrice sous-estimées (autrement dit, si un pixel est garanti comme étant entièrement couvert).</span><span class="sxs-lookup"><span data-stu-id="3f204-270">This is a 32-bit scalar integer that can be specified on input to a pixel shader, and represents the underestimated Conservative Rasterization information (that is, whether a pixel is guaranteed-to-be-fully covered).</span></span> <span data-ttu-id="3f204-271">Ce niveau est utile pour l’élimination des occlusions.</span><span class="sxs-lookup"><span data-stu-id="3f204-271">This tier is helpful for occlusion culling.</span></span>

## <a name="api-summary"></a><span data-ttu-id="3f204-272">Résumé des API</span><span class="sxs-lookup"><span data-stu-id="3f204-272">API summary</span></span>

<span data-ttu-id="3f204-273">Les méthodes, structures, énumérations et classes d’assistance suivantes font référence à la pixellisation conservatrice :</span><span class="sxs-lookup"><span data-stu-id="3f204-273">The following methods, structures, enums, and helper classes reference Conservative Rasterization:</span></span>

-   <span data-ttu-id="3f204-274">[**D3D12 \_ RASTÉRISEUR \_ desc**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure contenant la description du rastériseur.</span><span class="sxs-lookup"><span data-stu-id="3f204-274">[**D3D12\_RASTERIZER\_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_rasterizer_desc) : structure holding the rasterizer description.</span></span>
-   <span data-ttu-id="3f204-275">[**D3D12 \_ \_ \_ Mode de pixellisation conservateur**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : valeurs enum pour le mode (on ou OFF).</span><span class="sxs-lookup"><span data-stu-id="3f204-275">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_MODE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_mode) : enum values for the mode (on or off).</span></span>
-   <span data-ttu-id="3f204-276">[**D3D12 \_ \_ \_ \_ Options D3D12 données**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) de la fonctionnalité : structure contenant le niveau de prise en charge.</span><span class="sxs-lookup"><span data-stu-id="3f204-276">[**D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options) : structure holding the tier of support.</span></span>
-   <span data-ttu-id="3f204-277">[**D3D12 \_ \_ \_ Niveau de pixellisation conservateur**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : valeurs d’énumération pour chaque niveau de prise en charge par le matériel.</span><span class="sxs-lookup"><span data-stu-id="3f204-277">[**D3D12\_CONSERVATIVE\_RASTERIZATION\_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_conservative_rasterization_tier) : enum values for each tier of support by the hardware.</span></span>
-   <span data-ttu-id="3f204-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : méthode permettant d’accéder aux fonctionnalités prises en charge.</span><span class="sxs-lookup"><span data-stu-id="3f204-278">[**CheckFeatureSupport**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) : method to access the supported features.</span></span>
-   <span data-ttu-id="3f204-279">[**CD3DX12 \_ RASTÉRISEUR \_ desc**](cd3dx12-rasterizer-desc.md) : classe d’assistance pour la création de descriptions de rastériseur.</span><span class="sxs-lookup"><span data-stu-id="3f204-279">[**CD3DX12\_RASTERIZER\_DESC**](cd3dx12-rasterizer-desc.md) : helper class for creating rasterizer descriptions.</span></span>

## <a name="related-topics"></a><span data-ttu-id="3f204-280">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="3f204-280">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="3f204-281">Didacticiels vidéo sur DirectX Advanced Learning : pixellisation conservatrice</span><span class="sxs-lookup"><span data-stu-id="3f204-281">DirectX advanced learning video tutorials : Conservative Rasterization</span></span>](https://www.youtube.com/watch?v=zL0oSY_YmDY)
</dt> <dt>

[<span data-ttu-id="3f204-282">Affichages ordonnés du rastériseur</span><span class="sxs-lookup"><span data-stu-id="3f204-282">Rasterizer Ordered Views</span></span>](rasterizer-order-views.md)
</dt> <dt>

[<span data-ttu-id="3f204-283">Rendu</span><span class="sxs-lookup"><span data-stu-id="3f204-283">Rendering</span></span>](rendering.md)
</dt> </dl>

 

 




