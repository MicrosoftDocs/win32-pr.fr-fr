---
title: Utilisation avancée des tables de descripteurs
description: Les sections suivantes fournissent des informations sur l’utilisation avancée des tables de descripteurs.
ms.assetid: BB0CA29C-65CB-48B1-8351-EE13CC470B54
ms.date: 05/31/2018
ms.localizationpriority: high
ms.topic: article
ms.openlocfilehash: 79dad6914cff07726c2d40ed2ee27cccb6a0cf1e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104984"
---
# <a name="advanced-use-of-descriptor-tables"></a><span data-ttu-id="7086e-103">Utilisation avancée des tables de descripteurs</span><span class="sxs-lookup"><span data-stu-id="7086e-103">Advanced use of Descriptor Tables</span></span>

<span data-ttu-id="7086e-104">Les sections suivantes fournissent des informations sur l’utilisation avancée des tables de descripteurs.</span><span class="sxs-lookup"><span data-stu-id="7086e-104">The following sections provide information about the advanced use of descriptor tables.</span></span>

-   [<span data-ttu-id="7086e-105">Modification des entrées de table de descripteurs entre les appels de rendu</span><span class="sxs-lookup"><span data-stu-id="7086e-105">Changing Descriptor Table Entries between Rendering Calls</span></span>](#changing-descriptor-table-entries-between-rendering-calls)
-   [<span data-ttu-id="7086e-106">Indexation hors limites</span><span class="sxs-lookup"><span data-stu-id="7086e-106">Out of Bounds Indexing</span></span>](#out-of-bounds-indexing)
-   [<span data-ttu-id="7086e-107">Dérivés du nuanceur et indexation divergente</span><span class="sxs-lookup"><span data-stu-id="7086e-107">Shader Derivatives and Divergent Indexing</span></span>](#shader-derivatives-and-divergent-indexing)
-   [<span data-ttu-id="7086e-108">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="7086e-108">Related topics</span></span>](#related-topics)

## <a name="changing-descriptor-table-entries-between-rendering-calls"></a><span data-ttu-id="7086e-109">Modification des entrées de table de descripteurs entre les appels de rendu</span><span class="sxs-lookup"><span data-stu-id="7086e-109">Changing Descriptor Table Entries between Rendering Calls</span></span>

<span data-ttu-id="7086e-110">Après que les commandes qui définissent les tables de descripteur ont été soumises à une file d’attente pour exécution, l’application ne doit pas modifier à partir du processeur les portions de tas de descripteur que le GPU peut référencer jusqu’à ce que l’application sache que le GPU a fini d’utiliser les références.</span><span class="sxs-lookup"><span data-stu-id="7086e-110">After command lists that set descriptor tables have been submitted to a queue for execution, the application must not edit from the CPU the portions of descriptor heaps that the GPU might reference until the application knows that the GPU has finished using the references.</span></span>

<span data-ttu-id="7086e-111">L’achèvement du travail peut être déterminé à l’aide d’une limite restreinte à l’aide de limites d’API pour le suivi de la progression du GPU, ou de mécanismes plus grossiistes comme l’attente de l’envoi d’un rendu à l’affichage, quelle que soit l’application.</span><span class="sxs-lookup"><span data-stu-id="7086e-111">Work completion can be determined at a tight bound using API fences for tracking GPU progress, or more coarse mechanisms like waiting to see that rendering has been sent to display - whatever suits the application.</span></span> <span data-ttu-id="7086e-112">Si une application sait que seul un sous-ensemble de la région vers lequel pointe une table de descripteur est accessible (par exemple, en raison du contrôle de Flow dans le nuanceur), les autres descripteurs non référencés sont toujours libres d’être modifiés.</span><span class="sxs-lookup"><span data-stu-id="7086e-112">If an application knows that only a subset of the region a descriptor table points to will be accessed (say due to flow control in the shader), the other unreferenced descriptors are still free to be changed.</span></span> <span data-ttu-id="7086e-113">Si une application doit basculer entre les différents tableaux de descripteurs entre les appels de rendu, il existe plusieurs approches possibles pour l’application :</span><span class="sxs-lookup"><span data-stu-id="7086e-113">If an application needs to switch between different descriptor tables between rendering calls, there are a few approaches the application can choose from:</span></span>

-   <span data-ttu-id="7086e-114">Contrôle de version des tables de descripteurs : créez (ou réutilisez) une table de descripteur distincte pour chaque collection unique de descripteurs qui doit être référencée par une liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="7086e-114">Descriptor Table Versioning: Create (or reuse) a separate descriptor table for every unique collection of descriptors that is to be referenced by a command list.</span></span> <span data-ttu-id="7086e-115">Lors de la modification et de la réutilisation de zones déjà remplies sur des tas de descripteurs, les applications doivent d’abord s’assurer que le GPU a fini d’utiliser une partie d’un tas de descripteur qui sera recyclé.</span><span class="sxs-lookup"><span data-stu-id="7086e-115">When editing and reusing previously populated areas on descriptor heaps, applications must first ensure that the GPU has finished using any portion of a descriptor heap that will be recycled.</span></span>
-   <span data-ttu-id="7086e-116">Indexation dynamique : les applications peuvent organiser les objets qui varient d’un dessin à l’autre (ou même faire varier dans un dessin) dans une plage d’un tas de descripteurs, définir une table de descripteurs qui couvre toutes les tables et, à partir du nuanceur, utiliser l’indexation dynamique de la table pendant l’exécution du nuanceur pour sélectionner l’objet à utiliser.</span><span class="sxs-lookup"><span data-stu-id="7086e-116">Dynamic Indexing: Applications can arrange objects that vary across draw/dispatch (or even vary within a draw) in a range of a descriptor heap, define a descriptor table that spans all of them, and from the shader, use dynamic indexing of the table during shader execution to select which object to use.</span></span>
-   <span data-ttu-id="7086e-117">Placer directement les descripteurs dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="7086e-117">Putting descriptors in the root signature directly.</span></span> <span data-ttu-id="7086e-118">Seul un très petit nombre de descripteurs peut être géré de cette manière, car l’espace de signature racine est limité.</span><span class="sxs-lookup"><span data-stu-id="7086e-118">Only a very small number of descriptors can be managed this way because root signature space is limited.</span></span>

<span data-ttu-id="7086e-119">L’implication de l’utilisation du contrôle de version de table de descripteurs est que la mémoire de descripteur d’un tas de descripteur doit être gravée pour chaque ensemble unique de descripteurs référencé par le pipeline Graphics pour chaque liste de commandes pouvant être exécutée, mise en file d’attente d’exécution ou enregistrée à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="7086e-119">The implication of using descriptor table versioning is that descriptor memory out of a descriptor heap must be burned through for every unique set of descriptors referenced by the graphics pipeline for every command list that could be either executing, queued for execution, or being recorded at any given time.</span></span>

<span data-ttu-id="7086e-120">D3D12 reste responsable de la gestion du contrôle de version de l’application pour les types d’objets gérés via les tas de descripteurs et les tables de descripteurs.</span><span class="sxs-lookup"><span data-stu-id="7086e-120">D3D12 leaves the responsibility of managing versioning to the application for the object types managed via descriptor heaps and descriptor tables.</span></span> <span data-ttu-id="7086e-121">L’un des avantages est que les applications peuvent choisir de réutiliser le contenu des tables de descripteurs autant que possible, plutôt que de toujours définir une nouvelle version de table de descripteur pour chaque soumission de liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="7086e-121">One benefit of this is that applications can choose to reuse descriptor table contents as much as possible rather than always defining a new descriptor table version for every command list submission.</span></span> <span data-ttu-id="7086e-122">La signature racine est un espace que le pilote D3D12 version automatique.</span><span class="sxs-lookup"><span data-stu-id="7086e-122">The root signature is a space that the D3D12 driver automatically versions.</span></span>

<span data-ttu-id="7086e-123">La possibilité de lier plusieurs tables de descripteurs à la signature racine (et par conséquent au pipeline) à la fois permet aux applications de regrouper et de changer des ensembles de références de descripteur à différentes fréquences, si vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="7086e-123">The ability to bind multiple descriptor tables to the root signature (and thus to the pipeline) at a time allows applications to group and switch sets of descriptor references at different frequencies if desired.</span></span> <span data-ttu-id="7086e-124">Par exemple, une application peut utiliser un petit nombre (peut-être un seul) de tables de descripteurs statiques volumineuses qui changent rarement, ou dans quelles régions de la mémoire du tas du descripteur sous-jacent sont remplies en fonction des besoins, avec l’utilisation de l’indexation dynamique du nuanceur pour sélectionner les textures.</span><span class="sxs-lookup"><span data-stu-id="7086e-124">For example, an application could use a small number (perhaps just one) of large static descriptor tables that rarely change, or in which regions in the underlying descriptor heap memory are being populated as needed, with the use of dynamic indexing from the shader to select textures.</span></span> <span data-ttu-id="7086e-125">En même temps, l’application peut conserver une autre classe de ressources où le jeu référencé par chaque appel de dessin est basculé de l’UC à l’aide de la technique de contrôle de version de table de descripteur.</span><span class="sxs-lookup"><span data-stu-id="7086e-125">At the same time, the application could maintain another class of resources where the set referenced by each draw call is switched from the CPU using the descriptor table versioning technique.</span></span>

## <a name="out-of-bounds-indexing"></a><span data-ttu-id="7086e-126">Indexation hors limites</span><span class="sxs-lookup"><span data-stu-id="7086e-126">Out of Bounds Indexing</span></span>

<span data-ttu-id="7086e-127">En dehors des limites, l’indexation d’une table de descripteur à partir du nuanceur entraîne un accès à la mémoire largement non défini, y compris la possibilité de lire une mémoire arbitraire dans le processus comme s’il s’agissait d’un descripteur d’état matériel et de vivre avec la conséquence de ce que le matériel utilise.</span><span class="sxs-lookup"><span data-stu-id="7086e-127">Out of bounds indexing of any descriptor table from the shader results in a largely undefined memory access, including the possibility of reading arbitrary in-process memory as if it is a hardware state descriptor and living with the consequence of what the hardware does with that.</span></span> <span data-ttu-id="7086e-128">Cela peut entraîner la réinitialisation de l’appareil, mais ne bloquera pas Windows.</span><span class="sxs-lookup"><span data-stu-id="7086e-128">This could produce a device reset, but will not crash Windows.</span></span>

## <a name="shader-derivatives-and-divergent-indexing"></a><span data-ttu-id="7086e-129">Dérivés du nuanceur et indexation divergente</span><span class="sxs-lookup"><span data-stu-id="7086e-129">Shader Derivatives and Divergent Indexing</span></span>

<span data-ttu-id="7086e-130">Si les appels de nuanceur de pixels qui s’exécutent dans un tampon 2x2 (pour prendre en charge les calculs dérivés), choisissez différents index de texture à échantillonner à partir d’une table de descripteur. et si la configuration et la texture de l’échantillonneur sélectionné pour un pixel donné nécessitent un calcul LOD à partir de dérivées de coordonnées de texture, le processus de calcul LOD et d’échantillonnage de texture est effectué par le matériel indépendamment pour chaque recherche de texture dans le tampon 2x2. , ce qui aura un impact sur les performances.</span><span class="sxs-lookup"><span data-stu-id="7086e-130">If pixel shader invocations that are executing in a 2x2 stamp (to support derivative calculations) choose different texture indices to sample from out of a descriptor table, and if the selected sampler configuration and texture for any given pixel requires an LOD calculation from texture coordinate derivatives, then the LOD calculation and texture sampling process is done by the hardware independently for each texture lookup in the 2x2 stamp, which will impact performance.</span></span>

## <a name="related-topics"></a><span data-ttu-id="7086e-131">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="7086e-131">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="7086e-132">Tables de descripteurs</span><span class="sxs-lookup"><span data-stu-id="7086e-132">Descriptor Tables</span></span>](descriptor-tables.md)
</dt> </dl>

 

 




