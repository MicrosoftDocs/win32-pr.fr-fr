---
title: Utilisation directe des descripteurs dans la signature racine
description: Pour éviter d’avoir à passer par un tas de descripteur, vous pouvez placer un descripteur directement dans la signature racine.
ms.assetid: 033E3D8F-3003-42F7-BF77-68A7D62802E5
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ff9d459f3195a4cf722ea210edbe63e5c1bf3cc8
ms.sourcegitcommit: 170bc12e9724d00cecbb96d57c7226c51e135dee
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 07/07/2021
ms.locfileid: "113489166"
---
# <a name="using-descriptors-directly-in-the-root-signature"></a><span data-ttu-id="5f655-103">Utilisation directe des descripteurs dans la signature racine</span><span class="sxs-lookup"><span data-stu-id="5f655-103">Using descriptors directly in the root signature</span></span>

<span data-ttu-id="5f655-104">Pour éviter d’avoir à passer par un tas de descripteur, vous pouvez placer un descripteur directement dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-104">To avoid the need to go through a descriptor heap, you can put a descriptor directly into the root signature.</span></span> <span data-ttu-id="5f655-105">Ces descripteurs occupent beaucoup d’espace dans la signature racine (voir [limites de signature racine](/windows/win32/direct3d12/root-signature-limits)). nous vous recommandons donc de les utiliser avec modération.</span><span class="sxs-lookup"><span data-stu-id="5f655-105">These descriptors take up a lot of space in the root signature (see [Root signature limits](/windows/win32/direct3d12/root-signature-limits)), so we recommend that you use them sparingly.</span></span>

<span data-ttu-id="5f655-106">Un exemple d’utilisation serait de placer dans la disposition racine une vue de mémoire tampon constante (CBV) qui est modifiée par dessin.</span><span class="sxs-lookup"><span data-stu-id="5f655-106">An example usage would be to place in the root layout a constant buffer view (CBV) that is changing per draw.</span></span> <span data-ttu-id="5f655-107">C’est pour cela que l’espace du tas du descripteur ne doit pas être alloué par l’application par dessin (et enregistre le pointage d’une table de descripteur au nouvel emplacement dans le tas du descripteur).</span><span class="sxs-lookup"><span data-stu-id="5f655-107">That's so that descriptor heap space doesn't have to be allocated by the application per draw (and saves pointing a descriptor table at the new location in the descriptor heap).</span></span> <span data-ttu-id="5f655-108">En plaçant un texte dans la signature racine, l’application confie simplement la responsabilité du contrôle de version au pilote ; mais c’est l’infrastructure que les pilotes possèdent déjà.</span><span class="sxs-lookup"><span data-stu-id="5f655-108">By putting something in the root signature, the application is merely handing the versioning responsibility to the driver; but that's infrastructure that drivers already have.</span></span>

<span data-ttu-id="5f655-109">Dans le cas d’un rendu qui utilise très peu de ressources, l’utilisation des tables ou des tas de descripteurs peut ne pas être nécessaire du tout si tous les descripteurs nécessaires peuvent être placés directement dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-109">For rendering that uses extremely few resources, descriptor table/heap use may not be needed at all if all of the needed descriptors can be placed directly in the root signature.</span></span>

<span data-ttu-id="5f655-110">Ce sont les seuls types de descripteurs pris en charge dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-110">These are the only types of descriptors supported in the root signature.</span></span>

- <span data-ttu-id="5f655-111">Vue de la mémoire tampon constante (CBVs).</span><span class="sxs-lookup"><span data-stu-id="5f655-111">Constant buffer view (CBVs).</span></span>
- <span data-ttu-id="5f655-112">Vues des ressources de nuanceur (SRVs)/vues d’accès non ordonnées (UAVs) des ressources de mémoire tampon où la conversion de format n’est pas requise (mémoires tampons non typées).</span><span class="sxs-lookup"><span data-stu-id="5f655-112">Shader resource views (SRVs) / unordered access views (UAVs) of buffer resources where format conversion is not required (untyped buffers).</span></span> <span data-ttu-id="5f655-113">Voici quelques exemples de mémoires tampons non typées qui peuvent être liées à des descripteurs racine : `StructuredBuffer<type>` , `RWStructuredBuffer<type>` `ByteAddressBuffer` et `RWByteAddressBuffer` .</span><span class="sxs-lookup"><span data-stu-id="5f655-113">Some examples of untyped buffers that can be bound with root descriptors include `StructuredBuffer<type>`, `RWStructuredBuffer<type>`, `ByteAddressBuffer` and `RWByteAddressBuffer`.</span></span> <span data-ttu-id="5f655-114">Les mémoires tampons typées telles que `Buffer<uint>` et `Buffer<float2>` ne peuvent pas.</span><span class="sxs-lookup"><span data-stu-id="5f655-114">Typed buffers such as `Buffer<uint>` and `Buffer<float2>` can't.</span></span>
- <span data-ttu-id="5f655-115">SRVs de structures d’accélération Raytracing, dans les signatures racines locales ou globales.</span><span class="sxs-lookup"><span data-stu-id="5f655-115">SRVs of raytracing acceleration structures, in local or global root signatures.</span></span> 

<span data-ttu-id="5f655-116">Un UAV dans la racine ne peut pas être associé à des compteurs.</span><span class="sxs-lookup"><span data-stu-id="5f655-116">A UAV in the root cannot have counters associated with it.</span></span> <span data-ttu-id="5f655-117">Les descripteurs dans la signature racine apparaissent chacun sous forme de descripteurs distincts, &mdash; mais ils ne peuvent pas être indexés de manière dynamique.</span><span class="sxs-lookup"><span data-stu-id="5f655-117">Descriptors in the root signature appear each as individual separate descriptors&mdash;they cannot be dynamically indexed.</span></span>

``` syntax
struct SceneData
{
   uint foo;
   float bar[2];
   int moo;
};
ConstantBuffer<SceneData> mySceneData : register(b6);
```

<span data-ttu-id="5f655-118">Dans l’exemple ci-dessus, `mySceneData` ne peut pas être déclaré en tant que tableau, comme dans `cbuffer mySceneData[2]` s’il va être mappé sur un descripteur dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-118">In the above example, `mySceneData` can't be declared as an array, as in `cbuffer mySceneData[2]` if it is going to be mapped onto a descriptor in the root signature.</span></span> <span data-ttu-id="5f655-119">Cela est dû au fait que l’indexation entre les descripteurs n’est pas prise en charge dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-119">That's because indexing across descriptors isn't supported in the root signature.</span></span> <span data-ttu-id="5f655-120">Si vous le souhaitez, vous pouvez définir des mémoires tampons de constante individuelles distinctes et les définir comme une entrée distincte dans la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-120">If desired, you can define separate individual constant buffers, and define them each as a separate entry in the root signature.</span></span> <span data-ttu-id="5f655-121">Notez que, dans le `mySceneData` cas ci-dessus, il existe un tableau `bar[2]` .</span><span class="sxs-lookup"><span data-stu-id="5f655-121">Note that within `mySceneData` above, there is an array `bar[2]`.</span></span> <span data-ttu-id="5f655-122">L’indexation dynamique au sein de la mémoire tampon constante est valide &mdash; un descripteur dans la signature racine se comporte de la même façon que le même descripteur se comporterait s’il était accessible via un tas de descripteur.</span><span class="sxs-lookup"><span data-stu-id="5f655-122">Dynamic indexing within the constant buffer is valid&mdash;a descriptor in the root signature behaves just like the same descriptor would behave if it were accessed through a descriptor heap.</span></span> <span data-ttu-id="5f655-123">Cela est contraire aux constantes d’incorporation directement dans la signature racine, qui apparaît également comme une mémoire tampon constante, sauf si la contrainte stipule que l’indexation dynamique au sein des constantes inline n’est pas autorisée `bar[2]` .</span><span class="sxs-lookup"><span data-stu-id="5f655-123">This is in contrast with inlining constants directly in the root signature, which also appears like a constant buffer, except with the constraint that dynamic indexing within the inlined constants is not permitted, so `bar[2]` wouldn't be allowed there.</span></span>

<span data-ttu-id="5f655-124">Ces API (à partir de l’interface [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist) ) servent à définir des descripteurs directement sur la signature racine.</span><span class="sxs-lookup"><span data-stu-id="5f655-124">These APIs (from the [**ID3D12GraphicsCommandList**](/windows/win32/api/d3d12/nn-d3d12-id3d12graphicscommandlist) interface) are for setting descriptors directly on the root signature.</span></span>

-   [<span data-ttu-id="5f655-125">**SetComputeRootConstantBufferView**</span><span class="sxs-lookup"><span data-stu-id="5f655-125">**SetComputeRootConstantBufferView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootconstantbufferview)
-   [<span data-ttu-id="5f655-126">**SetGraphicsRootConstantBufferView**</span><span class="sxs-lookup"><span data-stu-id="5f655-126">**SetGraphicsRootConstantBufferView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootconstantbufferview)
-   [<span data-ttu-id="5f655-127">**SetComputeRootShaderResourceView**</span><span class="sxs-lookup"><span data-stu-id="5f655-127">**SetComputeRootShaderResourceView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootshaderresourceview)
-   [<span data-ttu-id="5f655-128">**SetGraphicsRootShaderResourceView**</span><span class="sxs-lookup"><span data-stu-id="5f655-128">**SetGraphicsRootShaderResourceView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootshaderresourceview)
-   [<span data-ttu-id="5f655-129">**SetComputeRootUnorderedAccessView**</span><span class="sxs-lookup"><span data-stu-id="5f655-129">**SetComputeRootUnorderedAccessView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setcomputerootunorderedaccessview)
-   [<span data-ttu-id="5f655-130">**SetGraphicsRootUnorderedAccessView**</span><span class="sxs-lookup"><span data-stu-id="5f655-130">**SetGraphicsRootUnorderedAccessView**</span></span>](/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setgraphicsrootunorderedaccessview)

> [!NOTE]  
> <span data-ttu-id="5f655-131">Il n’existe aucun concept de *tableau de descripteurs racine* dans Direct3D 12.</span><span class="sxs-lookup"><span data-stu-id="5f655-131">There's no concept of a *root descriptor array* in Direct3D 12.</span></span> <span data-ttu-id="5f655-132">Les tableaux de descripteurs sont pris en charge uniquement dans les tas de descripteurs.</span><span class="sxs-lookup"><span data-stu-id="5f655-132">Descriptor arrays are supported only in descriptor heaps.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5f655-133">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="5f655-133">Related topics</span></span>

* [<span data-ttu-id="5f655-134">Signatures racines</span><span class="sxs-lookup"><span data-stu-id="5f655-134">Root signatures</span></span>](root-signatures.md)
