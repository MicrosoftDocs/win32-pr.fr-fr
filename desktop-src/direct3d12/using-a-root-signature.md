---
title: Utilisation d’une signature racine
description: La signature racine est la définition d’une collection de tables de descripteurs réorganisée arbitrairement (y compris leur disposition), de constantes racine et de descripteurs racine.
ms.assetid: 0131CDE4-02DB-440A-92B8-B0933C6414B0
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3babe26dc06d4f85ce3d6fb771e18c78b54a3701
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104045"
---
# <a name="using-a-root-signature"></a><span data-ttu-id="75ea5-103">Utilisation d’une signature racine</span><span class="sxs-lookup"><span data-stu-id="75ea5-103">Using a Root Signature</span></span>

<span data-ttu-id="75ea5-104">La signature racine est la définition d’une collection de tables de descripteurs réorganisée arbitrairement (y compris leur disposition), de constantes racine et de descripteurs racine.</span><span class="sxs-lookup"><span data-stu-id="75ea5-104">The root signature is the definition of an arbitrarily arranged collection of descriptor tables (including their layout), root constants and root descriptors.</span></span> <span data-ttu-id="75ea5-105">Chaque entrée a un coût pour une limite maximale. par conséquent, l’application peut effectuer un compromis entre le nombre de chaque type d’entrée que la signature racine contiendra.</span><span class="sxs-lookup"><span data-stu-id="75ea5-105">Each entry has a cost towards a maximum limit, so the application can trade off the balance between how many of each type of entry the root signature will contain.</span></span>

-   [<span data-ttu-id="75ea5-106">Sémantique de liste de commandes</span><span class="sxs-lookup"><span data-stu-id="75ea5-106">Command List Semantic</span></span>](#command-list-semantic)
-   [<span data-ttu-id="75ea5-107">Sémantique de Bundle</span><span class="sxs-lookup"><span data-stu-id="75ea5-107">Bundle Semantics</span></span>](#bundle-semantics)
-   [<span data-ttu-id="75ea5-108">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="75ea5-108">Related topics</span></span>](#related-topics)

<span data-ttu-id="75ea5-109">La signature racine est un objet qui peut être créé par une spécification manuelle au niveau de l’API.</span><span class="sxs-lookup"><span data-stu-id="75ea5-109">The root signature is an object that can be created by manual specification at the API.</span></span> <span data-ttu-id="75ea5-110">Tous les nuanceurs d’un PSO doivent être compatibles avec la disposition racine spécifiée avec l’PSO, sinon les nuanceurs individuels doivent inclure des dispositions de racine incorporées qui correspondent les unes aux autres. dans le cas contraire, la création d’PSO échouera.</span><span class="sxs-lookup"><span data-stu-id="75ea5-110">All shaders in a PSO must be compatible with the root layout specified with the PSO, or else the individual shaders must include embedded root layouts that match each other; otherwise, PSO creation will fail.</span></span> <span data-ttu-id="75ea5-111">L’une des propriétés de la signature racine est que les nuanceurs n’ont pas besoin de les connaître lors de leur création, bien que les signatures racines puissent également être créées directement dans les nuanceurs si vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="75ea5-111">One property of the root signature is that shaders don't have to know about it when authored, although root signatures can also be authored directly in shaders if desired.</span></span> <span data-ttu-id="75ea5-112">Les ressources de nuanceur existantes ne nécessitent aucune modification pour être compatibles avec les signatures racines.</span><span class="sxs-lookup"><span data-stu-id="75ea5-112">Existing shader assets do not require any changes to be compatible with root signatures.</span></span> <span data-ttu-id="75ea5-113">Le modèle de nuanceur 5,1 est introduit pour offrir une plus grande flexibilité (indexation dynamique des descripteurs dans les nuanceurs) et peut être adopté de manière incrémentielle à partir des ressources de nuanceur existantes, comme vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="75ea5-113">Shader Model 5.1 is introduced to provide some extra flexibility (dynamic indexing of descriptors from within shaders), and can be incrementally adopted starting from existing shader assets as desired.</span></span>

## <a name="command-list-semantic"></a><span data-ttu-id="75ea5-114">Sémantique de liste de commandes</span><span class="sxs-lookup"><span data-stu-id="75ea5-114">Command List Semantic</span></span>

<span data-ttu-id="75ea5-115">Au début d’une liste de commandes, la signature racine n’est pas définie.</span><span class="sxs-lookup"><span data-stu-id="75ea5-115">At the beginning of a command list, the root signature is undefined.</span></span> <span data-ttu-id="75ea5-116">Les nuanceurs graphiques ont une signature racine distincte du nuanceur de calcul, chacun étant affecté indépendamment à une liste de commandes.</span><span class="sxs-lookup"><span data-stu-id="75ea5-116">Graphics shaders have a separate root signature from the compute shader, each independently assigned on a command list.</span></span> <span data-ttu-id="75ea5-117">La signature racine définie sur une liste de commandes ou un bundle doit également correspondre au PSO actuellement défini au niveau du dessin/Dispatch ; dans le cas contraire, le comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="75ea5-117">The root signature set on a command list or bundle must also match the currently set PSO at Draw/Dispatch; otherwise, the behavior is undefined.</span></span> <span data-ttu-id="75ea5-118">Les incompatibilités de signature racine temporaires avant le dessin/dispatch sont correctes, par exemple la définition d’un PSO incompatible avant le basculement vers une signature racine compatible (à condition qu’elles soient compatibles avec l’appel de la méthode Draw/Dispatch).</span><span class="sxs-lookup"><span data-stu-id="75ea5-118">Transient root signature mismatches before Draw/Dispatch are fine - such as setting an incompatible PSO before switching to a compatible root signature (as long as these are compatible by the time Draw/Dispatch is called).</span></span> <span data-ttu-id="75ea5-119">La définition d’un PSO ne modifie pas la signature racine.</span><span class="sxs-lookup"><span data-stu-id="75ea5-119">Setting a PSO does not change the root signature.</span></span> <span data-ttu-id="75ea5-120">L’application doit appeler une API dédiée pour définir la signature racine.</span><span class="sxs-lookup"><span data-stu-id="75ea5-120">The application must call a dedicated API for setting the root signature.</span></span>

<span data-ttu-id="75ea5-121">Une fois qu’une signature racine a été définie sur une liste de commandes, la disposition définit l’ensemble des liaisons que l’application est censée fournir et les objets psoables qui peuvent être utilisés (ceux qui sont compilés avec la même disposition) pour les appels de dessin/distribution suivants.</span><span class="sxs-lookup"><span data-stu-id="75ea5-121">Once a root signature has been set on a command list, the layout defines the set of bindings that the application is expected to provide, and which PSOs can be used (those compiled with the same layout) for the next draw/dispatch calls.</span></span> <span data-ttu-id="75ea5-122">Par exemple, une signature racine peut être définie par l’application pour avoir les entrées suivantes.</span><span class="sxs-lookup"><span data-stu-id="75ea5-122">For example, a root signature could be defined by the application to have the following entries.</span></span> <span data-ttu-id="75ea5-123">Chaque entrée est appelée « emplacement ».</span><span class="sxs-lookup"><span data-stu-id="75ea5-123">Each entry is referred to as a "slot".</span></span>

-   <span data-ttu-id="75ea5-124">\[0 un descripteur \] CBV en ligne (descripteurs racine)</span><span class="sxs-lookup"><span data-stu-id="75ea5-124">\[0\] A CBV descriptor inline (root descriptors)</span></span>
-   <span data-ttu-id="75ea5-125">\[1 \] table de descripteur contenant 2 SRVs, 1 CBVS et 1 UAV</span><span class="sxs-lookup"><span data-stu-id="75ea5-125">\[1\] A descriptor table containing 2 SRVs, 1 CBVs, and 1 UAV</span></span>
-   <span data-ttu-id="75ea5-126">\[2 \] table de descripteur contenant 1 échantillonneur</span><span class="sxs-lookup"><span data-stu-id="75ea5-126">\[2\] A descriptor table containing 1 sampler</span></span>
-   <span data-ttu-id="75ea5-127">\[3 \] une collection 4x32 bits de constantes racine</span><span class="sxs-lookup"><span data-stu-id="75ea5-127">\[3\] A 4x32-bit collection of root constants</span></span>
-   <span data-ttu-id="75ea5-128">\[4 \] une table de descripteur contenant un nombre non spécifié de SRVs</span><span class="sxs-lookup"><span data-stu-id="75ea5-128">\[4\] A descriptor table containing an unspecified number of SRVs</span></span>

<span data-ttu-id="75ea5-129">Dans ce cas, avant de pouvoir émettre un dessin/Dispatch, l’application est censée définir la liaison appropriée à chacun des emplacements \[ 0.. 4 \] que l’application a définie avec sa signature racine actuelle.</span><span class="sxs-lookup"><span data-stu-id="75ea5-129">In this case, before being able to issue a Draw/Dispatch, the application is expected to set the appropriate binding to each of the slots \[0..4\] that the application defined with its current root signature.</span></span> <span data-ttu-id="75ea5-130">Par exemple, à \[ l’emplacement 1 \] , une table de descripteur doit être liée, qui est une région contiguë dans un tas de descripteur qui contient (ou contiendra au moment de l’exécution) 2 SRVs, 1 CBVS et 1 UAV.</span><span class="sxs-lookup"><span data-stu-id="75ea5-130">For instance, at slot \[1\], a descriptor table must be bound, which is a contiguous region in a descriptor heap that contains (or will contain at execution) 2 SRVs, 1 CBVs, and 1 UAV.</span></span> <span data-ttu-id="75ea5-131">De même, les tables de descripteurs doivent être définies aux emplacements \[ 2 \] et \[ 4 \] .</span><span class="sxs-lookup"><span data-stu-id="75ea5-131">Similarly, descriptor tables must be set at slots \[2\] and \[4\].</span></span>

<span data-ttu-id="75ea5-132">L’application peut modifier une partie des liaisons de signature racine à la fois (le reste reste inchangé).</span><span class="sxs-lookup"><span data-stu-id="75ea5-132">The application can change part of the root signature bindings at a time (the rest remain unchanged).</span></span> <span data-ttu-id="75ea5-133">Par exemple, si la seule chose qui doit être modifiée entre draws est l’une des constantes à l’emplacement \[ 2 \] , c’est que toutes les applications doivent se relier.</span><span class="sxs-lookup"><span data-stu-id="75ea5-133">For example, if the only thing that needs to change between draws is one of the constants at slot \[2\], that is all the application needs to rebind.</span></span> <span data-ttu-id="75ea5-134">Comme nous l’avons vu précédemment, les versions de pilote/matériel de tous les États de liaison de signature racine sont modifiées automatiquement.</span><span class="sxs-lookup"><span data-stu-id="75ea5-134">As discussed previously, the driver/hardware versions all root signature bind state as it is modified automatically.</span></span> <span data-ttu-id="75ea5-135">Si une signature racine est modifiée sur une liste de commandes, toutes les liaisons de signature racine précédentes deviennent obsolètes et toutes les liaisons qui viennent d’être attendues doivent être définies avant le dessin/Dispatch ; dans le cas contraire, le comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="75ea5-135">If a root signature is changed on a command list, all previous root signature bindings become stale and all newly expected bindings must be set before Draw/Dispatch; otherwise, the behavior is undefined.</span></span> <span data-ttu-id="75ea5-136">Si la signature racine est définie de façon redondante sur la même que celle actuellement définie, les liaisons de signature racine existantes ne deviennent pas obsolètes.</span><span class="sxs-lookup"><span data-stu-id="75ea5-136">If the root signature is redundantly set to the same one currently set, existing root signature bindings do not become stale.</span></span>

## <a name="bundle-semantics"></a><span data-ttu-id="75ea5-137">Sémantique de Bundle</span><span class="sxs-lookup"><span data-stu-id="75ea5-137">Bundle Semantics</span></span>

<span data-ttu-id="75ea5-138">Les offres groupées héritent des liaisons de signature racine de la liste de commandes (liaisons aux différents emplacements dans l’exemple de liste de commandes ci-dessus).</span><span class="sxs-lookup"><span data-stu-id="75ea5-138">Bundles inherit the command list's root signature bindings (the bindings to the various slots in the Command List example above).</span></span> <span data-ttu-id="75ea5-139">Si un bundle doit modifier certaines des liaisons de signature racine héritées, il doit d’abord définir la signature racine de manière à ce qu’elle soit identique à la liste de commandes appelante (les liaisons héritées ne deviennent pas obsolètes).</span><span class="sxs-lookup"><span data-stu-id="75ea5-139">If a bundle needs to change some of the inherited root signature bindings, it must first set the root signature to be the same as the calling command list (the inherited bindings do not become stale).</span></span> <span data-ttu-id="75ea5-140">Si le bundle définit la signature racine sur une autre valeur que la liste de commandes appelante, qui a le même effet que la modification de la signature racine sur la liste de commandes décrite ci-dessus : toutes les liaisons de signature racine précédentes sont obsolètes et les liaisons nouvellement attendues doivent être définies avant le dessin/Dispatch ; dans le cas contraire, le comportement n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="75ea5-140">If the bundle sets the root signature to be different than the calling command list, that has the same effect as changing the root signature on the command list described above: all previous root signature bindings are stale and newly expected bindings must be set before Draw/Dispatch; otherwise, the behavior is undefined.</span></span> <span data-ttu-id="75ea5-141">Si un bundle n’a pas besoin de modifier des liaisons de signature racine, il n’a pas besoin de définir la signature racine.</span><span class="sxs-lookup"><span data-stu-id="75ea5-141">If a bundle does not need to change any root signature bindings, it does not need to set the root signature.</span></span>

<span data-ttu-id="75ea5-142">Le code suivant montre un exemple de déroulement d’appel dans un bundle.</span><span class="sxs-lookup"><span data-stu-id="75ea5-142">The following code shows an example call flow into a bundle.</span></span>

``` syntax
// Command List
...
pCmdList->SetGraphicsRootSignature(pRootSig); // new parameter space
MyEngine_SetTextures(); // bundle inherits descriptor table setting
MyEngine_SetAnimationFactor(fTime); // bundle inherits root constant
pCmdList->ExecuteBundle(...);
...
// Bundle
pBundle->SetGraphicsRootSignature(pRootSig); // same as caller, in order to inherits bindings
pBundle->SetPipelineState(pPS); 
pBundle->SetGraphicsRoot32BitConstant(drawConstantsSlot,0,drawIDOffset);
pBundle->Draw(...); // using inherited textures / animation factor
pBundle->SetGraphicsRoot32BitConstant(drawConstantsSlot,1,drawIDOffset);
pBundle->Draw(...);
...
```

<span data-ttu-id="75ea5-143">À partir d’un bundle, les modifications de disposition racine et/ou les modifications de liaison apportées par un bundle sont héritées de la liste de commandes appelante à la fin de l’exécution d’un bundle.</span><span class="sxs-lookup"><span data-stu-id="75ea5-143">Coming out of a bundle, any root layout changes and/or binding changes a bundle makes are inherited back to the calling command list when a bundle finishes executing.</span></span>

<span data-ttu-id="75ea5-144">Pour plus d’informations sur l’héritage, reportez-vous à la section héritage de l' **État du pipeline Graphics** de gestion de l' [État des pipelines graphiques dans Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span><span class="sxs-lookup"><span data-stu-id="75ea5-144">For more information on inheritance, refer to the **Graphics pipeline state inheritance** section of [Managing Graphics Pipeline State in Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="75ea5-145">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="75ea5-145">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="75ea5-146">Signatures racines</span><span class="sxs-lookup"><span data-stu-id="75ea5-146">Root Signatures</span></span>](root-signatures.md)
</dt> </dl>

 

 




