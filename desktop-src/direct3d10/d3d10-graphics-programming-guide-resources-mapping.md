---
description: Copie et accès aux données de ressource (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Copie et accès aux données de ressource (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 38bd075585ee3123e163075a50b06b53a77a214c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748517"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a><span data-ttu-id="29e65-103">Copie et accès aux données de ressource (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="29e65-103">Copying and Accessing Resource Data (Direct3D 10)</span></span>

<span data-ttu-id="29e65-104">Il n’est plus nécessaire de réfléchir aux ressources créées dans la mémoire vidéo ou la mémoire système.</span><span class="sxs-lookup"><span data-stu-id="29e65-104">It is no longer necessary to think about resources as being created in either video memory or system memory.</span></span> <span data-ttu-id="29e65-105">Ou si le runtime doit gérer la mémoire.</span><span class="sxs-lookup"><span data-stu-id="29e65-105">Or whether or not the runtime should manage the memory.</span></span> <span data-ttu-id="29e65-106">Grâce à l’architecture du nouveau WDDM (Windows Display Driver Model), les applications créent désormais des ressources Direct3D 10 avec différents indicateurs d' [**utilisation**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) pour indiquer comment l’application envisage d’utiliser les données de ressource.</span><span class="sxs-lookup"><span data-stu-id="29e65-106">Thanks to the architecture of the new WDDM (Windows Display Driver Model), applications now create Direct3D 10 resources with different [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) flags to indicate how the application intends on using the resource data.</span></span> <span data-ttu-id="29e65-107">Le nouveau modèle de pilote virtualise la mémoire utilisée par les ressources ; il devient alors le responsable du système d’exploitation/du pilote/de la mémoire de placer les ressources dans la zone de mémoire la plus performante possible en raison de l’utilisation prévue.</span><span class="sxs-lookup"><span data-stu-id="29e65-107">The new driver model virtualizes the memory used by resources; it then becomes the responsibility of the operating system/driver/memory manager to place resources in the most performant area of memory possible given the expected usage.</span></span>

<span data-ttu-id="29e65-108">Le cas par défaut est que les ressources sont disponibles pour le GPU.</span><span class="sxs-lookup"><span data-stu-id="29e65-108">The default case is for resources to be available to the GPU.</span></span> <span data-ttu-id="29e65-109">Bien entendu, il y a des cas où les données de ressources doivent être disponibles pour le processeur.</span><span class="sxs-lookup"><span data-stu-id="29e65-109">Of course, having said that, there are times when the resource data needs to be available to the CPU.</span></span> <span data-ttu-id="29e65-110">La copie de données de ressources pour que le processeur approprié puisse y accéder sans impact sur les performances nécessite une connaissance du fonctionnement des méthodes de l’API.</span><span class="sxs-lookup"><span data-stu-id="29e65-110">Copying resource data around so that the appropriate processor can access it without impacting performance requires some knowledge of how the API methods work.</span></span>

-   [<span data-ttu-id="29e65-111">Copie de données de ressource</span><span class="sxs-lookup"><span data-stu-id="29e65-111">Copying Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)
-   [<span data-ttu-id="29e65-112">Accès aux données de ressources</span><span class="sxs-lookup"><span data-stu-id="29e65-112">Accessing Resource Data</span></span>](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a><span data-ttu-id="29e65-113">Copie de données de ressource</span><span class="sxs-lookup"><span data-stu-id="29e65-113">Copying Resource Data</span></span>

<span data-ttu-id="29e65-114">Les ressources sont créées en mémoire lorsque Direct3D exécute un appel de création.</span><span class="sxs-lookup"><span data-stu-id="29e65-114">Resources are created in memory when Direct3D executes a Create call.</span></span> <span data-ttu-id="29e65-115">Ils peuvent être créés dans la mémoire vidéo, la mémoire système ou tout autre type de mémoire.</span><span class="sxs-lookup"><span data-stu-id="29e65-115">They can be created in video memory, system memory, or any other kind of memory.</span></span> <span data-ttu-id="29e65-116">Étant donné que le modèle de pilote WDDM virtualise cette mémoire, les applications n’ont plus besoin d’effectuer le suivi des types de ressources mémoire qui sont créés dans.</span><span class="sxs-lookup"><span data-stu-id="29e65-116">Since WDDM driver model virtualizes this memory, applications no longer need to keep track of what kind of memory resources are created in.</span></span>

<span data-ttu-id="29e65-117">Idéalement, toutes les ressources seraient situées dans la mémoire vidéo afin que le GPU puisse y accéder immédiatement.</span><span class="sxs-lookup"><span data-stu-id="29e65-117">Ideally, all resources would be located in video memory so that the GPU can have immediate access to them.</span></span> <span data-ttu-id="29e65-118">Toutefois, il est parfois nécessaire que le processeur lise les données de ressources ou que le GPU accède aux données de ressources sur lesquelles le processeur a écrit.</span><span class="sxs-lookup"><span data-stu-id="29e65-118">However, it is sometimes necessary for the CPU to read the resource data or for the GPU to access resource data the CPU has written to.</span></span> <span data-ttu-id="29e65-119">Direct3D 10 gère ces différents scénarios en demandant à l’application de spécifier une utilisation, puis propose plusieurs méthodes pour copier les données de ressource si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="29e65-119">Direct3D 10 handles these different scenarios by requesting the application specify a usage, and then offers several methods for copying resource data when necessary.</span></span>

<span data-ttu-id="29e65-120">Selon la façon dont la ressource a été créée, il n’est pas toujours possible d’accéder directement aux données sous-jacentes.</span><span class="sxs-lookup"><span data-stu-id="29e65-120">Depending on how the resource was created, it is not always possible to directly access the underlying data.</span></span> <span data-ttu-id="29e65-121">Cela peut signifier que les données de ressources doivent être copiées de la ressource source vers une autre ressource accessible par le processeur approprié.</span><span class="sxs-lookup"><span data-stu-id="29e65-121">This may mean that the resource data must be copied from the source resource to another resource that is accessible by the appropriate processor.</span></span> <span data-ttu-id="29e65-122">En termes de Direct3D 10, les ressources par défaut sont accessibles directement par le GPU, les ressources dynamiques et intermédiaires peuvent être directement accessibles par le processeur.</span><span class="sxs-lookup"><span data-stu-id="29e65-122">In terms of Direct3D 10, default resources can be accessed directly by the GPU, dynamic and staging resources can be directly accessed by the CPU.</span></span>

<span data-ttu-id="29e65-123">Une fois qu’une ressource a été créée, son [**utilisation**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) ne peut pas être modifiée.</span><span class="sxs-lookup"><span data-stu-id="29e65-123">Once a resource has been created, its [**usage**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) cannot be changed.</span></span> <span data-ttu-id="29e65-124">Au lieu de cela, copiez le contenu d’une ressource dans une autre ressource créée avec une utilisation différente.</span><span class="sxs-lookup"><span data-stu-id="29e65-124">Instead, copy the contents of one resource to another resource that was created with a different usage.</span></span> <span data-ttu-id="29e65-125">Direct3D 10 fournit cette fonctionnalité avec trois méthodes différentes.</span><span class="sxs-lookup"><span data-stu-id="29e65-125">Direct3D 10 provides this functionality with three different methods.</span></span> <span data-ttu-id="29e65-126">Les deux premières méthodes ( [**ID3D10Device :: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) et [**ID3D10Device :: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) sont conçues pour copier les données de ressources d’une ressource vers une autre.</span><span class="sxs-lookup"><span data-stu-id="29e65-126">The first two methods( [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) are designed to copy resource data from one resource to another.</span></span> <span data-ttu-id="29e65-127">La troisième méthode ([**ID3D10Device :: UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) est conçue pour copier des données de la mémoire vers une ressource.</span><span class="sxs-lookup"><span data-stu-id="29e65-127">The third method ([**ID3D10Device::UpdateSubresource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) is designed to copy data from memory to a resource.</span></span>

<span data-ttu-id="29e65-128">Il existe deux types de ressources principaux : mappables et non mappables.</span><span class="sxs-lookup"><span data-stu-id="29e65-128">There are two main kinds of resources: mappable and non-mappable.</span></span> <span data-ttu-id="29e65-129">Les ressources créées avec des utilisations dynamiques ou intermédiaires sont mappées, alors que les ressources créées avec des utilisations par défaut ou immuables ne peuvent pas être mappées.</span><span class="sxs-lookup"><span data-stu-id="29e65-129">Resources created with dynamic or staging usages are mappable, while resources created with default or immutable usages are non-mappable.</span></span>

<span data-ttu-id="29e65-130">La copie de données entre des ressources non mappables est très rapide, car il s’agit du cas le plus courant et a été optimisé pour s’exécuter correctement.</span><span class="sxs-lookup"><span data-stu-id="29e65-130">Copying data among non-mappable resources is very fast because this is the most common case and has been optimized to perform well.</span></span> <span data-ttu-id="29e65-131">Étant donné que ces ressources ne sont pas directement accessibles par le processeur, elles sont optimisées afin que le GPU puisse les manipuler rapidement.</span><span class="sxs-lookup"><span data-stu-id="29e65-131">Since these resources are not directly accessible by the CPU, they are optimized so that the GPU can manipulate them quickly.</span></span>

<span data-ttu-id="29e65-132">La copie de données entre des ressources mappables est plus problématique, car les performances dépendent de l’utilisation avec laquelle la ressource a été créée.</span><span class="sxs-lookup"><span data-stu-id="29e65-132">Copying data among mappable resources is more problematic because the performance will depend on the usage the resource was created with.</span></span> <span data-ttu-id="29e65-133">Par exemple, le GPU peut lire une ressource dynamique assez rapidement, mais ne peut pas y écrire, et le GPU ne peut pas lire ou écrire directement dans les ressources intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="29e65-133">For example, the GPU can read a dynamic resource fairly quickly but cannot write to them, and the GPU cannot read or write to staging resources directly.</span></span>

<span data-ttu-id="29e65-134">Les applications qui souhaitent copier des données à partir d’une ressource avec une utilisation par défaut vers une ressource avec une utilisation intermédiaire (pour permettre au processeur de lire les données, c.-à-d. le problème de readback GPU) doivent le faire avec précaution.</span><span class="sxs-lookup"><span data-stu-id="29e65-134">Applications that wish to copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data -- i.e. the GPU readback problem) must do so with care.</span></span> <span data-ttu-id="29e65-135">Pour plus d’informations sur ce dernier cas, consultez [accès aux données des ressources](#copying-and-accessing-resource-data-direct3d-10) .</span><span class="sxs-lookup"><span data-stu-id="29e65-135">See [Accessing Resource Data](#copying-and-accessing-resource-data-direct3d-10) for more details on this last case.</span></span>

## <a name="accessing-resource-data"></a><span data-ttu-id="29e65-136">Accès aux données de ressources</span><span class="sxs-lookup"><span data-stu-id="29e65-136">Accessing Resource Data</span></span>

<span data-ttu-id="29e65-137">L’accès à une ressource requiert le mappage de la ressource ; le mappage signifie essentiellement que l’application tente d’accorder l’accès de l’UC à la mémoire.</span><span class="sxs-lookup"><span data-stu-id="29e65-137">Accessing a resource requires mapping the resource; mapping essentially means the application is trying to give the CPU access to memory.</span></span> <span data-ttu-id="29e65-138">Le processus de mappage d’une ressource afin que le processeur puisse accéder à la mémoire sous-jacente peut entraîner des goulots d’étranglement de performances et, pour cette raison, vous devez tenir compte de la façon et du moment d’exécution de cette tâche.</span><span class="sxs-lookup"><span data-stu-id="29e65-138">The process of mapping a resource so that the CPU can access the underlying memory can cause some performance bottlenecks and for this reason, care must be taken as to how and when to perform this task.</span></span>

<span data-ttu-id="29e65-139">Les performances peuvent être interrompues si l’application tente de mapper une ressource à un moment incorrect.</span><span class="sxs-lookup"><span data-stu-id="29e65-139">Performance can grind to a halt if the application tries to map a resource at the wrong time.</span></span> <span data-ttu-id="29e65-140">Si l’application tente d’accéder aux résultats d’une opération avant que cette opération ne soit terminée, un blocage de pipeline se produit.</span><span class="sxs-lookup"><span data-stu-id="29e65-140">If the application tries to access the results of an operation before that operation is finished, a pipeline stall will occur.</span></span>

<span data-ttu-id="29e65-141">L’exécution d’une opération de mappage à un moment incorrect peut entraîner une baisse importante des performances en forçant le GPU et le processeur à se synchroniser entre eux.</span><span class="sxs-lookup"><span data-stu-id="29e65-141">Performing a map operation at the wrong time could potentially cause a severe drop in performance by forcing the GPU and the CPU to synchronize with each other.</span></span> <span data-ttu-id="29e65-142">Cette synchronisation aura lieu si l’application souhaite accéder à une ressource avant que le GPU n’ait fini de la copier dans une ressource que l’UC peut mapper.</span><span class="sxs-lookup"><span data-stu-id="29e65-142">This synchronization will occur if the application wants to access a resource before the GPU is finished copying it into a resource the CPU can map.</span></span>

<span data-ttu-id="29e65-143">L’UC ne peut lire que les ressources créées avec l' \_ indicateur intermédiaire d’utilisation de D3D10 \_ .</span><span class="sxs-lookup"><span data-stu-id="29e65-143">The CPU can only read from resources created with the D3D10\_USAGE\_STAGING flag.</span></span> <span data-ttu-id="29e65-144">Étant donné que les ressources créées avec cet indicateur ne peuvent pas être définies en tant que sorties du pipeline, si l’UC souhaite lire les données dans une ressource générée par le GPU, les données doivent être copiées dans une ressource créée avec l’indicateur de mise en lots.</span><span class="sxs-lookup"><span data-stu-id="29e65-144">Since resources created with this flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU, the data must be copied to a resource created with the staging flag.</span></span> <span data-ttu-id="29e65-145">L’application peut effectuer cette opération à l’aide des méthodes [**ID3D10Device :: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device :: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) pour copier le contenu d’une ressource vers une autre.</span><span class="sxs-lookup"><span data-stu-id="29e65-145">The application may do this by using the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods to copy the contents of one resource to another.</span></span> <span data-ttu-id="29e65-146">L’application peut alors accéder à cette ressource en appelant la méthode Map appropriée.</span><span class="sxs-lookup"><span data-stu-id="29e65-146">The application can then gain access to this resource by calling the appropriate Map method.</span></span> <span data-ttu-id="29e65-147">Lorsque l’accès à la ressource n’est plus nécessaire, l’application doit ensuite appeler la méthode unout correspondante.</span><span class="sxs-lookup"><span data-stu-id="29e65-147">When access to the resource is no longer needed, the application should then call the corresponding Unmap method.</span></span> <span data-ttu-id="29e65-148">Par exemple, [**ID3D10Texture2D :: Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) et [**ID3D10Texture2D :: DEMAPPAGE**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span><span class="sxs-lookup"><span data-stu-id="29e65-148">For example, [**ID3D10Texture2D::Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) and [**ID3D10Texture2D::Unmap**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap).</span></span> <span data-ttu-id="29e65-149">Les différentes méthodes de mappage retournent des valeurs spécifiques en fonction des indicateurs d’entrée.</span><span class="sxs-lookup"><span data-stu-id="29e65-149">The different Map methods return some specific values depending on the input flags.</span></span> <span data-ttu-id="29e65-150">Pour plus d’informations, consultez la [**section Remarques**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) sur la carte.</span><span class="sxs-lookup"><span data-stu-id="29e65-150">See [**Map Remarks section**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) for details.</span></span>

> [!Note]  
> <span data-ttu-id="29e65-151">Lorsque l’application appelle la méthode Map, elle reçoit un pointeur vers les données de ressources auxquelles accéder.</span><span class="sxs-lookup"><span data-stu-id="29e65-151">When the application calls the Map method, it receives a pointer to the resource data to access.</span></span> <span data-ttu-id="29e65-152">Le runtime garantit que le pointeur a un alignement spécifique, en fonction du [niveau](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md)de la fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="29e65-152">The runtime ensures that the pointer has a specific alignment, depending on [feature level](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md).</span></span> <span data-ttu-id="29e65-153">Pour [**le \_ niveau de fonctionnalité D3D \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) et supérieur, le pointeur est aligné à 16 octets.</span><span class="sxs-lookup"><span data-stu-id="29e65-153">For [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) and higher, the pointer is aligned to 16 bytes.</span></span> <span data-ttu-id="29e65-154">Pour le niveau de fonctionnalité inférieur à [**D3D \_ \_ \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), le pointeur est aligné sur 4 octets.</span><span class="sxs-lookup"><span data-stu-id="29e65-154">For lower than [**D3D\_FEATURE\_LEVEL\_10\_0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level), the pointer is aligned to 4 bytes.</span></span> <span data-ttu-id="29e65-155">L’alignement sur 16 octets permet à l’application d’effectuer des opérations optimisées [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))sur les données en mode natif, sans réalignement ni copie.</span><span class="sxs-lookup"><span data-stu-id="29e65-155">The 16-byte alignment allows the application to perform [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))-optimized operations on the data natively, without realignment or copy.</span></span>

 

### <a name="performance-considerations"></a><span data-ttu-id="29e65-156">Considérations relatives aux performances</span><span class="sxs-lookup"><span data-stu-id="29e65-156">Performance Considerations</span></span>

<span data-ttu-id="29e65-157">Il est préférable de considérer un PC comme une machine s’exécutant comme une architecture parallèle avec deux principaux types de processeurs : un ou plusieurs PROCESSEURs et un ou plusieurs GPU.</span><span class="sxs-lookup"><span data-stu-id="29e65-157">It is best to think of a PC as a machine running as a parallel architecture with two main types of processors: one or more CPU's and one or more GPU's.</span></span> <span data-ttu-id="29e65-158">Comme pour n’importe quelle architecture parallèle, les meilleures performances sont obtenues lorsque chaque processeur est planifié avec suffisamment de tâches pour éviter qu’il ne devienne inactif et que le travail d’un processeur n’attende pas le travail d’un autre.</span><span class="sxs-lookup"><span data-stu-id="29e65-158">As in any parallel architecture, the best performance is achieved when each processor is scheduled with enough tasks to prevent it from going idle and when the work of one processor is not waiting on the work of another.</span></span>

<span data-ttu-id="29e65-159">Le pire scénario pour le parallélisme GPU/UC est la nécessité de forcer un processeur à attendre les résultats du travail effectués par un autre.</span><span class="sxs-lookup"><span data-stu-id="29e65-159">The worst-case scenario for GPU/CPU parallelism is the need to force one processor to wait for the results of work done by another.</span></span> <span data-ttu-id="29e65-160">Direct3D 10 tente de supprimer ce coût en rendant les méthodes [**ID3D10Device :: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) et [**ID3D10Device :: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) asynchrones. la copie n’a pas nécessairement été exécutée au moment du retour de la méthode.</span><span class="sxs-lookup"><span data-stu-id="29e65-160">Direct3D 10 tries to remove this cost by making the [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) and [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) methods asynchronous; the copy has not necessarily executed by the time the method returns.</span></span> <span data-ttu-id="29e65-161">L’avantage de cette méthode est que l’application ne paie pas le coût des performances de la copie des données jusqu’à ce que l’UC accède aux données, ce qui est le cas lorsque map est appelé.</span><span class="sxs-lookup"><span data-stu-id="29e65-161">The benefit of this is that the application does not pay the performance cost of actually copying the data until the CPU accesses the data, which is when Map is called.</span></span> <span data-ttu-id="29e65-162">Si la méthode map est appelée après la copie des données, aucune perte de performances ne se produit.</span><span class="sxs-lookup"><span data-stu-id="29e65-162">If the Map method is called after the data has actually been copied, no performance loss occurs.</span></span> <span data-ttu-id="29e65-163">En revanche, si la méthode map est appelée avant que les données n’aient été copiées, un blocage de pipeline se produit.</span><span class="sxs-lookup"><span data-stu-id="29e65-163">On the other hand, if the Map method is called before the data has been copied, then a pipeline stall will occur.</span></span>

<span data-ttu-id="29e65-164">Les appels asynchrones dans Direct3D 10 (qui constituent la grande majorité des méthodes, et en particulier les appels de rendu) sont stockés dans ce qu’on appelle une mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="29e65-164">Asynchronous calls in Direct3D 10 (which are the vast majority of methods, and especially rendering calls) are stored in what is called a command buffer.</span></span> <span data-ttu-id="29e65-165">Ce tampon est interne au pilote Graphics et est utilisé pour les appels par lots au matériel sous-jacent afin que le passage coûteux du mode utilisateur au mode noyau dans Microsoft Windows se produise le plus rarement possible.</span><span class="sxs-lookup"><span data-stu-id="29e65-165">This buffer is internal to the graphics driver and is used to batch calls to the underlying hardware so that the costly switch from user mode to kernel mode in Microsoft Windows occurs as rarely as possible.</span></span>

<span data-ttu-id="29e65-166">La mémoire tampon de commande est vidée, provoquant ainsi un changement de mode utilisateur/noyau, dans l’une des quatre situations suivantes :</span><span class="sxs-lookup"><span data-stu-id="29e65-166">The command buffer is flushed, thus causing a user/kernel mode switch, in one of four situations, which are as follows.</span></span>

1.  <span data-ttu-id="29e65-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) est appelé.</span><span class="sxs-lookup"><span data-stu-id="29e65-167">[**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) is called.</span></span>
2.  <span data-ttu-id="29e65-168">[**ID3D10Device :: Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) est appelé.</span><span class="sxs-lookup"><span data-stu-id="29e65-168">[**ID3D10Device::Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) is called.</span></span>
3.  <span data-ttu-id="29e65-169">La mémoire tampon de commande est pleine ; sa taille est dynamique et est contrôlée par le système d’exploitation et le pilote Graphics.</span><span class="sxs-lookup"><span data-stu-id="29e65-169">The command buffer is full; its size is dynamic and is controlled by the Operating System and the graphics driver.</span></span>
4.  <span data-ttu-id="29e65-170">L’UC requiert l’accès aux résultats d’une commande en attente d’exécution dans la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="29e65-170">The CPU requires access to the results of a command waiting to execute in the command buffer.</span></span>

<span data-ttu-id="29e65-171">Parmi les quatre situations ci-dessus, le nombre quatre est le plus critique pour les performances.</span><span class="sxs-lookup"><span data-stu-id="29e65-171">Of the four situations above, number four is the most critical to performance.</span></span> <span data-ttu-id="29e65-172">Si l’application émet un appel [**ID3D10Device :: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device :: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , cet appel est mis en file d’attente dans la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="29e65-172">If the application issues a [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) call, this call is queued in the command buffer.</span></span> <span data-ttu-id="29e65-173">Si l’application essaie ensuite de mapper la ressource intermédiaire qui était la cible de l’appel de copie avant que le tampon de commande ait été vidé, un blocage de pipeline se produit, car non seulement l’appel de la méthode de copie doit être exécuté, mais toutes les autres commandes mises en mémoire tampon dans le tampon de commande doivent également s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="29e65-173">If the application then tries to map the staging resource that was the target of the copy call before the command buffer has been flushed, a pipeline stall will occur because not only does the Copy method call need to execute, but all other buffered commands in the command buffer must execute as well.</span></span> <span data-ttu-id="29e65-174">Cela entraînera la synchronisation du GPU et du processeur, car celui-ci attendra d’accéder à la ressource intermédiaire pendant que le GPU vide la mémoire tampon de commande et finalement à remplir la ressource dont le processeur a besoin.</span><span class="sxs-lookup"><span data-stu-id="29e65-174">This will cause the GPU and CPU to synchronize because the CPU will be waiting to access the staging resource while the GPU is emptying the command buffer and finally filling the resource the CPU needs.</span></span> <span data-ttu-id="29e65-175">Une fois que le GPU a terminé la copie, l’UC commence à accéder à la ressource de mise en lots, mais pendant ce temps, le GPU est resté inactif.</span><span class="sxs-lookup"><span data-stu-id="29e65-175">Once the GPU finishes the copy, the CPU will begin accessing the staging resource, but during this time, the GPU will be sitting idle.</span></span>

<span data-ttu-id="29e65-176">Ce qui se passe fréquemment lors de l’exécution entraîne une dégradation importante des performances.</span><span class="sxs-lookup"><span data-stu-id="29e65-176">Doing this frequently at runtime will severely degrade performance.</span></span> <span data-ttu-id="29e65-177">Pour cette raison, le mappage des ressources créées avec l’utilisation par défaut doit être effectué avec précaution.</span><span class="sxs-lookup"><span data-stu-id="29e65-177">For that reason, mapping of resources created with default usage should be done with care.</span></span> <span data-ttu-id="29e65-178">L’application doit attendre suffisamment longtemps pour que le tampon de commande soit vidé et, par conséquent, toutes ces commandes finissent à s’exécuter avant de tenter de mapper la ressource intermédiaire correspondante.</span><span class="sxs-lookup"><span data-stu-id="29e65-178">The application needs to wait long enough for the command buffer to be emptied and thus have all of those commands finish executing before it tries to map the corresponding staging resource.</span></span> <span data-ttu-id="29e65-179">Quelle est la durée d’attente de l’application ?</span><span class="sxs-lookup"><span data-stu-id="29e65-179">How long should the application wait?</span></span> <span data-ttu-id="29e65-180">Au moins deux frames, car cela permet d’optimiser le parallélisme entre le processeur et le GPU.</span><span class="sxs-lookup"><span data-stu-id="29e65-180">At least two frames because this will enable parallelism between the CPU(s) and the GPU to be maximally leveraged.</span></span> <span data-ttu-id="29e65-181">La façon dont le GPU fonctionne est que pendant que l’application traite le frame N en soumettant des appels au tampon de commande, le GPU est occupé à exécuter les appels à partir du frame précédent, N-1.</span><span class="sxs-lookup"><span data-stu-id="29e65-181">The way the GPU works is that while the application is processing frame N by submitting calls to the command buffer, the GPU is busy executing the calls from the previous frame, N-1.</span></span>

<span data-ttu-id="29e65-182">Par conséquent, si une application souhaite mapper une ressource qui provient de la mémoire vidéo et appelle [**ID3D10Device :: CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) ou [**ID3D10Device :: CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) au niveau de la trame n, cet appel commence en fait à s’exécuter au frame n + 1, lorsque l’application envoie des appels pour le frame suivant.</span><span class="sxs-lookup"><span data-stu-id="29e65-182">So if an application wants to map a resource that originates in video memory and calls [**ID3D10Device::CopyResource**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) or [**ID3D10Device::CopySubresourceRegion**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) at frame N, this call will actually begin to execute at frame N+1, when the application is submitting calls for the next frame.</span></span> <span data-ttu-id="29e65-183">La copie doit être terminée lorsque l’application traite le frame N + 2.</span><span class="sxs-lookup"><span data-stu-id="29e65-183">The copy should be finished when the application is processing frame N+2.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="29e65-184">Frame</span><span class="sxs-lookup"><span data-stu-id="29e65-184">Frame</span></span></th>
<th><span data-ttu-id="29e65-185">État GPU/UC</span><span class="sxs-lookup"><span data-stu-id="29e65-185">GPU/CPU Status</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="29e65-186">N</span><span class="sxs-lookup"><span data-stu-id="29e65-186">N</span></span></td>
<td><ul>
<li><span data-ttu-id="29e65-187">Les problèmes d’UC affichent les appels pour le frame actuel.</span><span class="sxs-lookup"><span data-stu-id="29e65-187">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="29e65-188">N + 1</span><span class="sxs-lookup"><span data-stu-id="29e65-188">N+1</span></span></td>
<td><ul>
<li><span data-ttu-id="29e65-189">Le GPU exécute les appels envoyés depuis l’UC pendant le frame N.</span><span class="sxs-lookup"><span data-stu-id="29e65-189">GPU executing calls sent from CPU during frame N.</span></span></li>
<li><span data-ttu-id="29e65-190">Les problèmes d’UC affichent les appels pour le frame actuel.</span><span class="sxs-lookup"><span data-stu-id="29e65-190">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="29e65-191">N + 2</span><span class="sxs-lookup"><span data-stu-id="29e65-191">N+2</span></span></td>
<td><ul>
<li><span data-ttu-id="29e65-192">Le GPU a terminé l’exécution des appels envoyés depuis le processeur au cours de la trame N. les résultats sont prêts.</span><span class="sxs-lookup"><span data-stu-id="29e65-192">GPU finished executing calls sent from CPU during frame N. Results ready.</span></span></li>
<li><span data-ttu-id="29e65-193">Le GPU exécute les appels envoyés depuis le processeur pendant la trame N + 1.</span><span class="sxs-lookup"><span data-stu-id="29e65-193">GPU executing calls sent from CPU during frame N+1.</span></span></li>
<li><span data-ttu-id="29e65-194">Les problèmes d’UC affichent les appels pour le frame actuel.</span><span class="sxs-lookup"><span data-stu-id="29e65-194">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="29e65-195">N + 3</span><span class="sxs-lookup"><span data-stu-id="29e65-195">N+3</span></span></td>
<td><ul>
<li><span data-ttu-id="29e65-196">Le GPU a terminé l’exécution des appels envoyés depuis le processeur pendant la trame N + 1.</span><span class="sxs-lookup"><span data-stu-id="29e65-196">GPU finished executing calls sent from CPU during frame N+1.</span></span> <span data-ttu-id="29e65-197">Résultats prêts.</span><span class="sxs-lookup"><span data-stu-id="29e65-197">Results ready.</span></span></li>
<li><span data-ttu-id="29e65-198">Le GPU exécute les appels envoyés depuis l’UC au cours de la trame N + 2.</span><span class="sxs-lookup"><span data-stu-id="29e65-198">GPU executing calls sent from CPU during frame N+2.</span></span></li>
<li><span data-ttu-id="29e65-199">Les problèmes d’UC affichent les appels pour le frame actuel.</span><span class="sxs-lookup"><span data-stu-id="29e65-199">CPU issues render calls for current frame.</span></span></li>
</ul></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="29e65-200">N + 4</span><span class="sxs-lookup"><span data-stu-id="29e65-200">N+4</span></span></td>
<td><span data-ttu-id="29e65-201">...</span><span class="sxs-lookup"><span data-stu-id="29e65-201">...</span></span></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="29e65-202">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="29e65-202">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="29e65-203">Ressources (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="29e65-203">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
