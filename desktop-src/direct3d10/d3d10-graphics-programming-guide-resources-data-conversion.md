---
description: Les sections suivantes décrivent comment Direct3D gère les conversions entre les types de données.
ms.assetid: 454d3fd0-fc0f-46a9-925e-13f8e3c39f02
title: Règles de conversion des données
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 61abdc58811af9155c67d7b32bcd47e9d4b71ea5
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748268"
---
# <a name="data-conversion-rules"></a><span data-ttu-id="47aa8-103">Règles de conversion des données</span><span class="sxs-lookup"><span data-stu-id="47aa8-103">Data Conversion Rules</span></span>

<span data-ttu-id="47aa8-104">Les sections suivantes décrivent comment Direct3D gère les conversions entre les types de données.</span><span class="sxs-lookup"><span data-stu-id="47aa8-104">The following sections describe how Direct3D handles conversions between data types.</span></span>

-   [<span data-ttu-id="47aa8-105">Terminologie des types de données</span><span class="sxs-lookup"><span data-stu-id="47aa8-105">Data Type Terminology</span></span>](#data-type-terminology)
-   [<span data-ttu-id="47aa8-106">Conversion à virgule flottante</span><span class="sxs-lookup"><span data-stu-id="47aa8-106">Floating Point Conversion</span></span>](#floating-point-conversion)
    -   [<span data-ttu-id="47aa8-107">Conververting d’une représentation de plage supérieure à une représentation de plage inférieure</span><span class="sxs-lookup"><span data-stu-id="47aa8-107">Conververting from a higher range representation to a lower range representation</span></span>](#conververting-from-a-higher-range-representation-to-a-lower-range-representation)
    -   [<span data-ttu-id="47aa8-108">Conversion d’une représentation de plage inférieure en une représentation de plage supérieure</span><span class="sxs-lookup"><span data-stu-id="47aa8-108">Converting from a lower range representation to a higher range representation</span></span>](#converting-from-a-lower-range-representation-to-a-higher-range-representation)
-   [<span data-ttu-id="47aa8-109">Conversion d’entier</span><span class="sxs-lookup"><span data-stu-id="47aa8-109">Integer Conversion</span></span>](#integer-conversion)
-   [<span data-ttu-id="47aa8-110">Conversion d’entier à virgule fixe</span><span class="sxs-lookup"><span data-stu-id="47aa8-110">Fixed Point Integer Conversion</span></span>](#fixed-point-integer-conversion)
-   [<span data-ttu-id="47aa8-111">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="47aa8-111">Related topics</span></span>](#related-topics)

## <a name="data-type-terminology"></a><span data-ttu-id="47aa8-112">Terminologie des types de données</span><span class="sxs-lookup"><span data-stu-id="47aa8-112">Data Type Terminology</span></span>

<span data-ttu-id="47aa8-113">Les termes suivants sont utilisés par la suite pour caractériser diverses conversions de format.</span><span class="sxs-lookup"><span data-stu-id="47aa8-113">The following set of terms are subsequently used to characterize various format conversions.</span></span>



| <span data-ttu-id="47aa8-114">Terme</span><span class="sxs-lookup"><span data-stu-id="47aa8-114">Term</span></span>  | <span data-ttu-id="47aa8-115">Définition</span><span class="sxs-lookup"><span data-stu-id="47aa8-115">Definition</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|-------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="47aa8-116">RONFLEr</span><span class="sxs-lookup"><span data-stu-id="47aa8-116">SNORM</span></span> | <span data-ttu-id="47aa8-117">Entier normalisé signé, ce qui signifie que pour le numéro de complément de n bits 2, la valeur maximale correspond à 1,0 f (par exemple, la valeur de 5 bits 01111 correspond à 1.0 f), et la valeur minimale signifie-1.0 f (par exemple, la valeur 5 bits 10000 correspond à-1.0 f).</span><span class="sxs-lookup"><span data-stu-id="47aa8-117">Signed normalized integer, meaning that for an n-bit 2's complement number, the maximum value means 1.0f (e.g. the 5-bit value 01111 maps to 1.0f), and the minimum value means -1.0f (e.g. the 5-bit value 10000 maps to -1.0f).</span></span> <span data-ttu-id="47aa8-118">En outre, le deuxième nombre minimal est mappé à-1.0 f (par exemple, la valeur 5 bits 10001 est mappée à-1.0 f).</span><span class="sxs-lookup"><span data-stu-id="47aa8-118">In addition, the second-minimum number maps to -1.0f (e.g. the 5-bit value 10001 maps to -1.0f).</span></span> <span data-ttu-id="47aa8-119">Il y a donc deux représentations entières pour-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-119">There are thus two integer representations for -1.0f.</span></span> <span data-ttu-id="47aa8-120">Il existe une représentation unique pour 0.0 f, et une représentation unique pour 1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-120">There is a single representation for 0.0f, and a single representation for 1.0f.</span></span> <span data-ttu-id="47aa8-121">Cela génère un ensemble de représentations entières pour les valeurs à virgule flottante uniformément espacées dans la plage (-1,0 f... 0.0 f) et également un ensemble complémentaire de représentations pour les nombres dans la plage (0.0 f... supérieures</span><span class="sxs-lookup"><span data-stu-id="47aa8-121">This results in a set of integer representations for evenly spaced floating point values in the range (-1.0f...0.0f), and also a complementary set of representations for numbers in the range (0.0f...1.0f)</span></span> |
| <span data-ttu-id="47aa8-122">UNORM</span><span class="sxs-lookup"><span data-stu-id="47aa8-122">UNORM</span></span> | <span data-ttu-id="47aa8-123">Entier normalisé non signé, ce qui signifie que pour un nombre n bits, tous les 0 signifient 0.0 f, et tous les 1 signifient 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-123">Unsigned normalized integer, meaning that for an n-bit number, all 0's means 0.0f, and all 1's means 1.0f.</span></span> <span data-ttu-id="47aa8-124">Une séquence de valeurs à virgule flottante uniformément espacées de 0.0 f à 1.0 f est représentée.</span><span class="sxs-lookup"><span data-stu-id="47aa8-124">A sequence of evenly spaced floating point values from 0.0f to 1.0f are represented.</span></span> <span data-ttu-id="47aa8-125">par exemple, un UNORM de 2 bits représente 0.0 f, 1/3, 2/3 et 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-125">e.g. a 2-bit UNORM represents 0.0f, 1/3, 2/3, and 1.0f.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="47aa8-126">Saint</span><span class="sxs-lookup"><span data-stu-id="47aa8-126">SINT</span></span>  | <span data-ttu-id="47aa8-127">Entier signé.</span><span class="sxs-lookup"><span data-stu-id="47aa8-127">Signed integer.</span></span> <span data-ttu-id="47aa8-128">entier du complément 2.</span><span class="sxs-lookup"><span data-stu-id="47aa8-128">2's complement integer.</span></span> <span data-ttu-id="47aa8-129">par exemple, un Saint-octet 3 bits représente les valeurs intégrales-4,-3,-2,-1, 0, 1, 2, 3.</span><span class="sxs-lookup"><span data-stu-id="47aa8-129">e.g. an 3-bit SINT represents the integral values -4, -3, -2, -1, 0, 1, 2, 3.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="47aa8-130">UINT</span><span class="sxs-lookup"><span data-stu-id="47aa8-130">UINT</span></span>  | <span data-ttu-id="47aa8-131">Entier non signé.</span><span class="sxs-lookup"><span data-stu-id="47aa8-131">Unsigned integer.</span></span> <span data-ttu-id="47aa8-132">par exemple, un UINT de 3 bits représente les valeurs intégrales 0, 1, 2, 3, 4, 5, 6, 7.</span><span class="sxs-lookup"><span data-stu-id="47aa8-132">e.g. a 3-bit UINT represents the integral values 0, 1, 2, 3, 4, 5, 6, 7.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="47aa8-133">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-133">FLOAT</span></span> | <span data-ttu-id="47aa8-134">Valeur à virgule flottante dans l’une des représentations définies par Direct3D.</span><span class="sxs-lookup"><span data-stu-id="47aa8-134">A floating-point value in any of the representations defined by Direct3D.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="47aa8-135">SRVB</span><span class="sxs-lookup"><span data-stu-id="47aa8-135">SRGB</span></span>  | <span data-ttu-id="47aa8-136">Semblable à UNORM, dans le cas d’un nombre n bits, les 0 signifient 0.0 f et tous les 1 signifient 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-136">Similar to UNORM, in that for an n-bit number, all 0's means 0.0f and all 1's means 1.0f.</span></span> <span data-ttu-id="47aa8-137">Toutefois, contrairement à UNORM, avec sRVB, la séquence d’encodages d’entiers non signés entre tous les 0 de tous les 1 représente une progression non linéaire dans l’interprétation à virgule flottante des nombres, comprise entre 0.0 f et 1,0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-137">However unlike UNORM, with SRGB the sequence of unsigned integer encodings between all 0's to all 1's represent a nonlinear progression in the floating point interpretation of the numbers, between 0.0f to 1.0f.</span></span> <span data-ttu-id="47aa8-138">En gros, si cette progression non linéaire, sRVB, est affichée sous la forme d’une séquence de couleurs, elle apparaît sous la forme d’une rampe linéaire des niveaux de luminosité pour un observateur « moyen », sous les conditions d’affichage « moyennes », sur un affichage « moyen ».</span><span class="sxs-lookup"><span data-stu-id="47aa8-138">Roughly, if this nonlinear progression, SRGB, is displayed as a sequence of colors, it would appear as a linear ramp of luminosity levels to an "average" observer, under "average" viewing conditions, on an "average" display.</span></span> <span data-ttu-id="47aa8-139">Pour obtenir des détails complets, reportez-vous à la norme de couleurs sRVB, IEC 61996-2-1, à l’adresse CEI (Commission Électrotechnique Internationale).</span><span class="sxs-lookup"><span data-stu-id="47aa8-139">For complete detail, refer to the SRGB color standard, IEC 61996-2-1, at IEC (International Electrotechnical Commission).</span></span>                |



 

## <a name="floating-point-conversion"></a><span data-ttu-id="47aa8-140">Conversion à virgule flottante</span><span class="sxs-lookup"><span data-stu-id="47aa8-140">Floating Point Conversion</span></span>

<span data-ttu-id="47aa8-141">À chaque fois qu’une conversion à virgule flottante entre différentes représentations se produit, y compris vers ou à partir de représentations à virgule non flottante, les règles suivantes s’appliquent.</span><span class="sxs-lookup"><span data-stu-id="47aa8-141">Whenever a floating point conversion between different representations occurs, including to or from non-floating point representations, the following rules apply.</span></span>

### <a name="conververting-from-a-higher-range-representation-to-a-lower-range-representation"></a><span data-ttu-id="47aa8-142">Conververting d’une représentation de plage supérieure à une représentation de plage inférieure</span><span class="sxs-lookup"><span data-stu-id="47aa8-142">Conververting from a higher range representation to a lower range representation</span></span>

-   <span data-ttu-id="47aa8-143">L’arrondi à zéro est utilisé lors de la conversion vers un autre format float.</span><span class="sxs-lookup"><span data-stu-id="47aa8-143">Round-to-zero is used during conversion to another float format.</span></span> <span data-ttu-id="47aa8-144">Si la cible est un format d’entier ou de point fixe, l’arrondi vers le le plus proche est utilisé, à moins que la conversion soit explicitement documentée comme utilisant un autre comportement d’arrondi, tel que l’arrondi au RONFLEment le plus proche de la virgule FLOTTante, la valeur float à UNORM ou la valeur FLOAT à sRVB.</span><span class="sxs-lookup"><span data-stu-id="47aa8-144">If the target is an integer or fixed point format, round-to-nearest-even is used, unless the conversion is explicitly documented as using another rounding behavior, such as round-to-nearest for FLOAT to SNORM, FLOAT to UNORM or FLOAT to SRGB.</span></span> <span data-ttu-id="47aa8-145">D’autres exceptions sont les instructions de nuanceur ftoi et ftou, qui utilisent l’arrondi à zéro.</span><span class="sxs-lookup"><span data-stu-id="47aa8-145">Other exceptions are the ftoi and ftou shader instructions, which use round-to-zero.</span></span> <span data-ttu-id="47aa8-146">Enfin, les conversions de type float vers Fixed utilisées par l’échantillonneur de texture et le rastériseur ont une tolérance spécifiée mesurée en unités en dernier lieu à partir d’une solution idéale de précision infinie.</span><span class="sxs-lookup"><span data-stu-id="47aa8-146">Finally, the float-to-fixed conversions used by the texture sampler and rasterizer have a specified tolerance measured in Unit-Last-Place from an infinitely precise ideal.</span></span>
-   <span data-ttu-id="47aa8-147">Pour les valeurs sources supérieures à la plage dynamique d’un format cible de plage inférieure (par exemple,</span><span class="sxs-lookup"><span data-stu-id="47aa8-147">For source values greater than the dynamic range of a lower range target format (eg.</span></span> <span data-ttu-id="47aa8-148">une grande valeur flottante de 32 bits est écrite dans une RenderTarget flottante de 16 bits), la valeur maximale représentable (correctement signée), à l’exclusion de l’infini signé (en raison de l’arrondi à zéro décrit ci-dessus).</span><span class="sxs-lookup"><span data-stu-id="47aa8-148">a large 32-bit float value is written into a 16-bit float RenderTarget), the maximum representable (appropriately signed) value results, NOT including signed infinity (due to the round to zero described above).</span></span>
-   <span data-ttu-id="47aa8-149">Une valeur NaN dans un format de plage plus élevé est convertie en représentation NaN dans le format de plage inférieure si la représentation NaN existe dans le format de plage inférieure.</span><span class="sxs-lookup"><span data-stu-id="47aa8-149">NaN in a higher range format will be converted to NaN representation in the lower range format if the NaN representation exists in the lower range format.</span></span> <span data-ttu-id="47aa8-150">Si le format inférieur n’a pas de représentation NaN, le résultat sera 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-150">If the lower format does not have a NaN representation, the result will be 0.</span></span>
-   <span data-ttu-id="47aa8-151">Le fichier INF dans un format de plage plus élevé est converti en fichier INF au format de plage inférieure, s’il est disponible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-151">INF in a higher range format will be converted to INF in the lower range format if available.</span></span> <span data-ttu-id="47aa8-152">Si le format inférieur n’a pas de représentation INF, il sera converti en valeur maximale pouvant être représentée.</span><span class="sxs-lookup"><span data-stu-id="47aa8-152">If the lower format does not have an INF representation, it will be converted to the maximum value representable.</span></span> <span data-ttu-id="47aa8-153">Le signe sera préservé s’il est disponible dans le format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-153">The sign will be preserved if available in the target format.</span></span>
-   <span data-ttu-id="47aa8-154">La dénorme dans un format de plage plus élevé est convertie en représentation dérespectee dans le format de plage inférieure, si elle est disponible dans le format de plage inférieur et que la conversion est possible ; sinon, le résultat est 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-154">Denorm in a higher range format will be converted to the Denorm representation in the lower range format if available in the lower range format and the conversion is possible, otherwise the result is 0.</span></span> <span data-ttu-id="47aa8-155">Le bit de signe sera préservé s’il est disponible dans le format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-155">The sign bit will be preserved if available in the target format.</span></span>

### <a name="converting-from-a-lower-range-representation-to-a-higher-range-representation"></a><span data-ttu-id="47aa8-156">Conversion d’une représentation de plage inférieure en une représentation de plage supérieure</span><span class="sxs-lookup"><span data-stu-id="47aa8-156">Converting from a lower range representation to a higher range representation</span></span>

-   <span data-ttu-id="47aa8-157">La valeur NaN dans un format de plage inférieure est convertie en représentation NaN dans le format de plage supérieur, si elle est disponible dans le format de plage supérieur.</span><span class="sxs-lookup"><span data-stu-id="47aa8-157">NaN in a lower range format will be converted to the NaN representation in the higher range format if available in the higher range format.</span></span> <span data-ttu-id="47aa8-158">Si le format de plage supérieur n’a pas de représentation NaN, il sera converti en 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-158">If the higher range format does not have a NaN representation, it will be converted to 0.</span></span>
-   <span data-ttu-id="47aa8-159">Le fichier INF dans un format de plage inférieure est converti en une représentation INF dans le format de plage supérieur, s’il est disponible dans le format de plage supérieur.</span><span class="sxs-lookup"><span data-stu-id="47aa8-159">INF in a lower range format will be converted to the INF representation in the higher range format if available in the higher range format.</span></span> <span data-ttu-id="47aa8-160">Si le format supérieur n’a pas de représentation INF, il sera converti en valeur maximale pouvant être représentée (MAX \_ float dans ce format).</span><span class="sxs-lookup"><span data-stu-id="47aa8-160">If the higher format does not have an INF representation, it will be converted to the maximum value representable (MAX\_FLOAT in that format).</span></span> <span data-ttu-id="47aa8-161">Le signe sera préservé s’il est disponible dans le format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-161">The sign will be preserved if available in the target format.</span></span>
-   <span data-ttu-id="47aa8-162">La dénorme dans un format de plage inférieure est convertie en une représentation normalisée dans le format de plage le plus élevé, si possible, ou en une représentation dénormalisée dans un format de plage supérieur si la représentation dénormalisée existe.</span><span class="sxs-lookup"><span data-stu-id="47aa8-162">Denorm in a lower range format will be converted to a normalized representation in the higher range format if possible, or else to a Denorm representation in the higher range format if the Denorm representation exists.</span></span> <span data-ttu-id="47aa8-163">En cas d’échec, si le format de plage supérieur n’a pas de représentation de dénorme, il sera converti en 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-163">Failing those, if the higher range format does not have a Denorm representation, it will be converted to 0.</span></span> <span data-ttu-id="47aa8-164">Le signe sera préservé s’il est disponible dans le format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-164">The sign will be preserved if available in the target format.</span></span> <span data-ttu-id="47aa8-165">Notez que les nombres à virgule flottante 32 bits sont décomptés comme un format sans représentation dénormale (car les dénormes dans les opérations sur les Floats 32 bits se vident pour le signe préservé 0).</span><span class="sxs-lookup"><span data-stu-id="47aa8-165">Note that 32-bit float numbers count as a format without a Denorm representation (because Denorms in operations on 32-bit floats flush to sign preserved 0).</span></span>

## <a name="integer-conversion"></a><span data-ttu-id="47aa8-166">Conversion d’entier</span><span class="sxs-lookup"><span data-stu-id="47aa8-166">Integer Conversion</span></span>

<span data-ttu-id="47aa8-167">Le tableau suivant décrit les conversions de différentes représentations décrites ci-dessus vers d’autres représentations.</span><span class="sxs-lookup"><span data-stu-id="47aa8-167">The following table describes conversions from various representations described above to other representations.</span></span> <span data-ttu-id="47aa8-168">Seules les conversions qui se produisent réellement dans Direct3D sont affichées.</span><span class="sxs-lookup"><span data-stu-id="47aa8-168">Only conversions that actually occur in Direct3D are shown.</span></span>



<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="47aa8-169">Type de données source</span><span class="sxs-lookup"><span data-stu-id="47aa8-169">Source Data Type</span></span></th>
<th><span data-ttu-id="47aa8-170">Type de données de destination</span><span class="sxs-lookup"><span data-stu-id="47aa8-170">Destination Data Type</span></span></th>
<th><span data-ttu-id="47aa8-171">Règle de conversion</span><span class="sxs-lookup"><span data-stu-id="47aa8-171">Conversion Rule</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="47aa8-172">RONFLEr</span><span class="sxs-lookup"><span data-stu-id="47aa8-172">SNORM</span></span></td>
<td><span data-ttu-id="47aa8-173">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-173">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-174">À partir d’une valeur entière n bits représentant la plage signée [-1.0 f à 1.0 f], la conversion en virgule flottante est la suivante.</span><span class="sxs-lookup"><span data-stu-id="47aa8-174">Given an n-bit integer value representing the signed range [-1.0f to 1.0f], conversion to floating-point is as follows.</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-175">La valeur la plus négative est mappée à-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-175">The most-negative value maps to -1.0f.</span></span> <span data-ttu-id="47aa8-176">par exemple, la valeur de 5 bits 10000 est mappée à-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-176">e.g. the 5-bit value 10000 maps to -1.0f.</span></span></li>
<li><span data-ttu-id="47aa8-177">Chaque autre valeur est convertie en valeur float (appelez-la c), puis result = c \* (1,0 f/(2 ⁽ ⁿ ⁻ ¹ ⁾-1)).</span><span class="sxs-lookup"><span data-stu-id="47aa8-177">Every other value is converted to a float (call it c), and then result = c \* (1.0f / (2⁽ⁿ⁻¹⁾-1)).</span></span> <span data-ttu-id="47aa8-178">Par exemple, la valeur 5 bits 10001 est convertie en-15 f, puis divisée par 15 15, produisant-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-178">For example the 5-bit value 10001 is converted to -15.0f, and then divided by 15.0f, yielding -1.0f.</span></span></li>
</ul></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-179">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-179">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-180">RONFLEr</span><span class="sxs-lookup"><span data-stu-id="47aa8-180">SNORM</span></span></td>
<td><span data-ttu-id="47aa8-181">Étant donné un nombre à virgule flottante, la conversion en valeur entière n bits représentant la plage signée [-1.0 f à 1.0 f] est la suivante.</span><span class="sxs-lookup"><span data-stu-id="47aa8-181">Given a floating-point number, conversion to an n-bit integer value representing the signed range [-1.0f to 1.0f] is as follows.</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-182">Supposons que c représente la valeur de départ.</span><span class="sxs-lookup"><span data-stu-id="47aa8-182">Let c represent the starting value.</span></span></li>
<li><span data-ttu-id="47aa8-183">Si c est NaN, le résultat est 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-183">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="47aa8-184">Si c > 1.0 f, y compris le fichier INF, il est ancré à 1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-184">If c > 1.0f, including INF, it is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="47aa8-185">Si c <-1.0 f, y compris-INF, il est ancré à-1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-185">If c < -1.0f, including -INF, it is clamped to -1.0f.</span></span></li>
<li><span data-ttu-id="47aa8-186">Conversion d’une échelle flottante en échelle d’entier : c = c \* (2 ⁿ ⁻ ¹-1).</span><span class="sxs-lookup"><span data-stu-id="47aa8-186">Convert from float scale to integer scale: c = c \* (2ⁿ⁻¹-1).</span></span></li>
<li><span data-ttu-id="47aa8-187">Convertissez en entier comme suit.</span><span class="sxs-lookup"><span data-stu-id="47aa8-187">Convert to an integer as follows.</span></span>
<ul>
<li><span data-ttu-id="47aa8-188">Si c >= 0 Then c = c + 0,5 f, sinon, c = c-0,5 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-188">If c >= 0 then c = c + 0.5f, otherwise, c = c - 0.5f.</span></span></li>
<li><span data-ttu-id="47aa8-189">Supprimer la fraction décimale, et la valeur à virgule flottante restante (intégrale) est convertie directement en entier.</span><span class="sxs-lookup"><span data-stu-id="47aa8-189">Drop the decimal fraction, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="47aa8-190">Cette conversion admet une tolérance de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_Unit-Last-place Unit-Last-place (côté entier).</span><span class="sxs-lookup"><span data-stu-id="47aa8-190">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_Unit-Last-Place Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="47aa8-191">Cela signifie qu’après la conversion de l’échelle float en Integer, toute valeur dans D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unité-Last-place d’une valeur de format cible représentable est autorisée à mapper à cette valeur.</span><span class="sxs-lookup"><span data-stu-id="47aa8-191">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="47aa8-192">L’exigence supplémentaire d’inversion des données garantit que la conversion est nondecreasing dans la plage et que toutes les valeurs de sortie sont réalisables.</span><span class="sxs-lookup"><span data-stu-id="47aa8-192">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span> <span data-ttu-id="47aa8-193">(Dans les constantes indiquées ici, <em>XX</em> doit être remplacé par la version de Direct3D, par exemple 10, 11 ou 12.)</span><span class="sxs-lookup"><span data-stu-id="47aa8-193">(In the constants shown here, <em>xx</em> should be replaced with the Direct3D version, for example 10, 11, or 12.)</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="47aa8-194">UNORM</span><span class="sxs-lookup"><span data-stu-id="47aa8-194">UNORM</span></span></td>
<td><span data-ttu-id="47aa8-195">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-195">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-196">La valeur de départ n bits est convertie en valeur float (0.0 f, 1.0 f, 2.0 f, etc.), puis divisée par (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="47aa8-196">The starting n-bit value is converted to float (0.0f, 1.0f, 2.0f, etc.) and then divided by (2ⁿ-1).</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-197">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-197">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-198">UNORM</span><span class="sxs-lookup"><span data-stu-id="47aa8-198">UNORM</span></span></td>
<td><span data-ttu-id="47aa8-199">Supposons que c représente la valeur de départ.</span><span class="sxs-lookup"><span data-stu-id="47aa8-199">Let c represent the starting value.</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-200">Si c est NaN, le résultat est 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-200">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="47aa8-201">Si c > 1.0 f, y compris le fichier INF, il est ancré à 1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-201">If c > 1.0f, including INF, it is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="47aa8-202">Si c < 0.0 f, y compris-INF, il est ancré à 0.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-202">If c < 0.0f, including -INF, it is clamped to 0.0f.</span></span></li>
<li><span data-ttu-id="47aa8-203">Convertir à partir d’une échelle flottante en échelle entière : c = c \* (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="47aa8-203">Convert from float scale to integer scale: c = c \* (2ⁿ-1).</span></span></li>
<li><span data-ttu-id="47aa8-204">Convertir en entier.</span><span class="sxs-lookup"><span data-stu-id="47aa8-204">Convert to integer.</span></span>
<ul>
<li><span data-ttu-id="47aa8-205">c = c + 0,5 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-205">c = c + 0.5f.</span></span></li>
<li><span data-ttu-id="47aa8-206">La fraction décimale est supprimée, et la valeur à virgule flottante restante (intégrale) est convertie directement en entier.</span><span class="sxs-lookup"><span data-stu-id="47aa8-206">The decimal fraction is dropped, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="47aa8-207">Cette conversion admet une tolérance de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unité-Last-place (côté entier).</span><span class="sxs-lookup"><span data-stu-id="47aa8-207">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="47aa8-208">Cela signifie qu’après la conversion de l’échelle float en Integer, toute valeur dans D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unité-Last-place d’une valeur de format cible représentable est autorisée à mapper à cette valeur.</span><span class="sxs-lookup"><span data-stu-id="47aa8-208">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="47aa8-209">L’exigence supplémentaire d’inversion des données garantit que la conversion est nondecreasing dans la plage et que toutes les valeurs de sortie sont réalisables.</span><span class="sxs-lookup"><span data-stu-id="47aa8-209">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="47aa8-210">SRVB</span><span class="sxs-lookup"><span data-stu-id="47aa8-210">SRGB</span></span></td>
<td><span data-ttu-id="47aa8-211">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-211">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-212">L’exemple suivant est la conversion d’sRVB en valeur FLOAT idéale.</span><span class="sxs-lookup"><span data-stu-id="47aa8-212">The following is the ideal SRGB to FLOAT conversion.</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-213">Prenez la valeur de départ n bits, convertissez-la en une valeur float (0.0 f, 1.0 f, 2.0 f, etc.). appelez ce c.</span><span class="sxs-lookup"><span data-stu-id="47aa8-213">Take the starting n-bit value, convert it a float (0.0f, 1.0f, 2.0f, etc.); call this c.</span></span></li>
<li><span data-ttu-id="47aa8-214">c = c \* (1,0 f/(2 ⁿ-1))</span><span class="sxs-lookup"><span data-stu-id="47aa8-214">c = c \* (1.0f / (2ⁿ-1))</span></span></li>
<li><span data-ttu-id="47aa8-215">Si (c < = D3D<em>xx</em>_SRGB_TO_FLOAT_THRESHOLD) Then : result = c/D3D<em>XX</em>_SRGB_TO_FLOAT_DENOMINATOR_1, Else : Result = ((c + D3D<em>xx</em>_SRGB_TO_FLOAT_OFFSET)/D3D<em>XX</em>_SRGB_TO_FLOAT_DENOMINATOR_2) D3D<em>XX</em>_SRGB_TO_FLOAT_EXPONENT</span><span class="sxs-lookup"><span data-stu-id="47aa8-215">If (c < = D3D<em>xx</em>_SRGB_TO_FLOAT_THRESHOLD) then: result = c / D3D<em>xx</em>_SRGB_TO_FLOAT_DENOMINATOR_1, else: result = ((c + D3D<em>xx</em>_SRGB_TO_FLOAT_OFFSET)/D3D<em>xx</em>_SRGB_TO_FLOAT_DENOMINATOR_2)D3D<em>xx</em>_SRGB_TO_FLOAT_EXPONENT</span></span></li>
</ul>
<span data-ttu-id="47aa8-216">Cette conversion admet une tolérance de D3D<em>xx</em>_SRGB_TO_FLOAT_TOLERANCE_IN_ULP unité-Last-place (côté sRVB).</span><span class="sxs-lookup"><span data-stu-id="47aa8-216">This conversion is permitted a tolerance of D3D<em>xx</em>_SRGB_TO_FLOAT_TOLERANCE_IN_ULP Unit-Last-Place (on the SRGB side).</span></span> <br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-217">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-217">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-218">SRVB</span><span class="sxs-lookup"><span data-stu-id="47aa8-218">SRGB</span></span></td>
<td><span data-ttu-id="47aa8-219">Voici la conversion d’sRVB à virgule flottante idéale >.</span><span class="sxs-lookup"><span data-stu-id="47aa8-219">The following is the ideal FLOAT -> SRGB conversion.</span></span><br/> <span data-ttu-id="47aa8-220">En supposant que le composant de couleur sRVB cible comporte n bits :</span><span class="sxs-lookup"><span data-stu-id="47aa8-220">Assuming the target SRGB color component has n bits:</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-221">Supposons que la valeur de départ est c.</span><span class="sxs-lookup"><span data-stu-id="47aa8-221">Suppose the starting value is c.</span></span></li>
<li><span data-ttu-id="47aa8-222">Si c est NaN, le résultat est 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-222">If c is NaN, the result is 0.</span></span></li>
<li><span data-ttu-id="47aa8-223">Si c > 1.0 f, y compris le fichier INF, est ancré à 1.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-223">If c > 1.0f, including INF, is clamped to 1.0f.</span></span></li>
<li><span data-ttu-id="47aa8-224">Si c < 0.0 f, y compris-INF, il est ancré à 0.0 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-224">If c < 0.0f, including -INF, it is clamped to 0.0f.</span></span></li>
<li><span data-ttu-id="47aa8-225">Si (c <= D3D<em>xx</em>_FLOAT_TO_SRGB_THRESHOLD) Then : c = d3d<em>XX</em>_FLOAT_TO_SRGB_SCALE_1 \* c, Else : c = D3D<em>XX</em>_FLOAT_TO_SRGB_SCALE_2 \* c (D3D<em>XX</em>_FLOAT_TO_SRGB_EXPONENT_NUMERATOR/D3D<em>XX</em>_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR)-D3D<em>XX</em>_FLOAT_TO_SRGB_OFFSET</span><span class="sxs-lookup"><span data-stu-id="47aa8-225">If (c <= D3D<em>xx</em>_FLOAT_TO_SRGB_THRESHOLD) then: c = D3D<em>xx</em>_FLOAT_TO_SRGB_SCALE_1 \* c, else: c = D3D<em>xx</em>_FLOAT_TO_SRGB_SCALE_2 \* c(D3D<em>xx</em>_FLOAT_TO_SRGB_EXPONENT_NUMERATOR/D3D<em>xx</em>_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR) - D3D<em>xx</em>_FLOAT_TO_SRGB_OFFSET</span></span></li>
<li><span data-ttu-id="47aa8-226">Convertir à partir d’une échelle flottante en échelle entière : c = c \* (2 ⁿ-1).</span><span class="sxs-lookup"><span data-stu-id="47aa8-226">Convert from float scale to integer scale: c = c \* (2ⁿ-1).</span></span></li>
<li><span data-ttu-id="47aa8-227">Convertir en entier :</span><span class="sxs-lookup"><span data-stu-id="47aa8-227">Convert to integer:</span></span>
<ul>
<li><span data-ttu-id="47aa8-228">c = c + 0,5 f.</span><span class="sxs-lookup"><span data-stu-id="47aa8-228">c = c + 0.5f.</span></span></li>
<li><span data-ttu-id="47aa8-229">La fraction décimale est supprimée, et la valeur à virgule flottante restante (intégrale) est convertie directement en entier.</span><span class="sxs-lookup"><span data-stu-id="47aa8-229">The decimal fraction is dropped, and the remaining floating point (integral) value is converted directly to an integer.</span></span></li>
</ul></li>
</ul>
<span data-ttu-id="47aa8-230">Cette conversion admet une tolérance de D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unité-Last-place (côté entier).</span><span class="sxs-lookup"><span data-stu-id="47aa8-230">This conversion is permitted a tolerance of D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place (on the integer side).</span></span> <span data-ttu-id="47aa8-231">Cela signifie qu’après la conversion de l’échelle float en Integer, toute valeur dans D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP unité-Last-place d’une valeur de format cible représentable est autorisée à mapper à cette valeur.</span><span class="sxs-lookup"><span data-stu-id="47aa8-231">This means that after converting from float to integer scale, any value within D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place of a representable target format value is permitted to map to that value.</span></span> <span data-ttu-id="47aa8-232">L’exigence supplémentaire d’inversion des données garantit que la conversion est nondecreasing dans la plage et que toutes les valeurs de sortie sont réalisables.</span><span class="sxs-lookup"><span data-stu-id="47aa8-232">The additional Data Invertability requirement ensures that the conversion is nondecreasing across the range and all output values are attainable.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="47aa8-233">Saint</span><span class="sxs-lookup"><span data-stu-id="47aa8-233">SINT</span></span></td>
<td><span data-ttu-id="47aa8-234">Saint-est avec plus de bits</span><span class="sxs-lookup"><span data-stu-id="47aa8-234">SINT With More Bits</span></span></td>
<td><span data-ttu-id="47aa8-235">Pour effectuer une conversion de Saint-vers-Saint-versa avec plus de bits, le bit le plus significatif (MSB) du numéro de départ est &quot; étendu &quot; aux bits supplémentaires disponibles dans le format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-235">To convert from SINT to an SINT with more bits, the most significant bit (MSB) of the starting number is &quot;sign-extended&quot; to the additional bits available in the target format.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-236">UINT</span><span class="sxs-lookup"><span data-stu-id="47aa8-236">UINT</span></span></td>
<td><span data-ttu-id="47aa8-237">Saint-est avec plus de bits</span><span class="sxs-lookup"><span data-stu-id="47aa8-237">SINT With More Bits</span></span></td>
<td><span data-ttu-id="47aa8-238">Pour convertir un UINT en un Saint-nouveau avec plus de bits, le nombre est copié vers les bits les moins significatifs du format cible (LSBs) et les MSBs supplémentaires sont remplis avec 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-238">To convert from UINT to an SINT with more bits, the number is copied to the target format's least significant bits (LSBs) and additional MSBs are padded with 0.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="47aa8-239">Saint</span><span class="sxs-lookup"><span data-stu-id="47aa8-239">SINT</span></span></td>
<td><span data-ttu-id="47aa8-240">UINT avec plus de bits</span><span class="sxs-lookup"><span data-stu-id="47aa8-240">UINT With More Bits</span></span></td>
<td><span data-ttu-id="47aa8-241">Pour effectuer une conversion de Saint-vers-UINT avec plus de bits : si la valeur est négative, la valeur est ancrée à 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-241">To convert from SINT to UINT with more bits: If negative, the value is clamped to 0.</span></span> <span data-ttu-id="47aa8-242">Sinon, le nombre est copié dans le LSBs du format cible et les MSB supplémentaires sont remplis avec 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-242">Otherwise the number is copied to the target format's LSBs and additional MSB's are padded with 0.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-243">UINT</span><span class="sxs-lookup"><span data-stu-id="47aa8-243">UINT</span></span></td>
<td><span data-ttu-id="47aa8-244">UINT avec plus de bits</span><span class="sxs-lookup"><span data-stu-id="47aa8-244">UINT With More Bits</span></span></td>
<td><span data-ttu-id="47aa8-245">Pour convertir de UINT en UINT avec plus de bits, le nombre est copié dans le LSBs du format cible et les MSB supplémentaires sont remplis avec 0.</span><span class="sxs-lookup"><span data-stu-id="47aa8-245">To convert from UINT to UINT with more bits the number is copied to the target format's LSBs and additional MSB's are padded with 0.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span data-ttu-id="47aa8-246">Saint-ou-UINT</span><span class="sxs-lookup"><span data-stu-id="47aa8-246">SINT or UINT</span></span></td>
<td><span data-ttu-id="47aa8-247">Saint-ou-UINT avec des bits inférieurs ou égaux</span><span class="sxs-lookup"><span data-stu-id="47aa8-247">SINT or UINT With Fewer or Equal Bits</span></span></td>
<td><span data-ttu-id="47aa8-248">Pour convertir un Saint-ou un UINT en Saint-ou UINT avec des bits inférieurs ou égaux (et/ou modifier l’inscription), la valeur de départ est simplement ancrée à la plage du format cible.</span><span class="sxs-lookup"><span data-stu-id="47aa8-248">To convert from a SINT or UINT to SINT or UINT with fewer or equal bits (and/or change in signedness), the starting value is simply clamped to the range of the target format.</span></span><br/></td>
</tr>
</tbody>
</table>



 

## <a name="fixed-point-integer-conversion"></a><span data-ttu-id="47aa8-249">Conversion d’entier à virgule fixe</span><span class="sxs-lookup"><span data-stu-id="47aa8-249">Fixed Point Integer Conversion</span></span>

<span data-ttu-id="47aa8-250">Les entiers à virgule fixe sont simplement des entiers d’une certaine taille de bit qui ont une virgule décimale implicite à un emplacement fixe.</span><span class="sxs-lookup"><span data-stu-id="47aa8-250">Fixed point integers are simply integers of some bit size that have an implicit decimal point at a fixed location.</span></span>

<span data-ttu-id="47aa8-251">Le type de données « Integer » omniprésent est un cas spécial d’un entier à virgule fixe avec la décimale à la fin du nombre.</span><span class="sxs-lookup"><span data-stu-id="47aa8-251">The ubiquitous "integer" data type is a special case of a fixed point integer with the decimal at the end of the number.</span></span>

<span data-ttu-id="47aa8-252">Les représentations de nombre à virgule fixe sont caractérisées par : i. f, où i est le nombre de bits entiers et f est le nombre de bits fractionnaires.</span><span class="sxs-lookup"><span data-stu-id="47aa8-252">Fixed point number representations are characterized as: i.f, where i is the number of integer bits and f is the number of fractional bits.</span></span> <span data-ttu-id="47aa8-253">par exemple, 16,8 signifie 16 bits entier suivi de 8 bits de fraction.</span><span class="sxs-lookup"><span data-stu-id="47aa8-253">e.g. 16.8 means 16 bits integer followed by 8 bits of fraction.</span></span> <span data-ttu-id="47aa8-254">La partie entière est stockée dans le complément à 2, au moins comme défini ici (bien qu’elle puisse également être définie de la même façon pour les entiers non signés).</span><span class="sxs-lookup"><span data-stu-id="47aa8-254">The integer part is stored in 2's complement, at least as defined here (though it can be defined equally for unsigned integers as well).</span></span> <span data-ttu-id="47aa8-255">La partie fractionnaire est stockée dans un format non signé.</span><span class="sxs-lookup"><span data-stu-id="47aa8-255">The fractional part is stored in unsigned form.</span></span> <span data-ttu-id="47aa8-256">La partie fractionnaire représente toujours la fraction positive entre les deux valeurs intégrales les plus proches, en commençant par le plus négatif.</span><span class="sxs-lookup"><span data-stu-id="47aa8-256">The fractional part always represents the positive fraction between the two nearest integral values, starting from the most negative.</span></span>

<span data-ttu-id="47aa8-257">Les opérations d’addition et de soustraction sur les nombres à virgule fixe sont effectuées simplement à l’aide d’une opération arithmétique sur les entiers standard, sans tenir compte de l’endroit où se trouve la virgule implicite.</span><span class="sxs-lookup"><span data-stu-id="47aa8-257">Addition and subtraction operations on fixed point numbers are performed simply using standard integer arithmetic, without any consideration for where the implied decimal lies.</span></span> <span data-ttu-id="47aa8-258">L’ajout de 1 à un nombre à virgule fixe 16,8 signifie simplement l’ajout de 256, puisque la décimale est de 8 emplacements à partir de la fin la moins significative du nombre.</span><span class="sxs-lookup"><span data-stu-id="47aa8-258">Adding 1 to a 16.8 fixed point number just means adding 256, since the decimal is 8 places in from the least significant end of the number.</span></span> <span data-ttu-id="47aa8-259">D’autres opérations, telles que la multiplication, peuvent être effectuées tout simplement à l’aide d’une opération arithmétique sur les entiers, à condition que l’effet sur la décimale fixe soit pris en compte.</span><span class="sxs-lookup"><span data-stu-id="47aa8-259">Other operations such as multiplication, can be performed as well simply using integer arithmetic, provided the effect on the fixed decimal is accounted for.</span></span> <span data-ttu-id="47aa8-260">Par exemple, la multiplication de deux entiers 16,8 à l’aide d’un nombre entier multiplie produit un résultat 32,16.</span><span class="sxs-lookup"><span data-stu-id="47aa8-260">For example, multiplying two 16.8 integers using an integer multiply produces a 32.16 result.</span></span>

<span data-ttu-id="47aa8-261">Les représentations d’entiers à virgule fixe sont utilisées de deux manières dans Direct3D.</span><span class="sxs-lookup"><span data-stu-id="47aa8-261">Fixed point integer representations are used in two ways in Direct3D.</span></span>

-   <span data-ttu-id="47aa8-262">Les positions de vertex après découpage dans le rastériseur sont alignées sur le point fixe, afin de répartir uniformément la précision dans la zone RenderTarget.</span><span class="sxs-lookup"><span data-stu-id="47aa8-262">Post-clipped vertex positions in the rasterizer are snapped to fixed point, to uniformly distribute precision across the RenderTarget area.</span></span> <span data-ttu-id="47aa8-263">De nombreuses opérations de rastérisation, y compris l’élimination de visage comme exemple, se produisent sur des positions alignées à virgule fixe, tandis que d’autres opérations, telles que la configuration de l’interpolateur d’attribut, utilisent des positions qui ont été reconverties en virgule flottante à partir des positions alignées à virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="47aa8-263">Many rasterizer operations, including face culling as one example, occur on fixed point snapped positions, while other operations, such as attribute interpolator setup, use positions that have been converted back to floating point from the fixed point snapped positions.</span></span>
-   <span data-ttu-id="47aa8-264">Les coordonnées de texture pour les opérations d’échantillonnage sont alignées sur le point fixe (après avoir été mises à l’échelle en fonction de la taille de la texture), afin de répartir uniformément la précision dans l’espace de texture, en choisissant les emplacements/poids du robinet de filtre.</span><span class="sxs-lookup"><span data-stu-id="47aa8-264">Texture coordinates for sampling operations are snapped to fixed point (after being scaled by texture size), to uniformly distribute precision across texture space, in choosing filter tap locations/weights.</span></span> <span data-ttu-id="47aa8-265">Les valeurs de pondération sont reconverties en virgule flottante avant l’exécution de l’arithmétique de filtrage réelle.</span><span class="sxs-lookup"><span data-stu-id="47aa8-265">Weight values are converted back to floating point before actual filtering arithmetic is performed.</span></span>



<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="47aa8-266">Type de données source</span><span class="sxs-lookup"><span data-stu-id="47aa8-266">Source Data Type</span></span></th>
<th><span data-ttu-id="47aa8-267">Type de données de destination</span><span class="sxs-lookup"><span data-stu-id="47aa8-267">Destination Data Type</span></span></th>
<th><span data-ttu-id="47aa8-268">Règle de conversion</span><span class="sxs-lookup"><span data-stu-id="47aa8-268">Conversion Rule</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span data-ttu-id="47aa8-269">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-269">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-270">Entier à virgule fixe</span><span class="sxs-lookup"><span data-stu-id="47aa8-270">Fixed Point Integer</span></span></td>
<td><span data-ttu-id="47aa8-271">Voici la procédure générale de conversion d’un nombre à virgule flottante n en un entier à virgule fixe i. f, où i est le nombre de bits d’entier (signé) et f est le nombre de bits fractionnaires.</span><span class="sxs-lookup"><span data-stu-id="47aa8-271">The following is the general procedure for converting a floating point number n to a fixed point integer i.f, where i is the number of (signed) integer bits and f is the number of fractional bits.</span></span><br/>
<ul>
<li><span data-ttu-id="47aa8-272">Compute FixedMin =-2 ⁽ ⁱ ⁻ ¹ ⁾</span><span class="sxs-lookup"><span data-stu-id="47aa8-272">Compute FixedMin = -2⁽ⁱ⁻¹⁾</span></span></li>
<li><span data-ttu-id="47aa8-273">Compute FixedMax = 2 ⁽ ⁱ ⁻ ¹ ⁾-2<sup>(-f)</sup></span><span class="sxs-lookup"><span data-stu-id="47aa8-273">Compute FixedMax = 2⁽ⁱ⁻¹⁾ - 2<sup>(-f)</sup></span></span></li>
<li><span data-ttu-id="47aa8-274">Si n est un NaN, result = 0 ; Si n est + inf, résultat = FixedMax \* 2<sup>f</sup>; Si n est-inf, résultat = FixedMin \* 2<sup>f</sup></span><span class="sxs-lookup"><span data-stu-id="47aa8-274">If n is a NaN, result = 0; if n is +Inf, result = FixedMax*2<sup>f</sup>; if n is -Inf, result = FixedMin*2<sup>f</sup></span></span></li>
<li><span data-ttu-id="47aa8-275">Si n >= FixedMax, result = Fixedmax \* 2<sup>f</sup>; Si n <= FixedMin, result = FixedMin \* 2 <sup> f</span><span class="sxs-lookup"><span data-stu-id="47aa8-275">If n >= FixedMax, result = Fixedmax*2<sup>f</sup>; if n <= FixedMin, result = FixedMin*2<sup>f</span></span></sup></li>
<li><span data-ttu-id="47aa8-276">Sinon calcul n \* 2<sup>f</sup> et conversion en entier.</span><span class="sxs-lookup"><span data-stu-id="47aa8-276">Else compute n\*2<sup>f</sup> and convert to integer.</span></span></li>
</ul>
<span data-ttu-id="47aa8-277">Les implémentations sont autorisées sur D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP la tolérance d’unité de dernier placement dans le résultat de type entier, au lieu de la valeur infiniment précise n \* 2<sup>f</sup> après la dernière étape ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="47aa8-277">Implementations are permitted D3D<em>xx</em>_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP Unit-Last-Place tolerance in the integer result, instead of the infinitely precise value n\*2<sup>f</sup> after the last step above.</span></span><br/></td>
</tr>
<tr class="even">
<td><span data-ttu-id="47aa8-278">Entier à virgule fixe</span><span class="sxs-lookup"><span data-stu-id="47aa8-278">Fixed Point Integer</span></span></td>
<td><span data-ttu-id="47aa8-279">FLOAT</span><span class="sxs-lookup"><span data-stu-id="47aa8-279">FLOAT</span></span></td>
<td><span data-ttu-id="47aa8-280">Supposons que la représentation à virgule fixe spécifique qui est convertie en valeur float ne contient pas plus d’un total de 24 bits d’informations, pas plus de 23 bits de qui se trouve dans le composant fractionnaire.</span><span class="sxs-lookup"><span data-stu-id="47aa8-280">Assume that the specific fixed point representation being converted to float does not contain more than a total of 24 bits of information, no more than 23 bits of which is in the fractional component.</span></span> <span data-ttu-id="47aa8-281">Supposons qu’un nombre à virgule fixe donné, FXP, se trouve dans la forme i. f (l’entier i bits, la fraction f bits).</span><span class="sxs-lookup"><span data-stu-id="47aa8-281">Suppose a given fixed point number, fxp, is in i.f form (i bits integer, f bits fraction).</span></span> <span data-ttu-id="47aa8-282">La conversion en valeur float est similaire au pseudo-code suivant.</span><span class="sxs-lookup"><span data-stu-id="47aa8-282">The conversion to float is akin to the following pseudocode.</span></span><br/> <span data-ttu-id="47aa8-283">float Result = (float) (FXP >> f) +//extraire un entier</span><span class="sxs-lookup"><span data-stu-id="47aa8-283">float result = (float)(fxp >> f) + // extract integer</span></span><br/> <dl> <span data-ttu-id="47aa8-284">((float) (FXP & (2<sup>f</sup> - 1))/(2<sup>f</sup>));//extraire une fraction</span><span class="sxs-lookup"><span data-stu-id="47aa8-284">((float)(fxp & (2<sup>f</sup> - 1)) / (2<sup>f</sup>)); // extract fraction</span></span><br />
</dl></td>
</tr>
</tbody>
</table>



 

## <a name="related-topics"></a><span data-ttu-id="47aa8-285">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="47aa8-285">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="47aa8-286">Ressources (Direct3D 10)</span><span class="sxs-lookup"><span data-stu-id="47aa8-286">Resources (Direct3D 10)</span></span>](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 




