---
description: Windows Sockets 2 prend en charge les e/s avec chevauchement et tous les fournisseurs de transport prennent en charge cette fonctionnalité.
ms.assetid: b36ab606-df1a-4254-b048-6d47eb366275
title: Objets d’e/s et d’événement avec chevauchement
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ed034f06243959d94a1ada7eaa71e33c84cd35ee
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "106513220"
---
# <a name="overlapped-io-and-event-objects"></a><span data-ttu-id="d758f-103">Objets d’e/s et d’événement avec chevauchement</span><span class="sxs-lookup"><span data-stu-id="d758f-103">Overlapped I/O and Event Objects</span></span>

<span data-ttu-id="d758f-104">Windows Sockets 2 prend en charge les e/s avec chevauchement et tous les fournisseurs de transport prennent en charge cette fonctionnalité.</span><span class="sxs-lookup"><span data-stu-id="d758f-104">Windows Sockets 2 supports overlapped I/O and all transport providers support this capability.</span></span> <span data-ttu-id="d758f-105">Les e/s avec chevauchement suivent le modèle établi dans Windows et peuvent être exécutées sur les sockets créés avec la fonction de [**Socket**](/windows/desktop/api/Winsock2/nf-winsock2-socket) ou les sockets créés avec la fonction [**WSASocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsasocketa) avec l’indicateur de **\_ \_ chevauchement d’indicateur WSA** défini dans le paramètre *dwFlags* .</span><span class="sxs-lookup"><span data-stu-id="d758f-105">Overlapped I/O follows the model established in Windows and can be performed on sockets created with the [**socket**](/windows/desktop/api/Winsock2/nf-winsock2-socket) function or sockets created with the [**WSASocket**](/windows/desktop/api/Winsock2/nf-winsock2-wsasocketa) function with the **WSA\_FLAG\_OVERLAPPED** flag set in the *dwFlags* parameter.</span></span>

> [!Note]  
> <span data-ttu-id="d758f-106">La création d’un socket avec l’attribut Overlapped n’a aucun impact sur le fait qu’un socket est actuellement en mode blocage ou non bloquant.</span><span class="sxs-lookup"><span data-stu-id="d758f-106">Creating a socket with the overlapped attribute has no impact on whether a socket is currently in blocking or nonblocking mode.</span></span> <span data-ttu-id="d758f-107">Les sockets créés avec l’attribut Overlapped peuvent être utilisés pour effectuer des e/s avec chevauchement, ce qui ne modifie pas le mode de blocage d’un Socket.</span><span class="sxs-lookup"><span data-stu-id="d758f-107">Sockets created with the overlapped attribute can be used to perform overlapped I/O—doing so does not change the blocking mode of a socket.</span></span> <span data-ttu-id="d758f-108">Étant donné que les opérations d’e/s avec chevauchement ne sont pas bloquées, le mode de blocage d’un socket n’est pas pertinent pour ces opérations.</span><span class="sxs-lookup"><span data-stu-id="d758f-108">Since overlapped I/O operations do not block, the blocking mode of a socket is irrelevant for these operations.</span></span>

 

<span data-ttu-id="d758f-109">Pour la réception, les applications utilisent les fonctions [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) ou [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom) pour fournir des mémoires tampons dans lesquelles les données doivent être reçues.</span><span class="sxs-lookup"><span data-stu-id="d758f-109">For receiving, applications use the [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) or [**WSARecvFrom**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom) functions to supply buffers into which data is to be received.</span></span> <span data-ttu-id="d758f-110">Si une ou plusieurs mémoires tampons sont publiées avant le moment où les données ont été reçues par le réseau, ces données peuvent être placées dans les tampons de l’utilisateur dès qu’elles arrivent.</span><span class="sxs-lookup"><span data-stu-id="d758f-110">If one or more buffers are posted prior to the time when data has been received by the network, that data could be placed in the user's buffers immediately as it arrives.</span></span> <span data-ttu-id="d758f-111">Ainsi, il peut éviter l’opération de copie qui, autrement, se produirait au moment de l’appel de la fonction [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) ou [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom) .</span><span class="sxs-lookup"><span data-stu-id="d758f-111">Thus, it can avoid the copy operation that would otherwise occur at the time the [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) or [**recvfrom**](/windows/desktop/api/winsock/nf-winsock-recvfrom) function is invoked.</span></span> <span data-ttu-id="d758f-112">Si des données sont déjà présentes lors de la publication des tampons de réception, elles sont copiées immédiatement dans les tampons de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="d758f-112">If data is already present when receive buffers are posted, it is copied immediately into the user's buffers.</span></span>

<span data-ttu-id="d758f-113">Si des données arrivent quand aucune mémoire tampon de réception n’a été publiée par l’application, le réseau passe au style de fonctionnement synchrone familier.</span><span class="sxs-lookup"><span data-stu-id="d758f-113">If data arrives when no receive buffers have been posted by the application, the network resorts to the familiar synchronous style of operation.</span></span> <span data-ttu-id="d758f-114">Autrement dit, les données entrantes sont mises en mémoire tampon jusqu’à ce que l’application envoie un appel de réception et fournit ainsi une mémoire tampon dans laquelle les données peuvent être copiées.</span><span class="sxs-lookup"><span data-stu-id="d758f-114">That is, the incoming data is buffered internally until the application issues a receive call and thereby supplies a buffer into which the data can be copied.</span></span> <span data-ttu-id="d758f-115">Une exception est quand l’application utilise [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) pour définir la taille de la mémoire tampon de réception sur zéro.</span><span class="sxs-lookup"><span data-stu-id="d758f-115">An exception to this is when the application uses [**setsockopt**](/windows/desktop/api/winsock/nf-winsock-setsockopt) to set the size of the receive buffer to zero.</span></span> <span data-ttu-id="d758f-116">Dans ce cas, les protocoles Reliable autorisent uniquement la réception des données lorsque les tampons d’application ont été publiés et la perte des données sur les protocoles non fiables.</span><span class="sxs-lookup"><span data-stu-id="d758f-116">In this instance, reliable protocols would only allow data to be received when application buffers had been posted and data on unreliable protocols would be lost.</span></span>

<span data-ttu-id="d758f-117">Du côté de l’envoi, les applications utilisent [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) ou [**WSASendTo**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto) pour fournir des pointeurs aux mémoires tampons remplies, puis décident de ne pas perturber les tampons jusqu’à ce que le réseau ait consommé le contenu de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="d758f-117">On the sending side, applications use [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend) or [**WSASendTo**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto) to supply pointers to filled buffers and then agree not to disturb the buffers in any way until the network has consumed the buffer's contents.</span></span>

<span data-ttu-id="d758f-118">Les appels d’envoi et de réception superposés sont retournés immédiatement.</span><span class="sxs-lookup"><span data-stu-id="d758f-118">Overlapped send and receive calls return immediately.</span></span> <span data-ttu-id="d758f-119">Une valeur de retour égale à zéro indique que l’opération d’e/s a été effectuée immédiatement et que l’indication d’achèvement correspondante a déjà eu lieu.</span><span class="sxs-lookup"><span data-stu-id="d758f-119">A return value of zero indicates that the I/O operation was completed immediately and that the corresponding completion indication already occurred.</span></span> <span data-ttu-id="d758f-120">Autrement dit, l’objet événement associé a été signalé, ou une routine de saisie semi-automatique a été mise en file d’attente et sera exécutée lorsque le thread appelant passera à l’état d’attente de l’alerte.</span><span class="sxs-lookup"><span data-stu-id="d758f-120">That is, the associated event object has been signaled, or a completion routine has been queued and will be executed when the calling thread gets into the alertable wait state.</span></span>

<span data-ttu-id="d758f-121">Une valeur de retour de \_ l’erreur de socket couplée avec un code d’erreur d' [ \_ e/s de WSA \_ en attente](windows-sockets-error-codes-2.md) indique que l’opération avec chevauchement a été lancée avec succès et qu’une indication suivante sera fournie quand les mémoires tampons d’envoi ont été consommées ou lorsqu’une opération de réception a été effectuée.</span><span class="sxs-lookup"><span data-stu-id="d758f-121">A return value of SOCKET\_ERROR coupled with an error code of [WSA\_IO\_PENDING](windows-sockets-error-codes-2.md) indicates that the overlapped operation has been successfully initiated and that a subsequent indication will be provided when send buffers have been consumed or when a receive operation has been completed.</span></span> <span data-ttu-id="d758f-122">Toutefois, pour les sockets qui sont du style de flux d’octets, l’indication de saisie semi-automatique se produit chaque fois que les données entrantes sont épuisées, que les mémoires tampons soient pleines ou non.</span><span class="sxs-lookup"><span data-stu-id="d758f-122">However, for sockets that are byte-stream style, the completion indication occurs whenever the incoming data is exhausted, regardless of whether the buffers are full.</span></span> <span data-ttu-id="d758f-123">Tout autre code d’erreur indique que l’opération avec chevauchement n’a pas été lancée avec succès et qu’aucune indication d’achèvement n’est à venir.</span><span class="sxs-lookup"><span data-stu-id="d758f-123">Any other error code indicates that the overlapped operation was not successfully initiated and that no completion indication will be forthcoming.</span></span>

<span data-ttu-id="d758f-124">Les opérations d’envoi et de réception peuvent être superposées.</span><span class="sxs-lookup"><span data-stu-id="d758f-124">Both send and receive operations can be overlapped.</span></span> <span data-ttu-id="d758f-125">Les fonctions Receive peuvent être appelées plusieurs fois pour poster des tampons de réception en vue de la préparation des données entrantes, et les fonctions Send peuvent être appelées plusieurs fois pour mettre en file d’attente plusieurs mémoires tampons à envoyer.</span><span class="sxs-lookup"><span data-stu-id="d758f-125">The receive functions can be invoked several times to post receive buffers in preparation for incoming data, and the send functions can be invoked several times to queue multiple buffers to send.</span></span> <span data-ttu-id="d758f-126">Alors que l’application peut reposer sur une série de mémoires tampons d’envoi avec chevauchement envoyées dans l’ordre indiqué, les indications d’achèvement correspondantes peuvent se produire dans un ordre différent.</span><span class="sxs-lookup"><span data-stu-id="d758f-126">While the application can rely upon a series of overlapped send buffers being sent in the order supplied, the corresponding completion indications might occur in a different order.</span></span> <span data-ttu-id="d758f-127">De même, du côté de la réception, les tampons peuvent être remplis dans l’ordre dans lequel ils sont fournis, mais les indications de saisie semi-automatique peuvent se produire dans un ordre différent.</span><span class="sxs-lookup"><span data-stu-id="d758f-127">Likewise, on the receiving side, buffers can be filled in the order they are supplied, but the completion indications might occur in a different order.</span></span>

<span data-ttu-id="d758f-128">Dans de nombreux cas, les opérations de chevauchement Winsock utilisant [**accepted**](/windows/win32/api/mswsock/nf-mswsock-acceptex), [**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex), [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend), [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv), [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile)et des fonctions similaires peuvent être annulées.</span><span class="sxs-lookup"><span data-stu-id="d758f-128">In many cases, Winsock overlapped operations using [**AcceptEx**](/windows/win32/api/mswsock/nf-mswsock-acceptex), [**ConnectEx**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex), [**WSASend**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend), [**WSARecv**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv), [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile), and similar functions are cancelable.</span></span> <span data-ttu-id="d758f-129">Toutefois, le comportement n’est pas défini pour l’utilisation continue d’un socket qui a annulé des opérations en suspens.</span><span class="sxs-lookup"><span data-stu-id="d758f-129">However, behavior is undefined for the continued use of a socket that has canceled outstanding operations.</span></span> <span data-ttu-id="d758f-130">La fonction [**opération closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) doit être appelée après l’annulation d’une opération avec chevauchement.</span><span class="sxs-lookup"><span data-stu-id="d758f-130">The [**closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket) function should be called after canceling an overlapped operation.</span></span> <span data-ttu-id="d758f-131">Par conséquent, pour des résultats optimaux, au lieu d’annuler directement les e/s, la fonction **opération closesocket** doit être appelée pour fermer le socket qui finit par cesser toutes les opérations en attente.</span><span class="sxs-lookup"><span data-stu-id="d758f-131">Therefore, for best results, instead of canceling the I/O directly, the **closesocket** function should be called to close the socket which will eventually discontinue all pending operations.</span></span>

<span data-ttu-id="d758f-132">La fonctionnalité d’achèvement différé des e/s avec chevauchement est également disponible pour [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl), qui est une version améliorée de [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket).</span><span class="sxs-lookup"><span data-stu-id="d758f-132">The deferred completion feature of overlapped I/O is also available for [**WSAIoctl**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl), which is an enhanced version of [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket).</span></span>

 

 
