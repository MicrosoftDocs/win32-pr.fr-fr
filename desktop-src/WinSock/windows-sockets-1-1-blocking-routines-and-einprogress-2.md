---
description: Un problème majeur dans le portage d’applications à partir d’un environnement de sockets Berkeley vers un environnement Windows implique un blocage ; autrement dit, l’appel d’une fonction qui ne retourne pas tant que l’opération associée n’est pas terminée.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Routines de blocage Windows Sockets 1,1 et EINPROGRESS
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "106544729"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a><span data-ttu-id="d6ba7-103">Routines de blocage Windows Sockets 1,1 et EINPROGRESS</span><span class="sxs-lookup"><span data-stu-id="d6ba7-103">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</span></span>

<span data-ttu-id="d6ba7-104">Un problème majeur dans le portage d’applications à partir d’un environnement de sockets Berkeley vers un environnement Windows implique un blocage ; autrement dit, l’appel d’une fonction qui ne retourne pas tant que l’opération associée n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-104">One major issue in porting applications from a Berkeley Sockets environment to a Windows environment involves blocking; that is, invoking a function that does not return until the associated operation is completed.</span></span> <span data-ttu-id="d6ba7-105">Un problème survient lorsque l’opération prend un temps arbitrairement long : il s’agit par exemple d’une fonction [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) , qui peut se bloquer jusqu’à ce que des données soient reçues du système homologue.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-105">A problem arises when the operation takes an arbitrarily long time to complete: an example is a [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) function, which might block until data has been received from the peer system.</span></span> <span data-ttu-id="d6ba7-106">Le comportement par défaut dans le modèle de sockets Berkeley est qu’un socket fonctionne en mode blocage, sauf si le programmeur demande explicitement que les opérations soient traitées comme non bloquantes.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-106">The default behavior within the Berkeley Sockets model is for a socket to operate in blocking mode unless the programmer explicitly requests that operations be treated as nonblocking.</span></span> <span data-ttu-id="d6ba7-107">Les environnements Windows Sockets 1,1 n’ont pas pu supposer la planification préemptive.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-107">Windows Sockets 1.1 environments could not assume preemptive scheduling.</span></span> <span data-ttu-id="d6ba7-108">Par conséquent, il est fortement recommandé que les programmeurs utilisent les opérations non bloquantes (asynchrones) si possible avec Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-108">Therefore, it was strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible with Windows Sockets 1.1.</span></span> <span data-ttu-id="d6ba7-109">Comme cela n’était pas toujours possible, les fonctionnalités de Pseudo-blocage décrites dans les éléments suivants ont été fournies.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-109">Because this was not always possible, the pseudo-blocking facilities described in the following were provided.</span></span>

> [!Note]  
> <span data-ttu-id="d6ba7-110">Windows Sockets 2 s’exécute uniquement sur les systèmes d’exploitation préemptif 32 bits où les blocages ne constituent pas un problème.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-110">Windows Sockets 2 only runs on preemptive 32-bit operating systems where deadlocks are not a problem.</span></span> <span data-ttu-id="d6ba7-111">Les pratiques de programmation recommandées pour Windows Sockets 1,1 ne sont pas nécessaires dans Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-111">Programming practices recommended for Windows Sockets 1.1 are not necessary in Windows Sockets 2.</span></span>

 

<span data-ttu-id="d6ba7-112">Même sur un socket bloquant, certaines fonctions ( [**Bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt)et [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) , par exemple) se terminent immédiatement.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-112">Even on a blocking socket, some functions — [**bind**](/windows/desktop/api/winsock/nf-winsock-bind), [**getsockopt**](/windows/desktop/api/winsock/nf-winsock-getsockopt), and [**getpeername**](/windows/desktop/api/winsock/nf-winsock-getpeername) for example — complete immediately.</span></span> <span data-ttu-id="d6ba7-113">Il n’existe aucune différence entre un blocage et une opération de non-blocage pour ces fonctions.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-113">There is no difference between a blocking and a nonblocking operation for those functions.</span></span> <span data-ttu-id="d6ba7-114">D’autres opérations, telles que [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), peuvent se terminer immédiatement ou prendre une heure arbitraire, en fonction de différentes conditions de transport.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-114">Other operations, such as [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), can complete immediately or take an arbitrary time to complete, depending on various transport conditions.</span></span> <span data-ttu-id="d6ba7-115">En cas d’application à un socket bloquant, ces opérations sont appelées « opérations bloquantes ».</span><span class="sxs-lookup"><span data-stu-id="d6ba7-115">When applied to a blocking socket, these operations are referred to as blocking operations.</span></span> <span data-ttu-id="d6ba7-116">Les fonctions suivantes peuvent bloquer :</span><span class="sxs-lookup"><span data-stu-id="d6ba7-116">The following functions can block:</span></span>

-   [<span data-ttu-id="d6ba7-117">**reçu**</span><span class="sxs-lookup"><span data-stu-id="d6ba7-117">**recv**</span></span>](/windows/desktop/api/winsock/nf-winsock-recv)
-   [<span data-ttu-id="d6ba7-118">**recvfrom**</span><span class="sxs-lookup"><span data-stu-id="d6ba7-118">**recvfrom**</span></span>](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [<span data-ttu-id="d6ba7-119">**Envoyer**</span><span class="sxs-lookup"><span data-stu-id="d6ba7-119">**send**</span></span>](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [<span data-ttu-id="d6ba7-120">**SendTo**</span><span class="sxs-lookup"><span data-stu-id="d6ba7-120">**sendto**</span></span>](/windows/desktop/api/winsock/nf-winsock-sendto)

<span data-ttu-id="d6ba7-121">Avec Windows Sockets 16 bits 1,1, une opération de blocage qui ne peut pas se terminer immédiatement est gérée par le Pseudo-blocage comme suit.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-121">With 16-bit Windows Sockets 1.1, a blocking operation that cannot complete immediately is handled by pseudo-blocking as follows.</span></span>

<span data-ttu-id="d6ba7-122">Le fournisseur de services lance l’opération, puis entre une boucle dans laquelle il distribue les messages Windows (ce qui produit le processeur à un autre thread, si nécessaire), puis vérifie la fin de la fonction Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-122">The service provider initiates the operation, then enters a loop in which it dispatches any Windows messages (yielding the processor to another thread, if necessary), and then checks for the completion of the Windows Sockets function.</span></span> <span data-ttu-id="d6ba7-123">Si la fonction est terminée ou si [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) a été appelé, la fonction de blocage se termine avec un résultat approprié.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-123">If the function has completed, or if [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) has been invoked, the blocking function completes with an appropriate result.</span></span>

<span data-ttu-id="d6ba7-124">Un fournisseur de services doit autoriser l’installation d’une fonction de raccordement bloquant qui ne traite pas les messages afin d’éviter la possibilité de réacheminer les messages pendant qu’une opération de blocage est en attente.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-124">A service provider must allow installation of a blocking hook function that does not process messages in order to avoid the possibility of re-entrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="d6ba7-125">La fonction de raccordement de blocage la plus simple retourne **false**.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-125">The simplest such blocking hook function would return **FALSE**.</span></span> <span data-ttu-id="d6ba7-126">Si une DLL Windows Sockets dépend de messages pour une opération interne, elle peut exécuter **PeekMessage**(**hMyWnd**...) avant d’exécuter le hook de blocage d’application afin qu’elle puisse obtenir ses messages sans affecter le reste du système.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-126">If a Windows Sockets DLL depends on messages for internal operation, it can execute **PeekMessage**(**hMyWnd**...) before executing the application blocking hook so that it can get its messages without affecting the rest of the system.</span></span>

<span data-ttu-id="d6ba7-127">Dans un environnement Windows Sockets 1,1 16 bits, si un message Windows est reçu pour un processus pour lequel une opération de blocage est en cours, il existe un risque que l’application tente d’émettre un autre appel Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-127">In a 16-bit Windows Sockets 1.1 environment, if a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.</span></span> <span data-ttu-id="d6ba7-128">En raison de la difficulté à gérer cette condition en toute sécurité, Windows Sockets 1,1 ne prend pas en charge ce comportement d’application.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-128">Because of the difficulty in managing this condition safely, Windows Sockets 1.1 does not support such application behavior.</span></span> <span data-ttu-id="d6ba7-129">Une application n’est pas autorisée à effectuer plusieurs appels de fonction Windows Sockets imbriqués.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-129">An application is not permitted to make more than one nested Windows Sockets function call.</span></span> <span data-ttu-id="d6ba7-130">Un seul appel de fonction en suspens est autorisé pour une tâche particulière.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-130">Only one outstanding function call is allowed for a particular task.</span></span> <span data-ttu-id="d6ba7-131">Les seules exceptions sont les deux fonctions fournies pour aider le programmeur dans cette situation : [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) et [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span><span class="sxs-lookup"><span data-stu-id="d6ba7-131">The only exceptions are two functions that are provided to assist the programmer in this situation: [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) and [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).</span></span>

<span data-ttu-id="d6ba7-132">La fonction [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) peut être appelée à tout moment pour déterminer si un appel de blocage de Windows sockets 1,1 est en cours.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-132">The [**WSAIsBlocking**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) function can be called at any time to determine whether or not a blocking Windows Sockets 1.1 call is in progress.</span></span> <span data-ttu-id="d6ba7-133">De même, la fonction [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) peut être appelée à tout moment pour annuler un appel bloquant en cours.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-133">Similarly, the [**WSACancelBlockingCall**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) function can be called at any time to cancel an in-progress blocking call.</span></span> <span data-ttu-id="d6ba7-134">Toute autre imbrication de fonctions Windows Sockets échoue avec l’erreur WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-134">Any other nesting of Windows Sockets functions fails with the error WSAEINPROGRESS.</span></span>

<span data-ttu-id="d6ba7-135">Il convient de souligner que cette restriction s’applique aux opérations de blocage et de non-blocage.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-135">It should be emphasized that this restriction applies to both blocking and nonblocking operations.</span></span> <span data-ttu-id="d6ba7-136">Pour les applications Windows Sockets 2 qui négocient la version 2,0 ou une version ultérieure au moment de l’appel de [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), aucune restriction sur l’imbrication des opérations ne se termine.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-136">For Windows Sockets 2 applications that negotiate version 2.0 or higher at the time of calling [**WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), no restriction on the nesting of operations exits.</span></span> <span data-ttu-id="d6ba7-137">Les opérations peuvent devenir imbriquées dans de rares circonstances, par exemple pendant un rappel d’acceptation conditionnelle [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , ou si un fournisseur de services appelle à son tour une fonction Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-137">Operations can become nested under rare circumstances, such as during a [**WSAAccept**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) conditional-acceptance callback, or if a service provider in turn invokes a Windows Sockets 2 function.</span></span>

<span data-ttu-id="d6ba7-138">Bien que ce mécanisme soit suffisant pour les applications simples, il ne peut pas prendre en charge les exigences complexes de distribution des messages des applications plus avancées (par exemple, celles utilisant le modèle MDI).</span><span class="sxs-lookup"><span data-stu-id="d6ba7-138">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).</span></span> <span data-ttu-id="d6ba7-139">Pour de telles applications, l’API Windows Sockets comprend la fonction [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), qui permet à l’application de spécifier une routine spéciale qui peut être appelée à la place de la routine de distribution de messages par défaut décrite dans la discussion précédente.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-139">For such applications, the Windows Sockets API includes the function [**WSASetBlockingHook**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), which allows the application to specify a special routine which can be called instead of the default message dispatch routine described in the preceding discussion.</span></span>

<span data-ttu-id="d6ba7-140">Le fournisseur Windows Sockets appelle le hook de blocage uniquement si toutes les conditions suivantes sont vraies :</span><span class="sxs-lookup"><span data-stu-id="d6ba7-140">The Windows Sockets provider calls the blocking hook only if all of the following are true:</span></span>

-   <span data-ttu-id="d6ba7-141">La routine est une routine qui est définie comme pouvant être bloquée.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-141">The routine is one that is defined as being able to block.</span></span>
-   <span data-ttu-id="d6ba7-142">Le socket spécifié est un socket bloquant.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-142">The specified socket is a blocking socket.</span></span>
-   <span data-ttu-id="d6ba7-143">La demande ne peut pas être effectuée immédiatement.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-143">The request cannot be completed immediately.</span></span>

<span data-ttu-id="d6ba7-144">Un socket est défini comme bloquant par défaut, mais la fonction [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) avec l’IOCTL **FIONBIO** ou la fonction [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) peut définir un socket en mode non bloquant.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-144">A socket is set to blocking by default, but the [**ioctlsocket**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) function with the **FIONBIO** IOCTL or the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) function can set a socket to nonblocking mode.</span></span>

<span data-ttu-id="d6ba7-145">Le hook de blocage n’est jamais appelé et l’application n’a pas besoin de se préoccuper des problèmes de réentrance que le hook de blocage peut introduire, si une application respecte les instructions suivantes :</span><span class="sxs-lookup"><span data-stu-id="d6ba7-145">The blocking hook is never called and the application does not need to be concerned with the re-entrancy issues the blocking hook can introduce, if an application follows these guidelines:</span></span>

-   <span data-ttu-id="d6ba7-146">Elle utilise uniquement des sockets non bloquants.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-146">It uses only nonblocking sockets.</span></span>
-   <span data-ttu-id="d6ba7-147">Elle utilise les routines [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) et/ou **WSAAsyncGetXByY** au lieu de [**Select**](/windows/desktop/api/Winsock2/nf-winsock2-select) et des routines **getXbyY** .</span><span class="sxs-lookup"><span data-stu-id="d6ba7-147">It uses the [**WSAAsyncSelect**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) and/or the **WSAAsyncGetXByY** routines instead of [**select**](/windows/desktop/api/Winsock2/nf-winsock2-select) and the **getXbyY** routines.</span></span>

<span data-ttu-id="d6ba7-148">Si une application Windows Sockets 1,1 appelle une opération asynchrone ou non bloquante qui prend un pointeur vers un objet mémoire (une mémoire tampon ou une variable globale, par exemple) en tant qu’argument, il est de la responsabilité de l’application de s’assurer que l’objet est disponible pour Windows Sockets tout au long de l’opération.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-148">If a Windows Sockets 1.1 application invokes an asynchronous or nonblocking operation that takes a pointer to a memory object (a buffer or a global variable, for example) as an argument, it is the responsibility of the application to ensure that the object is available to Windows Sockets throughout the operation.</span></span> <span data-ttu-id="d6ba7-149">L’application ne doit pas appeler de fonction Windows susceptible d’affecter le mappage ou la viabilité de la mémoire impliquée.</span><span class="sxs-lookup"><span data-stu-id="d6ba7-149">The application must not invoke any Windows function that might affect the mapping or address viability of the memory involved.</span></span>

 

 



