---
description: Bien que ce mécanisme soit suffisant pour les applications simples, il ne peut pas prendre en charge les exigences complexes de distribution des messages des applications plus avancées, telles que celles utilisant le modèle d’interface multidocument (MDI, multiple document interface).
ms.assetid: e4558e71-bbec-415a-a7c2-9025a4d6c474
title: Crochet bloquant
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2dcd098692784a662456c990a238bd309db0c321
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "106513229"
---
# <a name="blocking-hook"></a><span data-ttu-id="8c29b-103">Crochet bloquant</span><span class="sxs-lookup"><span data-stu-id="8c29b-103">Blocking Hook</span></span>

<span data-ttu-id="8c29b-104">Bien que ce mécanisme soit suffisant pour les applications simples, il ne peut pas prendre en charge les exigences complexes de distribution des messages des applications plus avancées, telles que celles utilisant le modèle d’interface multidocument (MDI, multiple document interface).</span><span class="sxs-lookup"><span data-stu-id="8c29b-104">Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications such as those using the Multiple Document Interface (MDI) model.</span></span> <span data-ttu-id="8c29b-105">Pour ces applications, un raccordement bloquant propre au thread peut être installé par l’application.</span><span class="sxs-lookup"><span data-stu-id="8c29b-105">For such applications, a thread-specific blocking hook may be installed by the application.</span></span> <span data-ttu-id="8c29b-106">Ce sera appelé par le fournisseur de services au lieu du hook de blocage par défaut décrit dans le précédent.</span><span class="sxs-lookup"><span data-stu-id="8c29b-106">This will be called by the service provider instead of the default blocking hook described in the preceding.</span></span> <span data-ttu-id="8c29b-107">Un fournisseur de services doit récupérer un pointeur vers le hook de blocage par thread à partir de la \_32.dll Ws2 en appelant [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span><span class="sxs-lookup"><span data-stu-id="8c29b-107">A service provider must retrieve a pointer to the per-thread blocking hook from the Ws2\_32.dll by calling [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback).</span></span> <span data-ttu-id="8c29b-108">Si l’application n’a pas installé son propre raccordement de blocage, un pointeur vers la fonction de raccordement de blocage par défaut sera retourné.</span><span class="sxs-lookup"><span data-stu-id="8c29b-108">If the application has not installed its own blocking hook a pointer to the default blocking hook function will be returned.</span></span>

<span data-ttu-id="8c29b-109">Un fournisseur de services Windows Sockets ne peut pas supposer qu’un raccordement bloquant fourni par l’application permet au traitement des messages de continuer comme le hook de blocage par défaut.</span><span class="sxs-lookup"><span data-stu-id="8c29b-109">A Windows Sockets service provider cannot assume that an application-supplied blocking hook allows message processing to continue as the default blocking hook does.</span></span> <span data-ttu-id="8c29b-110">Certaines applications ne peuvent pas tolérer la possibilité de réentrant des messages pendant qu’une opération de blocage est en attente.</span><span class="sxs-lookup"><span data-stu-id="8c29b-110">Some applications cannot tolerate the possibility of reentrant messages while a blocking operation is outstanding.</span></span> <span data-ttu-id="8c29b-111">Une telle fonction de raccordement de blocage de l’application retourne simplement la **valeur false**.</span><span class="sxs-lookup"><span data-stu-id="8c29b-111">Such an application's blocking hook function would simply return **FALSE**.</span></span> <span data-ttu-id="8c29b-112">Si un fournisseur de services dépend des messages pour son fonctionnement interne, il peut exécuter **PeekMessage**(hMyWnd...) avant d’exécuter le hook de blocage de l’application afin qu’il puisse obtenir ses propres messages sans affecter le reste du système.</span><span class="sxs-lookup"><span data-stu-id="8c29b-112">If a service provider depends on messages for its internal operation, it may execute **PeekMessage**(hMyWnd...) before executing the application's blocking hook so that it can get its own messages without affecting the rest of the system.</span></span>

<span data-ttu-id="8c29b-113">Aucun hook de blocage par défaut n’est installé dans les versions préemptif multithread de Windows.</span><span class="sxs-lookup"><span data-stu-id="8c29b-113">There is no default blocking hook installed in preemptive multithreaded versions of Windows.</span></span> <span data-ttu-id="8c29b-114">En effet, les autres processus ne sont pas bloqués si une seule application attend la fin d’une opération (et n’appelle donc pas **PeekMessage** ou **GetMessage** , ce qui amène l’application à générer le processeur dans Windows non préemptif).</span><span class="sxs-lookup"><span data-stu-id="8c29b-114">This is because other processes will not be blocked if a single application is waiting for an operation to complete (and hence not calling **PeekMessage** or **GetMessage** which causes the application to yield the processor in nonpreemptive Windows).</span></span> <span data-ttu-id="8c29b-115">Lorsque le fournisseur de services appelle [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) , un pointeur null est retourné, indiquant que le fournisseur doit utiliser des fonctions de blocage du système d’exploitation natives.</span><span class="sxs-lookup"><span data-stu-id="8c29b-115">When the service provider calls [**WPUQueryBlockingCallback**](/windows/desktop/api/Ws2spi/nf-ws2spi-wpuqueryblockingcallback) a null pointer will be returned indicating that the provider is to use native operating system blocking functions.</span></span> <span data-ttu-id="8c29b-116">Toutefois, pour préserver la compatibilité descendante, un raccordement de blocage fourni par l’application peut toujours être installé sur une base par thread dans Windows.</span><span class="sxs-lookup"><span data-stu-id="8c29b-116">However, in order to preserve backward compatibility, an application-supplied blocking hook can still be installed on a per-thread basis in Windows.</span></span>

<span data-ttu-id="8c29b-117">Le fournisseur de services Winsock appelle le hook de blocage uniquement si tous les éléments suivants sont vrais : la routine est définie comme étant capable de bloquer, le socket spécifié est un socket bloquant et la demande ne peut pas être effectuée immédiatement.</span><span class="sxs-lookup"><span data-stu-id="8c29b-117">The Winsock service provider calls the blocking hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.</span></span> <span data-ttu-id="8c29b-118">Si seuls les sockets non bloquants et [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85)) / [**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) au lieu de [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) sont utilisés, le hook de blocage ne sera jamais appelé.</span><span class="sxs-lookup"><span data-stu-id="8c29b-118">If only nonblocking sockets and [**WSPAsyncSelect**](/previous-versions/windows/desktop/legacy/ms742267(v=vs.85))/[**WSPEventSelect**](/previous-versions/windows/hardware/network/ff566287(v=vs.85)) instead of [**WSPSelect**](/previous-versions/windows/desktop/legacy/ms742289(v=vs.85)) are used, then the blocking hook will never be called.</span></span>

> [!Note]  
> <span data-ttu-id="8c29b-119">Si, pendant l’utilisation de pseudoblocking pour bloquer un thread, un message Windows est reçu pour le thread, il existe un risque que le thread tente d’émettre un autre appel Winsock.</span><span class="sxs-lookup"><span data-stu-id="8c29b-119">If, during the time pseudoblocking is being used to block a thread, a Windows message is received for the thread, there is a risk that the thread will attempt to issue another Winsock call.</span></span> <span data-ttu-id="8c29b-120">En raison de la difficulté de gérer cette condition de manière sécurisée, la spécification de Windows Sockets 1,1 n’autorise pas ce comportement.</span><span class="sxs-lookup"><span data-stu-id="8c29b-120">Because of the difficulty of managing this condition safely, the Windows Sockets 1.1 specification disallowed this behavior.</span></span> <span data-ttu-id="8c29b-121">Il n’est pas possible pour un thread donné d’effectuer plusieurs appels de fonction Winsock imbriqués.</span><span class="sxs-lookup"><span data-stu-id="8c29b-121">It is not permissible for a given thread to make multiple, nested Winsock function calls.</span></span> <span data-ttu-id="8c29b-122">Un seul appel de fonction en suspens est autorisé pour un thread particulier.</span><span class="sxs-lookup"><span data-stu-id="8c29b-122">Only one outstanding function call is allowed for a particular thread.</span></span> <span data-ttu-id="8c29b-123">Les appels de fonction Winsock imbriqués échouent avec l’erreur WSAEINPROGRESS.</span><span class="sxs-lookup"><span data-stu-id="8c29b-123">Any nested Winsock function calls fail with the error WSAEINPROGRESS.</span></span> <span data-ttu-id="8c29b-124">Il convient de souligner que cette restriction s’applique aux opérations de blocage et de non-blocage, mais uniquement dans les environnements Windows Sockets 1,1.</span><span class="sxs-lookup"><span data-stu-id="8c29b-124">It should be emphasized that this restriction applies to both blocking and nonblocking operations, but only in Windows Sockets 1.1 environments.</span></span> <span data-ttu-id="8c29b-125">Il existe quelques exceptions à cette règle, y compris deux fonctions qui permettent à une application de déterminer si une opération de pseudoblocking est en cours, et d’annuler une telle opération si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="8c29b-125">There are a few exceptions to this rule, including two functions that allow an application to determine whether a pseudoblocking operation is in fact in progress, and to cancel such an operation if need be.</span></span> <span data-ttu-id="8c29b-126">Celles-ci sont décrites dans les rubriques suivantes.</span><span class="sxs-lookup"><span data-stu-id="8c29b-126">These are described in the following.</span></span>

 

 

 
