---
title: Différences entre les implémentations de fichiers composés et autonomes
description: L’implémentation autonome des interfaces de jeu de propriétés et l’implémentation des fichiers composés diffèrent d’une certaine manière.
ms.assetid: 650d4759-a58a-47a4-922d-5757e356cf56
keywords:
- IPropertyStorage Strctd STG, implémentations
- IPropertyStorage Strctd STG, implémentations, différences
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 988f8a9cfdaca0a131bedf98cd8ff10ae8b89525
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "103839830"
---
# <a name="differences-between-stand-alone-and-compound-file-implementations"></a><span data-ttu-id="95f42-105">Différences entre les implémentations de fichiers composés et autonomes</span><span class="sxs-lookup"><span data-stu-id="95f42-105">Differences between Stand-alone and Compound File Implementations</span></span>

<span data-ttu-id="95f42-106">L’implémentation autonome des interfaces de jeu de propriétés et l’implémentation des fichiers composés diffèrent d’une certaine manière.</span><span class="sxs-lookup"><span data-stu-id="95f42-106">The stand-alone implementation of the property set interfaces and the compound file implementation differ in some ways.</span></span> <span data-ttu-id="95f42-107">Dans l’implémentation de fichier composé de flux, stockage, stockage de jeu de propriétés et objets de stockage de propriétés, les différentes interfaces coordonnent les unes avec les autres, car elles partagent une implémentation commune.</span><span class="sxs-lookup"><span data-stu-id="95f42-107">In the compound-file implementation of stream, storage, property set storage, and property storage objects, the various interfaces coordinate with each another because they share a common implementation.</span></span> <span data-ttu-id="95f42-108">Dans l’implémentation autonome, les implémentations d’interface sont distinctes.</span><span class="sxs-lookup"><span data-stu-id="95f42-108">In the stand-alone implementation, the interface implementations are distinct.</span></span>

<span data-ttu-id="95f42-109">Par conséquent, l’implémentation de fichier composé gère les problèmes d’accès concurrentiel et synchronise l’objet de jeu de propriétés avec l’objet de stockage ou de flux.</span><span class="sxs-lookup"><span data-stu-id="95f42-109">As a result, the compound-file implementation handles concurrency issues and synchronizes the property set object with the storage or stream object.</span></span> <span data-ttu-id="95f42-110">Avec l’implémentation autonome, le client est responsable de la gestion de l’accès concurrentiel et des problèmes de synchronisation entre l’objet de stockage ou de flux et le jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="95f42-110">With the stand-alone implementation, the client is responsible for handling concurrency and synchronization issues between the storage or stream object and the property set.</span></span> <span data-ttu-id="95f42-111">Un client peut répondre à ces exigences en suivant deux règles simples.</span><span class="sxs-lookup"><span data-stu-id="95f42-111">A client can meet these requirements by following two simple rules.</span></span> <span data-ttu-id="95f42-112">Tout d’abord, ne manipulez jamais un jeu de propriétés à l’aide de son flux ou de ses interfaces de stockage lorsqu’un objet de stockage de propriétés est ouvert dessus.</span><span class="sxs-lookup"><span data-stu-id="95f42-112">First, never manipulate a property set using its stream or storage interfaces while a property storage object is open on it.</span></span> <span data-ttu-id="95f42-113">Deuxièmement, appelez toujours **Commit** sur un objet de stockage de propriétés avant d’appeler **CopyTo**, **MoveElementTo** ou **Commit** sur un objet de stockage ancêtre.</span><span class="sxs-lookup"><span data-stu-id="95f42-113">Second, always call **Commit** on a property storage object before calling **CopyTo**, **MoveElementTo**, or **Commit** on an ancestor storage object.</span></span> <span data-ttu-id="95f42-114">Plus précisément, les éléments suivants requièrent l’attention du client :</span><span class="sxs-lookup"><span data-stu-id="95f42-114">Specifically, the following items require client attention:</span></span>

-   <span data-ttu-id="95f42-115">Dans l’implémentation de fichier composé, un mécanisme unique fournit une protection d’accès concurrentiel pour l’objet de stockage et ses objets de jeu de propriétés associés.</span><span class="sxs-lookup"><span data-stu-id="95f42-115">In the compound-file implementation, a single mechanism provides concurrency protection for the storage object and its associated property set objects.</span></span> <span data-ttu-id="95f42-116">Toutefois, dans l’implémentation autonome, l’implémentation de l’objet de stockage est distincte de l’implémentation du jeu de propriétés et chacune fournit ses propres mécanismes de concurrence.</span><span class="sxs-lookup"><span data-stu-id="95f42-116">However, in the stand-alone implementation, the storage object implementation is separate from the property set implementation and each provides its own concurrency mechanisms.</span></span> <span data-ttu-id="95f42-117">Ainsi, dans l’implémentation autonome, le client est responsable de la gestion de la protection d’accès concurrentiel entre les deux implémentations via un mécanisme d’exclusion mutuelle.</span><span class="sxs-lookup"><span data-stu-id="95f42-117">Thus, in the stand-alone implementation, the client is responsible for maintaining concurrency protection between the two implementations through a mechanism of mutual exclusion.</span></span>
-   <span data-ttu-id="95f42-118">Dans l’implémentation de fichier composé, les modifications apportées aux jeux de propriétés sont mises en mémoire tampon dans un cache de jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="95f42-118">In the compound file implementation, changes to property sets are buffered in a property-set cache.</span></span> <span data-ttu-id="95f42-119">Ensuite, lorsque la méthode [**IStorage :: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) est appelée sur l’objet de stockage, l’implémentation des fichiers composés vide automatiquement les modifications de l’ensemble de propriétés à partir de la mémoire tampon définie par la propriété avant la validation de l’objet de stockage.</span><span class="sxs-lookup"><span data-stu-id="95f42-119">Then, when the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method is called on the storage object, the compound files implementation automatically flushes the property-set changes from the property-set buffer before the storage object is committed.</span></span> <span data-ttu-id="95f42-120">Ainsi, les modifications de l’ensemble de propriétés sont rendues visibles dans le cadre de la transaction en cours de validation.</span><span class="sxs-lookup"><span data-stu-id="95f42-120">Thus, the property-set changes are made visible as part of the transaction being committed.</span></span>

    <span data-ttu-id="95f42-121">Dans l’implémentation autonome, le client doit vider explicitement la mémoire tampon de l’ensemble de propriétés en appelant [**IPropertyStorage :: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) avant d’appeler la méthode [**IStorage :: Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) sur le stockage.</span><span class="sxs-lookup"><span data-stu-id="95f42-121">In the stand-alone implementation, the client must explicitly flush the property-set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling the [**IStorage::Commit**](/windows/desktop/api/Objidl/nf-objidl-istorage-commit) method on the storage.</span></span> <span data-ttu-id="95f42-122">Le client peut également utiliser la nouvelle \_ valeur non mise en mémoire tampon PROPSETFLAG dans l’implémentation autonome pour écrire directement dans le jeu de propriétés au lieu de mettre en cache les modifications apportées à la mémoire tampon interne du jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="95f42-122">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value in the stand-alone implementation to write directly to the property set instead of caching changes to the property set's internal buffer.</span></span> <span data-ttu-id="95f42-123">Si PROPSETFLAG \_ n’est pas mis en mémoire tampon, les responsabilités du client sont automatiquement respectées.</span><span class="sxs-lookup"><span data-stu-id="95f42-123">If PROPSETFLAG\_UNBUFFERED is used, the client's responsibilities are automatically met.</span></span> <span data-ttu-id="95f42-124">L’implémentation de fichier composé ne prend pas en charge la \_ valeur non mise en mémoire tampon PROPSETFLAG.</span><span class="sxs-lookup"><span data-stu-id="95f42-124">The compound file implementation does not support the PROPSETFLAG\_UNBUFFERED value.</span></span> <span data-ttu-id="95f42-125">Pour plus d’informations, consultez [**constantes PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="95f42-125">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

-   <span data-ttu-id="95f42-126">Comme avec les stockages transactionnels, l’implémentation de fichiers composés met à jour le jeu de propriétés en vidant sa mémoire tampon interne avant d’exécuter un appel à [**IStorage :: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) ou [**IStorage :: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="95f42-126">As with transacted storages, the compound file implementation updates the property set by flushing its internal buffer before executing a call to [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="95f42-127">Ainsi, les modifications apportées au jeu de propriétés sont reflétées dans l’élément de stockage copié ou déplacé.</span><span class="sxs-lookup"><span data-stu-id="95f42-127">Thus, changes to the property set are reflected in the copied or moved storage element.</span></span>

    <span data-ttu-id="95f42-128">Dans l’implémentation autonome, le client doit vider explicitement la mémoire tampon du jeu de propriétés en appelant [**IPropertyStorage :: Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) avant d’appeler [**IStorage :: CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) ou [**IStorage :: MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span><span class="sxs-lookup"><span data-stu-id="95f42-128">In the stand-alone implementation, the client must explicitly flush the property set buffer by calling [**IPropertyStorage::Commit**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-commit) before calling [**IStorage::CopyTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-copyto) or [**IStorage::MoveElementTo**](/windows/desktop/api/Objidl/nf-objidl-istorage-moveelementto).</span></span> <span data-ttu-id="95f42-129">Le client peut également utiliser la nouvelle \_ valeur non mise en mémoire tampon PROPSETFLAG pour écrire directement dans le jeu de propriétés au lieu de mettre en cache les modifications apportées à la mémoire tampon du jeu de propriétés.</span><span class="sxs-lookup"><span data-stu-id="95f42-129">Alternatively, the client can use the new PROPSETFLAG\_UNBUFFERED value to write directly to the property set instead of caching changes to the property set buffer.</span></span> <span data-ttu-id="95f42-130">Pour plus d’informations, consultez [**constantes PROPSETFLAG**](propsetflag-constants.md).</span><span class="sxs-lookup"><span data-stu-id="95f42-130">For more information, see [**PROPSETFLAG Constants**](propsetflag-constants.md).</span></span>

 

 




