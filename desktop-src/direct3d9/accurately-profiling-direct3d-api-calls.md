---
description: Une fois que vous disposez d’une application Microsoft Direct3D fonctionnelle et que vous souhaitez améliorer ses performances, vous utilisez généralement un outil de profilage en dehors de la conservation ou une technique de mesure personnalisée pour mesurer le temps nécessaire à l’exécution d’un ou plusieurs appels de l’interface de programmation d’applications (API). Si vous avez effectué cette opération mais que vous obtenez des résultats de synchronisation qui varient d’une séquence de rendu à l’autre, ou que vous faites des calculs qui ne comportent pas de résultats d’expérimentation réels, les informations suivantes peuvent vous aider à comprendre pourquoi.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Profilage précis des appels d’API Direct3D (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103748740"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a><span data-ttu-id="15694-104">Profilage précis des appels d’API Direct3D (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="15694-104">Accurately Profiling Direct3D API Calls (Direct3D 9)</span></span>

-   [<span data-ttu-id="15694-105">Il est difficile de Profiler avec précision Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-105">Accurately Profiling Direct3D Is Difficult</span></span>](#accurately-profiling-direct3d-is-difficult)
-   [<span data-ttu-id="15694-106">Comment Profiler avec précision une séquence de rendu Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-106">How to Accurately Profile a Direct3D Render Sequence</span></span>](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [<span data-ttu-id="15694-107">Profilage des modifications de l’État Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-107">Profiling Direct3D State Changes</span></span>](#profiling-direct3d-state-changes)
-   [<span data-ttu-id="15694-108">Résumé</span><span class="sxs-lookup"><span data-stu-id="15694-108">Summary</span></span>](#summary)
-   [<span data-ttu-id="15694-109">A</span><span class="sxs-lookup"><span data-stu-id="15694-109">Appendix</span></span>](#appendix)

<span data-ttu-id="15694-110">Une fois que vous disposez d’une application Microsoft Direct3D fonctionnelle et que vous souhaitez améliorer ses performances, vous utilisez généralement un outil de profilage en dehors de la conservation ou une technique de mesure personnalisée pour mesurer le temps nécessaire à l’exécution d’un ou plusieurs appels de l’interface de programmation d’applications (API).</span><span class="sxs-lookup"><span data-stu-id="15694-110">Once you have a functional Microsoft Direct3D application and you want to improve its performance, you generally use an off-the-shelf profiling tool or some custom measurement technique to measure the time it takes to execute one or more application programming interface (API) calls.</span></span> <span data-ttu-id="15694-111">Si vous avez effectué cette opération mais que vous obtenez des résultats de synchronisation qui varient d’une séquence de rendu à l’autre, ou que vous faites des calculs qui ne comportent pas de résultats d’expérimentation réels, les informations suivantes peuvent vous aider à comprendre pourquoi.</span><span class="sxs-lookup"><span data-stu-id="15694-111">If you have done this but are getting timing results that vary from one render sequence to the next, or you are making hypotheses that do not hold up to actual experiment results, the following information may help you to understand why.</span></span>

<span data-ttu-id="15694-112">Les informations fournies ici sont basées sur l’hypothèse que vous connaissez et que vous avez besoin de connaître les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="15694-112">The information provided here is based upon the assumption that you have knowledge of and experience with the following:</span></span>

-   <span data-ttu-id="15694-113">Programmation C/C++</span><span class="sxs-lookup"><span data-stu-id="15694-113">C/C++ programming</span></span>
-   <span data-ttu-id="15694-114">Programmation de l’API Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-114">Direct3D API programming</span></span>
-   <span data-ttu-id="15694-115">Mesure du temps de l’API</span><span class="sxs-lookup"><span data-stu-id="15694-115">Measuring API timing</span></span>
-   <span data-ttu-id="15694-116">La carte vidéo et son pilote logiciel</span><span class="sxs-lookup"><span data-stu-id="15694-116">The video card and its software driver</span></span>
-   <span data-ttu-id="15694-117">Résultats inexpliqués possibles d’une expérience de profilage précédente</span><span class="sxs-lookup"><span data-stu-id="15694-117">Possible unexplainable results from previous profiling experience</span></span>

## <a name="accurately-profiling-direct3d-is-difficult"></a><span data-ttu-id="15694-118">Il est difficile de Profiler avec précision Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-118">Accurately Profiling Direct3D Is Difficult</span></span>

<span data-ttu-id="15694-119">Un profileur signale le temps passé dans chaque appel d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-119">A profiler reports on the amount of time spent in each API call.</span></span> <span data-ttu-id="15694-120">Cela permet d’améliorer les performances en recherchant et en réglant les zones réactives.</span><span class="sxs-lookup"><span data-stu-id="15694-120">This is done to improve performance by finding and tuning away hot spots.</span></span> <span data-ttu-id="15694-121">Il existe différents types de profileurs et de techniques de profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-121">There are different kinds of profilers and profiling techniques.</span></span>

-   <span data-ttu-id="15694-122">Un profileur d’échantillonnage devient inactif une grande partie du temps, en se réexécutant à des intervalles spécifiques pour échantillonner les fonctions en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="15694-122">A sampling profiler sits idle much of the time, awakening at specific intervals to sample (or to record) the functions being executed.</span></span> <span data-ttu-id="15694-123">Elle retourne le pourcentage de temps passé dans chaque appel.</span><span class="sxs-lookup"><span data-stu-id="15694-123">It returns the percentage of time spent in each call.</span></span> <span data-ttu-id="15694-124">En règle générale, un profileur d’échantillonnage n’est pas très invasif pour l’application et a un impact minimal sur la surcharge de l’application.</span><span class="sxs-lookup"><span data-stu-id="15694-124">Generally, a sampling profiler is not very invasive to the application and has minimal impact on the overhead for the application.</span></span>
-   <span data-ttu-id="15694-125">Un profileur d’instrumentation mesure le temps réel nécessaire pour qu’un appel retourne.</span><span class="sxs-lookup"><span data-stu-id="15694-125">An instrumenting profiler measures the actual time it takes for a call to return.</span></span> <span data-ttu-id="15694-126">Elle nécessite la compilation des délimiteurs de démarrage et d’arrêt dans une application.</span><span class="sxs-lookup"><span data-stu-id="15694-126">It requires compiling start and stop delimiters into an application.</span></span> <span data-ttu-id="15694-127">Un profileur d’instrumentation est comparativement plus invasif pour une application qu’un générateur de profils d’échantillonnage.</span><span class="sxs-lookup"><span data-stu-id="15694-127">An instrumenting profiler is comparatively more invasive to an application than a sampling profiler.</span></span>
-   <span data-ttu-id="15694-128">Il est également possible d’utiliser une technique de profilage personnalisée avec un minuteur à hautes performances.</span><span class="sxs-lookup"><span data-stu-id="15694-128">It is also possible to use a custom profiling technique with a high-performance timer.</span></span> <span data-ttu-id="15694-129">Cela produit des résultats très similaires à ceux d’un profileur d’instrumentation.</span><span class="sxs-lookup"><span data-stu-id="15694-129">This produces results very much like an instrumenting profiler.</span></span>

<span data-ttu-id="15694-130">Le type de profileur ou la technique de profilage utilisé n’est qu’une partie du défi qui consiste à générer des mesures précises.</span><span class="sxs-lookup"><span data-stu-id="15694-130">The type of profiler or profiling technique used is only part of the challenge of generating accurate measurements.</span></span>

<span data-ttu-id="15694-131">Le profilage vous donne des réponses qui vous aident à budgétiser les performances.</span><span class="sxs-lookup"><span data-stu-id="15694-131">Profiling gives you answers that help you budget performance.</span></span> <span data-ttu-id="15694-132">Supposons, par exemple, que vous sachiez qu’un appel d’API calcule la moyenne de 1000 cycles d’horloge à exécuter.</span><span class="sxs-lookup"><span data-stu-id="15694-132">For instance, suppose you know that an API call averages one thousand clock cycles to execute.</span></span> <span data-ttu-id="15694-133">Vous pouvez déclarer des conclusions sur les performances, telles que les suivantes :</span><span class="sxs-lookup"><span data-stu-id="15694-133">You can assert some conclusions about performance such as the following:</span></span>

-   <span data-ttu-id="15694-134">Un processeur de 2 GHz (qui passe 50% de son temps de rendu) est limité à l’appel de cette API 1 million fois par seconde.</span><span class="sxs-lookup"><span data-stu-id="15694-134">A 2 GHz CPU (which spends 50 percent of its time rendering) is limited to calling this API 1 million times a second.</span></span>
-   <span data-ttu-id="15694-135">Pour atteindre 30 images par seconde, vous ne pouvez pas appeler cette API plus de 33 000 fois par frame.</span><span class="sxs-lookup"><span data-stu-id="15694-135">To achieve 30 frames per second, you cannot call this API more than 33,000 times per frame.</span></span>
-   <span data-ttu-id="15694-136">Vous ne pouvez afficher que 3.3 Ko d’objets par trame (en supposant que 10 de ces appels d’API sont effectués pour chaque séquence de rendu de l’objet).</span><span class="sxs-lookup"><span data-stu-id="15694-136">You can only render 3.3K objects per frame (assuming 10 of these API calls for each object's render sequence).</span></span>

<span data-ttu-id="15694-137">En d’autres termes, si vous aviez suffisamment de temps par appel d’API, vous pourriez répondre à une question de budgétisation, comme le nombre de primitives qui peuvent être rendues de manière interactive.</span><span class="sxs-lookup"><span data-stu-id="15694-137">In other words, if you had sufficient time per API call, you could answer a budgeting question such as the number of primitives that can be rendered interactively.</span></span> <span data-ttu-id="15694-138">Toutefois, les nombres bruts retournés par un profileur d’instrumentation ne répondront pas précisément aux questions de budget.</span><span class="sxs-lookup"><span data-stu-id="15694-138">But the raw numbers returned by an instrumenting profiler will not accurately answer the budgeting questions.</span></span> <span data-ttu-id="15694-139">Cela est dû au fait que le pipeline graphique présente des problèmes de conception complexes tels que le nombre de composants qui doivent effectuer le travail, le nombre de processeurs qui contrôlent le flux de travail entre les composants et les stratégies d’optimisation implémentées dans le runtime et dans un pilote qui sont conçues pour rendre le pipeline plus efficace.</span><span class="sxs-lookup"><span data-stu-id="15694-139">This is because the graphics pipeline has complex design issues such as the number of components that need to do work, the number of processors that control how the work flows between components, and optimization strategies implemented in the runtime and in a driver that are designed to make the pipeline more efficient.</span></span>

### <a name="each-api-call-goes-through-several-components"></a><span data-ttu-id="15694-140">Chaque appel d’API passe par plusieurs composants</span><span class="sxs-lookup"><span data-stu-id="15694-140">Each API Call Goes through Several Components</span></span>

<span data-ttu-id="15694-141">Chaque appel est traité par plusieurs composants en direction de l’application vers la carte vidéo.</span><span class="sxs-lookup"><span data-stu-id="15694-141">Each call is processed by several components on its way from the application to the video card.</span></span> <span data-ttu-id="15694-142">Par exemple, considérez la séquence de rendu suivante contenant deux appels pour dessiner un seul triangle :</span><span class="sxs-lookup"><span data-stu-id="15694-142">For instance, consider the following render sequence containing two calls for drawing a single triangle:</span></span>


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



<span data-ttu-id="15694-143">Le diagramme conceptuel suivant montre les différents composants par le biais desquels les appels doivent réussir.</span><span class="sxs-lookup"><span data-stu-id="15694-143">The following conceptual diagram shows the different components through which the calls must pass.</span></span>

![diagramme des composants graphiques parcourant les appels d’API](images/microbenchmarkinstructionflow2.png)

<span data-ttu-id="15694-145">L’application appelle Direct3D qui contrôle la scène, gère les interactions de l’utilisateur et détermine la façon dont le rendu est effectué.</span><span class="sxs-lookup"><span data-stu-id="15694-145">The application invokes Direct3D which controls the scene, handles user interactions, and determines how rendering is done.</span></span> <span data-ttu-id="15694-146">Tout ce travail est spécifié dans la séquence de rendu, qui est envoyée au runtime à l’aide d’appels d’API Direct3D.</span><span class="sxs-lookup"><span data-stu-id="15694-146">All of this work is specified in the render sequence, which is sent to the runtime using Direct3D API calls.</span></span> <span data-ttu-id="15694-147">La séquence de rendu est pratiquement indépendante du matériel (autrement dit, les appels d’API sont indépendants du matériel, mais une application connaît les fonctionnalités prises en charge par une carte vidéo).</span><span class="sxs-lookup"><span data-stu-id="15694-147">The render sequence is virtually hardware independent (that is, the API calls are hardware independent but an application has knowledge of what features a video card supports).</span></span>

<span data-ttu-id="15694-148">Le Runtime convertit ces appels dans un format indépendant du périphérique.</span><span class="sxs-lookup"><span data-stu-id="15694-148">The runtime converts these calls into a device-independent format.</span></span> <span data-ttu-id="15694-149">Le Runtime gère toutes les communications entre l’application et le pilote, afin qu’une application s’exécute sur plusieurs éléments de matériel compatibles (selon les fonctionnalités requises).</span><span class="sxs-lookup"><span data-stu-id="15694-149">The runtime handles all the communication between the application and the driver, so that an application will run on more than one compatible piece of hardware (depending on the features required).</span></span> <span data-ttu-id="15694-150">Lors de la mesure d’un appel de fonction, un profileur d’instrumentation mesure le temps qu’il a passé dans une fonction, ainsi que l’heure à laquelle la fonction doit être retournée.</span><span class="sxs-lookup"><span data-stu-id="15694-150">When measuring a function call, an instrumenting profiler measures the time it spent in a function as well as the time for the function to return.</span></span> <span data-ttu-id="15694-151">L’une des limitations d’un profileur d’instrumentation est qu’il peut ne pas inclure le temps nécessaire à un pilote pour envoyer le travail résultant à la carte vidéo, ni l’heure de la carte vidéo pour traiter le travail.</span><span class="sxs-lookup"><span data-stu-id="15694-151">One limitation of an instrumenting profiler is that it may not include the time it takes a driver to send the resulting work to the video card nor the time for the video card to process the work.</span></span> <span data-ttu-id="15694-152">En d’autres termes, un profileur d’instrumentation hors connexion ne parvient pas à attribuer un attribut à l’ensemble du travail associé à chaque appel de fonction.</span><span class="sxs-lookup"><span data-stu-id="15694-152">In other words, an off-the-shelf instrumenting profiler fails to attribute all of the work associated with each function call.</span></span>

<span data-ttu-id="15694-153">Le pilote logiciel utilise une connaissance matérielle spécifique de la carte vidéo pour convertir les commandes indépendantes du périphérique en une séquence de commandes de carte vidéo.</span><span class="sxs-lookup"><span data-stu-id="15694-153">The software driver uses hardware specific knowledge about the video card to convert the device-independent commands into a sequence of video card commands.</span></span> <span data-ttu-id="15694-154">Les pilotes peuvent également optimiser la séquence de commandes qui sont envoyées à la carte vidéo, afin que le rendu sur la carte vidéo soit effectué efficacement.</span><span class="sxs-lookup"><span data-stu-id="15694-154">Drivers may also optimize the sequence of commands that are sent to the video card, so that rendering on the video card is done efficiently.</span></span> <span data-ttu-id="15694-155">Ces optimisations peuvent entraîner des problèmes de profilage, car la quantité de travail effectuée n’est pas celle qu’elle semble être (vous devrez peut-être comprendre les optimisations pour les prendre en compte).</span><span class="sxs-lookup"><span data-stu-id="15694-155">These optimizations can cause profiling problems because the amount of work done is not what it appears to be (you may need to understand the optimizations to account for them).</span></span> <span data-ttu-id="15694-156">Le pilote retourne généralement le contrôle à l’exécution avant que la carte vidéo ait terminé le traitement de toutes les commandes.</span><span class="sxs-lookup"><span data-stu-id="15694-156">The driver typically returns control to the runtime before the video card has finished processing all the commands.</span></span>

<span data-ttu-id="15694-157">La carte vidéo effectue la majorité du rendu en combinant les données des mémoires tampons de vertex et d’index, des textures, des informations d’état de rendu et des commandes graphiques.</span><span class="sxs-lookup"><span data-stu-id="15694-157">The video card performs the majority of the rendering by combining data from the vertex and index buffers, textures, render state information, and the graphics commands.</span></span> <span data-ttu-id="15694-158">Lorsque la carte vidéo termine le rendu, le travail créé à partir de la séquence de rendu est terminé.</span><span class="sxs-lookup"><span data-stu-id="15694-158">When the video card finishes rendering, the work created from the render sequence is complete.</span></span>

<span data-ttu-id="15694-159">Chaque appel d’API Direct3D doit être traité par chaque composant (le runtime, le pilote et la carte vidéo) pour restituer quoi que ce soit.</span><span class="sxs-lookup"><span data-stu-id="15694-159">Each Direct3D API call must be processed by each component (the runtime, the driver, and the video card) to render anything.</span></span>

### <a name="there-is-more-than-one-processor-controlling-the-components"></a><span data-ttu-id="15694-160">Plusieurs processeurs contrôlent les composants</span><span class="sxs-lookup"><span data-stu-id="15694-160">There Is More than One Processor Controlling the Components</span></span>

<span data-ttu-id="15694-161">La relation entre ces composants est encore plus complexe, car l’application, le runtime et le pilote sont contrôlés par un processeur et la carte vidéo est contrôlée par un processeur distinct.</span><span class="sxs-lookup"><span data-stu-id="15694-161">The relationship between these components is even more complex, because the application, runtime, and the driver are controlled by one processor and the video card is controlled by a separate processor.</span></span> <span data-ttu-id="15694-162">Le diagramme suivant illustre deux types de processeurs : une unité centrale (UC) et une unité de traitement graphique (GPU).</span><span class="sxs-lookup"><span data-stu-id="15694-162">The following diagram shows two kinds of processors: a central processing unit (CPU) and a graphics processing unit (GPU).</span></span>

![diagramme d’une UC et d’un GPU et de leurs composants](images/microbenchmarkprocessors.png)

<span data-ttu-id="15694-164">Les PC disposent d’au moins un processeur et d’un GPU, mais ils peuvent avoir plus d’un ou des deux.</span><span class="sxs-lookup"><span data-stu-id="15694-164">PC systems have at least one CPU and one GPU, but can have more than one of either or both.</span></span> <span data-ttu-id="15694-165">Les processeurs sont situés sur la carte mère et les GPU se trouvent soit sur la carte mère, soit sur la carte vidéo.</span><span class="sxs-lookup"><span data-stu-id="15694-165">The CPUs are located on the motherboard, and the GPUs are located either on the motherboard or on the video card.</span></span> <span data-ttu-id="15694-166">La vitesse du processeur est déterminée par une puce de l’horloge sur la carte mère, et la vitesse du GPU est déterminée par une puce d’horloge distincte.</span><span class="sxs-lookup"><span data-stu-id="15694-166">The speed of the CPU is determined by a clock chip on the motherboard, and the speed of the GPU is determined by a separate clock chip.</span></span> <span data-ttu-id="15694-167">L’horloge de l’UC contrôle la vitesse du travail effectué par l’application, le runtime et le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-167">The CPU clock controls the speed of the work done by the application, the runtime, and the driver.</span></span> <span data-ttu-id="15694-168">L’application envoie un travail au GPU par le biais du runtime et du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-168">The application sends work to the GPU via the runtime and the driver.</span></span>

<span data-ttu-id="15694-169">L’UC et le GPU s’exécutent généralement à des vitesses différentes, indépendamment les unes des autres.</span><span class="sxs-lookup"><span data-stu-id="15694-169">The CPU and the GPU generally run at different speeds, independent of one another.</span></span> <span data-ttu-id="15694-170">Le GPU peut répondre au travail dès que le travail est disponible (en supposant que le GPU a fini de traiter le travail précédent).</span><span class="sxs-lookup"><span data-stu-id="15694-170">The GPU may respond to the work as soon as the work is available (assuming the GPU has finished processing previous work).</span></span> <span data-ttu-id="15694-171">Le travail GPU est effectué en parallèle avec le travail du processeur mis en surbrillance par la ligne courbée dans la figure ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="15694-171">The GPU work is done in parallel with the CPU work as highlighted by the curved line in the figure above.</span></span> <span data-ttu-id="15694-172">Un profileur mesure généralement les performances de l’UC, et non le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-172">A profiler generally measures the performance of the CPU, not the GPU.</span></span> <span data-ttu-id="15694-173">Cela complique le profilage, car les mesures effectuées par un profileur d’instrumentation incluent le temps processeur, mais peuvent ne pas inclure le temps GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-173">This makes profiling challenging, because the measurements made by an instrumenting profiler include the CPU time but may not include the GPU time.</span></span>

<span data-ttu-id="15694-174">L’objectif du GPU est de décharger le traitement du processeur vers un processeur conçu spécifiquement pour le travail graphique.</span><span class="sxs-lookup"><span data-stu-id="15694-174">The purpose of the GPU is to off-load processing from the CPU to a processor specifically designed for graphics work.</span></span> <span data-ttu-id="15694-175">Sur les cartes vidéo modernes, le GPU remplace une grande partie des tâches de transformation et d’éclairage dans le pipeline du processeur au GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-175">On modern video cards, the GPU replaces much of the transform and lighting work in the pipeline from the CPU to the GPU.</span></span> <span data-ttu-id="15694-176">Cela réduit considérablement la charge de travail du processeur, ce qui laisse plus de cycles de processeur disponibles pour d’autres traitements.</span><span class="sxs-lookup"><span data-stu-id="15694-176">This greatly reduces the CPU workload, leaving more CPU cycles available for other processing.</span></span> <span data-ttu-id="15694-177">Pour paramétrer une application graphique pour des performances de pointe, vous devez mesurer les performances de l’UC et du GPU, et équilibrer le travail entre les deux types de processeurs.</span><span class="sxs-lookup"><span data-stu-id="15694-177">To tune a graphical application for peak performance, you need to measure the performance of both the CPU and the GPU, and balance the work between the two types of processors.</span></span>

<span data-ttu-id="15694-178">Ce document ne couvre pas les sujets liés à la mesure des performances du GPU ou à l’équilibrage du travail entre l’UC et le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-178">This document does not cover topics related to measuring the performance of the GPU or balancing the work between the CPU and the GPU.</span></span> <span data-ttu-id="15694-179">Si vous souhaitez mieux comprendre les performances d’un GPU (ou d’une carte vidéo particulière), visitez le site Web du fournisseur pour obtenir plus d’informations sur les performances du GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-179">If you want to better understand the performance of a GPU (or a particular video card), visit the vendor's web site to look for more information about GPU performance.</span></span> <span data-ttu-id="15694-180">Au lieu de cela, ce document met l’accent sur le travail effectué par le runtime et le pilote en réduisant le travail du GPU à une quantité négligeable.</span><span class="sxs-lookup"><span data-stu-id="15694-180">Instead, this document focuses on the work done by the runtime and the driver by reducing the GPU work to a negligible amount.</span></span> <span data-ttu-id="15694-181">Cela est en partie basé sur l’expérience dans laquelle les applications qui rencontrent des problèmes de performances sont généralement limitées par le processeur.</span><span class="sxs-lookup"><span data-stu-id="15694-181">This is, in part, based on experience that applications experiencing performance problems are generally CPU-limited.</span></span>

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a><span data-ttu-id="15694-182">Les optimisations du runtime et du pilote peuvent masquer les mesures de l’API</span><span class="sxs-lookup"><span data-stu-id="15694-182">Runtime and Driver Optimizations Can Mask API Measurements</span></span>

<span data-ttu-id="15694-183">Le runtime intègre une optimisation des performances qui peut saturer la mesure d’un appel individuel.</span><span class="sxs-lookup"><span data-stu-id="15694-183">The runtime has a performance optimization built into it that can overwhelm the measurement of an individual call.</span></span> <span data-ttu-id="15694-184">Voici un exemple de scénario illustrant ce problème.</span><span class="sxs-lookup"><span data-stu-id="15694-184">Here's an example scenario that demonstrates this problem.</span></span> <span data-ttu-id="15694-185">Considérez la séquence de rendu suivante :</span><span class="sxs-lookup"><span data-stu-id="15694-185">Consider the following render sequence:</span></span>


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



<span data-ttu-id="15694-186">Exemple 1 : séquence de rendu simple</span><span class="sxs-lookup"><span data-stu-id="15694-186">Example 1: Simple Render Sequence</span></span>

<span data-ttu-id="15694-187">En examinant les résultats des deux appels dans la séquence de rendu, un profileur d’instrumentation peut retourner des résultats similaires à ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-187">Looking at the results for the two calls in the render sequence, an instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



<span data-ttu-id="15694-188">Le profileur retourne le nombre de cycles de processeur requis pour traiter le travail associé à chaque appel (n’oubliez pas que le GPU n’est pas inclus dans ces numéros, car le GPU n’a pas encore commencé à travailler sur ces commandes).</span><span class="sxs-lookup"><span data-stu-id="15694-188">The profiler returns the number of CPU cycles required to process the work associated with each call (remember that the GPU isn't included in these numbers because the GPU hasn't started working on these commands yet).</span></span> <span data-ttu-id="15694-189">Étant donné que [**IDirect3DDevice9 ::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) nécessitait presque un million de cycles à traiter, vous pouvez conclure qu’il n’est pas très efficace.</span><span class="sxs-lookup"><span data-stu-id="15694-189">Because [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) required almost a million cycles to process, you could conclude that it is not very efficient.</span></span> <span data-ttu-id="15694-190">Toutefois, vous verrez bientôt pourquoi cette conclusion est incorrecte et comment vous pouvez générer des résultats qui peuvent être utilisés pour la budgétisation.</span><span class="sxs-lookup"><span data-stu-id="15694-190">However, you'll soon see why this conclusion is incorrect and how you can generate results that can be used for budgeting.</span></span>

### <a name="measuring-state-changes-requires-careful-render-sequences"></a><span data-ttu-id="15694-191">La mesure des modifications d’état nécessite des séquences de rendu prudentes</span><span class="sxs-lookup"><span data-stu-id="15694-191">Measuring State Changes Requires Careful Render Sequences</span></span>

<span data-ttu-id="15694-192">Tous les appels autres que [**IDirect3DDevice9 ::D rawprimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)ou [**Clear**](/windows/desktop/api) (tels que [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api)et [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produisent un changement d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-192">All calls other than [**IDirect3DDevice9::DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), or [**Clear**](/windows/desktop/api) (such as [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**SetVertexDeclaration**](/windows/desktop/api), and [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) produce a state change.</span></span> <span data-ttu-id="15694-193">Chaque modification d’État définit l’état du pipeline qui contrôle comment le rendu sera effectué.</span><span class="sxs-lookup"><span data-stu-id="15694-193">Each state change sets pipeline state that controls how rendering will be done.</span></span>

<span data-ttu-id="15694-194">Les optimisations dans le runtime et/ou le pilote sont conçues pour accélérer le rendu en réduisant la quantité de travail requise.</span><span class="sxs-lookup"><span data-stu-id="15694-194">Optimizations in the runtime and/or the driver are designed to speed up rendering by reducing the amount of work required.</span></span> <span data-ttu-id="15694-195">Voici quelques-unes des optimisations de modification d’État qui peuvent polluer les moyennes de profil :</span><span class="sxs-lookup"><span data-stu-id="15694-195">The following are a couple of state change optimizations that may pollute profile averages:</span></span>

-   <span data-ttu-id="15694-196">Un pilote (ou le Runtime) peut enregistrer une modification d’État comme un état local.</span><span class="sxs-lookup"><span data-stu-id="15694-196">A driver (or the runtime) could save a state change as a local state.</span></span> <span data-ttu-id="15694-197">Étant donné que le pilote peut fonctionner dans un algorithme « paresseux » (en différant le travail jusqu’à ce qu’il soit absolument nécessaire), le travail associé à certains changements d’État peut être retardé.</span><span class="sxs-lookup"><span data-stu-id="15694-197">Because the driver could operate in a "lazy" algorithm (postponing work until it is absolutely necessary), work associated with some state changes could get delayed.</span></span>
-   <span data-ttu-id="15694-198">Le Runtime (ou un pilote) peut supprimer les modifications d’État en optimisant.</span><span class="sxs-lookup"><span data-stu-id="15694-198">The runtime (or a driver) may remove state changes by optimizing.</span></span> <span data-ttu-id="15694-199">Par exemple, vous pouvez supprimer un changement d’État redondant qui désactive l’éclairage, car l’éclairage a déjà été désactivé.</span><span class="sxs-lookup"><span data-stu-id="15694-199">An example of this might be to remove a redundant state change that disables lighting because lighting has previously been disabled.</span></span>

<span data-ttu-id="15694-200">Il n’existe aucun moyen infaillible d’examiner une séquence de rendu et de conclure les modifications d’État qui définiront un bit d’intégrité et de différer le travail, ou sera simplement supprimée par l’optimisation.</span><span class="sxs-lookup"><span data-stu-id="15694-200">There is no foolproof way to look at a render sequence and conclude which state changes will set a dirty bit and defer work, or will simply be removed by optimization.</span></span> <span data-ttu-id="15694-201">Même si vous pouviez identifier des modifications d’État optimisées dans le runtime ou le pilote d’aujourd’hui, le runtime ou le pilote de demain est susceptible d’être mis à jour.</span><span class="sxs-lookup"><span data-stu-id="15694-201">Even if you could identify optimized state changes in today's runtime or driver, tomorrow's runtime or driver is likely to be updated.</span></span> <span data-ttu-id="15694-202">Vous ne connaissez pas non plus facilement l’état précédent et il est donc difficile d’identifier les changements d’État redondants.</span><span class="sxs-lookup"><span data-stu-id="15694-202">You also don't readily know what the previous state was so it is difficult to identify redundant state changes.</span></span> <span data-ttu-id="15694-203">La seule façon de vérifier le coût d’un changement d’État est de mesurer la séquence de rendu qui comprend les modifications d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-203">The only way to verify the cost of a state change is to measure the render sequence that includes the state changes.</span></span>

<span data-ttu-id="15694-204">Comme vous pouvez le voir, les complications causées par l’utilisation de plusieurs processeurs, les commandes traitées par plusieurs composants et les optimisations intégrées aux composants rendent le profilage difficile à prédire.</span><span class="sxs-lookup"><span data-stu-id="15694-204">As you can see, the complications caused by having multiple processors, commands being processed by more than one component, and optimizations built into the components make profiling difficult to predict.</span></span> <span data-ttu-id="15694-205">Dans la section suivante, chacun de ces défis de profilage sera traité.</span><span class="sxs-lookup"><span data-stu-id="15694-205">In the next section, each of these profiling challenges will be addressed.</span></span> <span data-ttu-id="15694-206">Des exemples de séquences de rendu Direct3D s’affichent, avec les techniques de mesure associées.</span><span class="sxs-lookup"><span data-stu-id="15694-206">Sample Direct3D render sequences will be shown, with the accompanying measurement techniques.</span></span> <span data-ttu-id="15694-207">Grâce à ces connaissances, vous serez en mesure de générer des mesures précises et reproductibles sur des appels individuels.</span><span class="sxs-lookup"><span data-stu-id="15694-207">With this knowledge, you will be able to generate accurate, repeatable measurements on individual calls.</span></span>

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a><span data-ttu-id="15694-208">Comment Profiler avec précision une séquence de rendu Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-208">How to Accurately Profile a Direct3D Render Sequence</span></span>

<span data-ttu-id="15694-209">Maintenant que certains des défis de profilage ont été mis en évidence, cette section vous montrera des techniques qui vous aideront à générer des mesures de profil qui peuvent être utilisées pour la budgétisation.</span><span class="sxs-lookup"><span data-stu-id="15694-209">Now that some of the profiling challenges have been highlighted, this section will show you techniques that will help you generate profile measurements that can be used for budgeting.</span></span> <span data-ttu-id="15694-210">Des mesures de profilage précises et reproductibles sont possibles si vous comprenez la relation entre les composants contrôlés par l’UC et comment éviter les optimisations de performances implémentées par le runtime et le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-210">Accurate, repeatable profiling measurements are possible if you understand the relationship between the components controlled by the CPU, and how to avoid performance optimizations implemented by the runtime and the driver.</span></span>

<span data-ttu-id="15694-211">Pour commencer, vous devez être en mesure de mesurer avec précision la durée d’exécution d’un appel d’API unique.</span><span class="sxs-lookup"><span data-stu-id="15694-211">To begin, you need to be able to accurately measure the execution time of a single API call.</span></span>

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a><span data-ttu-id="15694-212">Choisissez un outil de mesure précis comme QueryPerformanceCounter</span><span class="sxs-lookup"><span data-stu-id="15694-212">Pick an Accurate Measurement Tool Like QueryPerformanceCounter</span></span>

<span data-ttu-id="15694-213">Le système d’exploitation Microsoft Windows comprend un minuteur haute résolution qui peut être utilisé pour mesurer les temps écoulés à haute résolution.</span><span class="sxs-lookup"><span data-stu-id="15694-213">The Microsoft Windows operating system includes a high-resolution timer that can be used to measure high-resolution elapsed times.</span></span> <span data-ttu-id="15694-214">La valeur actuelle d’une telle minuterie peut être retournée à l’aide de [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span><span class="sxs-lookup"><span data-stu-id="15694-214">The current value of one such timer can be returned using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter).</span></span> <span data-ttu-id="15694-215">Après l’appel de **QueryPerformanceCounter** pour retourner les valeurs de début et de fin, la différence entre les deux valeurs peut être convertie en temps réel écoulé (en secondes) à l’aide de **QueryPerformanceCounter**.</span><span class="sxs-lookup"><span data-stu-id="15694-215">After invoking **QueryPerformanceCounter** to return start and stop values, the difference between the two values can be converted to the actual elapsed time (in seconds) using **QueryPerformanceCounter**.</span></span>

<span data-ttu-id="15694-216">Les avantages de l’utilisation de [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) sont qu’elle est disponible dans Windows et qu’elle est facile à utiliser.</span><span class="sxs-lookup"><span data-stu-id="15694-216">The advantages of using [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) are that it is available in Windows and it is easy to use.</span></span> <span data-ttu-id="15694-217">Entourez simplement les appels avec un appel **QueryPerformanceCounter** et enregistrez les valeurs de début et de fin.</span><span class="sxs-lookup"><span data-stu-id="15694-217">Simply surround the calls with a **QueryPerformanceCounter** call and save the start and stop values.</span></span> <span data-ttu-id="15694-218">Par conséquent, ce document explique comment utiliser **QueryPerformanceCounter** pour profiler les durées d’exécution, de la même manière qu’un profileur d’instrumentation le mesure.</span><span class="sxs-lookup"><span data-stu-id="15694-218">Therefore, this paper will demonstrate how to use **QueryPerformanceCounter** to profile execution times, similar to the way an instrumenting profiler would measure it.</span></span> <span data-ttu-id="15694-219">Voici un exemple qui montre comment incorporer **QueryPerformanceCounter** dans votre code source :</span><span class="sxs-lookup"><span data-stu-id="15694-219">Here's an example that shows how to embed **QueryPerformanceCounter** in your source code:</span></span>


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



<span data-ttu-id="15694-220">Exemple 2 : implémentation personnalisée du profilage avec QPC</span><span class="sxs-lookup"><span data-stu-id="15694-220">Example 2: Custom Profiling Implementation with QPC</span></span>

<span data-ttu-id="15694-221">Start et stop sont deux entiers volumineux qui contiendront les valeurs Start et Stop retournées par le minuteur hautes performances.</span><span class="sxs-lookup"><span data-stu-id="15694-221">start and stop are two large integers that will hold the start and stop values returned by the high-performance timer.</span></span> <span data-ttu-id="15694-222">Notez que QueryPerformanceCounter (&Start) est appelé juste avant [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et QueryPerformanceCounter (&Stop) est appelé juste après [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="15694-222">Notice that QueryPerformanceCounter(&start) is called just before [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and QueryPerformanceCounter(&stop) is called just after [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="15694-223">Après avoir obtenu la valeur d’arrêt, QueryPerformanceFrequency est appelé pour retourner FREQ, qui est la fréquence de la minuterie haute résolution.</span><span class="sxs-lookup"><span data-stu-id="15694-223">After getting the stop value, QueryPerformanceFrequency is called to return freq, which is the frequency of the high-resolution timer.</span></span> <span data-ttu-id="15694-224">Dans cet exemple hypothétique, supposons que vous obteniez les résultats suivants pour Start, stop et FREQ :</span><span class="sxs-lookup"><span data-stu-id="15694-224">In this hypothetical example, suppose you get the following results for start, stop, and freq:</span></span>



| <span data-ttu-id="15694-225">Variable locale</span><span class="sxs-lookup"><span data-stu-id="15694-225">Local Variable</span></span> | <span data-ttu-id="15694-226">Nombre de graduations</span><span class="sxs-lookup"><span data-stu-id="15694-226">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="15694-227">start</span><span class="sxs-lookup"><span data-stu-id="15694-227">start</span></span>          | <span data-ttu-id="15694-228">1792998845094</span><span class="sxs-lookup"><span data-stu-id="15694-228">1792998845094</span></span>   |
| <span data-ttu-id="15694-229">stop</span><span class="sxs-lookup"><span data-stu-id="15694-229">stop</span></span>           | <span data-ttu-id="15694-230">1792998845102</span><span class="sxs-lookup"><span data-stu-id="15694-230">1792998845102</span></span>   |
| <span data-ttu-id="15694-231">Fréq</span><span class="sxs-lookup"><span data-stu-id="15694-231">freq</span></span>           | <span data-ttu-id="15694-232">3579545</span><span class="sxs-lookup"><span data-stu-id="15694-232">3579545</span></span>         |



 

<span data-ttu-id="15694-233">Vous pouvez convertir ces valeurs en nombre de cycles nécessaires pour exécuter les appels d’API comme suit :</span><span class="sxs-lookup"><span data-stu-id="15694-233">You could convert these values to the number of cycles it takes to execute the API calls like this:</span></span>


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



<span data-ttu-id="15694-234">En d’autres termes, il faut environ 4568 cycles d’horloge pour traiter [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sur cet ordinateur de 2 GHz.</span><span class="sxs-lookup"><span data-stu-id="15694-234">In other words, it takes about 4568 clock cycles to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) on this 2 GHz machine.</span></span> <span data-ttu-id="15694-235">Vous pouvez convertir ces valeurs en temps réel nécessaire pour exécuter tous les appels de la façon suivante :</span><span class="sxs-lookup"><span data-stu-id="15694-235">You could convert these values to the actual time it took to execute all the calls like this:</span></span>


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



<span data-ttu-id="15694-236">L’utilisation de QueryPerformanceCounter requiert l’ajout de mesures de démarrage et d’arrêt à votre séquence de rendu et l’utilisation de QueryPerformanceFrequency pour convertir la différence (nombre de graduations) en nombre de cycles du processeur ou en temps réel.</span><span class="sxs-lookup"><span data-stu-id="15694-236">Using QueryPerformanceCounter requires that you add start and stop measurements to your render sequence and use QueryPerformanceFrequency to convert the difference (number of ticks) to the number of CPU cycles or to actual time.</span></span> <span data-ttu-id="15694-237">L’identification de la technique de mesure est un bon point de départ pour le développement d’une implémentation de profilage personnalisée.</span><span class="sxs-lookup"><span data-stu-id="15694-237">Identifying the measurement technique is a good start for developing a custom profiling implementation.</span></span> <span data-ttu-id="15694-238">Mais avant de commencer à effectuer des mesures, vous devez savoir comment gérer la carte vidéo.</span><span class="sxs-lookup"><span data-stu-id="15694-238">But before you jump in and start making measurements, you need to know how to deal with the video card.</span></span>

### <a name="focus-on-cpu-measurements"></a><span data-ttu-id="15694-239">Focus sur les mesures de l’UC</span><span class="sxs-lookup"><span data-stu-id="15694-239">Focus on CPU Measurements</span></span>

<span data-ttu-id="15694-240">Comme indiqué précédemment, l’UC et le GPU fonctionnent en parallèle pour traiter le travail généré par les appels d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-240">As stated earlier, the CPU and the GPU work in parallel to process the work generated by the API calls.</span></span> <span data-ttu-id="15694-241">Une application réelle nécessite de profiler les deux types de processeurs pour déterminer si votre application est limitée par le processeur ou par GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-241">A real world application requires profiling both types of processors to find out if your application is CPU-limited or GPU-limited.</span></span> <span data-ttu-id="15694-242">Étant donné que les performances du GPU sont spécifiques au fournisseur, il serait très difficile de produire des résultats dans ce document qui couvre la variété des cartes vidéo disponibles.</span><span class="sxs-lookup"><span data-stu-id="15694-242">Since GPU performance is vendor specific, it would be very challenging to produce results in this paper that cover the variety of video cards available.</span></span>

<span data-ttu-id="15694-243">Au lieu de cela, ce document se concentre uniquement sur le profilage du travail effectué par le processeur à l’aide d’une technique personnalisée pour mesurer le travail du runtime et du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-243">Instead, this paper will focus only on profiling the work performed by the CPU by using a custom technique for measuring the runtime and driver work.</span></span> <span data-ttu-id="15694-244">Le travail GPU est réduit à une quantité insignifiante, de sorte que les résultats de l’UC sont plus visibles.</span><span class="sxs-lookup"><span data-stu-id="15694-244">The GPU work will be reduced to an insignificant amount, so that CPU results are more visible.</span></span> <span data-ttu-id="15694-245">L’un des avantages de cette approche est que cette technique produit les résultats dans l’annexe que vous devez être en mesure de mettre en corrélation avec vos mesures.</span><span class="sxs-lookup"><span data-stu-id="15694-245">One benefit of this approach is that this technique yields results in the Appendix that you should be able to correlate with your measurements.</span></span> <span data-ttu-id="15694-246">Pour réduire le travail requis par la carte vidéo à un niveau non significatif, réduisez simplement le travail de rendu le moins possible.</span><span class="sxs-lookup"><span data-stu-id="15694-246">To reduce the work required by the video card to an insignificant level, simply reduce the rendering work to the least amount possible.</span></span> <span data-ttu-id="15694-247">Cela peut être accompli en limitant les appels de dessin pour afficher un triangle unique et peut être davantage limité afin que chaque triangle contienne uniquement un pixel.</span><span class="sxs-lookup"><span data-stu-id="15694-247">This can be accomplished by limiting draw calls to render a single triangle, and can be further constrained so that each triangle only contains one pixel.</span></span>

<span data-ttu-id="15694-248">L’unité de mesure utilisée dans ce document pour mesurer le travail de l’UC est le nombre de cycles d’horloge de l’UC plutôt que le temps réel.</span><span class="sxs-lookup"><span data-stu-id="15694-248">The unit of measure used in this paper for measuring CPU work will be the number of CPU clock cycles rather than actual time.</span></span> <span data-ttu-id="15694-249">Les cycles d’horloge de l’UC ont l’avantage d’être plus portables (pour les applications limitées par le processeur) que le temps écoulé réel sur les ordinateurs avec des vitesses de processeur différentes.</span><span class="sxs-lookup"><span data-stu-id="15694-249">CPU clock cycles has the advantage that it is more portable (for CPU-limited applications) than actual elapsed time across machines with different CPU speeds.</span></span> <span data-ttu-id="15694-250">Cette valeur peut être facilement convertie en temps réel si vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="15694-250">This can easily be converted to actual time if desired.</span></span>

<span data-ttu-id="15694-251">Ce document ne couvre pas les sujets liés à l’équilibrage de la charge de travail entre l’UC et le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-251">This document does not cover topics related to balancing the work load between the CPU and the GPU.</span></span> <span data-ttu-id="15694-252">N’oubliez pas que l’objectif de ce document est de ne pas mesurer les performances globales d’une application, mais de mesurer avec précision le temps nécessaire au runtime et au pilote pour traiter les appels d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-252">Remember, the goal of this paper is not to measure the overall performance of an application, but to show you how to accurately measure the time it takes the runtime and the driver to process API calls.</span></span> <span data-ttu-id="15694-253">Avec ces mesures précises, vous pouvez effectuer la tâche de budgétisation de l’UC pour comprendre certains scénarios de performances.</span><span class="sxs-lookup"><span data-stu-id="15694-253">With these accurate measurements, you can take on the task of budgeting the CPU to understand certain performance scenarios.</span></span>

### <a name="controlling-runtime-and-driver-optimizations"></a><span data-ttu-id="15694-254">Contrôle des optimisations du runtime et du pilote</span><span class="sxs-lookup"><span data-stu-id="15694-254">Controlling Runtime and Driver Optimizations</span></span>

<span data-ttu-id="15694-255">Avec une technique de mesure identifiée et une stratégie pour réduire le travail du GPU, l’étape suivante consiste à comprendre les optimisations du runtime et du pilote qui s’imposent lorsque vous profilez.</span><span class="sxs-lookup"><span data-stu-id="15694-255">With a measurement technique identified, and a strategy for reducing GPU work, the next step is to understand the runtime and driver optimizations that get in the way when you are profiling.</span></span>

<span data-ttu-id="15694-256">Le travail du processeur peut être divisé en trois compartiments : l’application, le travail d’exécution et le pilote fonctionnent.</span><span class="sxs-lookup"><span data-stu-id="15694-256">The CPU work can be divided into three buckets: the application work, the runtime work, and the driver work.</span></span> <span data-ttu-id="15694-257">Ignorez le travail de l’application, car il est sous contrôle du programmeur.</span><span class="sxs-lookup"><span data-stu-id="15694-257">Ignore the application work since this is under programmer control.</span></span> <span data-ttu-id="15694-258">Du point de vue de l’application, le runtime et le pilote sont semblables aux zones noires, car l’application n’a aucun contrôle sur ce qui est implémenté dans ces zones.</span><span class="sxs-lookup"><span data-stu-id="15694-258">From the application's standpoint, the runtime and the driver are like black boxes, as the application has no control over what is implemented in them.</span></span> <span data-ttu-id="15694-259">La clé consiste à comprendre les techniques d’optimisation qui peuvent être implémentées dans le runtime et le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-259">The key is to understand the optimization techniques that may be implemented in the runtime and the driver.</span></span> <span data-ttu-id="15694-260">Si vous ne comprenez pas ces optimisations, il est très facile de passer à une mauvaise conclusion quant à la quantité de travail effectuée par le processeur en fonction des mesures du profil.</span><span class="sxs-lookup"><span data-stu-id="15694-260">If you don't understand these optimizations, it is very easy to jump to the wrong conclusion about the amount of work the CPU is doing based on the profile measurements.</span></span> <span data-ttu-id="15694-261">En particulier, il existe deux rubriques relatives à un élément appelé mémoire tampon de commande et ce qu’il peut faire pour obscurcir le profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-261">In particular, there are two topics related to something called the command buffer and what it can do to obfuscate profiling.</span></span> <span data-ttu-id="15694-262">Ces rubriques sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="15694-262">These topics are:</span></span>

-   <span data-ttu-id="15694-263">Optimisation du Runtime avec la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-263">Runtime optimization with the Command Buffer.</span></span> <span data-ttu-id="15694-264">La mémoire tampon de commande est une optimisation du runtime qui réduit l’impact d’une transition de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-264">The command buffer is a runtime optimization that reduces the impact of a mode transition.</span></span> <span data-ttu-id="15694-265">Pour contrôler le minutage de la transition en mode, consultez [contrôle du tampon de commande](#controlling-the-command-buffer).</span><span class="sxs-lookup"><span data-stu-id="15694-265">To control the timing of the mode transition, see [Controlling the Command Buffer](#controlling-the-command-buffer).</span></span>
-   <span data-ttu-id="15694-266">Négation des effets de minutage de la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-266">Negating the timing effects of the Command Buffer.</span></span> <span data-ttu-id="15694-267">Le temps écoulé d’une transition de mode peut avoir un impact important sur le profilage des mesures.</span><span class="sxs-lookup"><span data-stu-id="15694-267">The elapsed time of a mode transition can have a big impact on profiling measurements.</span></span> <span data-ttu-id="15694-268">La stratégie consiste à [rendre la séquence de rendu volumineuse par rapport à la transition en mode](#make-the-render-sequence-large-compared-to-the-mode-transition).</span><span class="sxs-lookup"><span data-stu-id="15694-268">The strategy for this is to [Make the Render Sequence Large Compared to the Mode Transition](#make-the-render-sequence-large-compared-to-the-mode-transition).</span></span>

### <a name="controlling-the-command-buffer"></a><span data-ttu-id="15694-269">Contrôle de la mémoire tampon de commande</span><span class="sxs-lookup"><span data-stu-id="15694-269">Controlling the Command Buffer</span></span>

<span data-ttu-id="15694-270">Lorsqu’une application effectue un appel d’API, le Runtime convertit l’appel d’API en un format indépendant du périphérique (que nous appelons une commande) et le stocke dans le tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-270">When an application makes an API call, the runtime converts the API call to a device-independent format (which we will call a command), and stores it in the command buffer.</span></span> <span data-ttu-id="15694-271">Le tampon de commande est ajouté au diagramme suivant.</span><span class="sxs-lookup"><span data-stu-id="15694-271">The command buffer is added to the following diagram.</span></span>

![diagramme des composants de l’UC, y compris une mémoire tampon de commande](images/microbenchmarkcommandbuffer2.png)

<span data-ttu-id="15694-273">Chaque fois que l’application effectue un autre appel d’API, le runtime répète cette séquence et ajoute une autre commande à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-273">Each time the application makes another API call, the runtime repeats this sequence and adds another command to the command buffer.</span></span> <span data-ttu-id="15694-274">À un moment donné, le runtime vide la mémoire tampon (en envoyant les commandes au pilote).</span><span class="sxs-lookup"><span data-stu-id="15694-274">At some point, the runtime empties the buffer (sending the commands to the driver).</span></span> <span data-ttu-id="15694-275">Dans Windows XP, le vidage du tampon de commande entraîne une transition du mode à mesure que le système d’exploitation bascule du Runtime (exécuté en mode utilisateur) au pilote (exécuté en mode noyau), comme indiqué dans le diagramme suivant.</span><span class="sxs-lookup"><span data-stu-id="15694-275">In Windows XP, emptying the command buffer causes a mode transition as the operating system switches from the runtime (running in user mode) to the driver (running in kernel mode), as shown in the following diagram.</span></span>

-   <span data-ttu-id="15694-276">mode utilisateur : mode de processeur non privilégié qui exécute le code de l’application.</span><span class="sxs-lookup"><span data-stu-id="15694-276">user mode - The non-privileged processor mode that executes application code.</span></span> <span data-ttu-id="15694-277">Les applications en mode utilisateur ne peuvent pas accéder aux données système, sauf par le biais des services système.</span><span class="sxs-lookup"><span data-stu-id="15694-277">User-mode applications cannot gain access to system data except through system services.</span></span>
-   <span data-ttu-id="15694-278">mode noyau : mode processeur privilégié dans lequel s’exécute le code exécutif Windows.</span><span class="sxs-lookup"><span data-stu-id="15694-278">kernel mode - The privileged processor mode in which Windows-based executive code runs.</span></span> <span data-ttu-id="15694-279">Un pilote ou un thread s’exécutant en mode noyau a accès à toute la mémoire système, à l’accès direct au matériel et aux instructions de l’UC pour effectuer des e/s avec le matériel.</span><span class="sxs-lookup"><span data-stu-id="15694-279">A driver or thread running in kernel mode has access to all system memory, direct access to hardware, and the CPU instructions to perform I/O with the hardware.</span></span>

![diagramme des transitions entre le mode utilisateur et le mode noyau](images/microbenchmarkcommandbuffer3.png)

<span data-ttu-id="15694-281">La transition se produit chaque fois que l’UC passe du mode utilisateur au mode noyau (et inversement) et que le nombre de cycles nécessaires est élevé par rapport à un appel d’API individuel.</span><span class="sxs-lookup"><span data-stu-id="15694-281">The transition happens each time the CPU switches from user to kernel mode (and vice versa) and the number of cycles it requires is large compared to an individual API call.</span></span> <span data-ttu-id="15694-282">Si le runtime a envoyé chaque appel d’API au pilote lorsqu’il a été appelé, chaque appel d’API entraînerait le coût d’une transition de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-282">If the runtime sent each API call to the driver when it was invoked, every API call would incur the cost of a mode transition.</span></span>

<span data-ttu-id="15694-283">Au lieu de cela, la mémoire tampon de commande est une optimisation du runtime conçue pour réduire le coût effectif de la transition du mode.</span><span class="sxs-lookup"><span data-stu-id="15694-283">Instead, the command buffer is a runtime optimization designed to reduce the effective cost of the mode transition.</span></span> <span data-ttu-id="15694-284">La mémoire tampon de commande met en file d’attente de nombreuses commandes de pilote en vue d’une transition en mode unique.</span><span class="sxs-lookup"><span data-stu-id="15694-284">The command buffer queues many driver commands in preparation for a single mode transition.</span></span> <span data-ttu-id="15694-285">Quand le runtime ajoute une commande à la mémoire tampon de commande, le contrôle est retourné à l’application.</span><span class="sxs-lookup"><span data-stu-id="15694-285">When the runtime adds a command to the command buffer, control is returned to the application.</span></span> <span data-ttu-id="15694-286">Un profileur n’a aucun moyen de savoir que les commandes de pilote n’ont probablement pas encore été envoyées au pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-286">A profiler has no way of knowing that the driver commands have probably not even been sent to the driver yet.</span></span> <span data-ttu-id="15694-287">Par conséquent, les nombres retournés par un profileur d’instrumentation hors service sont trompeurs puisqu’il mesure le travail du runtime, mais pas le fonctionnement du pilote associé.</span><span class="sxs-lookup"><span data-stu-id="15694-287">As a result, the numbers returned by an off-the-shelf instrumenting profiler are misleading since it measures the runtime work but not the associated driver work.</span></span>

### <a name="profile-results-without-a-mode-transition"></a><span data-ttu-id="15694-288">Résultats de profil sans transition de mode</span><span class="sxs-lookup"><span data-stu-id="15694-288">Profile Results without a Mode Transition</span></span>

<span data-ttu-id="15694-289">À l’aide de la séquence de rendu de l’exemple 2, voici quelques mesures de minutage typiques qui illustrent la grandeur d’une transition de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-289">Using the render sequence from example 2, here are some typical timing measurements that illustrate the magnitude of a mode transition.</span></span> <span data-ttu-id="15694-290">En supposant que les appels [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) n’entraînent pas de transition en mode, un profileur d’instrumentation hors connexion peut retourner des résultats similaires à ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-290">Assuming that [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls do not cause a mode transition, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



<span data-ttu-id="15694-291">Chacun de ces nombres est la durée nécessaire au runtime pour ajouter ces appels au tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-291">Each of these numbers are the amount of time it takes for the runtime to add these calls to the command buffer.</span></span> <span data-ttu-id="15694-292">Étant donné qu’il n’y a aucune transition en mode, le pilote n’a pas encore effectué de travail.</span><span class="sxs-lookup"><span data-stu-id="15694-292">Since there is no mode transition, the driver has not done any work yet.</span></span> <span data-ttu-id="15694-293">Les résultats du profileur sont exacts, mais ils ne mesurent pas tout le travail que la séquence de rendu finira par entraîner l’exécution du processeur.</span><span class="sxs-lookup"><span data-stu-id="15694-293">The profiler results are accurate, but they do not measure all of the work that the render sequence will eventually cause the CPU to perform.</span></span>

### <a name="profile-results-with-a-mode-transition"></a><span data-ttu-id="15694-294">Résultats de profil avec une transition de mode</span><span class="sxs-lookup"><span data-stu-id="15694-294">Profile Results with a Mode Transition</span></span>

<span data-ttu-id="15694-295">À présent, examinez ce qui se passe pour le même exemple quand une transition de mode se produit.</span><span class="sxs-lookup"><span data-stu-id="15694-295">Now, look at what happens for the same example when a mode transition occurs.</span></span> <span data-ttu-id="15694-296">Cette fois, supposons que [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) provoquent une transition de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-296">This time, assume [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) cause a mode transition.</span></span> <span data-ttu-id="15694-297">Une fois encore, un profileur d’instrumentation à l’emploi peut retourner des résultats similaires à ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-297">Once again, an off-the-shelf instrumenting profiler could return results similar to these:</span></span>


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



<span data-ttu-id="15694-298">La durée mesurée pour [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) est à peu de temps égale, mais l’augmentation spectaculaire du temps passé dans [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) est due à la transition en mode.</span><span class="sxs-lookup"><span data-stu-id="15694-298">The time measured for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about the same, however, the dramatic increase in the amount of time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is due to the mode transition.</span></span> <span data-ttu-id="15694-299">Voici ce qui se passe :</span><span class="sxs-lookup"><span data-stu-id="15694-299">Here's what is happening:</span></span>

1.  <span data-ttu-id="15694-300">Supposons que le tampon de commande dispose de suffisamment d’espace pour une commande avant le démarrage de la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-300">Assume the command buffer has room for one command before our render sequence starts.</span></span>
2.  <span data-ttu-id="15694-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) est converti en un format indépendant du périphérique et ajouté à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-301">[**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is converted to a device-independent format and added to the command buffer.</span></span> <span data-ttu-id="15694-302">Dans ce scénario, cet appel remplit la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-302">In this scenario, this call fills the command buffer.</span></span>
3.  <span data-ttu-id="15694-303">Le runtime tente d’ajouter [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) à la mémoire tampon de commande, mais ne le peut pas, car il est plein.</span><span class="sxs-lookup"><span data-stu-id="15694-303">The runtime tries to add [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to the command buffer but cannot, because it is full.</span></span> <span data-ttu-id="15694-304">Au lieu de cela, le runtime vide la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-304">Instead, the runtime empties the command buffer.</span></span> <span data-ttu-id="15694-305">Cela provoque la transition en mode noyau.</span><span class="sxs-lookup"><span data-stu-id="15694-305">This causes the kernel-mode transition.</span></span> <span data-ttu-id="15694-306">Supposons que la transition dure environ 5000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-306">Assume the transition takes about 5000 cycles.</span></span> <span data-ttu-id="15694-307">Cette fois, participe au temps passé dans **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="15694-307">This time contributes to time spent in **DrawPrimitive**.</span></span>
4.  <span data-ttu-id="15694-308">Le pilote traite ensuite le travail associé à toutes les commandes qui ont été vidées de la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-308">The driver then processes the work associated with all the commands that were emptied from the command buffer.</span></span> <span data-ttu-id="15694-309">Supposons que le temps du pilote pour traiter les commandes qui ont presque rempli le tampon de commande est d’environ 935 000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-309">Assume that the driver time to process the commands that nearly filled the command buffer is about 935,000 cycles.</span></span> <span data-ttu-id="15694-310">Supposons que le fonctionnement du pilote associé à [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) est d’environ 2750 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-310">Assume that the driver work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2750 cycles.</span></span> <span data-ttu-id="15694-311">Cette fois, participe au temps passé dans [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="15694-311">This time contributes to time spent in [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>
5.  <span data-ttu-id="15694-312">Lorsque le pilote termine son travail, la transition en mode utilisateur retourne le contrôle au Runtime.</span><span class="sxs-lookup"><span data-stu-id="15694-312">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="15694-313">Le tampon de commande est maintenant vide.</span><span class="sxs-lookup"><span data-stu-id="15694-313">The command buffer is now empty.</span></span> <span data-ttu-id="15694-314">Supposons que la transition dure environ 5000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-314">Assume the transition takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="15694-315">La séquence de rendu se termine en convertissant [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) et en l’ajoutant à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-315">The render sequence finishes by converting [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) and adding it to the command buffer.</span></span> <span data-ttu-id="15694-316">Supposons que cela prend environ 900 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-316">Assume this takes about 900 cycles.</span></span> <span data-ttu-id="15694-317">Cette fois, participe au temps passé dans **DrawPrimitive**.</span><span class="sxs-lookup"><span data-stu-id="15694-317">This time contributes to time spent in **DrawPrimitive**.</span></span>

<span data-ttu-id="15694-318">En résumant les résultats, vous voyez :</span><span class="sxs-lookup"><span data-stu-id="15694-318">Summarizing the results, you see:</span></span>


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



<span data-ttu-id="15694-319">Tout comme la mesure pour [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sans la transition de mode (cycles 900), la mesure pour **DrawPrimitive** avec la transition de mode (947 950 cycles) est exacte, mais inutile en termes de budget du travail de l’UC.</span><span class="sxs-lookup"><span data-stu-id="15694-319">Just like the measurement for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) without the mode transition (900 cycles), the measurement for **DrawPrimitive** with the mode transition (947,950 cycles) is accurate but useless in terms of budgeting CPU work.</span></span> <span data-ttu-id="15694-320">Le résultat contient le bon fonctionnement du runtime, le pilote fonctionne pour [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), le pilote fonctionne pour toutes les commandes qui précèdent **SetTexture** et les transitions en deux modes.</span><span class="sxs-lookup"><span data-stu-id="15694-320">The result contains the correct runtime work, the driver work for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), the driver work for any commands that preceded **SetTexture**, and two mode transitions.</span></span> <span data-ttu-id="15694-321">Toutefois, il manque le travail du pilote **DrawPrimitive** dans la mesure.</span><span class="sxs-lookup"><span data-stu-id="15694-321">However, the measurement is missing the **DrawPrimitive** driver work.</span></span>

<span data-ttu-id="15694-322">Une transition en mode peut avoir lieu en réponse à un appel.</span><span class="sxs-lookup"><span data-stu-id="15694-322">A mode transition could happen in response to any call.</span></span> <span data-ttu-id="15694-323">Cela dépend de ce qui se trouvait précédemment dans le tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-323">It depends on what was previously in the command buffer.</span></span> <span data-ttu-id="15694-324">Vous devez contrôler la transition du mode pour comprendre la quantité de travail de l’UC (Runtime et pilote) associée à chaque appel.</span><span class="sxs-lookup"><span data-stu-id="15694-324">You need to control the mode transition to understand how much CPU work (runtime and driver) is associated with each call.</span></span> <span data-ttu-id="15694-325">Pour ce faire, vous avez besoin d’un mécanisme pour contrôler la mémoire tampon de commande et le minutage de la transition de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-325">To do that, you need a mechanism for controlling the command buffer and the timing of the mode transition.</span></span>

### <a name="the-query-mechanism"></a><span data-ttu-id="15694-326">Mécanisme de requête</span><span class="sxs-lookup"><span data-stu-id="15694-326">The Query Mechanism</span></span>

<span data-ttu-id="15694-327">Le mécanisme de requête de Microsoft Direct3D 9 a été conçu pour permettre au runtime d’interroger le GPU à des fins de progression et de retourner certaines données à partir du GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-327">The query mechanism in Microsoft Direct3D 9 was designed to allow the runtime to query the GPU for progress and return certain data from the GPU.</span></span> <span data-ttu-id="15694-328">Lors du profilage, si le travail du GPU est réduit afin d’avoir un impact négligeable sur les performances, vous pouvez retourner l’état du GPU pour aider à mesurer le fonctionnement du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-328">While profiling, if the GPU work is minimized so that it has a negligible impact on performance, you can return status from the GPU to help measure the driver work.</span></span> <span data-ttu-id="15694-329">Après tout, le fonctionnement du pilote est terminé lorsque le GPU a vu les commandes du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-329">After all, the driver work is complete when the GPU has seen the driver commands.</span></span> <span data-ttu-id="15694-330">En outre, le mécanisme de requête peut être coaxiaux en contrôlant deux caractéristiques de mémoire tampon de commande qui sont importantes pour le profilage : lorsque le tampon de commande est vidé et la quantité de travail dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="15694-330">Additionally, the query mechanism can be coaxed into controlling two command buffer characteristics that are important to profiling: when the command buffer empties and how much work is in the buffer.</span></span>

<span data-ttu-id="15694-331">Voici la même séquence de rendu à l’aide du mécanisme de requête :</span><span class="sxs-lookup"><span data-stu-id="15694-331">Here's the same render sequence using the query mechanism:</span></span>


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="15694-332">Exemple 3 : utilisation d’une requête pour contrôler la mémoire tampon de commande</span><span class="sxs-lookup"><span data-stu-id="15694-332">Example 3: Using a Query to Control the Command Buffer</span></span>

<span data-ttu-id="15694-333">Voici une explication plus détaillée de chacune de ces lignes de code :</span><span class="sxs-lookup"><span data-stu-id="15694-333">Here is a more detailed explanation of each of these lines of code:</span></span>

1.  <span data-ttu-id="15694-334">Créez une requête d’événement en créant un objet de requête avec l' \_ événement D3DQUERYTYPE.</span><span class="sxs-lookup"><span data-stu-id="15694-334">Create an event query by creating a query object with D3DQUERYTYPE\_EVENT.</span></span>
2.  <span data-ttu-id="15694-335">Ajoutez un marqueur d’événement de requête à la mémoire tampon de commande en appelant [**issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ end**](d3dissue-end.md)).</span><span class="sxs-lookup"><span data-stu-id="15694-335">Add a query event marker to the command buffer by calling [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE\_END**](d3dissue-end.md)).</span></span> <span data-ttu-id="15694-336">Ce marqueur indique au pilote d’effectuer le suivi de la fin de l’exécution des commandes précédées du marqueur par le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-336">This marker tells the driver to track when the GPU finishes executing whatever commands preceded the marker.</span></span>
3.  <span data-ttu-id="15694-337">Le premier appel vide la mémoire tampon de commande, car l’appel de [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) avec [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) force le vidage de la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-337">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="15694-338">Chaque appel suivant consiste à vérifier le GPU pour voir quand il termine le traitement de l’ensemble du travail de mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-338">Each subsequent call is checking the GPU to see when it finishes processing all the command-buffer work.</span></span> <span data-ttu-id="15694-339">Cette boucle ne retourne pas \_ la réponse OK tant que le GPU n’est pas inactif.</span><span class="sxs-lookup"><span data-stu-id="15694-339">This loop does not return S\_OK until the GPU is idle.</span></span>
4.  <span data-ttu-id="15694-340">Échantillonne l’heure de début.</span><span class="sxs-lookup"><span data-stu-id="15694-340">Sample the start time.</span></span>
5.  <span data-ttu-id="15694-341">Appelez les appels d’API en cours de profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-341">Invoke the API calls being profiled.</span></span>
6.  <span data-ttu-id="15694-342">Ajoutez un deuxième marqueur d’événement de requête à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-342">Add a second query event marker to the command buffer.</span></span> <span data-ttu-id="15694-343">Ce marqueur sera utilisé pour suivre l’achèvement des appels.</span><span class="sxs-lookup"><span data-stu-id="15694-343">This marker will be used to track the completion of the calls.</span></span>
7.  <span data-ttu-id="15694-344">Le premier appel vide la mémoire tampon de commande, car l’appel de [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) avec [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) force le vidage de la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-344">The first call empties the command buffer because calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md) forces the command buffer to be emptied.</span></span> <span data-ttu-id="15694-345">Lorsque le GPU termine le traitement de l’ensemble du travail de mémoire tampon de commande, **GetData** retourne \_ la valeur OK, et la boucle est abandonnée, car le GPU est inactif.</span><span class="sxs-lookup"><span data-stu-id="15694-345">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
8.  <span data-ttu-id="15694-346">Échantillonne l’heure d’arrêt.</span><span class="sxs-lookup"><span data-stu-id="15694-346">Sample the stop time.</span></span>

<span data-ttu-id="15694-347">Voici les résultats mesurés avec QueryPerformanceCounter et QueryPerformanceFrequency :</span><span class="sxs-lookup"><span data-stu-id="15694-347">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="15694-348">Variable locale</span><span class="sxs-lookup"><span data-stu-id="15694-348">Local Variable</span></span> | <span data-ttu-id="15694-349">Nombre de graduations</span><span class="sxs-lookup"><span data-stu-id="15694-349">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="15694-350">start</span><span class="sxs-lookup"><span data-stu-id="15694-350">start</span></span>          | <span data-ttu-id="15694-351">1792998845060</span><span class="sxs-lookup"><span data-stu-id="15694-351">1792998845060</span></span>   |
| <span data-ttu-id="15694-352">stop</span><span class="sxs-lookup"><span data-stu-id="15694-352">stop</span></span>           | <span data-ttu-id="15694-353">1792998845090</span><span class="sxs-lookup"><span data-stu-id="15694-353">1792998845090</span></span>   |
| <span data-ttu-id="15694-354">Fréq</span><span class="sxs-lookup"><span data-stu-id="15694-354">freq</span></span>           | <span data-ttu-id="15694-355">3579545</span><span class="sxs-lookup"><span data-stu-id="15694-355">3579545</span></span>         |



 

<span data-ttu-id="15694-356">Conversion des battements en cycles une nouvelle fois (sur une machine de 2 GHz) :</span><span class="sxs-lookup"><span data-stu-id="15694-356">Converting ticks to cycles once again (on a 2 GHz machine):</span></span>


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



<span data-ttu-id="15694-357">Voici la répartition du nombre de cycles par appel :</span><span class="sxs-lookup"><span data-stu-id="15694-357">Here is the breakdown of the number of cycles per call:</span></span>


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



<span data-ttu-id="15694-358">Le mécanisme de requête nous a permis de contrôler le runtime et le travail du pilote mesuré.</span><span class="sxs-lookup"><span data-stu-id="15694-358">The query mechanism has allowed us to control the runtime and the driver work that is being measured.</span></span> <span data-ttu-id="15694-359">Pour comprendre chacun de ces nombres, voici ce qui se passe en réponse à chacun des appels d’API, ainsi que les minutages estimés :</span><span class="sxs-lookup"><span data-stu-id="15694-359">To understand each of these numbers, here's what is happening in response to each of the API calls, along with the estimated timings:</span></span>

1.  <span data-ttu-id="15694-360">Le premier appel vide la mémoire tampon de commande en appelant [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) avec [**D3DGETDATA \_ flush**](d3dgetdata-flush.md).</span><span class="sxs-lookup"><span data-stu-id="15694-360">The first call empties the command buffer by calling [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) with [**D3DGETDATA\_FLUSH**](d3dgetdata-flush.md).</span></span> <span data-ttu-id="15694-361">Lorsque le GPU termine le traitement de l’ensemble du travail de mémoire tampon de commande, **GetData** retourne \_ la valeur OK, et la boucle est abandonnée, car le GPU est inactif.</span><span class="sxs-lookup"><span data-stu-id="15694-361">When the GPU finishes processing all the command-buffer work, **GetData** returns S\_OK, and the loop is exited because the GPU is idle.</span></span>
2.  <span data-ttu-id="15694-362">La séquence de rendu commence par convertir [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) en un format indépendant du périphérique et en l’ajoutant à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-362">The render sequence starts by converting [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to a device-independent format and adding it to the command buffer.</span></span> <span data-ttu-id="15694-363">Supposons que cela prend environ 100 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-363">Assume this takes about 100 cycles.</span></span>
3.  <span data-ttu-id="15694-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) est converti et ajouté à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-364">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is converted and added to the command buffer.</span></span> <span data-ttu-id="15694-365">Supposons que cela prend environ 900 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-365">Assume this takes about 900 cycles.</span></span>
4.  <span data-ttu-id="15694-366">Le [**problème**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) ajoute un marqueur de requête à la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-366">[**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) adds a query marker to the command buffer.</span></span> <span data-ttu-id="15694-367">Supposons que cela prend environ 200 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-367">Assume this takes about 200 cycles.</span></span>
5.  <span data-ttu-id="15694-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) provoque le vidage de la mémoire tampon de commande, ce qui force la transition en mode noyau.</span><span class="sxs-lookup"><span data-stu-id="15694-368">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) causes the command buffer to be emptied which forces the kernel-mode transition.</span></span> <span data-ttu-id="15694-369">Supposons que cela prend environ 5000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-369">Assume this takes about 5000 cycles.</span></span>
6.  <span data-ttu-id="15694-370">Le pilote traite ensuite le travail associé aux quatre appels.</span><span class="sxs-lookup"><span data-stu-id="15694-370">The driver then processes the work associated with all four calls.</span></span> <span data-ttu-id="15694-371">Supposons que le temps du pilote pour traiter le [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) est d’environ 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) est d’environ 3600 cycles, le [**problème**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) est d’environ 200 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-371">Assume that the driver time to process [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) is about 2964 cycles, [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is about 3600 cycles, [**Issue**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) is about 200 cycles.</span></span> <span data-ttu-id="15694-372">Ainsi, le temps total du pilote pour les quatre commandes est d’environ 6450 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-372">So the total driver time for all four commands is about 6450 cycles.</span></span>
    > [!Note]  
    > <span data-ttu-id="15694-373">Le pilote prend également un peu de temps pour voir l’état du GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-373">The driver also takes a little time to see what the status of the GPU is.</span></span> <span data-ttu-id="15694-374">Étant donné que le fonctionnement du GPU est trivial, le GPU doit déjà être fait.</span><span class="sxs-lookup"><span data-stu-id="15694-374">Because the GPU work is trivial, the GPU should be done already.</span></span> <span data-ttu-id="15694-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) retourne la réponse \_ OK en fonction de la probabilité que le GPU soit terminé.</span><span class="sxs-lookup"><span data-stu-id="15694-375">[**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) will return S\_OK based on the likelihood that the GPU is finished.</span></span>

     

7.  <span data-ttu-id="15694-376">Lorsque le pilote termine son travail, la transition en mode utilisateur retourne le contrôle au Runtime.</span><span class="sxs-lookup"><span data-stu-id="15694-376">When the driver finishes its work, the user-mode transition returns control to the runtime.</span></span> <span data-ttu-id="15694-377">Le tampon de commande est maintenant vide.</span><span class="sxs-lookup"><span data-stu-id="15694-377">The command buffer is now empty.</span></span> <span data-ttu-id="15694-378">Supposons que cela prend environ 5000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-378">Assume this takes about 5000 cycles.</span></span>

<span data-ttu-id="15694-379">Les nombres pour [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) sont les suivants :</span><span class="sxs-lookup"><span data-stu-id="15694-379">The numbers for [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) include:</span></span>


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



<span data-ttu-id="15694-380">Le mécanisme de requête utilisé en association avec QueryPerformanceCounter mesure tout le travail du processeur.</span><span class="sxs-lookup"><span data-stu-id="15694-380">The query mechanism used in combination with QueryPerformanceCounter measures all of the CPU work.</span></span> <span data-ttu-id="15694-381">Cette opération s’effectue avec une combinaison de marqueurs de requête et des comparaisons d’état des requêtes.</span><span class="sxs-lookup"><span data-stu-id="15694-381">This is done with a combination of query markers, and query status comparisons.</span></span> <span data-ttu-id="15694-382">Les marqueurs de début et de fin de requête ajoutés au tampon de commande permettent de contrôler la quantité de travail dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="15694-382">Start and stop query markers added to the command buffer are used to control how much work is in the buffer.</span></span> <span data-ttu-id="15694-383">En attendant que le code de retour correct soit retourné, la mesure de début est effectuée juste avant le début d’une séquence de rendu propre, et la mesure d’arrêt est effectuée juste après que le pilote a terminé le travail associé au contenu de la mémoire tampon de commande.</span><span class="sxs-lookup"><span data-stu-id="15694-383">By waiting until the right return code is returned, the start measurement is made just before a clean render sequence starts, and the stop measurement is made just after the driver has finished the work associated with the command buffer contents.</span></span> <span data-ttu-id="15694-384">Cela permet de capturer efficacement le travail du processeur effectué par le runtime ainsi que le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-384">This effectively captures the CPU work done by the runtime as well as the driver.</span></span>

<span data-ttu-id="15694-385">Maintenant que vous connaissez la mémoire tampon de commande et l’effet qu’elle peut avoir sur le profilage, vous devez savoir qu’il existe quelques autres conditions qui peuvent entraîner le vidage du tampon de commande par le Runtime.</span><span class="sxs-lookup"><span data-stu-id="15694-385">Now that you know about the command buffer and the effect it can have on profiling, you should know that there are a few other conditions that can cause the runtime to empty the command buffer.</span></span> <span data-ttu-id="15694-386">Vous devez les surveiller dans vos séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-386">You need to watch out for these in your render sequences.</span></span> <span data-ttu-id="15694-387">Certaines de ces conditions sont en réponse à des appels d’API, d’autres sont en réponse à des modifications de ressources dans le Runtime.</span><span class="sxs-lookup"><span data-stu-id="15694-387">Some of these conditions are in response to API calls, others are in response to resource changes in the runtime.</span></span> <span data-ttu-id="15694-388">L’une des conditions suivantes entraîne une transition de mode :</span><span class="sxs-lookup"><span data-stu-id="15694-388">Any of the following conditions will cause a mode transition:</span></span>

-   <span data-ttu-id="15694-389">Quand l’une des méthodes de verrouillage ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) est appelée sur une mémoire tampon de vertex, une mémoire tampon d’index ou une texture (sous certaines conditions avec certains indicateurs).</span><span class="sxs-lookup"><span data-stu-id="15694-389">When one of the lock methods ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) is called on a vertex buffer, index buffer, or texture (under certain conditions with certain flags).</span></span>
-   <span data-ttu-id="15694-390">Lors de la création d’une mémoire tampon de l’appareil ou d’un vertex, d’un tampon d’index ou d’une texture.</span><span class="sxs-lookup"><span data-stu-id="15694-390">When a device or vertex buffer, index buffer, or texture is created.</span></span>
-   <span data-ttu-id="15694-391">Quand une mémoire tampon de périphérique ou de vertex, une mémoire tampon d’index ou une texture sont détruites par la dernière version.</span><span class="sxs-lookup"><span data-stu-id="15694-391">When a device or vertex buffer, index buffer, or texture is destroyed by the last release.</span></span>
-   <span data-ttu-id="15694-392">Lorsque [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) est appelé.</span><span class="sxs-lookup"><span data-stu-id="15694-392">When [**ValidateDevice**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) is called.</span></span>
-   <span data-ttu-id="15694-393">Lorsqu’il est [**présent**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) , est appelé.</span><span class="sxs-lookup"><span data-stu-id="15694-393">When [**Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) is called.</span></span>
-   <span data-ttu-id="15694-394">Lorsque la mémoire tampon de commande est remplie.</span><span class="sxs-lookup"><span data-stu-id="15694-394">When the command buffer fills up.</span></span>
-   <span data-ttu-id="15694-395">Lorsque [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) est appelé avec D3DGETDATA \_ Flush.</span><span class="sxs-lookup"><span data-stu-id="15694-395">When [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) is called with D3DGETDATA\_FLUSH.</span></span>

<span data-ttu-id="15694-396">Veillez à surveiller ces conditions dans vos séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-396">Be careful to watch for these conditions in your render sequences.</span></span> <span data-ttu-id="15694-397">À chaque fois qu’une transition de mode est ajoutée, 10 000 cycles de travail du pilote sont ajoutés à vos mesures de profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-397">Every time a mode transition is added, 10,000 cycles of driver work will be added to your profiling measurements.</span></span> <span data-ttu-id="15694-398">En outre, la mémoire tampon de commande n’est pas dimensionnée statiquement.</span><span class="sxs-lookup"><span data-stu-id="15694-398">In addition, the command buffer is not statically sized.</span></span> <span data-ttu-id="15694-399">Le runtime peut modifier la taille de la mémoire tampon en réponse à la quantité de travail qui est générée par l’application.</span><span class="sxs-lookup"><span data-stu-id="15694-399">The runtime may change the buffer's size in response to the amount of work that is being generated by the application.</span></span> <span data-ttu-id="15694-400">Il s’agit d’une autre optimisation qui est dépendante d’une séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-400">This is yet another optimization that is dependent on a render sequence.</span></span>

<span data-ttu-id="15694-401">Veillez donc à contrôler les transitions de mode pendant le profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-401">So be careful to control mode transitions during profiling.</span></span> <span data-ttu-id="15694-402">Le mécanisme de requête offre une méthode fiable pour vider le tampon de commande afin que vous puissiez contrôler le minutage de la transition du mode, ainsi que la quantité de travail que contient la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="15694-402">The query mechanism offers a robust method for emptying the command buffer so that you can control the timing of the mode transition as well as the amount of work the buffer contains.</span></span> <span data-ttu-id="15694-403">Toutefois, même cette technique peut être améliorée en réduisant le temps de transition du mode pour qu’elle soit non significative en ce qui concerne le résultat mesuré.</span><span class="sxs-lookup"><span data-stu-id="15694-403">However, even this technique can be improved by reducing the mode transition time to make it insignificant with respect to the measured result.</span></span>

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a><span data-ttu-id="15694-404">Rendre la séquence de rendu plus grande comparée à la transition de mode</span><span class="sxs-lookup"><span data-stu-id="15694-404">Make the Render Sequence Large Compared to the Mode Transition</span></span>

<span data-ttu-id="15694-405">Dans l’exemple précédent, le commutateur en mode noyau et le commutateur en mode utilisateur consomment environ 10 000 cycles qui n’ont rien à faire avec le fonctionnement du runtime et du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-405">In the previous example, the kernel-mode switch and the user-mode switch consume about 10,000 cycles that have nothing to do with runtime and driver work.</span></span> <span data-ttu-id="15694-406">Étant donné que la transition de mode est intégrée au système d’exploitation, elle ne peut pas être réduite à zéro.</span><span class="sxs-lookup"><span data-stu-id="15694-406">Since the mode transition is built into the operating system, it cannot be reduced to zero.</span></span> <span data-ttu-id="15694-407">Pour rendre le mode non significatif, la séquence de rendu doit être ajustée pour que le fonctionnement du pilote et du runtime soit un ordre de grandeur supérieur aux commutateurs de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-407">To make the mode transition insignificant, the render sequence needs to adjusted so that the driver and runtime work are an order of magnitude larger than the mode switches.</span></span> <span data-ttu-id="15694-408">Vous pouvez essayer d’effectuer une soustraction pour supprimer les transitions, mais l’amortissement du coût sur un coût de séquence de rendu bien plus élevé est plus fiable.</span><span class="sxs-lookup"><span data-stu-id="15694-408">You could try to do a subtraction to remove the transitions, but amortizing the cost over a much larger render sequence cost is more reliable.</span></span>

<span data-ttu-id="15694-409">La stratégie de réduction du mode de transition jusqu’à ce qu’il devienne non significatif consiste à ajouter une boucle à la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-409">The strategy for reducing the mode transition until it becomes insignificant is to add a loop to the render sequence.</span></span> <span data-ttu-id="15694-410">Par exemple, examinons les résultats de profilage si vous ajoutez une boucle qui répétera la séquence de rendu 1500 fois :</span><span class="sxs-lookup"><span data-stu-id="15694-410">For example, let look at the profiling results if a loop is added that will repeat the render sequence 1500 times:</span></span>


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



<span data-ttu-id="15694-411">Exemple 4 : ajouter une boucle à la séquence de rendu</span><span class="sxs-lookup"><span data-stu-id="15694-411">Example 4: Add a Loop to the Render Sequence</span></span>

<span data-ttu-id="15694-412">Voici les résultats mesurés avec QueryPerformanceCounter et QueryPerformanceFrequency :</span><span class="sxs-lookup"><span data-stu-id="15694-412">Here are the results measured with QueryPerformanceCounter and QueryPerformanceFrequency:</span></span>



| <span data-ttu-id="15694-413">Variable locale</span><span class="sxs-lookup"><span data-stu-id="15694-413">Local Variable</span></span> | <span data-ttu-id="15694-414">Nombre de tics</span><span class="sxs-lookup"><span data-stu-id="15694-414">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="15694-415">start</span><span class="sxs-lookup"><span data-stu-id="15694-415">start</span></span>          | <span data-ttu-id="15694-416">1792998845000</span><span class="sxs-lookup"><span data-stu-id="15694-416">1792998845000</span></span>  |
| <span data-ttu-id="15694-417">stop</span><span class="sxs-lookup"><span data-stu-id="15694-417">stop</span></span>           | <span data-ttu-id="15694-418">1792998847084</span><span class="sxs-lookup"><span data-stu-id="15694-418">1792998847084</span></span>  |
| <span data-ttu-id="15694-419">Fréq</span><span class="sxs-lookup"><span data-stu-id="15694-419">freq</span></span>           | <span data-ttu-id="15694-420">3579545</span><span class="sxs-lookup"><span data-stu-id="15694-420">3579545</span></span>        |



 

<span data-ttu-id="15694-421">L’utilisation des mesures QueryPerformanceCounter 2 840 est maintenant terminée.</span><span class="sxs-lookup"><span data-stu-id="15694-421">Using QueryPerformanceCounter measures 2,840 ticks now.</span></span> <span data-ttu-id="15694-422">La conversion des battements en cycles est identique à celle que nous avons déjà indiquée :</span><span class="sxs-lookup"><span data-stu-id="15694-422">Converting ticks to cycles is the same as we have already shown:</span></span>


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



<span data-ttu-id="15694-423">En d’autres termes, il faut environ 6,9 millions cycles sur cet ordinateur de 2 GHz pour traiter les appels 1500 dans la boucle de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-423">In other words, it takes about 6.9 million cycles on this 2 GHz machine to process the 1500 calls in the render loop.</span></span> <span data-ttu-id="15694-424">Des cycles de 6,9 millions, la durée des transitions de mode est d’environ 10 Ko, donc les résultats du profil sont presque entièrement mesurant le travail associé à [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="15694-424">Of the 6.9 million cycles, the amount of time in the mode transitions is approximately 10k, so now the profile results are almost entirely measuring work associated with [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span>

<span data-ttu-id="15694-425">Notez que l’exemple de code requiert un tableau de deux textures.</span><span class="sxs-lookup"><span data-stu-id="15694-425">Notice that the code sample requires an array of two textures.</span></span> <span data-ttu-id="15694-426">Pour éviter une optimisation du runtime qui supprime [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) si elle définit le même pointeur de texture chaque fois qu’elle est appelée, utilisez simplement un tableau de deux textures.</span><span class="sxs-lookup"><span data-stu-id="15694-426">To avoid a runtime optimization that would remove [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) if it sets the same texture pointer every time it is called, simply use an array of two textures.</span></span> <span data-ttu-id="15694-427">De cette façon, chaque fois que la boucle est exécutée, le pointeur de texture change et le travail complet associé à **SetTexture** est effectué.</span><span class="sxs-lookup"><span data-stu-id="15694-427">That way, each time through the loop, the texture pointer changes, and the full work associated with **SetTexture** is performed.</span></span> <span data-ttu-id="15694-428">Assurez-vous que les deux textures ont la même taille et le même format, afin qu’aucun autre État ne change en cas de texture.</span><span class="sxs-lookup"><span data-stu-id="15694-428">Be sure that both textures are the same size and format, so that no other state will change when the texture does.</span></span>

<span data-ttu-id="15694-429">Et maintenant, vous disposez d’une technique pour profiler Direct3D.</span><span class="sxs-lookup"><span data-stu-id="15694-429">And now you have a technique for profiling Direct3D.</span></span> <span data-ttu-id="15694-430">Il s’appuie sur le compteur de performances élevé (QueryPerformanceCounter) pour enregistrer le nombre de graduations qu’il prend pour traiter le travail.</span><span class="sxs-lookup"><span data-stu-id="15694-430">It relies on the high performance counter (QueryPerformanceCounter) to record the number of ticks it takes the CPU to process work.</span></span> <span data-ttu-id="15694-431">Le travail est soigneusement contrôlé pour être le travail du runtime et du pilote associé aux appels d’API à l’aide du mécanisme de requête.</span><span class="sxs-lookup"><span data-stu-id="15694-431">The work is carefully controlled to be the runtime and driver work associated with API calls using the query mechanism.</span></span> <span data-ttu-id="15694-432">Une requête fournit deux méthodes de contrôle : tout d’abord pour vider la mémoire tampon de commande avant le démarrage de la séquence de rendu, et ensuite pour retourner à la fin du travail GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-432">A query provides two means of control: first to empty the command buffer before the render sequence starts, and secondly to return when the GPU work is finished.</span></span>

<span data-ttu-id="15694-433">Jusqu’à présent, ce document explique comment profiler une séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-433">So far, this paper has shown how to profile a render sequence.</span></span> <span data-ttu-id="15694-434">Chaque séquence de rendu a été assez simple, contenant un appel [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) unique et un appel [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) .</span><span class="sxs-lookup"><span data-stu-id="15694-434">Each render sequence has been fairly simple, containing a single [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call and a [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) call.</span></span> <span data-ttu-id="15694-435">Cela a été fait pour se concentrer sur la mémoire tampon de commande et l’utilisation du mécanisme de requête pour la contrôler.</span><span class="sxs-lookup"><span data-stu-id="15694-435">This was done to focus on the command buffer and the use of the query mechanism to control it.</span></span> <span data-ttu-id="15694-436">Voici un bref résumé de la procédure de profilage d’une séquence de rendu arbitraire :</span><span class="sxs-lookup"><span data-stu-id="15694-436">Here is a brief summary of how to profile an arbitrary render sequence:</span></span>

-   <span data-ttu-id="15694-437">Utilisez un compteur de performances élevé comme QueryPerformanceCounter pour mesurer le temps nécessaire au traitement de chaque appel d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-437">Use a high performance counter like QueryPerformanceCounter to measure the time it takes to process each API call.</span></span> <span data-ttu-id="15694-438">Utilisez QueryPerformanceFrequency et le taux d’horloge de l’UC pour convertir cela en nombre de cycles de processeur par appel d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-438">Use QueryPerformanceFrequency and the CPU clock rate to convert this to the number of CPU cycles per API call.</span></span>
-   <span data-ttu-id="15694-439">Réduisez le nombre d’opérations GPU en affichant des listes de triangles, où chaque triangle contient un pixel.</span><span class="sxs-lookup"><span data-stu-id="15694-439">Minimize the amount of GPU work by rendering triangle lists, where each triangle contains one pixel.</span></span>
-   <span data-ttu-id="15694-440">Utilisez le mécanisme de requête pour vider la mémoire tampon de commande avant la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-440">Use the query mechanism to empty the command buffer before the render sequence.</span></span> <span data-ttu-id="15694-441">Cela permet de garantir que le profilage capturera la quantité correcte de travail de Runtime et de pilote associée à la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-441">This guarantees that profiling will capturing the correct amount of runtime and driver work associated with the render sequence.</span></span>
-   <span data-ttu-id="15694-442">Contrôler la quantité de travail ajoutée à la mémoire tampon de commande à l’aide de marqueurs d’événements de requête.</span><span class="sxs-lookup"><span data-stu-id="15694-442">Control the amount of work added to the command buffer with query event markers.</span></span> <span data-ttu-id="15694-443">Cette même requête détecte à quel moment le travail du GPU est terminé.</span><span class="sxs-lookup"><span data-stu-id="15694-443">This same query detects when the GPU finishes its work.</span></span> <span data-ttu-id="15694-444">Étant donné que le fonctionnement du GPU est trivial, il est quasiment équivalent à la mesure de la fin du fonctionnement du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-444">Since the GPU work is trivial, this is virtually equivalent to measuring when the driver work is completed.</span></span>

<span data-ttu-id="15694-445">Toutes ces techniques sont utilisées pour profiler les changements d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-445">All of these techniques are used to profile state changes.</span></span> <span data-ttu-id="15694-446">En supposant que vous avez lu et compris comment contrôler le tampon de commande et que vous avez terminé avec succès les mesures de ligne de base sur [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), vous êtes prêt à ajouter des modifications d’État à vos séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-446">Assuming that you have read and understood how to control the command buffer, and have successfully completed baseline measurements on [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), you are ready to add state changes to your render sequences.</span></span> <span data-ttu-id="15694-447">Il existe quelques défis supplémentaires de profilage lors de l’ajout de modifications d’État à une séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-447">There are a few additional profiling challenges when adding state changes to a render sequence.</span></span> <span data-ttu-id="15694-448">Si vous envisagez d’ajouter des modifications d’État à vos séquences de rendu, veillez à passer à la section suivante.</span><span class="sxs-lookup"><span data-stu-id="15694-448">If you intend to add state changes to your render sequences, be sure to continue into the next section.</span></span>

## <a name="profiling-direct3d-state-changes"></a><span data-ttu-id="15694-449">Profilage des modifications de l’État Direct3D</span><span class="sxs-lookup"><span data-stu-id="15694-449">Profiling Direct3D State Changes</span></span>

<span data-ttu-id="15694-450">Direct3D utilise de nombreux États de rendu pour contrôler presque tous les aspects du pipeline.</span><span class="sxs-lookup"><span data-stu-id="15694-450">Direct3D uses many render states to control almost every aspect of the pipeline.</span></span> <span data-ttu-id="15694-451">Les API qui entraînent des changements d’État incluent toute fonction ou méthode autre que les \* appels de primitives de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-451">The APIs that cause state changes include any function or method other than the Draw\*Primitive calls.</span></span>

<span data-ttu-id="15694-452">Les changements d’État sont délicats, car il est possible que vous ne puissiez pas voir le coût d’un changement d’État sans rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-452">State changes are tricky because you may not be able to see the cost of a state change without rendering.</span></span> <span data-ttu-id="15694-453">Cela est dû à l’algorithme paresseux utilisé par le pilote et le GPU pour différer le travail jusqu’à ce qu’il soit absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="15694-453">This is a result of the lazy algorithm that the driver and the GPU use to defer work until it absolutely has to be done.</span></span> <span data-ttu-id="15694-454">En général, vous devez suivre ces étapes pour mesurer un seul changement d’État :</span><span class="sxs-lookup"><span data-stu-id="15694-454">In general, you should follow these steps to measure a single state change:</span></span>

1.  <span data-ttu-id="15694-455">Commencez par Profiler [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="15694-455">Profile [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) first.</span></span>
2.  <span data-ttu-id="15694-456">Ajoutez une modification d’État à la séquence de rendu et profilez la nouvelle séquence.</span><span class="sxs-lookup"><span data-stu-id="15694-456">Add one state change to the render sequence and profile the new sequence.</span></span>
3.  <span data-ttu-id="15694-457">Soustraire la différence entre les deux séquences pour connaître le coût du changement d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-457">Subtract the difference between the two sequences to get the cost of the state change.</span></span>

<span data-ttu-id="15694-458">Naturellement, tout ce que vous avez appris à utiliser le mécanisme de requête et à placer la séquence de rendu dans une boucle pour nier le coût de la transition en mode s’applique toujours.</span><span class="sxs-lookup"><span data-stu-id="15694-458">Naturally, everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

### <a name="profiling-a-simple-state-change"></a><span data-ttu-id="15694-459">Profilage d’une modification d’état simple</span><span class="sxs-lookup"><span data-stu-id="15694-459">Profiling a Simple State Change</span></span>

<span data-ttu-id="15694-460">À partir d’une séquence de rendu qui contient [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), voici la séquence de code pour mesurer le coût de l’ajout de [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span><span class="sxs-lookup"><span data-stu-id="15694-460">Starting with a render sequence that contains [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), here is the code sequence for measuring the cost of adding [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):</span></span>


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="15694-461">Exemple 5 : mesure d’un appel d’API de modification d’État</span><span class="sxs-lookup"><span data-stu-id="15694-461">Example 5: Measuring One State Change API Call</span></span>

<span data-ttu-id="15694-462">Notez que la boucle contient deux appels, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="15694-462">Notice that the loop contains two calls, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="15694-463">La séquence de rendu effectue une boucle de 1500 fois et génère des résultats similaires à ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-463">The render sequence loops 1500 times and generates results similar to these:</span></span>



| <span data-ttu-id="15694-464">Variable locale</span><span class="sxs-lookup"><span data-stu-id="15694-464">Local Variable</span></span> | <span data-ttu-id="15694-465">Nombre de tics</span><span class="sxs-lookup"><span data-stu-id="15694-465">Number of Tics</span></span> |
|----------------|----------------|
| <span data-ttu-id="15694-466">start</span><span class="sxs-lookup"><span data-stu-id="15694-466">start</span></span>          | <span data-ttu-id="15694-467">1792998860000</span><span class="sxs-lookup"><span data-stu-id="15694-467">1792998860000</span></span>  |
| <span data-ttu-id="15694-468">stop</span><span class="sxs-lookup"><span data-stu-id="15694-468">stop</span></span>           | <span data-ttu-id="15694-469">1792998870260</span><span class="sxs-lookup"><span data-stu-id="15694-469">1792998870260</span></span>  |
| <span data-ttu-id="15694-470">Fréq</span><span class="sxs-lookup"><span data-stu-id="15694-470">freq</span></span>           | <span data-ttu-id="15694-471">3579545</span><span class="sxs-lookup"><span data-stu-id="15694-471">3579545</span></span>        |



 

<span data-ttu-id="15694-472">La conversion des battements en cycles à nouveau donne :</span><span class="sxs-lookup"><span data-stu-id="15694-472">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



<span data-ttu-id="15694-473">La division par le nombre d’itérations dans la boucle génère :</span><span class="sxs-lookup"><span data-stu-id="15694-473">Dividing by the number of iterations in the loop yields:</span></span>


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



<span data-ttu-id="15694-474">Chaque itération de la boucle contient un changement d’État et un appel de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-474">Each iteration of the loop contains a state change and a draw call.</span></span> <span data-ttu-id="15694-475">Le fait de soustraire le résultat de la séquence de rendu [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) laisse :</span><span class="sxs-lookup"><span data-stu-id="15694-475">Subtracting out the result of the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence leaves:</span></span>


```
3850 - 1100 = 2750 cycles for SetTexture
```



<span data-ttu-id="15694-476">Il s’agit du nombre moyen de cycles pour ajouter des [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) à cette séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-476">This is the average number of cycles to add [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) to this render sequence.</span></span> <span data-ttu-id="15694-477">Cette même technique peut être appliquée à d’autres modifications d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-477">This same technique can be applied to other state changes.</span></span>

<span data-ttu-id="15694-478">Pourquoi la [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) est-elle appelée simple changement d’État ?</span><span class="sxs-lookup"><span data-stu-id="15694-478">Why is [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) called a simple state change?</span></span> <span data-ttu-id="15694-479">Étant donné que l’état défini est restreint afin que le pipeline effectue la même quantité de travail chaque fois que l’État est modifié.</span><span class="sxs-lookup"><span data-stu-id="15694-479">Because the state that is being set is constrained so that the pipeline does the same amount of work each time the state is changed.</span></span> <span data-ttu-id="15694-480">Contraindre les deux textures à la même taille et au même format garantit la même quantité de travail pour chaque appel **SetTexture** .</span><span class="sxs-lookup"><span data-stu-id="15694-480">Constraining both textures to the same size and format assures the same amount of work for each **SetTexture** call.</span></span>

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a><span data-ttu-id="15694-481">Profilage d’une modification d’État qui doit être activée/désactivée</span><span class="sxs-lookup"><span data-stu-id="15694-481">Profiling a State Change that Needs to Be Toggled</span></span>

<span data-ttu-id="15694-482">D’autres modifications d’État peuvent entraîner la modification de la quantité de travail effectuée par le pipeline Graphics pour chaque itération de la boucle de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-482">There are other state changes that cause the amount of work performed by the graphics pipeline to change for every iteration of the render loop.</span></span> <span data-ttu-id="15694-483">Par exemple, si le test z est activé, chaque couleur de pixel met à jour une cible de rendu uniquement après que la valeur z du nouveau pixel a été testée par rapport à la valeur z du pixel existant.</span><span class="sxs-lookup"><span data-stu-id="15694-483">For example, if z-testing is enabled, each pixel color updates a render target only after the new pixel's z value is tested against the z-value for the existing pixel.</span></span> <span data-ttu-id="15694-484">Si le test z est désactivé, ce test par pixel n’est pas effectué et la sortie est écrite beaucoup plus rapidement.</span><span class="sxs-lookup"><span data-stu-id="15694-484">If z-testing is disabled, this per-pixel test is not done and the output is written much faster.</span></span> <span data-ttu-id="15694-485">L’activation ou la désactivation de l’État z-test modifie considérablement la quantité de travail effectuée (par le processeur et le GPU) pendant le rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-485">Enabling or disabling the z-test state dramatically changes the amount of work done (by the CPU as well as the GPU) during rendering.</span></span>

<span data-ttu-id="15694-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requiert un état de rendu particulier et une valeur d’État pour activer ou désactiver le test z.</span><span class="sxs-lookup"><span data-stu-id="15694-486">[**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) requires a particular render state and a state value to enable or disable z-testing.</span></span> <span data-ttu-id="15694-487">La valeur d’État particulière est évaluée au moment de l’exécution pour déterminer la quantité de travail nécessaire.</span><span class="sxs-lookup"><span data-stu-id="15694-487">The particular state value is evaluated at runtime to determine how much work is necessary.</span></span> <span data-ttu-id="15694-488">Il est difficile de mesurer ce changement d’État dans une boucle de rendu tout en préservant l’état du pipeline pour qu’il bascule.</span><span class="sxs-lookup"><span data-stu-id="15694-488">It is difficult to measure this state change in a render loop and still precondition the pipeline state so that it switches.</span></span> <span data-ttu-id="15694-489">La seule solution consiste à basculer le changement d’État au cours de la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-489">The only solution is to toggle the state change during the render sequence.</span></span>

<span data-ttu-id="15694-490">Par exemple, la technique de profilage doit être répétée deux fois, comme suit :</span><span class="sxs-lookup"><span data-stu-id="15694-490">For example, the profiling technique needs to be repeated twice as follows:</span></span>

1.  <span data-ttu-id="15694-491">Commencez par profiler la séquence de rendu [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .</span><span class="sxs-lookup"><span data-stu-id="15694-491">Start by profiling the [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) render sequence.</span></span> <span data-ttu-id="15694-492">Appelez cette ligne de base.</span><span class="sxs-lookup"><span data-stu-id="15694-492">Call this the baseline.</span></span>
2.  <span data-ttu-id="15694-493">Profiler une deuxième séquence de rendu qui bascule le changement d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-493">Profile a second render sequence that toggles the state change.</span></span> <span data-ttu-id="15694-494">La boucle de séquence de rendu contient les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="15694-494">The render sequence loop contains:</span></span>
    -   <span data-ttu-id="15694-495">Changement d’État pour définir l’État dans une condition « false ».</span><span class="sxs-lookup"><span data-stu-id="15694-495">A state change to set the state into a "false" condition.</span></span>
    -   <span data-ttu-id="15694-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) exactement comme la séquence d’origine.</span><span class="sxs-lookup"><span data-stu-id="15694-496">[**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) just like the original sequence.</span></span>
    -   <span data-ttu-id="15694-497">Changement d’État pour définir l’État dans une condition « true ».</span><span class="sxs-lookup"><span data-stu-id="15694-497">A state change to set the state into a "true" condition.</span></span>
    -   <span data-ttu-id="15694-498">Deuxième [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) pour forcer la réalisation de la deuxième modification d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-498">A second [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) to force the second state change to be realized.</span></span>
3.  <span data-ttu-id="15694-499">Recherchez la différence entre les deux séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-499">Find the difference between the two render sequences.</span></span> <span data-ttu-id="15694-500">Pour ce faire :</span><span class="sxs-lookup"><span data-stu-id="15694-500">This is done by:</span></span>
    -   <span data-ttu-id="15694-501">Multipliez la séquence de base [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) par 2, car il existe deux appels **DrawPrimitive** dans la nouvelle séquence.</span><span class="sxs-lookup"><span data-stu-id="15694-501">Multiply the baseline [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) sequence by 2 because there are two **DrawPrimitive** calls in the new sequence.</span></span>
    -   <span data-ttu-id="15694-502">Soustrait le résultat de la nouvelle séquence de la séquence d’origine.</span><span class="sxs-lookup"><span data-stu-id="15694-502">Subtract the result of the new sequence from the original sequence.</span></span>
    -   <span data-ttu-id="15694-503">Divisez le résultat par 2 pour obtenir le coût moyen du changement d’état « false » et « true ».</span><span class="sxs-lookup"><span data-stu-id="15694-503">Divide the result by 2 to get the average cost of both the "false" and the "true" state change.</span></span>

<span data-ttu-id="15694-504">Avec la technique de bouclage utilisée dans la séquence de rendu, le coût de la modification de l’état du pipeline doit être mesuré en basculant l’état d’une « vraie » à une condition « false » et vice versa, pour chaque itération de la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-504">With the looping technique used in the render sequence, the cost of changing pipeline state needs to be measured by toggling the state from a "true" to a "false" condition and vice versa, for each iteration in the render sequence.</span></span> <span data-ttu-id="15694-505">La signification de « true » et « false » ici ne sont pas des littéraux, ce qui signifie simplement que l’État doit être défini dans des conditions opposées.</span><span class="sxs-lookup"><span data-stu-id="15694-505">The meaning of "true" and "false" here are not literal, this simply means that the state needs to be set into opposing conditions.</span></span> <span data-ttu-id="15694-506">Cela entraîne la mesure des modifications d’État au cours du profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-506">This causes both state changes to be measured during profiling.</span></span> <span data-ttu-id="15694-507">Bien entendu, tout ce que vous avez appris à utiliser le mécanisme de requête et à placer la séquence de rendu dans une boucle pour nier le coût de la transition en mode s’applique toujours.</span><span class="sxs-lookup"><span data-stu-id="15694-507">Of course everything you have learned about using the query mechanism and putting the render sequence in a loop to negate the cost of the mode transition still applies.</span></span>

<span data-ttu-id="15694-508">Par exemple, voici la séquence de code pour mesurer le coût d’activation ou de désactivation du test z :</span><span class="sxs-lookup"><span data-stu-id="15694-508">For example, here is the code sequence for measuring the cost of toggling z-testing on or off:</span></span>


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



<span data-ttu-id="15694-509">Exemple 5 : mesure d’un changement d’état de basculement</span><span class="sxs-lookup"><span data-stu-id="15694-509">Example 5: Measuring a Toggling State Change</span></span>

<span data-ttu-id="15694-510">La boucle bascule l’État en exécutant deux appels [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) .</span><span class="sxs-lookup"><span data-stu-id="15694-510">The loop toggles the state by executing two [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) calls.</span></span> <span data-ttu-id="15694-511">Le premier appel **SetRenderState** désactive z-testing et le second **SetRenderState** active les tests z.</span><span class="sxs-lookup"><span data-stu-id="15694-511">The first **SetRenderState** call disables z-testing and the second **SetRenderState** enables z-testing.</span></span> <span data-ttu-id="15694-512">Chaque **SetRenderState** est suivi par [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , de sorte que le travail associé au changement d’État est traité par le pilote au lieu de définir uniquement un bit non intègre dans le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-512">Each **SetRenderState** is followed by [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) so that the work associated with the state change is processed by the driver instead of only setting a dirty bit in the driver.</span></span>

<span data-ttu-id="15694-513">Ces nombres sont raisonnables pour cette séquence de rendu :</span><span class="sxs-lookup"><span data-stu-id="15694-513">These numbers are reasonable for this render sequence:</span></span>



| <span data-ttu-id="15694-514">Variable locale</span><span class="sxs-lookup"><span data-stu-id="15694-514">Local Variable</span></span> | <span data-ttu-id="15694-515">Nombre de graduations</span><span class="sxs-lookup"><span data-stu-id="15694-515">Number of Ticks</span></span> |
|----------------|-----------------|
| <span data-ttu-id="15694-516">start</span><span class="sxs-lookup"><span data-stu-id="15694-516">start</span></span>          | <span data-ttu-id="15694-517">1792998845000</span><span class="sxs-lookup"><span data-stu-id="15694-517">1792998845000</span></span>   |
| <span data-ttu-id="15694-518">stop</span><span class="sxs-lookup"><span data-stu-id="15694-518">stop</span></span>           | <span data-ttu-id="15694-519">1792998861740</span><span class="sxs-lookup"><span data-stu-id="15694-519">1792998861740</span></span>   |
| <span data-ttu-id="15694-520">Fréq</span><span class="sxs-lookup"><span data-stu-id="15694-520">freq</span></span>           | <span data-ttu-id="15694-521">3579545</span><span class="sxs-lookup"><span data-stu-id="15694-521">3579545</span></span>         |



 

<span data-ttu-id="15694-522">La conversion des battements en cycles à nouveau donne :</span><span class="sxs-lookup"><span data-stu-id="15694-522">Converting ticks to cycles once again yields:</span></span>


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



<span data-ttu-id="15694-523">La division par le nombre d’itérations dans la boucle génère :</span><span class="sxs-lookup"><span data-stu-id="15694-523">Dividing by the number of iterations in the loop yields:</span></span>


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



<span data-ttu-id="15694-524">Chaque itération de la boucle contient deux modifications d’État et deux appels de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-524">Each iteration of the loop contains two state changes and two draw calls.</span></span> <span data-ttu-id="15694-525">La soustraction des appels de dessin (en supposant que 1100 cycles) laisse :</span><span class="sxs-lookup"><span data-stu-id="15694-525">Subtracting out the draw calls (assuming 1100 cycles) leaves:</span></span>


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



<span data-ttu-id="15694-526">Il s’agit du nombre moyen de cycles pour les deux changements d’État. la durée moyenne pour chaque changement d’État est donc :</span><span class="sxs-lookup"><span data-stu-id="15694-526">This is the average number of cycles for both state changes so the average time for each state change is:</span></span>


```
4000 / 2  = 2000 cycles for each state change
```



<span data-ttu-id="15694-527">Par conséquent, le nombre moyen de cycles pour activer ou désactiver les tests z est de 2000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-527">Therefore, the average number of cycles to enable or disable z-testing is 2000 cycles.</span></span> <span data-ttu-id="15694-528">Il est intéressant de noter que QueryPerformanceCounter mesure la demi-heure et le z-désactivent la moitié du temps.</span><span class="sxs-lookup"><span data-stu-id="15694-528">It is worth noting that QueryPerformanceCounter is measuring z-enable half the time and z-disable half of the time.</span></span> <span data-ttu-id="15694-529">Cette technique mesure en fait la moyenne des deux modifications d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-529">This technique actually measures the average of both state changes.</span></span> <span data-ttu-id="15694-530">En d’autres termes, vous mesurez le temps de basculement d’un État.</span><span class="sxs-lookup"><span data-stu-id="15694-530">In other words, you are measuring the time to toggle a state.</span></span> <span data-ttu-id="15694-531">À l’aide de cette technique, vous n’avez aucun moyen de savoir si les heures d’activation et de désactivation sont équivalentes, car vous avez mesuré la moyenne des deux.</span><span class="sxs-lookup"><span data-stu-id="15694-531">Using this technique, you have no way of knowing if the enable and disable times are equivalent since you have measured the average of both of them.</span></span> <span data-ttu-id="15694-532">Toutefois, il s’agit d’un nombre raisonnable à utiliser lors du budget d’un état de basculement en tant qu’application qui provoque cette modification d’état uniquement en basculant cet État.</span><span class="sxs-lookup"><span data-stu-id="15694-532">Nevertheless, this is a reasonable number to use when budgeting a toggling state as an application that causes this state change can only do so by toggling this state.</span></span>

<span data-ttu-id="15694-533">Maintenant, vous pouvez appliquer ces techniques et Profiler toutes les modifications d’État que vous souhaitez, n’est-ce pas ?</span><span class="sxs-lookup"><span data-stu-id="15694-533">So now you can apply these techniques and profile all the state changes you want, right?</span></span> <span data-ttu-id="15694-534">Pas tout à fait.</span><span class="sxs-lookup"><span data-stu-id="15694-534">Not quite.</span></span> <span data-ttu-id="15694-535">Vous devez toujours faire attention aux optimisations conçues pour réduire la quantité de travail qui doit être effectuée.</span><span class="sxs-lookup"><span data-stu-id="15694-535">You still need to be careful about optimizations that are designed to reduce the amount of work that needs to be done.</span></span> <span data-ttu-id="15694-536">Il existe deux types d’optimisations que vous devez connaître lors de la conception de vos séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-536">There are two types of optimizations that you should be aware of when designing your render sequences.</span></span>

### <a name="watch-out-for-state-change-optimizations"></a><span data-ttu-id="15694-537">Méfiez-vous des optimisations de changement d’État</span><span class="sxs-lookup"><span data-stu-id="15694-537">Watch Out for State Change Optimizations</span></span>

<span data-ttu-id="15694-538">La section précédente montre comment profiler les deux types de modifications d’État : un changement d’état simple qui est restreint pour générer la même quantité de travail pour chaque itération et une modification de l’état de basculement qui modifie radicalement la quantité de travail effectuée.</span><span class="sxs-lookup"><span data-stu-id="15694-538">The previous section show how to profile both kinds of state changes: a simple state change that is constrained to generate the same amount of work for each iteration, and a toggling state change that dramatically changes the amount of work done.</span></span> <span data-ttu-id="15694-539">Que se passe-t-il si vous prenez la séquence de rendu précédente et y ajoutez un autre changement d’État ?</span><span class="sxs-lookup"><span data-stu-id="15694-539">What happens if you take the previous render sequence and add another state change to it?</span></span> <span data-ttu-id="15694-540">Par exemple, cet exemple prend la séquence de rendu z>-Enable et y ajoute une comparaison z-Func :</span><span class="sxs-lookup"><span data-stu-id="15694-540">For instance, this example takes the z>-enable render sequence and adds a z-func comparison to it:</span></span>


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



<span data-ttu-id="15694-541">L’État z-Func définit le niveau de comparaison lors de l’écriture dans la mémoire tampon z (entre la valeur z d’un pixel actuel et la valeur z d’un pixel dans le tampon de profondeur).</span><span class="sxs-lookup"><span data-stu-id="15694-541">The z-func state sets the comparison level when writing to the z-buffer (between the z-value of a current pixel with the z-value of a pixel in the depth buffer).</span></span> <span data-ttu-id="15694-542">D3DCMP \_ ne désactive jamais la comparaison z-test, tandis que D3DCMP \_ définit toujours la comparaison à chaque fois que le test z est effectué.</span><span class="sxs-lookup"><span data-stu-id="15694-542">D3DCMP\_NEVER turns off the z-testing comparison while D3DCMP\_ALWAYS sets the comparison to happen every time z-testing is done.</span></span>

<span data-ttu-id="15694-543">Le profilage de l’un de ces changements d’État dans une séquence de rendu avec [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) génère des résultats similaires à ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-543">Profiling either one of these state changes in a render sequence with [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) generates results similar to these:</span></span>



| <span data-ttu-id="15694-544">Changement d’État unique</span><span class="sxs-lookup"><span data-stu-id="15694-544">Single State Change</span></span> | <span data-ttu-id="15694-545">Nombre moyen de cycles</span><span class="sxs-lookup"><span data-stu-id="15694-545">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="15694-546">D3DRS \_ ZENABLE uniquement</span><span class="sxs-lookup"><span data-stu-id="15694-546">D3DRS\_ZENABLE only</span></span> | <span data-ttu-id="15694-547">2000</span><span class="sxs-lookup"><span data-stu-id="15694-547">2000</span></span>                     |



 

<span data-ttu-id="15694-548">ou</span><span class="sxs-lookup"><span data-stu-id="15694-548">or</span></span>



| <span data-ttu-id="15694-549">Changement d’État unique</span><span class="sxs-lookup"><span data-stu-id="15694-549">Single State Change</span></span> | <span data-ttu-id="15694-550">Nombre moyen de cycles</span><span class="sxs-lookup"><span data-stu-id="15694-550">Average Number of Cycles</span></span> |
|---------------------|--------------------------|
| <span data-ttu-id="15694-551">D3DRS \_ ZFUNC uniquement</span><span class="sxs-lookup"><span data-stu-id="15694-551">D3DRS\_ZFUNC only</span></span>   | <span data-ttu-id="15694-552">600</span><span class="sxs-lookup"><span data-stu-id="15694-552">600</span></span>                      |



 

<span data-ttu-id="15694-553">Toutefois, si vous profilez \_ à la fois D3DRS ZENABLE et D3DRS \_ ZFUNC dans la même séquence de rendu, vous pouvez voir des résultats comme ceux-ci :</span><span class="sxs-lookup"><span data-stu-id="15694-553">But, if you profile both D3DRS\_ZENABLE and D3DRS\_ZFUNC in the same render sequence you could see results like these:</span></span>



| <span data-ttu-id="15694-554">Les deux modifications d’État</span><span class="sxs-lookup"><span data-stu-id="15694-554">Both State Changes</span></span>            | <span data-ttu-id="15694-555">Nombre moyen de cycles</span><span class="sxs-lookup"><span data-stu-id="15694-555">Average Number of Cycles</span></span> |
|-------------------------------|--------------------------|
| <span data-ttu-id="15694-556">D3DRS \_ ZENABLE + D3DRS \_ ZFUNC</span><span class="sxs-lookup"><span data-stu-id="15694-556">D3DRS\_ZENABLE + D3DRS\_ZFUNC</span></span> | <span data-ttu-id="15694-557">2000</span><span class="sxs-lookup"><span data-stu-id="15694-557">2000</span></span>                     |



 

<span data-ttu-id="15694-558">Vous pouvez vous attendre à ce que le résultat soit la somme des cycles 2000 et 600 (ou 2600), car le pilote effectue tout le travail associé à la définition des deux États de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-558">You could expect the result to be to be the sum of 2000 and 600 (or 2600) cycles because the driver is doing all the work associated with setting both render states.</span></span> <span data-ttu-id="15694-559">Au lieu de cela, la moyenne est de 2000 cycles.</span><span class="sxs-lookup"><span data-stu-id="15694-559">Instead, the average is 2000 cycles.</span></span>

<span data-ttu-id="15694-560">Ce résultat reflète une optimisation de changement d’État implémentée dans le runtime, le pilote ou le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-560">This result reflects a state change optimization implemented in the runtime, the driver, or the GPU.</span></span> <span data-ttu-id="15694-561">Dans ce cas, le pilote peut voir le premier [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) et définir un état de modification qui différerait le travail jusqu’à la version ultérieure.</span><span class="sxs-lookup"><span data-stu-id="15694-561">In this case, the driver could see the first [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) and set a dirty state which would postpone the work until later.</span></span> <span data-ttu-id="15694-562">Lorsque le pilote voit le deuxième **SetRenderState**, le même état modifié peut être défini de manière redondante et le même travail est reporté une nouvelle fois.</span><span class="sxs-lookup"><span data-stu-id="15694-562">When the driver sees the second **SetRenderState**, the same dirty state could be redundantly set and the same work would be postponed once again.</span></span> <span data-ttu-id="15694-563">Quand [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) est appelé, le travail associé à l’état modifié est enfin traité.</span><span class="sxs-lookup"><span data-stu-id="15694-563">When [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is called, the work associated with the dirty state is finally processed.</span></span> <span data-ttu-id="15694-564">Le pilote exécute le travail une fois, ce qui signifie que les deux premières modifications d’État sont effectivement consolidées par le pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-564">The driver executes the work one time, which means that the first two state changes are effectively consolidated by the driver.</span></span> <span data-ttu-id="15694-565">De même, le troisième et le quatrième État sont consolidés de manière efficace par le pilote en un seul changement d’État lorsque le second **DrawPrimitive** est appelé.</span><span class="sxs-lookup"><span data-stu-id="15694-565">Similarly, the third and fourth state changes are effectively consolidated by the driver into a single state change when the second **DrawPrimitive** is called.</span></span> <span data-ttu-id="15694-566">Le résultat net est que le pilote et le GPU traitent une seule modification d’État pour chaque appel de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-566">The net result is that the driver and the GPU process a single state change for each draw call.</span></span>

<span data-ttu-id="15694-567">Il s’agit d’un bon exemple d’optimisation du pilote dépendant de la séquence.</span><span class="sxs-lookup"><span data-stu-id="15694-567">This is a good example of a sequence-dependent driver optimization.</span></span> <span data-ttu-id="15694-568">Le pilote a différé le travail à deux reprises en définissant un état modifié, puis il a effectué le travail une fois pour effacer l’état modifié.</span><span class="sxs-lookup"><span data-stu-id="15694-568">The driver postponed work twice by setting a dirty state, and then performed the work once to clear the dirty state.</span></span> <span data-ttu-id="15694-569">Il s’agit d’un bon exemple du type d’amélioration de l’efficacité qui peut se produire lorsque le travail est différé jusqu’à ce qu’il soit absolument nécessaire.</span><span class="sxs-lookup"><span data-stu-id="15694-569">This is a good example of the kind of efficiency improvement that can take place when work is deferred until absolutely necessary.</span></span>

<span data-ttu-id="15694-570">Comment savoir quels sont les changements d’État qui définissent un état de modification en interne et, par conséquent, retarder le travail jusqu’à la date ultérieure ?</span><span class="sxs-lookup"><span data-stu-id="15694-570">How do you know which state changes set a dirty state internally and therefore postpone work until later?</span></span> <span data-ttu-id="15694-571">Uniquement en testant les séquences de rendu (ou en parlant aux Writers de pilote).</span><span class="sxs-lookup"><span data-stu-id="15694-571">Only by testing render sequences (or talking to driver writers).</span></span> <span data-ttu-id="15694-572">Les pilotes sont mis à jour et améliorés régulièrement pour que la liste des optimisations ne soit pas statique.</span><span class="sxs-lookup"><span data-stu-id="15694-572">Drivers are updated and improved periodically so the list of optimizations is not static.</span></span> <span data-ttu-id="15694-573">Il n’existe qu’une seule façon de savoir exactement ce qu’est un changement d’état des coûts dans une séquence de rendu donnée, sur un ensemble de matériel spécifique. et c’est pour cela qu’il faut le mesurer.</span><span class="sxs-lookup"><span data-stu-id="15694-573">There is only one way to absolutely know what a state change costs in a given render sequence, on a particular set of hardware; and that is to measure it.</span></span>

### <a name="watch-out-for-drawprimitive-optimizations"></a><span data-ttu-id="15694-574">Méfiez-vous des optimisations de DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="15694-574">Watch Out for DrawPrimitive Optimizations</span></span>

<span data-ttu-id="15694-575">En plus des optimisations de modification d’État, le runtime tente d’optimiser le nombre d’appels de dessin que le pilote doit traiter.</span><span class="sxs-lookup"><span data-stu-id="15694-575">In addition to state change optimizations, the runtime will attempt to optimize the number of draw calls that the driver has to process.</span></span> <span data-ttu-id="15694-576">Par exemple, considérez les appels de retour vers l’arrière-plan :</span><span class="sxs-lookup"><span data-stu-id="15694-576">For example, consider these back to back draw calls:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



<span data-ttu-id="15694-577">Exemple 5A : deux appels de dessin</span><span class="sxs-lookup"><span data-stu-id="15694-577">Example 5a: Two Draw Calls</span></span>

<span data-ttu-id="15694-578">Cette séquence contient deux appels de dessin, que le runtime consolidera en un seul appel équivalent à :</span><span class="sxs-lookup"><span data-stu-id="15694-578">This sequence contains two draw calls, which the runtime will consolidate into a single call equivalent to:</span></span>


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



<span data-ttu-id="15694-579">Exemple 5B : un appel de dessin concaténé unique</span><span class="sxs-lookup"><span data-stu-id="15694-579">Example 5b: A Single Concatenated Draw Call</span></span>

<span data-ttu-id="15694-580">Le runtime concatène ces deux appels de dessin particuliers en un seul appel, ce qui réduit le travail du pilote de 50%, car le pilote n’a à présent qu’à traiter un appel de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-580">The runtime will concatenate both of these particular draw calls into a single call, which reduces the driver work by 50 percent because the driver will now only need to process one draw call.</span></span>

<span data-ttu-id="15694-581">En général, le runtime concatène deux ou plusieurs appels [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) de secours dans les cas suivants :</span><span class="sxs-lookup"><span data-stu-id="15694-581">In general, the runtime will concatenate two or more back-to-back [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) calls when:</span></span>

1.  <span data-ttu-id="15694-582">Le type primitif est une liste de triangles (D3DPT \_ TRIANGLELIST).</span><span class="sxs-lookup"><span data-stu-id="15694-582">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="15694-583">Chaque appel [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) successif doit faire référence à des vertex consécutifs dans la mémoire tampon de vertex.</span><span class="sxs-lookup"><span data-stu-id="15694-583">Each successive [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) call must reference consecutive vertices within the vertex buffer.</span></span>

<span data-ttu-id="15694-584">De même, les conditions appropriées pour la concaténation de deux ou plusieurs appels [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) de secours sont les suivantes :</span><span class="sxs-lookup"><span data-stu-id="15694-584">Similarly, the right conditions for concatenating two or more back-to-back [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) calls are:</span></span>

1.  <span data-ttu-id="15694-585">Le type primitif est une liste de triangles (D3DPT \_ TRIANGLELIST).</span><span class="sxs-lookup"><span data-stu-id="15694-585">The primitive type is a triangle list (D3DPT\_TRIANGLELIST).</span></span>
2.  <span data-ttu-id="15694-586">Chaque appel [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) successif doit faire référence à des index consécutifs dans la mémoire tampon d’index.</span><span class="sxs-lookup"><span data-stu-id="15694-586">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must sequential reference consecutive indices within the index buffer.</span></span>
3.  <span data-ttu-id="15694-587">Chaque appel [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) successif doit utiliser la même valeur pour BaseVertexIndex.</span><span class="sxs-lookup"><span data-stu-id="15694-587">Each successive [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) call must use the same value for BaseVertexIndex.</span></span>

<span data-ttu-id="15694-588">Pour empêcher la concaténation pendant le profilage, modifiez la séquence de rendu afin que le type primitif ne soit pas une liste de triangles, ou modifiez la séquence de rendu afin qu’il n’y ait pas d’appels de dessin arrière à dos utilisant des vertex (ou des index) consécutifs.</span><span class="sxs-lookup"><span data-stu-id="15694-588">To prevent concatenation during profiling, modify the render sequence so that the primitive type is not a triangle list, or modify the render sequence so that there are no back-to-back draw calls that use consecutive vertices (or indices).</span></span> <span data-ttu-id="15694-589">Plus précisément, le runtime concatène également les appels de dessin qui remplissent les deux conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="15694-589">More specifically, the runtime will also concatenate draw calls that meet both of the following conditions:</span></span>

-   <span data-ttu-id="15694-590">Lorsque l’appel précédent est [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), si l’appel de dessin suivant :</span><span class="sxs-lookup"><span data-stu-id="15694-590">When the previous call is [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="15694-591">utilise une liste de triangles, et</span><span class="sxs-lookup"><span data-stu-id="15694-591">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="15694-592">Spécifie le StartVertex = précédent StartVertex + PrimitiveCount précédent \* 3</span><span class="sxs-lookup"><span data-stu-id="15694-592">specifies the StartVertex = previous StartVertex + previous PrimitiveCount \* 3</span></span>
-   <span data-ttu-id="15694-593">Lors de l’utilisation de [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), si l’appel de dessin suivant est utilisé :</span><span class="sxs-lookup"><span data-stu-id="15694-593">When using [**DrawIndexedPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive), if the next draw call:</span></span>
    -   <span data-ttu-id="15694-594">utilise une liste de triangles, et</span><span class="sxs-lookup"><span data-stu-id="15694-594">uses a triangle list, AND</span></span>
    -   <span data-ttu-id="15694-595">spécifie StartIndex = précédent StartIndex + PrimitiveCount précédent \* 3, et</span><span class="sxs-lookup"><span data-stu-id="15694-595">specifies the StartIndex = previous StartIndex + previous PrimitiveCount \* 3, AND</span></span>
    -   <span data-ttu-id="15694-596">Spécifie le BaseVertexIndex = précédent BaseVertexIndex</span><span class="sxs-lookup"><span data-stu-id="15694-596">specifies the BaseVertexIndex = previous BaseVertexIndex</span></span>

<span data-ttu-id="15694-597">Voici un exemple plus subtil de dessin de la concaténation d’appel qui est facile à ignorer lorsque vous profilez.</span><span class="sxs-lookup"><span data-stu-id="15694-597">Here is a more subtle example of draw call concatenation that is easy to overlook when you are profiling.</span></span> <span data-ttu-id="15694-598">Supposons que la séquence de rendu ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="15694-598">Assume the render sequence looks like this:</span></span>


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="15694-599">Exemple 5C : un changement d’État et un appel de dessin</span><span class="sxs-lookup"><span data-stu-id="15694-599">Example 5c: One State Change and One Draw Call</span></span>

<span data-ttu-id="15694-600">La boucle itère jusqu’à 1500 triangles, en définissant une texture et en dessinant chaque triangle.</span><span class="sxs-lookup"><span data-stu-id="15694-600">The loop iterates through 1500 triangles, setting a texture and drawing each triangle.</span></span> <span data-ttu-id="15694-601">Cette boucle de rendu prend environ 2750 cycles pour [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) et 1100 cycles pour [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , comme indiqué dans les sections précédentes.</span><span class="sxs-lookup"><span data-stu-id="15694-601">This render loop takes approximately 2750 cycles for [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) and 1100 cycles for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) as shown in previous sections.</span></span> <span data-ttu-id="15694-602">Vous vous attendez peut-être à ce que le déplacement de **SetTexture** en dehors de la boucle de rendu réduise la quantité de travail effectuée par le pilote de 1500 \* 2750 cycles, ce qui correspond à la quantité de travail associée à l’appel de **SetTexture** 1500 fois.</span><span class="sxs-lookup"><span data-stu-id="15694-602">You might intuitively expect that moving **SetTexture** outside the render loop should reduce the amount of work done by the driver by 1500 \* 2750 cycles, which is the amount of work associated with calling **SetTexture** 1500 times.</span></span> <span data-ttu-id="15694-603">L’extrait de code ressemble à ceci :</span><span class="sxs-lookup"><span data-stu-id="15694-603">The code snippet would look like this:</span></span>


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



<span data-ttu-id="15694-604">Exemple 5D : exemple 5c avec le changement d’État en dehors de la boucle</span><span class="sxs-lookup"><span data-stu-id="15694-604">Example 5d: Example 5c with the State Change Outside the Loop</span></span>

<span data-ttu-id="15694-605">Le déplacement de [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) en dehors de la boucle de rendu réduit la quantité de travail associée à **SetTexture** , car elle est appelée une fois au lieu de 1500 fois.</span><span class="sxs-lookup"><span data-stu-id="15694-605">Moving [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) outside the render loop does reduce the amount of work associated with **SetTexture** since it is called once instead of 1500 times.</span></span> <span data-ttu-id="15694-606">Un effet secondaire moins évident est que le travail pour [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) est également réduit de 1500 appels à 1 appel, car toutes les conditions de concaténation des appels de dessin sont satisfaites.</span><span class="sxs-lookup"><span data-stu-id="15694-606">A less obvious secondary effect is that the work for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) is also reduced from 1500 calls to 1 call because all of the conditions for concatenating draw calls are satisfied.</span></span> <span data-ttu-id="15694-607">Lorsque la séquence de rendu est traitée, le runtime traite les appels 1500 dans un appel de pilote unique.</span><span class="sxs-lookup"><span data-stu-id="15694-607">When the render sequence is processed, the runtime will process 1500 calls into a single driver call.</span></span> <span data-ttu-id="15694-608">En déplaçant cette ligne de code, la quantité de travail de pilote a été considérablement réduite :</span><span class="sxs-lookup"><span data-stu-id="15694-608">By moving this one line of code, the amount of driver work has been reduced dramatically:</span></span>


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



<span data-ttu-id="15694-609">Ces résultats sont entièrement corrects, mais sont très trompeurs dans le contexte de la question d’origine.</span><span class="sxs-lookup"><span data-stu-id="15694-609">These results are entirely correct, but are very misleading in the context of the original question.</span></span> <span data-ttu-id="15694-610">L’optimisation de l’appel de dessin a entraîné une réduction considérable de la quantité de travail du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-610">The draw call optimization has caused the amount of driver work to be dramatically reduced.</span></span> <span data-ttu-id="15694-611">Il s’agit d’un problème courant lors de la création d’un profilage personnalisé.</span><span class="sxs-lookup"><span data-stu-id="15694-611">This is a common problem when doing custom profiling.</span></span> <span data-ttu-id="15694-612">Lors de l’élimination des appels d’une séquence de rendu, veillez à éviter la concaténation des appels de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-612">When eliminating calls from a render sequence, be careful to avoid draw call concatenation.</span></span> <span data-ttu-id="15694-613">En fait, ce scénario est un exemple puissant de la quantité d’amélioration des performances du pilote possible grâce à cette optimisation du Runtime.</span><span class="sxs-lookup"><span data-stu-id="15694-613">In fact, this scenario is a powerful example of the amount of improvement in driver performance possible by this runtime optimization.</span></span>

<span data-ttu-id="15694-614">Vous savez maintenant comment mesurer les changements d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-614">So now you know how to measure state changes.</span></span> <span data-ttu-id="15694-615">Commencez par Profiler [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span><span class="sxs-lookup"><span data-stu-id="15694-615">Start by profiling [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).</span></span> <span data-ttu-id="15694-616">Ajoutez ensuite chaque modification d’État supplémentaire à la séquence (dans certains cas, en ajoutant un appel et, dans d’autres cas, en ajoutant deux appels) et mesurez la différence entre les deux séquences.</span><span class="sxs-lookup"><span data-stu-id="15694-616">Then add each additional state change to the sequence (in some cases adding one call and in other cases adding two calls) and measure the difference between the two sequences.</span></span> <span data-ttu-id="15694-617">Vous pouvez convertir les résultats en cycles ou en cycles ou en temps.</span><span class="sxs-lookup"><span data-stu-id="15694-617">You can convert the results to ticks or cycles or time.</span></span> <span data-ttu-id="15694-618">Tout comme la mesure des séquences de rendu avec QueryPerformanceCounter, la mesure des modifications d’État individuel s’appuie sur le mécanisme de requête pour contrôler la mémoire tampon de commande et sur la modification de l’État dans une boucle pour réduire l’impact des transitions de mode.</span><span class="sxs-lookup"><span data-stu-id="15694-618">Just like measuring render sequences with QueryPerformanceCounter, measuring individual state changes relies on the query mechanism to control the command buffer, and putting the state changes in a loop to minimize the impact of the mode transitions.</span></span> <span data-ttu-id="15694-619">Cette technique mesure le coût du basculement d’un État, puisque le profileur retourne la moyenne d’activation et de désactivation de l’État.</span><span class="sxs-lookup"><span data-stu-id="15694-619">This technique measures the cost of toggling a state, since the profiler returns the average of enabling and disabling the state.</span></span>

<span data-ttu-id="15694-620">Avec cette fonctionnalité, vous pouvez commencer à générer des séquences de rendu arbitraires et mesurer précisément le travail du runtime et du pilote associé.</span><span class="sxs-lookup"><span data-stu-id="15694-620">With this capability, you can start generating arbitrary rendering sequences and accurately measuring the associated runtime and driver work.</span></span> <span data-ttu-id="15694-621">Les numéros peuvent ensuite être utilisés pour répondre à des questions de budgétisation, telles que le « nombre de ces appels », peuvent être effectuées dans la séquence de rendu tout en maintenant une fréquence d’images raisonnable, en supposant des scénarios limités par le processeur.</span><span class="sxs-lookup"><span data-stu-id="15694-621">The numbers can then be used to answer budgeting questions like "how many more of these calls" can be made in the render sequence while still maintaining a reasonable frame rate, assuming CPU-limited scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="15694-622">Résumé</span><span class="sxs-lookup"><span data-stu-id="15694-622">Summary</span></span>

<span data-ttu-id="15694-623">Cet article montre comment contrôler le tampon de commande afin que les appels individuels puissent être profilés avec précision.</span><span class="sxs-lookup"><span data-stu-id="15694-623">This paper demonstrates how to control the command buffer so that individual calls can be accurately profiled.</span></span> <span data-ttu-id="15694-624">Les nombres de profilage peuvent être générés en graduations, en cycles ou en temps absolu.</span><span class="sxs-lookup"><span data-stu-id="15694-624">The profiling numbers can be generated in ticks, cycles, or absolute time.</span></span> <span data-ttu-id="15694-625">Ils représentent la quantité de travail d’exécution et de pilote associée à chaque appel d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-625">They represent the amount of runtime and driver work associated with each API call.</span></span>

<span data-ttu-id="15694-626">Commencez par profiler un \* appel de la primitive de dessin dans une séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-626">Start by profiling a Draw\*Primitive call in a render sequence.</span></span> <span data-ttu-id="15694-627">Veillez à effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="15694-627">Remember to:</span></span>

1.  <span data-ttu-id="15694-628">Utilisez QueryPerformanceCounter pour mesurer le nombre de graduations par appel d’API.</span><span class="sxs-lookup"><span data-stu-id="15694-628">Use QueryPerformanceCounter to measure the number of ticks per API call.</span></span> <span data-ttu-id="15694-629">Utilisez QueryPerformanceFrequency pour convertir les résultats en cycles ou en temps si vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="15694-629">Use QueryPerformanceFrequency to convert the results to cycles or time if you like.</span></span>
2.  <span data-ttu-id="15694-630">Utilisez le mécanisme de requête pour vider la mémoire tampon de commande avant de commencer.</span><span class="sxs-lookup"><span data-stu-id="15694-630">Use the query mechanism to empty the command buffer before starting.</span></span>
3.  <span data-ttu-id="15694-631">Incluez la séquence de rendu dans une boucle pour réduire l’impact de la transition du mode.</span><span class="sxs-lookup"><span data-stu-id="15694-631">Include the render sequence in a loop to minimize the impact of the mode transition.</span></span>
4.  <span data-ttu-id="15694-632">Utilisez le mécanisme de requête pour mesurer le moment où le GPU a terminé son travail.</span><span class="sxs-lookup"><span data-stu-id="15694-632">Use the query mechanism to measure when the GPU has completed its work.</span></span>
5.  <span data-ttu-id="15694-633">Méfiez-vous de la concaténation du runtime qui aura un impact majeur sur la quantité de travail effectuée.</span><span class="sxs-lookup"><span data-stu-id="15694-633">Watch out for runtime concatenation that will have a major impact on the amount of work done.</span></span>

<span data-ttu-id="15694-634">Vous bénéficiez ainsi d’une performance de base pour [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) qui peut être utilisée pour générer à partir de.</span><span class="sxs-lookup"><span data-stu-id="15694-634">This gives you a baseline performance for [**DrawPrimitive**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) that can be used to build from.</span></span> <span data-ttu-id="15694-635">Pour profiler un changement d’État, suivez ces conseils supplémentaires :</span><span class="sxs-lookup"><span data-stu-id="15694-635">To profile one state change, follow these additional tips:</span></span>

1.  <span data-ttu-id="15694-636">Ajoutez la modification d’État à un profil de séquence de rendu connu la nouvelle séquence.</span><span class="sxs-lookup"><span data-stu-id="15694-636">Add the state change to a known render sequence profile the new sequence.</span></span> <span data-ttu-id="15694-637">Étant donné que le test est effectué dans une boucle, vous devez définir l’État à deux reprises comme valeurs opposées (par exemple, activer et désactiver par exemple).</span><span class="sxs-lookup"><span data-stu-id="15694-637">Since the testing is done in a loop, this requires setting the state twice into opposite values (like enable and disable for instance).</span></span>
2.  <span data-ttu-id="15694-638">Comparez la différence entre les temps de cycle entre les deux séquences.</span><span class="sxs-lookup"><span data-stu-id="15694-638">Compare the difference in cycle times between the two sequences.</span></span>
3.  <span data-ttu-id="15694-639">Pour les changements d’État qui modifient de manière significative le pipeline (par exemple, [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), soustraire la différence entre les deux séquences pour obtenir le temps nécessaire au changement d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-639">For state changes that significantly change the pipeline (like [**SetTexture**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), subtract the difference between the two sequences to get the time for state change.</span></span>
4.  <span data-ttu-id="15694-640">Pour les changements d’État qui modifient de manière significative le pipeline (et, par conséquent, nécessitent des États de basculement tels que [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), soustraire la différence entre les séquences de rendu et la division par 2.</span><span class="sxs-lookup"><span data-stu-id="15694-640">For state changes that significantly change the pipeline (and therefore require toggling states like [**SetRenderState**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), subtract the difference between the render sequences and divide by 2.</span></span> <span data-ttu-id="15694-641">Le nombre moyen de cycles pour chaque changement d’État est alors généré.</span><span class="sxs-lookup"><span data-stu-id="15694-641">This will generate the average number of cycles for each state change.</span></span>

<span data-ttu-id="15694-642">Mais méfiez-vous des optimisations qui provoquent des résultats inattendus lors du profilage.</span><span class="sxs-lookup"><span data-stu-id="15694-642">But be careful of optimizations that cause unexpected results when profiling.</span></span> <span data-ttu-id="15694-643">Les optimisations de changement d’État peuvent définir des États de modification qui entraînent le report du travail.</span><span class="sxs-lookup"><span data-stu-id="15694-643">State change optimizations may set dirty states which causes work to be deferred.</span></span> <span data-ttu-id="15694-644">Cela peut entraîner des résultats de profil qui ne sont pas aussi intuitifs que prévu.</span><span class="sxs-lookup"><span data-stu-id="15694-644">This can cause profile results which are not as intuitive as expected.</span></span> <span data-ttu-id="15694-645">Les appels de dessin qui sont concaténés réduisent considérablement le travail du pilote, ce qui peut entraîner des conclusions trompeuses.</span><span class="sxs-lookup"><span data-stu-id="15694-645">Draw calls that are concatenated will dramatically reduce driver work which can lead to misleading conclusions.</span></span> <span data-ttu-id="15694-646">Les séquences de rendu soigneusement planifiées sont utilisées pour empêcher la modification de l’État et les concaténations des appels de dessin.</span><span class="sxs-lookup"><span data-stu-id="15694-646">Carefully planned render sequences are used to prevent state change and draw call concatenations from occurring.</span></span> <span data-ttu-id="15694-647">L’astuce consiste à empêcher les optimisations de se produire au cours du profilage afin que les nombres que vous génériez soient des chiffres de budgétisation raisonnables.</span><span class="sxs-lookup"><span data-stu-id="15694-647">The trick is to prevent the optimizations from happening during profiling so that the numbers you generate are reasonable budgeting numbers.</span></span>

> [!Note]  
> <span data-ttu-id="15694-648">La duplication de cette stratégie de profilage dans une application sans le mécanisme de requête est plus difficile.</span><span class="sxs-lookup"><span data-stu-id="15694-648">Duplicating this profiling strategy in an application without the query mechanism is more difficult.</span></span> <span data-ttu-id="15694-649">Avant Direct3D 9, le seul moyen prévisible de vider le tampon de commande consiste à verrouiller une surface active (telle qu’une cible de rendu) pour attendre que le GPU soit inactif.</span><span class="sxs-lookup"><span data-stu-id="15694-649">Prior to Direct3D 9 the only predictable way to empty the command buffer is to lock an active surface (such as a render target) to wait until the GPU is idle.</span></span> <span data-ttu-id="15694-650">Cela est dû au fait que le verrouillage d’une surface force le runtime à vider le tampon de commande au cas où il y aurait des commandes de rendu dans la mémoire tampon qui doivent mettre à jour la surface avant qu’elle ne soit verrouillée, en plus d’attendre la fin du GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-650">This is because locking a surface forces the runtime to empty the command buffer in case there are any rendering commands in the buffer that should update the surface before it gets locked, in addition to waiting for the GPU to finish.</span></span> <span data-ttu-id="15694-651">Cette technique est fonctionnelle, bien qu’il soit plus discret que d’utiliser le mécanisme de requête introduit dans Direct3D 9.</span><span class="sxs-lookup"><span data-stu-id="15694-651">This technique is functional, although it is more obtrusive that using the query mechanism introduced in Direct3D 9.</span></span>

 

## <a name="appendix"></a><span data-ttu-id="15694-652">Annexe</span><span class="sxs-lookup"><span data-stu-id="15694-652">Appendix</span></span>

<span data-ttu-id="15694-653">Les nombres de ce tableau sont une plage de approximations pour la quantité de travail de Runtime et de pilote associée à chacun de ces changements d’État.</span><span class="sxs-lookup"><span data-stu-id="15694-653">The numbers in this table are a range of approximations for the amount of runtime and driver work associated with each of these state changes.</span></span> <span data-ttu-id="15694-654">Les approximations sont basées sur les mesures réelles effectuées sur les pilotes à l’aide des techniques présentées dans le document.</span><span class="sxs-lookup"><span data-stu-id="15694-654">The approximations are based on actual measurements made on drivers using the techniques shown in the paper.</span></span> <span data-ttu-id="15694-655">Ces nombres ont été générés à l’aide du runtime Direct3D 9 et dépendent du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-655">These numbers were generated using the Direct3D 9 runtime and are driver-dependent.</span></span>

<span data-ttu-id="15694-656">Les techniques décrites dans ce document sont conçues pour mesurer le travail du runtime et du pilote.</span><span class="sxs-lookup"><span data-stu-id="15694-656">The techniques in this paper are designed to measure runtime and driver work.</span></span> <span data-ttu-id="15694-657">En général, il est peu pratique de fournir des résultats qui correspondent aux performances du processeur et du GPU dans chaque application, car cela nécessiterait un tableau exhaustif de séquences de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-657">In general, it is impractical to provide results that match the performance of the CPU and the GPU in every application as this would require an exhaustive array of render sequences.</span></span> <span data-ttu-id="15694-658">En outre, il est particulièrement difficile de tester les performances du GPU, car il dépend fortement de la configuration de l’État dans le pipeline avant la séquence de rendu.</span><span class="sxs-lookup"><span data-stu-id="15694-658">In addition, it is particularly difficult to benchmark performance of the GPU because it is highly dependent on the state setup in the pipeline before the render sequence.</span></span> <span data-ttu-id="15694-659">Par exemple, l’activation de la fusion alpha n’a que peu d’incidence sur la quantité de travail du processeur nécessaire, mais peut avoir un impact important sur la quantité de travail effectuée par le GPU.</span><span class="sxs-lookup"><span data-stu-id="15694-659">For instance, enabling alpha blending does little to affect the amount of CPU work necessary, but can have a big impact on the amount of work done by the GPU.</span></span> <span data-ttu-id="15694-660">Par conséquent, les techniques décrites dans ce document limitent le travail du GPU au minimum possible en limitant la quantité de données qui doivent être rendues.</span><span class="sxs-lookup"><span data-stu-id="15694-660">Therefore, the techniques in this paper constrain the GPU work to the minimum amount possible by limiting the amount of data that needs to be rendered.</span></span> <span data-ttu-id="15694-661">Cela signifie que les nombres de la table correspondent plus précisément aux résultats obtenus à partir d’applications qui sont limitées par l’UC (par opposition à une application limitée par le GPU).</span><span class="sxs-lookup"><span data-stu-id="15694-661">This means that the numbers in the table will most closely match the results attained from applications that are CPU limited (as opposed to an application that is limited by the GPU).</span></span>

<span data-ttu-id="15694-662">Il est recommandé d’utiliser les techniques présentées pour couvrir les scénarios et les configurations les plus importants pour vous.</span><span class="sxs-lookup"><span data-stu-id="15694-662">You are encouraged to use the techniques presented to cover the scenarios and configurations most important to you.</span></span> <span data-ttu-id="15694-663">Les valeurs de la table peuvent être utilisées pour effectuer une comparaison avec les nombres que vous générez.</span><span class="sxs-lookup"><span data-stu-id="15694-663">The values in the table can be used to compare with the numbers you generate.</span></span> <span data-ttu-id="15694-664">Étant donné que chaque pilote varie, le seul moyen de générer les chiffres réels est de générer des résultats de profilage à l’aide de vos scénarios.</span><span class="sxs-lookup"><span data-stu-id="15694-664">Since each driver varies, the only way to generate the actual numbers you will see is to generate profiling results using your scenarios.</span></span>



| <span data-ttu-id="15694-665">Appel d’API</span><span class="sxs-lookup"><span data-stu-id="15694-665">API Call</span></span>                             | <span data-ttu-id="15694-666">Nombre moyen de cycles</span><span class="sxs-lookup"><span data-stu-id="15694-666">Average number of Cycles</span></span> |
|--------------------------------------|--------------------------|
| <span data-ttu-id="15694-667">SetVertexDeclaration</span><span class="sxs-lookup"><span data-stu-id="15694-667">SetVertexDeclaration</span></span>                 | <span data-ttu-id="15694-668">6500-11250</span><span class="sxs-lookup"><span data-stu-id="15694-668">6500 - 11250</span></span>             |
| <span data-ttu-id="15694-669">SetFVF</span><span class="sxs-lookup"><span data-stu-id="15694-669">SetFVF</span></span>                               | <span data-ttu-id="15694-670">6400-11200</span><span class="sxs-lookup"><span data-stu-id="15694-670">6400 - 11200</span></span>             |
| <span data-ttu-id="15694-671">SetVertexShader</span><span class="sxs-lookup"><span data-stu-id="15694-671">SetVertexShader</span></span>                      | <span data-ttu-id="15694-672">3000-12100</span><span class="sxs-lookup"><span data-stu-id="15694-672">3000 - 12100</span></span>             |
| <span data-ttu-id="15694-673">SetPixelShader</span><span class="sxs-lookup"><span data-stu-id="15694-673">SetPixelShader</span></span>                       | <span data-ttu-id="15694-674">6300-7000</span><span class="sxs-lookup"><span data-stu-id="15694-674">6300 - 7000</span></span>              |
| <span data-ttu-id="15694-675">SPECULARENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-675">SPECULARENABLE</span></span>                       | <span data-ttu-id="15694-676">1900-11200</span><span class="sxs-lookup"><span data-stu-id="15694-676">1900 - 11200</span></span>             |
| <span data-ttu-id="15694-677">SetRenderTarget</span><span class="sxs-lookup"><span data-stu-id="15694-677">SetRenderTarget</span></span>                      | <span data-ttu-id="15694-678">6000-6250</span><span class="sxs-lookup"><span data-stu-id="15694-678">6000 - 6250</span></span>              |
| <span data-ttu-id="15694-679">SetPixelShaderConstant (1 constante)</span><span class="sxs-lookup"><span data-stu-id="15694-679">SetPixelShaderConstant (1 Constant)</span></span>  | <span data-ttu-id="15694-680">1500-9000</span><span class="sxs-lookup"><span data-stu-id="15694-680">1500 - 9000</span></span>              |
| <span data-ttu-id="15694-681">NORMALIZENORMALS</span><span class="sxs-lookup"><span data-stu-id="15694-681">NORMALIZENORMALS</span></span>                     | <span data-ttu-id="15694-682">2200-8100</span><span class="sxs-lookup"><span data-stu-id="15694-682">2200 - 8100</span></span>              |
| <span data-ttu-id="15694-683">Éclaircie</span><span class="sxs-lookup"><span data-stu-id="15694-683">LightEnable</span></span>                          | <span data-ttu-id="15694-684">1300-9000</span><span class="sxs-lookup"><span data-stu-id="15694-684">1300 - 9000</span></span>              |
| <span data-ttu-id="15694-685">SetStreamSource</span><span class="sxs-lookup"><span data-stu-id="15694-685">SetStreamSource</span></span>                      | <span data-ttu-id="15694-686">3700-5800</span><span class="sxs-lookup"><span data-stu-id="15694-686">3700 - 5800</span></span>              |
| <span data-ttu-id="15694-687">Unit</span><span class="sxs-lookup"><span data-stu-id="15694-687">LIGHTING</span></span>                             | <span data-ttu-id="15694-688">1700-7500</span><span class="sxs-lookup"><span data-stu-id="15694-688">1700 - 7500</span></span>              |
| <span data-ttu-id="15694-689">DIFFUSEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="15694-689">DIFFUSEMATERIALSOURCE</span></span>                | <span data-ttu-id="15694-690">900-8300</span><span class="sxs-lookup"><span data-stu-id="15694-690">900 - 8300</span></span>               |
| <span data-ttu-id="15694-691">AMBIENTMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="15694-691">AMBIENTMATERIALSOURCE</span></span>                | <span data-ttu-id="15694-692">900-8200</span><span class="sxs-lookup"><span data-stu-id="15694-692">900 - 8200</span></span>               |
| <span data-ttu-id="15694-693">COLORVERTEX</span><span class="sxs-lookup"><span data-stu-id="15694-693">COLORVERTEX</span></span>                          | <span data-ttu-id="15694-694">800-7800</span><span class="sxs-lookup"><span data-stu-id="15694-694">800 - 7800</span></span>               |
| <span data-ttu-id="15694-695">SetLight</span><span class="sxs-lookup"><span data-stu-id="15694-695">SetLight</span></span>                             | <span data-ttu-id="15694-696">2200-5100</span><span class="sxs-lookup"><span data-stu-id="15694-696">2200 - 5100</span></span>              |
| <span data-ttu-id="15694-697">SetTransform</span><span class="sxs-lookup"><span data-stu-id="15694-697">SetTransform</span></span>                         | <span data-ttu-id="15694-698">3200-3750</span><span class="sxs-lookup"><span data-stu-id="15694-698">3200 - 3750</span></span>              |
| <span data-ttu-id="15694-699">SetIndices</span><span class="sxs-lookup"><span data-stu-id="15694-699">SetIndices</span></span>                           | <span data-ttu-id="15694-700">900-5600</span><span class="sxs-lookup"><span data-stu-id="15694-700">900 - 5600</span></span>               |
| <span data-ttu-id="15694-701">AMBIANT</span><span class="sxs-lookup"><span data-stu-id="15694-701">AMBIENT</span></span>                              | <span data-ttu-id="15694-702">1150-4800</span><span class="sxs-lookup"><span data-stu-id="15694-702">1150 - 4800</span></span>              |
| <span data-ttu-id="15694-703">SetTexture</span><span class="sxs-lookup"><span data-stu-id="15694-703">SetTexture</span></span>                           | <span data-ttu-id="15694-704">2500-3100</span><span class="sxs-lookup"><span data-stu-id="15694-704">2500 - 3100</span></span>              |
| <span data-ttu-id="15694-705">SPECULARMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="15694-705">SPECULARMATERIALSOURCE</span></span>               | <span data-ttu-id="15694-706">900-4600</span><span class="sxs-lookup"><span data-stu-id="15694-706">900 - 4600</span></span>               |
| <span data-ttu-id="15694-707">EMISSIVEMATERIALSOURCE</span><span class="sxs-lookup"><span data-stu-id="15694-707">EMISSIVEMATERIALSOURCE</span></span>               | <span data-ttu-id="15694-708">900-4500</span><span class="sxs-lookup"><span data-stu-id="15694-708">900 - 4500</span></span>               |
| <span data-ttu-id="15694-709">SetMaterial</span><span class="sxs-lookup"><span data-stu-id="15694-709">SetMaterial</span></span>                          | <span data-ttu-id="15694-710">1000-3700</span><span class="sxs-lookup"><span data-stu-id="15694-710">1000 - 3700</span></span>              |
| <span data-ttu-id="15694-711">ZENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-711">ZENABLE</span></span>                              | <span data-ttu-id="15694-712">700-3900</span><span class="sxs-lookup"><span data-stu-id="15694-712">700 - 3900</span></span>               |
| <span data-ttu-id="15694-713">WRAP0</span><span class="sxs-lookup"><span data-stu-id="15694-713">WRAP0</span></span>                                | <span data-ttu-id="15694-714">1600-2700</span><span class="sxs-lookup"><span data-stu-id="15694-714">1600 - 2700</span></span>              |
| <span data-ttu-id="15694-715">MINFILTER</span><span class="sxs-lookup"><span data-stu-id="15694-715">MINFILTER</span></span>                            | <span data-ttu-id="15694-716">1700-2500</span><span class="sxs-lookup"><span data-stu-id="15694-716">1700 - 2500</span></span>              |
| <span data-ttu-id="15694-717">MAGFILTER</span><span class="sxs-lookup"><span data-stu-id="15694-717">MAGFILTER</span></span>                            | <span data-ttu-id="15694-718">1700-2400</span><span class="sxs-lookup"><span data-stu-id="15694-718">1700 - 2400</span></span>              |
| <span data-ttu-id="15694-719">SetVertexShaderConstant (1 constante)</span><span class="sxs-lookup"><span data-stu-id="15694-719">SetVertexShaderConstant (1 Constant)</span></span> | <span data-ttu-id="15694-720">1000-2700</span><span class="sxs-lookup"><span data-stu-id="15694-720">1000 - 2700</span></span>              |
| <span data-ttu-id="15694-721">COLOROP</span><span class="sxs-lookup"><span data-stu-id="15694-721">COLOROP</span></span>                              | <span data-ttu-id="15694-722">1500-2100</span><span class="sxs-lookup"><span data-stu-id="15694-722">1500 - 2100</span></span>              |
| <span data-ttu-id="15694-723">COLORARG2</span><span class="sxs-lookup"><span data-stu-id="15694-723">COLORARG2</span></span>                            | <span data-ttu-id="15694-724">1300-2000</span><span class="sxs-lookup"><span data-stu-id="15694-724">1300 - 2000</span></span>              |
| <span data-ttu-id="15694-725">COLORARG1</span><span class="sxs-lookup"><span data-stu-id="15694-725">COLORARG1</span></span>                            | <span data-ttu-id="15694-726">1300-1980</span><span class="sxs-lookup"><span data-stu-id="15694-726">1300 - 1980</span></span>              |
| <span data-ttu-id="15694-727">CULLMODE</span><span class="sxs-lookup"><span data-stu-id="15694-727">CULLMODE</span></span>                             | <span data-ttu-id="15694-728">500-2570</span><span class="sxs-lookup"><span data-stu-id="15694-728">500 - 2570</span></span>               |
| <span data-ttu-id="15694-729">PORTION</span><span class="sxs-lookup"><span data-stu-id="15694-729">CLIPPING</span></span>                             | <span data-ttu-id="15694-730">500-2550</span><span class="sxs-lookup"><span data-stu-id="15694-730">500 - 2550</span></span>               |
| <span data-ttu-id="15694-731">DrawIndexedPrimitive</span><span class="sxs-lookup"><span data-stu-id="15694-731">DrawIndexedPrimitive</span></span>                 | <span data-ttu-id="15694-732">1200-1400</span><span class="sxs-lookup"><span data-stu-id="15694-732">1200 - 1400</span></span>              |
| <span data-ttu-id="15694-733">ADDRESSV</span><span class="sxs-lookup"><span data-stu-id="15694-733">ADDRESSV</span></span>                             | <span data-ttu-id="15694-734">1090-1500</span><span class="sxs-lookup"><span data-stu-id="15694-734">1090 - 1500</span></span>              |
| <span data-ttu-id="15694-735">ADRESSE</span><span class="sxs-lookup"><span data-stu-id="15694-735">ADDRESSU</span></span>                             | <span data-ttu-id="15694-736">1070-1500</span><span class="sxs-lookup"><span data-stu-id="15694-736">1070 - 1500</span></span>              |
| <span data-ttu-id="15694-737">DrawPrimitive</span><span class="sxs-lookup"><span data-stu-id="15694-737">DrawPrimitive</span></span>                        | <span data-ttu-id="15694-738">1050-1150</span><span class="sxs-lookup"><span data-stu-id="15694-738">1050 - 1150</span></span>              |
| <span data-ttu-id="15694-739">SRGBTEXTURE</span><span class="sxs-lookup"><span data-stu-id="15694-739">SRGBTEXTURE</span></span>                          | <span data-ttu-id="15694-740">150-1500</span><span class="sxs-lookup"><span data-stu-id="15694-740">150 - 1500</span></span>               |
| <span data-ttu-id="15694-741">STENCILMASK</span><span class="sxs-lookup"><span data-stu-id="15694-741">STENCILMASK</span></span>                          | <span data-ttu-id="15694-742">570-700</span><span class="sxs-lookup"><span data-stu-id="15694-742">570 - 700</span></span>                |
| <span data-ttu-id="15694-743">STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="15694-743">STENCILZFAIL</span></span>                         | <span data-ttu-id="15694-744">500-800</span><span class="sxs-lookup"><span data-stu-id="15694-744">500 - 800</span></span>                |
| <span data-ttu-id="15694-745">STENCILREF</span><span class="sxs-lookup"><span data-stu-id="15694-745">STENCILREF</span></span>                           | <span data-ttu-id="15694-746">550-700</span><span class="sxs-lookup"><span data-stu-id="15694-746">550 - 700</span></span>                |
| <span data-ttu-id="15694-747">ALPHABLENDENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-747">ALPHABLENDENABLE</span></span>                     | <span data-ttu-id="15694-748">550-700</span><span class="sxs-lookup"><span data-stu-id="15694-748">550 - 700</span></span>                |
| <span data-ttu-id="15694-749">STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="15694-749">STENCILFUNC</span></span>                          | <span data-ttu-id="15694-750">560-680</span><span class="sxs-lookup"><span data-stu-id="15694-750">560 - 680</span></span>                |
| <span data-ttu-id="15694-751">STENCILWRITEMASK</span><span class="sxs-lookup"><span data-stu-id="15694-751">STENCILWRITEMASK</span></span>                     | <span data-ttu-id="15694-752">520-700</span><span class="sxs-lookup"><span data-stu-id="15694-752">520 - 700</span></span>                |
| <span data-ttu-id="15694-753">STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="15694-753">STENCILFAIL</span></span>                          | <span data-ttu-id="15694-754">500-750</span><span class="sxs-lookup"><span data-stu-id="15694-754">500 - 750</span></span>                |
| <span data-ttu-id="15694-755">ZFUNC</span><span class="sxs-lookup"><span data-stu-id="15694-755">ZFUNC</span></span>                                | <span data-ttu-id="15694-756">510-700</span><span class="sxs-lookup"><span data-stu-id="15694-756">510 - 700</span></span>                |
| <span data-ttu-id="15694-757">ZWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-757">ZWRITEENABLE</span></span>                         | <span data-ttu-id="15694-758">520-680</span><span class="sxs-lookup"><span data-stu-id="15694-758">520 - 680</span></span>                |
| <span data-ttu-id="15694-759">STENCILENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-759">STENCILENABLE</span></span>                        | <span data-ttu-id="15694-760">540-650</span><span class="sxs-lookup"><span data-stu-id="15694-760">540 - 650</span></span>                |
| <span data-ttu-id="15694-761">STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="15694-761">STENCILPASS</span></span>                          | <span data-ttu-id="15694-762">560-630</span><span class="sxs-lookup"><span data-stu-id="15694-762">560 - 630</span></span>                |
| <span data-ttu-id="15694-763">SRCBLEND</span><span class="sxs-lookup"><span data-stu-id="15694-763">SRCBLEND</span></span>                             | <span data-ttu-id="15694-764">500-685</span><span class="sxs-lookup"><span data-stu-id="15694-764">500 - 685</span></span>                |
| <span data-ttu-id="15694-765">\_StencilMODE deux côtés \_</span><span class="sxs-lookup"><span data-stu-id="15694-765">Two\_Sided\_StencilMODE</span></span>              | <span data-ttu-id="15694-766">450-590</span><span class="sxs-lookup"><span data-stu-id="15694-766">450 - 590</span></span>                |
| <span data-ttu-id="15694-767">ALPHATESTENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-767">ALPHATESTENABLE</span></span>                      | <span data-ttu-id="15694-768">470-525</span><span class="sxs-lookup"><span data-stu-id="15694-768">470 - 525</span></span>                |
| <span data-ttu-id="15694-769">ALPHAREF</span><span class="sxs-lookup"><span data-stu-id="15694-769">ALPHAREF</span></span>                             | <span data-ttu-id="15694-770">460-530</span><span class="sxs-lookup"><span data-stu-id="15694-770">460 - 530</span></span>                |
| <span data-ttu-id="15694-771">ALPHAFUNC</span><span class="sxs-lookup"><span data-stu-id="15694-771">ALPHAFUNC</span></span>                            | <span data-ttu-id="15694-772">450-540</span><span class="sxs-lookup"><span data-stu-id="15694-772">450 - 540</span></span>                |
| <span data-ttu-id="15694-773">DESTBLEND</span><span class="sxs-lookup"><span data-stu-id="15694-773">DESTBLEND</span></span>                            | <span data-ttu-id="15694-774">475-510</span><span class="sxs-lookup"><span data-stu-id="15694-774">475 - 510</span></span>                |
| <span data-ttu-id="15694-775">COLORWRITEENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-775">COLORWRITEENABLE</span></span>                     | <span data-ttu-id="15694-776">465-515</span><span class="sxs-lookup"><span data-stu-id="15694-776">465 - 515</span></span>                |
| <span data-ttu-id="15694-777">wrapper CCW \_ STENCILFAIL</span><span class="sxs-lookup"><span data-stu-id="15694-777">CCW\_STENCILFAIL</span></span>                     | <span data-ttu-id="15694-778">340-560</span><span class="sxs-lookup"><span data-stu-id="15694-778">340 - 560</span></span>                |
| <span data-ttu-id="15694-779">wrapper CCW \_ STENCILPASS</span><span class="sxs-lookup"><span data-stu-id="15694-779">CCW\_STENCILPASS</span></span>                     | <span data-ttu-id="15694-780">340-545</span><span class="sxs-lookup"><span data-stu-id="15694-780">340 - 545</span></span>                |
| <span data-ttu-id="15694-781">wrapper CCW \_ STENCILZFAIL</span><span class="sxs-lookup"><span data-stu-id="15694-781">CCW\_STENCILZFAIL</span></span>                    | <span data-ttu-id="15694-782">330-495</span><span class="sxs-lookup"><span data-stu-id="15694-782">330 - 495</span></span>                |
| <span data-ttu-id="15694-783">SCISSORTESTENABLE</span><span class="sxs-lookup"><span data-stu-id="15694-783">SCISSORTESTENABLE</span></span>                    | <span data-ttu-id="15694-784">375-440</span><span class="sxs-lookup"><span data-stu-id="15694-784">375 - 440</span></span>                |
| <span data-ttu-id="15694-785">wrapper CCW \_ STENCILFUNC</span><span class="sxs-lookup"><span data-stu-id="15694-785">CCW\_STENCILFUNC</span></span>                     | <span data-ttu-id="15694-786">250-480</span><span class="sxs-lookup"><span data-stu-id="15694-786">250 - 480</span></span>                |
| <span data-ttu-id="15694-787">SetScissorRect</span><span class="sxs-lookup"><span data-stu-id="15694-787">SetScissorRect</span></span>                       | <span data-ttu-id="15694-788">150-340</span><span class="sxs-lookup"><span data-stu-id="15694-788">150 - 340</span></span>                |



 

## <a name="related-topics"></a><span data-ttu-id="15694-789">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="15694-789">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="15694-790">Rubriques avancées</span><span class="sxs-lookup"><span data-stu-id="15694-790">Advanced Topics</span></span>](advanced-topics.md)
</dt> </dl>

 

 
