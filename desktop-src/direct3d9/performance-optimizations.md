---
description: Chaque développeur qui crée des applications en temps réel qui utilisent des graphiques 3D est préoccupé par l’optimisation des performances. Cette section fournit des instructions pour obtenir les meilleures performances de votre code.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Optimisations des performances (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4d42be994522f0d83e36387b1a5866b3eee10df3
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104480689"
---
# <a name="performance-optimizations-direct3d-9"></a><span data-ttu-id="7c125-104">Optimisations des performances (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="7c125-104">Performance Optimizations (Direct3D 9)</span></span>

<span data-ttu-id="7c125-105">Chaque développeur qui crée des applications en temps réel qui utilisent des graphiques 3D est préoccupé par l’optimisation des performances.</span><span class="sxs-lookup"><span data-stu-id="7c125-105">Every developer who creates real-time applications that use 3D graphics is concerned about performance optimization.</span></span> <span data-ttu-id="7c125-106">Cette section fournit des instructions pour obtenir les meilleures performances de votre code.</span><span class="sxs-lookup"><span data-stu-id="7c125-106">This section provides guidelines for getting the best performance from your code.</span></span>

-   [<span data-ttu-id="7c125-107">Conseils généraux sur les performances</span><span class="sxs-lookup"><span data-stu-id="7c125-107">General Performance Tips</span></span>](#general-performance-tips)
-   [<span data-ttu-id="7c125-108">Bases de données et élimination</span><span class="sxs-lookup"><span data-stu-id="7c125-108">Databases and Culling</span></span>](#databases-and-culling)
-   [<span data-ttu-id="7c125-109">Primitives de traitement par lot</span><span class="sxs-lookup"><span data-stu-id="7c125-109">Batching Primitives</span></span>](#batching-primitives)
-   [<span data-ttu-id="7c125-110">Conseils d’éclairage</span><span class="sxs-lookup"><span data-stu-id="7c125-110">Lighting Tips</span></span>](#lighting-tips)
-   [<span data-ttu-id="7c125-111">Taille de la texture</span><span class="sxs-lookup"><span data-stu-id="7c125-111">Texture Size</span></span>](#texture-size)
-   [<span data-ttu-id="7c125-112">Transformations de matrice</span><span class="sxs-lookup"><span data-stu-id="7c125-112">Matrix Transforms</span></span>](#matrix-transforms)
-   [<span data-ttu-id="7c125-113">Utilisation de textures dynamiques</span><span class="sxs-lookup"><span data-stu-id="7c125-113">Using Dynamic Textures</span></span>](#using-dynamic-textures)
-   [<span data-ttu-id="7c125-114">Utilisation de mémoires tampons de vertex et d’index dynamiques</span><span class="sxs-lookup"><span data-stu-id="7c125-114">Using Dynamic Vertex and Index Buffers</span></span>](#using-dynamic-vertex-and-index-buffers)
-   [<span data-ttu-id="7c125-115">Utilisation de maillages</span><span class="sxs-lookup"><span data-stu-id="7c125-115">Using Meshes</span></span>](#using-meshes)
-   [<span data-ttu-id="7c125-116">Performances de la mémoire tampon Z</span><span class="sxs-lookup"><span data-stu-id="7c125-116">Z-Buffer Performance</span></span>](#z-buffer-performance)

## <a name="general-performance-tips"></a><span data-ttu-id="7c125-117">Conseils généraux sur les performances</span><span class="sxs-lookup"><span data-stu-id="7c125-117">General Performance Tips</span></span>

-   <span data-ttu-id="7c125-118">Désactivez uniquement lorsque vous devez.</span><span class="sxs-lookup"><span data-stu-id="7c125-118">Clear only when you must.</span></span>
-   <span data-ttu-id="7c125-119">Réduisez les modifications d’État et regroupez les modifications d’État restantes.</span><span class="sxs-lookup"><span data-stu-id="7c125-119">Minimize state changes and group the remaining state changes.</span></span>
-   <span data-ttu-id="7c125-120">Utilisez des textures plus petites si vous le pouvez.</span><span class="sxs-lookup"><span data-stu-id="7c125-120">Use smaller textures, if you can do so.</span></span>
-   <span data-ttu-id="7c125-121">Dessinez des objets dans votre scène de l’avant vers l’arrière.</span><span class="sxs-lookup"><span data-stu-id="7c125-121">Draw objects in your scene from front to back.</span></span>
-   <span data-ttu-id="7c125-122">Utilisez des bandes triangulaires à la place des listes et des ventilateurs.</span><span class="sxs-lookup"><span data-stu-id="7c125-122">Use triangle strips instead of lists and fans.</span></span> <span data-ttu-id="7c125-123">Pour optimiser les performances du cache des vertex, réorganisez les bandes pour réutiliser les sommets de triangle plus tôt et plus tard.</span><span class="sxs-lookup"><span data-stu-id="7c125-123">For optimal vertex cache performance, arrange strips to reuse triangle vertices sooner, rather than later.</span></span>
-   <span data-ttu-id="7c125-124">Dégradez correctement les effets spéciaux qui nécessitent un partage disproportionné des ressources système.</span><span class="sxs-lookup"><span data-stu-id="7c125-124">Gracefully degrade special effects that require a disproportionate share of system resources.</span></span>
-   <span data-ttu-id="7c125-125">Testez en permanence les performances de votre application.</span><span class="sxs-lookup"><span data-stu-id="7c125-125">Constantly test your application's performance.</span></span>
-   <span data-ttu-id="7c125-126">Réduire les commutateurs de mémoire tampon de vertex.</span><span class="sxs-lookup"><span data-stu-id="7c125-126">Minimize vertex buffer switches.</span></span>
-   <span data-ttu-id="7c125-127">Utilisez des mémoires tampons de vertex statiques dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-127">Use static vertex buffers where possible.</span></span>
-   <span data-ttu-id="7c125-128">Utilisez un grand tampon de vertex statique par Commission pour les objets statiques, plutôt qu’un par objet.</span><span class="sxs-lookup"><span data-stu-id="7c125-128">Use one large static vertex buffer per FVF for static objects, rather than one per object.</span></span>
-   <span data-ttu-id="7c125-129">Si votre application a besoin d’un accès aléatoire à la mémoire tampon de vertex dans la mémoire AGP, choisissez une taille de format de vertex qui est un multiple de 32 octets.</span><span class="sxs-lookup"><span data-stu-id="7c125-129">If your application needs random access into the vertex buffer in AGP memory, choose a vertex format size that is a multiple of 32 bytes.</span></span> <span data-ttu-id="7c125-130">Dans le cas contraire, sélectionnez le plus petit format approprié.</span><span class="sxs-lookup"><span data-stu-id="7c125-130">Otherwise, select the smallest appropriate format.</span></span>
-   <span data-ttu-id="7c125-131">Dessinez à l’aide de primitives indexées.</span><span class="sxs-lookup"><span data-stu-id="7c125-131">Draw using indexed primitives.</span></span> <span data-ttu-id="7c125-132">Cela peut permettre une mise en cache des vertex plus efficace au sein du matériel.</span><span class="sxs-lookup"><span data-stu-id="7c125-132">This can allow for more efficient vertex caching within hardware.</span></span>
-   <span data-ttu-id="7c125-133">Si le format de mémoire tampon de profondeur contient un canal de stencil, effacez toujours les canaux de profondeur et de stencil en même temps.</span><span class="sxs-lookup"><span data-stu-id="7c125-133">If the depth buffer format contains a stencil channel, always clear the depth and stencil channels at the same time.</span></span>
-   <span data-ttu-id="7c125-134">Combinez l’instruction du nuanceur et la sortie des données dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-134">Combine the shader instruction and the data output where possible.</span></span> <span data-ttu-id="7c125-135">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="7c125-135">For example:</span></span>
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a><span data-ttu-id="7c125-136">Bases de données et élimination</span><span class="sxs-lookup"><span data-stu-id="7c125-136">Databases and Culling</span></span>

<span data-ttu-id="7c125-137">La création d’une base de données fiable des objets dans votre monde est essentielle pour obtenir d’excellentes performances dans Direct3D.</span><span class="sxs-lookup"><span data-stu-id="7c125-137">Building a reliable database of the objects in your world is key to excellent performance in Direct3D.</span></span> <span data-ttu-id="7c125-138">Il est plus important que les améliorations apportées à la pixellisation ou au matériel.</span><span class="sxs-lookup"><span data-stu-id="7c125-138">It is more important than improvements to rasterization or hardware.</span></span>

<span data-ttu-id="7c125-139">Vous devez conserver le nombre de polygones le plus bas que vous pouvez éventuellement gérer.</span><span class="sxs-lookup"><span data-stu-id="7c125-139">You should maintain the lowest polygon count you can possibly manage.</span></span> <span data-ttu-id="7c125-140">Créez un nombre faible de polygones en générant des modèles à faible polygones à partir du début.</span><span class="sxs-lookup"><span data-stu-id="7c125-140">Design for a low polygon count by building low-polygon models from the start.</span></span> <span data-ttu-id="7c125-141">Ajoutez des polygones si vous pouvez le faire sans sacrifier les performances plus tard dans le processus de développement.</span><span class="sxs-lookup"><span data-stu-id="7c125-141">Add polygons if you can do so without sacrificing performance later in the development process.</span></span> <span data-ttu-id="7c125-142">N’oubliez pas que les polygones les plus rapides sont ceux que vous ne dessinez pas.</span><span class="sxs-lookup"><span data-stu-id="7c125-142">Remember, the fastest polygons are the ones you don't draw.</span></span>

## <a name="batching-primitives"></a><span data-ttu-id="7c125-143">Primitives de traitement par lot</span><span class="sxs-lookup"><span data-stu-id="7c125-143">Batching Primitives</span></span>

<span data-ttu-id="7c125-144">Pour obtenir les meilleures performances de rendu lors de l’exécution, essayez d’utiliser des primitives dans des lots et gardez le nombre de modifications d’état de rendu aussi faible que possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-144">To get the best rendering performance during execution, try to work with primitives in batches and keep the number of render-state changes as low as possible.</span></span> <span data-ttu-id="7c125-145">Par exemple, si vous avez un objet avec deux textures, regroupez les triangles qui utilisent la première texture et suivez l’état de rendu nécessaire pour modifier la texture.</span><span class="sxs-lookup"><span data-stu-id="7c125-145">For example, if you have an object with two textures, group the triangles that use the first texture and follow them with the necessary render state to change the texture.</span></span> <span data-ttu-id="7c125-146">Regroupez ensuite tous les triangles qui utilisent la deuxième texture.</span><span class="sxs-lookup"><span data-stu-id="7c125-146">Then group all the triangles that use the second texture.</span></span> <span data-ttu-id="7c125-147">La prise en charge matérielle la plus simple pour Direct3D est appelée avec des lots d’États de rendu et des lots de primitives via la couche d’abstraction matérielle (HAL).</span><span class="sxs-lookup"><span data-stu-id="7c125-147">The simplest hardware support for Direct3D is called with batches of render states and batches of primitives through the hardware abstraction layer (HAL).</span></span> <span data-ttu-id="7c125-148">Plus les instructions sont traitées par lot, moins le nombre d’appels de la couche HAL est élevé pendant l’exécution.</span><span class="sxs-lookup"><span data-stu-id="7c125-148">The more effectively the instructions are batched, the fewer HAL calls are performed during execution.</span></span>

## <a name="lighting-tips"></a><span data-ttu-id="7c125-149">Conseils d’éclairage</span><span class="sxs-lookup"><span data-stu-id="7c125-149">Lighting Tips</span></span>

<span data-ttu-id="7c125-150">Étant donné que les lumières ajoutent un coût par vertex à chaque image rendue, vous pouvez améliorer considérablement les performances en veillant à la façon dont vous les utilisez dans votre application.</span><span class="sxs-lookup"><span data-stu-id="7c125-150">Because lights add a per-vertex cost to each rendered frame, you can improve performance significantly by being careful about how you use them in your application.</span></span> <span data-ttu-id="7c125-151">La plupart des conseils suivants dérivent du maximiser, « le code le plus rapide est le code qui n’est jamais appelé ».</span><span class="sxs-lookup"><span data-stu-id="7c125-151">Most of the following tips derive from the maxim, "the fastest code is code that is never called."</span></span>

-   <span data-ttu-id="7c125-152">Utilisez le moins de sources de lumière possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-152">Use as few light sources as possible.</span></span> <span data-ttu-id="7c125-153">Pour augmenter le niveau d’éclairage global, par exemple, utilisez la lumière ambiante au lieu d’ajouter une nouvelle source de lumière.</span><span class="sxs-lookup"><span data-stu-id="7c125-153">To increase the overall lighting level, for example, use the ambient light instead of adding a new light source.</span></span>
-   <span data-ttu-id="7c125-154">Les lumières directionnelles sont plus efficaces que les lumières de point ou les actualités.</span><span class="sxs-lookup"><span data-stu-id="7c125-154">Directional lights are more efficient than point lights or spotlights.</span></span> <span data-ttu-id="7c125-155">Pour les lumières directionnelles, le sens de la lumière est fixe et n’a pas besoin d’être calculé sur la base de chaque vertex.</span><span class="sxs-lookup"><span data-stu-id="7c125-155">For directional lights, the direction to the light is fixed and doesn't need to be calculated on a per-vertex basis.</span></span>
-   <span data-ttu-id="7c125-156">Les lumières peuvent être plus efficaces que les lumières de point, car la zone en dehors du cône est calculée rapidement.</span><span class="sxs-lookup"><span data-stu-id="7c125-156">Spotlights can be more efficient than point lights, because the area outside the cone of light is calculated quickly.</span></span> <span data-ttu-id="7c125-157">Le fait que les lumières soient plus efficaces ou non dépend de la proportion de votre scène qui est éclairée par la lumière.</span><span class="sxs-lookup"><span data-stu-id="7c125-157">Whether spotlights are more efficient or not depends on how much of your scene is lit by the spotlight.</span></span>
-   <span data-ttu-id="7c125-158">Utilisez le paramètre Range pour limiter vos lumières aux seules parties de la scène que vous devez éclairer.</span><span class="sxs-lookup"><span data-stu-id="7c125-158">Use the range parameter to limit your lights to only the parts of the scene you need to illuminate.</span></span> <span data-ttu-id="7c125-159">Tous les types de lumière se ferment assez tôt lorsqu’ils sont hors limites.</span><span class="sxs-lookup"><span data-stu-id="7c125-159">All the light types exit fairly early when they are out of range.</span></span>
-   <span data-ttu-id="7c125-160">La surbrillance spéculaire revient presque à doubler le coût d’une lumière.</span><span class="sxs-lookup"><span data-stu-id="7c125-160">Specular highlights almost double the cost of a light.</span></span> <span data-ttu-id="7c125-161">Utilisez-les uniquement lorsque vous devez le faire.</span><span class="sxs-lookup"><span data-stu-id="7c125-161">Use them only when you must.</span></span> <span data-ttu-id="7c125-162">Définissez l' \_ État de rendu D3DRS SpecularEnable sur 0, la valeur par défaut, dans la mesure du possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-162">Set the D3DRS\_SPECULARENABLE render state to 0, the default value, whenever possible.</span></span> <span data-ttu-id="7c125-163">Lors de la définition de matériaux, vous devez définir la valeur de puissance spéculaire sur zéro pour désactiver les surbrillances spéculaires de ce matériel. le fait de définir simplement la couleur spéculaire sur 0, 0, n’est pas suffisant.</span><span class="sxs-lookup"><span data-stu-id="7c125-163">When defining materials, you must set the specular power value to zero to turn off specular highlights for that material; just setting the specular color to 0,0,0 is not enough.</span></span>

## <a name="texture-size"></a><span data-ttu-id="7c125-164">Taille de la texture</span><span class="sxs-lookup"><span data-stu-id="7c125-164">Texture Size</span></span>

<span data-ttu-id="7c125-165">Les performances de mappage de texture dépendent fortement de la vitesse de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="7c125-165">Texture-mapping performance is heavily dependent on the speed of memory.</span></span> <span data-ttu-id="7c125-166">Il existe plusieurs façons d’optimiser les performances du cache des textures de votre application.</span><span class="sxs-lookup"><span data-stu-id="7c125-166">There are a number of ways to maximize the cache performance of your application's textures.</span></span>

-   <span data-ttu-id="7c125-167">Conservez les textures de petite taille.</span><span class="sxs-lookup"><span data-stu-id="7c125-167">Keep the textures small.</span></span> <span data-ttu-id="7c125-168">Plus les textures sont petites, plus il est probable qu’elles soient gérées dans le cache secondaire de l’UC principale.</span><span class="sxs-lookup"><span data-stu-id="7c125-168">The smaller the textures are, the better chance they have of being maintained in the main CPU's secondary cache.</span></span>
-   <span data-ttu-id="7c125-169">Ne modifiez pas les textures en fonction de la primitive.</span><span class="sxs-lookup"><span data-stu-id="7c125-169">Do not change the textures on a per-primitive basis.</span></span> <span data-ttu-id="7c125-170">Essayez de faire en sorte que les polygones soient regroupés dans l’ordre des textures qu’ils utilisent.</span><span class="sxs-lookup"><span data-stu-id="7c125-170">Try to keep polygons grouped in order of the textures they use.</span></span>
-   <span data-ttu-id="7c125-171">Utilisez des textures carrées chaque fois que possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-171">Use square textures whenever possible.</span></span> <span data-ttu-id="7c125-172">Les textures dont les dimensions sont 256x256 sont les plus rapides.</span><span class="sxs-lookup"><span data-stu-id="7c125-172">Textures whose dimensions are 256x256 are the fastest.</span></span> <span data-ttu-id="7c125-173">Si votre application utilise quatre textures 128 x 128, par exemple, essayez de vous assurer qu’elles utilisent la même palette et placez-les toutes dans une texture 256x256.</span><span class="sxs-lookup"><span data-stu-id="7c125-173">If your application uses four 128x128 textures, for example, try to ensure that they use the same palette and place them all into one 256x256 texture.</span></span> <span data-ttu-id="7c125-174">Cette technique réduit également la quantité de permutation de texture.</span><span class="sxs-lookup"><span data-stu-id="7c125-174">This technique also reduces the amount of texture swapping.</span></span> <span data-ttu-id="7c125-175">Bien entendu, vous ne devez pas utiliser les textures 256x256, à moins que votre application ne nécessite un grand nombre de textures car, comme mentionné, les textures doivent être conservées le plus petit possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-175">Of course, you should not use 256x256 textures unless your application requires that much texturing because, as mentioned, textures should be kept as small as possible.</span></span>

## <a name="matrix-transforms"></a><span data-ttu-id="7c125-176">Transformations de matrice</span><span class="sxs-lookup"><span data-stu-id="7c125-176">Matrix Transforms</span></span>

<span data-ttu-id="7c125-177">Direct3D utilise les matrices universelles et de vue que vous avez définies pour configurer plusieurs structures de données internes.</span><span class="sxs-lookup"><span data-stu-id="7c125-177">Direct3D uses the world and view matrices that you set to configure several internal data structures.</span></span> <span data-ttu-id="7c125-178">Chaque fois que vous définissez une nouvelle matrice de monde ou d’affichage, le système recalcule les structures internes associées.</span><span class="sxs-lookup"><span data-stu-id="7c125-178">Each time you set a new world or view matrix, the system recalculates the associated internal structures.</span></span> <span data-ttu-id="7c125-179">La définition fréquente de ces matrices, par exemple, des milliers de fois par trame, prend beaucoup de temps.</span><span class="sxs-lookup"><span data-stu-id="7c125-179">Setting these matrices frequently - for example, thousands of times per frame - is computationally time-consuming.</span></span> <span data-ttu-id="7c125-180">Vous pouvez réduire le nombre de calculs requis en concaténant votre monde et en vue des matrices dans une matrice de vue universelle que vous définissez comme matrice universelle, puis en définissant la matrice de vue sur l’identité.</span><span class="sxs-lookup"><span data-stu-id="7c125-180">You can minimize the number of required calculations by concatenating your world and view matrices into a world-view matrix that you set as the world matrix, and then setting the view matrix to the identity.</span></span> <span data-ttu-id="7c125-181">Conservez les copies mises en cache des matrices de monde et de vue individuelles afin de pouvoir modifier, concaténer et réinitialiser la matrice universelle en fonction des besoins.</span><span class="sxs-lookup"><span data-stu-id="7c125-181">Keep cached copies of individual world and view matrices so that you can modify, concatenate, and reset the world matrix as needed.</span></span> <span data-ttu-id="7c125-182">Par souci de clarté dans cette documentation, les exemples Direct3D utilisent rarement cette optimisation.</span><span class="sxs-lookup"><span data-stu-id="7c125-182">For clarity in this documentation, Direct3D samples rarely employ this optimization.</span></span>

## <a name="using-dynamic-textures"></a><span data-ttu-id="7c125-183">Utilisation de textures dynamiques</span><span class="sxs-lookup"><span data-stu-id="7c125-183">Using Dynamic Textures</span></span>

<span data-ttu-id="7c125-184">Pour savoir si le pilote prend en charge les textures dynamiques, consultez l' \_ indicateur D3DCAPS2 DYNAMICTEXTURES de la structure [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .</span><span class="sxs-lookup"><span data-stu-id="7c125-184">To find out if the driver supports dynamic textures, check the D3DCAPS2\_DYNAMICTEXTURES flag of the [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) structure.</span></span>

<span data-ttu-id="7c125-185">Gardez à l’esprit les points suivants lorsque vous travaillez avec des textures dynamiques.</span><span class="sxs-lookup"><span data-stu-id="7c125-185">Keep the following things in mind when working with dynamic textures.</span></span>

-   <span data-ttu-id="7c125-186">Ils ne peuvent pas être gérés.</span><span class="sxs-lookup"><span data-stu-id="7c125-186">They cannot be managed.</span></span> <span data-ttu-id="7c125-187">Par exemple, le pool ne peut pas être géré par D3DPOOL \_ .</span><span class="sxs-lookup"><span data-stu-id="7c125-187">For example, their pool cannot be D3DPOOL\_MANAGED.</span></span>
-   <span data-ttu-id="7c125-188">Les textures dynamiques peuvent être verrouillées, même si elles sont créées dans D3DPOOL \_ par défaut.</span><span class="sxs-lookup"><span data-stu-id="7c125-188">Dynamic textures can be locked, even if they are created in D3DPOOL\_DEFAULT.</span></span>
-   <span data-ttu-id="7c125-189">D3DLOCK \_ ignore est un indicateur de verrou valide pour les textures dynamiques.</span><span class="sxs-lookup"><span data-stu-id="7c125-189">D3DLOCK\_DISCARD is a valid lock flag for dynamic textures.</span></span>

<span data-ttu-id="7c125-190">Il est judicieux de créer une seule texture dynamique par format et éventuellement par taille.</span><span class="sxs-lookup"><span data-stu-id="7c125-190">It is a good idea to create only one dynamic texture per format and possibly per size.</span></span> <span data-ttu-id="7c125-191">Les des mipmaps, cubes et volumes dynamiques ne sont pas recommandés en raison de la surcharge supplémentaire dans le verrouillage de chaque niveau.</span><span class="sxs-lookup"><span data-stu-id="7c125-191">Dynamic mipmaps, cubes, and volumes are not recommended because of the additional overhead in locking every level.</span></span> <span data-ttu-id="7c125-192">Pour des mipmaps, D3DLOCK \_ ignore est autorisé uniquement au niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="7c125-192">For mipmaps, D3DLOCK\_DISCARD is allowed only on the top level.</span></span> <span data-ttu-id="7c125-193">Tous les niveaux sont ignorés en verrouillant uniquement le niveau supérieur.</span><span class="sxs-lookup"><span data-stu-id="7c125-193">All levels are discarded by locking just the top level.</span></span> <span data-ttu-id="7c125-194">Ce comportement est le même pour les volumes et les cubes.</span><span class="sxs-lookup"><span data-stu-id="7c125-194">This behavior is the same for volumes and cubes.</span></span> <span data-ttu-id="7c125-195">Pour les cubes, le niveau supérieur et le visage 0 sont verrouillés.</span><span class="sxs-lookup"><span data-stu-id="7c125-195">For cubes, the top level and face 0 are locked.</span></span>

<span data-ttu-id="7c125-196">Le pseudo-code suivant montre un exemple d’utilisation d’une texture dynamique.</span><span class="sxs-lookup"><span data-stu-id="7c125-196">The following pseudocode shows an example of using a dynamic texture.</span></span>


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a><span data-ttu-id="7c125-197">Utilisation de mémoires tampons de vertex et d’index dynamiques</span><span class="sxs-lookup"><span data-stu-id="7c125-197">Using Dynamic Vertex and Index Buffers</span></span>

<span data-ttu-id="7c125-198">Le verrouillage d’une mémoire tampon de vertex statique pendant que le processeur graphique utilise la mémoire tampon peut avoir une incidence significative sur les performances.</span><span class="sxs-lookup"><span data-stu-id="7c125-198">Locking a static vertex buffer while the graphics processor is using the buffer can have a significant performance penalty.</span></span> <span data-ttu-id="7c125-199">L’appel de verrou doit attendre que le processeur graphique ait fini de lire les données du vertex ou de l’index dans la mémoire tampon avant de pouvoir retourner à l’application appelante, ce qui représente un délai important.</span><span class="sxs-lookup"><span data-stu-id="7c125-199">The lock call must wait until the graphics processor is finished reading vertex or index data from the buffer before it can return to the calling application, a significant delay.</span></span> <span data-ttu-id="7c125-200">Le verrouillage, puis le rendu à partir d’une mémoire tampon statique plusieurs fois par trame, empêche également le processeur graphique de mettre en mémoire tampon les commandes de rendu, car il doit terminer les commandes avant de retourner le pointeur de verrou.</span><span class="sxs-lookup"><span data-stu-id="7c125-200">Locking and then rendering from a static buffer several times per frame also prevents the graphics processor from buffering rendering commands, since it must finish commands before returning the lock pointer.</span></span> <span data-ttu-id="7c125-201">Sans commandes mises en mémoire tampon, le processeur graphique reste inactif jusqu’à ce que l’application ait fini de remplir la mémoire tampon de vertex ou le tampon d’index et envoie une commande de rendu.</span><span class="sxs-lookup"><span data-stu-id="7c125-201">Without buffered commands, the graphics processor remains idle until after the application is finished filling the vertex buffer or index buffer and issues a rendering command.</span></span>

<span data-ttu-id="7c125-202">Dans l’idéal, les données de vertex ou d’index ne changeraient jamais, mais ce n’est pas toujours possible.</span><span class="sxs-lookup"><span data-stu-id="7c125-202">Ideally the vertex or index data would never change, however this is not always possible.</span></span> <span data-ttu-id="7c125-203">Dans de nombreux cas, l’application doit modifier des données de vertex ou d’index à chaque trame, voire plusieurs fois par frame.</span><span class="sxs-lookup"><span data-stu-id="7c125-203">There are many situations where the application needs to change vertex or index data every frame, perhaps even multiple times per frame.</span></span> <span data-ttu-id="7c125-204">Dans ce cas, la mémoire tampon de vertex ou d’index doit être créée avec D3DUSAGE \_ Dynamic.</span><span class="sxs-lookup"><span data-stu-id="7c125-204">For these situations, the vertex or index buffer should be created with D3DUSAGE\_DYNAMIC.</span></span> <span data-ttu-id="7c125-205">Cet indicateur d’utilisation entraîne l’optimisation de Direct3D pour les opérations de verrouillage fréquentes.</span><span class="sxs-lookup"><span data-stu-id="7c125-205">This usage flag causes Direct3D to optimize for frequent lock operations.</span></span> <span data-ttu-id="7c125-206">D3DUSAGE \_ Dynamic est utile uniquement lorsque la mémoire tampon est verrouillée fréquemment ; les données qui restent constantes doivent être placées dans un sommet statique ou une mémoire tampon d’index.</span><span class="sxs-lookup"><span data-stu-id="7c125-206">D3DUSAGE\_DYNAMIC is only useful when the buffer is locked frequently; data that remains constant should be placed in a static vertex or index buffer.</span></span>

<span data-ttu-id="7c125-207">Pour bénéficier d’une amélioration des performances lors de l’utilisation de mémoires tampons de vertex dynamiques, l’application doit appeler [**IDirect3DVertexBuffer9 :: Lock**](/windows/desktop/api) ou [**IDirect3DIndexBuffer9 :: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) avec les indicateurs appropriés.</span><span class="sxs-lookup"><span data-stu-id="7c125-207">To receive a performance improvement when using dynamic vertex buffers, the application must call [**IDirect3DVertexBuffer9::Lock**](/windows/desktop/api) or [**IDirect3DIndexBuffer9::Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) with the appropriate flags.</span></span> <span data-ttu-id="7c125-208">D3DLOCK \_ ignore indique que l’application n’a pas besoin de conserver les anciennes données de vertex ou d’index dans la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7c125-208">D3DLOCK\_DISCARD indicates that the application does not need to keep the old vertex or index data in the buffer.</span></span> <span data-ttu-id="7c125-209">Si le processeur graphique utilise toujours le tampon lorsque Lock est appelé avec D3DLOCK \_ Discard, un pointeur vers une nouvelle région de mémoire est retourné à la place des anciennes données de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7c125-209">If the graphics processor is still using the buffer when lock is called with D3DLOCK\_DISCARD, a pointer to a new region of memory is returned instead of the old buffer data.</span></span> <span data-ttu-id="7c125-210">Cela permet au processeur graphique de continuer à utiliser les anciennes données pendant que l’application place les données dans la nouvelle mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7c125-210">This allows the graphics processor to continue using the old data while the application places data in the new buffer.</span></span> <span data-ttu-id="7c125-211">Aucune gestion de mémoire supplémentaire n’est nécessaire dans l’application. l’ancienne mémoire tampon est réutilisée ou détruite automatiquement lorsque le processeur graphique en a terminé avec celle-ci.</span><span class="sxs-lookup"><span data-stu-id="7c125-211">No additional memory management is required in the application; the old buffer is reused or destroyed automatically when the graphics processor is finished with it.</span></span> <span data-ttu-id="7c125-212">Notez que le verrouillage d’une mémoire tampon avec D3DLOCK \_ Discard ignore toujours l’intégralité de la mémoire tampon, la spécification d’un décalage différent de zéro ou d’un champ de taille limitée ne conserve pas les informations dans les zones déverrouillées de la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="7c125-212">Note that locking a buffer with D3DLOCK\_DISCARD always discards the entire buffer, specifying a nonzero offset or limited size field does not preserve information in unlocked areas of the buffer.</span></span>

<span data-ttu-id="7c125-213">Dans certains cas, la quantité de données que l’application doit stocker par verrou est faible, par exemple l’ajout de quatre sommets pour le rendu d’un sprite.</span><span class="sxs-lookup"><span data-stu-id="7c125-213">There are cases where the amount of data the application needs to store per lock is small, such as adding four vertices to render a sprite.</span></span> <span data-ttu-id="7c125-214">D3DLOCK \_ NOOVERWRITE indique que l’application ne remplacera pas les données déjà en cours d’utilisation dans la mémoire tampon dynamique.</span><span class="sxs-lookup"><span data-stu-id="7c125-214">D3DLOCK\_NOOVERWRITE indicates that the application will not overwrite data already in use in the dynamic buffer.</span></span> <span data-ttu-id="7c125-215">L’appel de verrou retourne un pointeur vers les anciennes données, ce qui permet à l’application d’ajouter de nouvelles données dans les régions inutilisées du vertex ou de la mémoire tampon d’index.</span><span class="sxs-lookup"><span data-stu-id="7c125-215">The lock call will return a pointer to the old data, allowing the application to add new data in unused regions of the vertex or index buffer.</span></span> <span data-ttu-id="7c125-216">L’application ne doit pas modifier les vertex ou les index utilisés dans une opération de dessin, car ils peuvent toujours être utilisés par le processeur graphique.</span><span class="sxs-lookup"><span data-stu-id="7c125-216">The application should not modify vertices or indices used in a draw operation as they might still be in use by the graphics processor.</span></span> <span data-ttu-id="7c125-217">L’application doit ensuite utiliser D3DLOCK \_ ignore une fois que la mémoire tampon dynamique est pleine pour recevoir une nouvelle région de mémoire, en ignorant les anciennes données de vertex ou d’index une fois le processeur graphique terminé.</span><span class="sxs-lookup"><span data-stu-id="7c125-217">The application should then use D3DLOCK\_DISCARD after the dynamic buffer is full to receive a new region of memory, discarding the old vertex or index data after the graphics processor is finished.</span></span>

<span data-ttu-id="7c125-218">Le mécanisme de requête asynchrone est utile pour déterminer si les vertex sont toujours utilisés par le processeur graphique.</span><span class="sxs-lookup"><span data-stu-id="7c125-218">The asynchronous query mechanism is useful to determine if vertices are still in use by the graphics processor.</span></span> <span data-ttu-id="7c125-219">Émettez une requête de type \_ événement D3DQUERYTYPE après le dernier appel DrawPrimitive qui utilise les vertex.</span><span class="sxs-lookup"><span data-stu-id="7c125-219">Issue a query of type D3DQUERYTYPE\_EVENT after the last DrawPrimitive call that uses the vertices.</span></span> <span data-ttu-id="7c125-220">Les vertex ne sont plus utilisés quand [**IDirect3DQuery9 :: GetData**](/windows/desktop/api) retourne S \_ OK.</span><span class="sxs-lookup"><span data-stu-id="7c125-220">The vertices are no longer in use when [**IDirect3DQuery9::GetData**](/windows/desktop/api) returns S\_OK.</span></span> <span data-ttu-id="7c125-221">Le verrouillage d’un tampon avec D3DLOCK \_ Discard ignore ou no Flags garantit toujours que les vertex sont correctement synchronisés avec le processeur graphique, mais l’utilisation de Lock sans Flags entraîne une pénalité de performance décrite plus haut.</span><span class="sxs-lookup"><span data-stu-id="7c125-221">Locking a buffer with D3DLOCK\_DISCARD or no flags will always guarantee the vertices are synchronized properly with the graphics processor, however using lock without flags will incur the performance penalty described earlier.</span></span> <span data-ttu-id="7c125-222">D’autres appels d’API tels que [**IDirect3DDevice9 :: BeginScene**](/windows/desktop/api), [**IDirect3DDevice9 :: EndScene**](/windows/desktop/api)et [**IDirect3DDevice9 ::P renvoyés**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) ne garantissent pas que le processeur graphique est terminé à l’aide de vertex.</span><span class="sxs-lookup"><span data-stu-id="7c125-222">Other API calls such as [**IDirect3DDevice9::BeginScene**](/windows/desktop/api), [**IDirect3DDevice9::EndScene**](/windows/desktop/api), and [**IDirect3DDevice9::Present**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) do not guarantee the graphics processor is finished using vertices.</span></span>

<span data-ttu-id="7c125-223">Vous trouverez ci-dessous les façons d’utiliser des mémoires tampons dynamiques et les indicateurs de verrou appropriés.</span><span class="sxs-lookup"><span data-stu-id="7c125-223">Below are ways to use dynamic buffers and the proper lock flags.</span></span>


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a><span data-ttu-id="7c125-224">Utilisation de maillages</span><span class="sxs-lookup"><span data-stu-id="7c125-224">Using Meshes</span></span>

<span data-ttu-id="7c125-225">Vous pouvez optimiser les maillages à l’aide des triangles indexés Direct3D plutôt que des bandes à facettes indexées.</span><span class="sxs-lookup"><span data-stu-id="7c125-225">You can optimize meshes by using Direct3D indexed triangles instead of indexed triangle strips.</span></span> <span data-ttu-id="7c125-226">Le matériel découvre que 95% des triangles successifs forment en réalité des bandes et s’ajustent en conséquence.</span><span class="sxs-lookup"><span data-stu-id="7c125-226">The hardware will discover that 95 percent of successive triangles actually form strips and adjust accordingly.</span></span> <span data-ttu-id="7c125-227">De nombreux pilotes le font également pour un matériel plus ancien.</span><span class="sxs-lookup"><span data-stu-id="7c125-227">Many drivers do this for older hardware also.</span></span>

<span data-ttu-id="7c125-228">Les objets de maillage D3DX peuvent avoir chaque triangle, ou face, avec une valeur DWORD, appelée l’attribut de cette face.</span><span class="sxs-lookup"><span data-stu-id="7c125-228">D3DX mesh objects can have each triangle, or face, tagged with a DWORD, called the attribute of that face.</span></span> <span data-ttu-id="7c125-229">La sémantique de la valeur DWORD est définie par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="7c125-229">The semantics of the DWORD are user-defined.</span></span> <span data-ttu-id="7c125-230">Ils sont utilisés par D3DX pour classer le maillage en sous-ensembles.</span><span class="sxs-lookup"><span data-stu-id="7c125-230">They are used by D3DX to classify the mesh into subsets.</span></span> <span data-ttu-id="7c125-231">L’application définit des attributs par face à l’aide de l’appel de [**ID3DXMesh :: LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) .</span><span class="sxs-lookup"><span data-stu-id="7c125-231">The application sets per-face attributes using the [**ID3DXMesh::LockAttributeBuffer**](id3dxmesh--lockattributebuffer.md) call.</span></span> <span data-ttu-id="7c125-232">La méthode [**ID3DXMesh :: Optimize**](id3dxmesh--optimize.md) a une option permettant de regrouper les vertex et les visages de maillage sur les attributs à l’aide de l' \_ option D3DXMESHOPT ATTRSORT.</span><span class="sxs-lookup"><span data-stu-id="7c125-232">The [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) method has an option to group the mesh vertices and faces on attributes using the D3DXMESHOPT\_ATTRSORT option.</span></span> <span data-ttu-id="7c125-233">Une fois cette opération effectuée, l’objet Mesh calcule une table d’attributs qui peut être obtenue par l’application en appelant [**ID3DXBaseMesh :: GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span><span class="sxs-lookup"><span data-stu-id="7c125-233">When this is done, the mesh object calculates an attribute table that can be obtained by the application by calling [**ID3DXBaseMesh::GetAttributeTable**](id3dxbasemesh--getattributetable.md).</span></span> <span data-ttu-id="7c125-234">Cet appel retourne 0 si le maillage n’est pas trié par attributs.</span><span class="sxs-lookup"><span data-stu-id="7c125-234">This call returns 0 if the mesh is not sorted by attributes.</span></span> <span data-ttu-id="7c125-235">Il n’existe aucun moyen pour une application de définir une table d’attributs, car elle est générée par la méthode **ID3DXMesh :: Optimize** .</span><span class="sxs-lookup"><span data-stu-id="7c125-235">There is no way for an application to set an attribute table because it is generated by the **ID3DXMesh::Optimize** method.</span></span> <span data-ttu-id="7c125-236">Le tri d’attribut est sensible aux données. par conséquent, si l’application sait qu’une maille est triée par attribut, elle doit toujours appeler **ID3DXMesh :: Optimize** pour générer la table d’attributs.</span><span class="sxs-lookup"><span data-stu-id="7c125-236">The attribute sort is data sensitive, so if the application knows that a mesh is attribute sorted, it still needs to call **ID3DXMesh::Optimize** to generate the attribute table.</span></span>

<span data-ttu-id="7c125-237">Les rubriques suivantes décrivent les différents attributs d’une maille.</span><span class="sxs-lookup"><span data-stu-id="7c125-237">The following topics describe the different attributes of a mesh.</span></span>

### <a name="attribute-id"></a><span data-ttu-id="7c125-238">ID d’attribut</span><span class="sxs-lookup"><span data-stu-id="7c125-238">Attribute ID</span></span>

<span data-ttu-id="7c125-239">Un ID d’attribut est une valeur qui associe un groupe de faces à un groupe d’attributs.</span><span class="sxs-lookup"><span data-stu-id="7c125-239">An attribute id is a value that associates a group of faces with an attribute group.</span></span> <span data-ttu-id="7c125-240">Cet ID décrit le sous-ensemble des visages [**ID3DXBaseMesh ::D rawsubset**](id3dxbasemesh--drawsubset.md) doit dessiner.</span><span class="sxs-lookup"><span data-stu-id="7c125-240">This id describes which subset of faces [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) should draw.</span></span> <span data-ttu-id="7c125-241">Les ID d’attribut sont spécifiés pour les visages dans la mémoire tampon d’attribut.</span><span class="sxs-lookup"><span data-stu-id="7c125-241">Attribute ids are specified for the faces in the attribute buffer.</span></span> <span data-ttu-id="7c125-242">Les valeurs réelles des ID d’attribut peuvent correspondre à tout ce qui s’ajuste à 32 bits, mais il est courant d’utiliser 0 à n, où n est le nombre d’attributs.</span><span class="sxs-lookup"><span data-stu-id="7c125-242">The actual values of the attribute ids can be anything that fits in 32 bits, but it is common to use 0 to n where n is the number of attributes.</span></span>

### <a name="attribute-buffer"></a><span data-ttu-id="7c125-243">Mémoire tampon d’attributs</span><span class="sxs-lookup"><span data-stu-id="7c125-243">Attribute Buffer</span></span>

<span data-ttu-id="7c125-244">La mémoire tampon d’attribut est un tableau de DWORDs (un par visage) qui spécifie le groupe d’attributs auquel chaque face appartient.</span><span class="sxs-lookup"><span data-stu-id="7c125-244">The attribute buffer is an array of DWORDs (one per face) that specifies which attribute group each face belongs in.</span></span> <span data-ttu-id="7c125-245">Cette mémoire tampon est initialisée sur zéro à la création d’un maillage, mais est remplie par les routines de chargement ou doit être remplie par l’utilisateur si plusieurs attributs avec l’ID 0 sont souhaités.</span><span class="sxs-lookup"><span data-stu-id="7c125-245">This buffer is initialized to zero on creation of a mesh, but is either filled by the load routines or must be filled by the user if more than one attribute with id 0 is desired.</span></span> <span data-ttu-id="7c125-246">Cette mémoire tampon contient les informations utilisées pour trier le maillage en fonction des attributs de [**ID3DXMesh :: Optimize**](id3dxmesh--optimize.md).</span><span class="sxs-lookup"><span data-stu-id="7c125-246">This buffer contains the information that is used to sort the mesh based on attributes in [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md).</span></span> <span data-ttu-id="7c125-247">Si aucune table d’attributs n’est présente, [**ID3DXBaseMesh ::D rawsubset**](id3dxbasemesh--drawsubset.md) analyse cette mémoire tampon pour sélectionner les faces de l’attribut donné à dessiner.</span><span class="sxs-lookup"><span data-stu-id="7c125-247">If no attribute table is present, [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md) scans this buffer to select the faces of the given attribute to draw.</span></span>

### <a name="attribute-table"></a><span data-ttu-id="7c125-248">Table d’attributs</span><span class="sxs-lookup"><span data-stu-id="7c125-248">Attribute Table</span></span>

<span data-ttu-id="7c125-249">La table d’attributs est une structure appartenant et gérée par la maille.</span><span class="sxs-lookup"><span data-stu-id="7c125-249">The attribute table is a structure owned and maintained by the mesh.</span></span> <span data-ttu-id="7c125-250">La seule façon d’être générée est d’appeler [**ID3DXMesh :: Optimize**](id3dxmesh--optimize.md) avec le tri d’attribut ou une optimisation renforcée activée.</span><span class="sxs-lookup"><span data-stu-id="7c125-250">The only way for one to be generated is by calling [**ID3DXMesh::Optimize**](id3dxmesh--optimize.md) with attribute sorting or stronger optimization enabled.</span></span> <span data-ttu-id="7c125-251">La table d’attributs est utilisée pour initialiser rapidement un appel de la primitive de dessin unique à [**ID3DXBaseMesh ::D rawsubset**](id3dxbasemesh--drawsubset.md).</span><span class="sxs-lookup"><span data-stu-id="7c125-251">The attribute table is used to quickly initiate a single draw primitive call to [**ID3DXBaseMesh::DrawSubset**](id3dxbasemesh--drawsubset.md).</span></span> <span data-ttu-id="7c125-252">La seule autre utilisation est que la progression des maillages conserve également cette structure. il est donc possible de voir quelles faces et quels vertex sont actifs au niveau de détail actuel.</span><span class="sxs-lookup"><span data-stu-id="7c125-252">The only other use is that progressing meshes also maintain this structure, so it is possible to see what faces and vertices are active at the current level of detail.</span></span>

## <a name="z-buffer-performance"></a><span data-ttu-id="7c125-253">Performances de la mémoire tampon Z</span><span class="sxs-lookup"><span data-stu-id="7c125-253">Z-Buffer Performance</span></span>

<span data-ttu-id="7c125-254">Les applications peuvent améliorer les performances lors de l’utilisation de la mise en mémoire tampon z et de la texturation en veillant à ce que les scènes soient rendues de l’avant vers l’arrière.</span><span class="sxs-lookup"><span data-stu-id="7c125-254">Applications can increase performance when using z-buffering and texturing by ensuring that scenes are rendered from front to back.</span></span> <span data-ttu-id="7c125-255">Les primitives de mise en mémoire tampon z texturées sont prétestées par rapport à la mémoire tampon z sur la base d’une ligne d’analyse.</span><span class="sxs-lookup"><span data-stu-id="7c125-255">Textured z-buffered primitives are pretested against the z-buffer on a scan line basis.</span></span> <span data-ttu-id="7c125-256">Si une ligne de numérisation est masquée par un polygone précédemment rendu, le système la rejette rapidement et efficacement.</span><span class="sxs-lookup"><span data-stu-id="7c125-256">If a scan line is hidden by a previously rendered polygon, the system rejects it quickly and efficiently.</span></span> <span data-ttu-id="7c125-257">La mise en mémoire tampon Z peut améliorer les performances, mais la technique est particulièrement utile lorsqu’une scène dessine les mêmes pixels plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="7c125-257">Z-buffering can improve performance, but the technique is most useful when a scene draws the same pixels more than once.</span></span> <span data-ttu-id="7c125-258">Cela est difficile à calculer exactement, mais vous pouvez souvent faire une approximation proche.</span><span class="sxs-lookup"><span data-stu-id="7c125-258">This is difficult to calculate exactly, but you can often make a close approximation.</span></span> <span data-ttu-id="7c125-259">Si les mêmes pixels sont dessinés en moins de deux fois, vous pouvez obtenir des performances optimales en désactivant la mise en mémoire tampon z et en rendant la scène de l’arrière vers l’avant.</span><span class="sxs-lookup"><span data-stu-id="7c125-259">If the same pixels are drawn less than twice, you can achieve the best performance by turning z-buffering off and rendering the scene from back to front.</span></span>

## <a name="related-topics"></a><span data-ttu-id="7c125-260">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="7c125-260">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="7c125-261">Conseils de programmation</span><span class="sxs-lookup"><span data-stu-id="7c125-261">Programming Tips</span></span>](programming-tips.md)
</dt> </dl>

 

 
