---
description: L’exemple PRTDemo et le simulateur PRTCmdLine inclus dans le kit de développement logiciel (SDK) DirectX représentent des vecteurs de transfert aux sommets d’une maille.
ms.assetid: cee049e8-3245-4fce-ab2f-ba251eacc72a
title: Représentation de PRT avec des textures (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4647cfc85451ede9507e007ed556a203a3cd890a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104200816"
---
# <a name="representing-prt-with-textures-direct3d-9"></a><span data-ttu-id="fcf35-103">Représentation de PRT avec des textures (Direct3D 9)</span><span class="sxs-lookup"><span data-stu-id="fcf35-103">Representing PRT With Textures (Direct3D 9)</span></span>

<span data-ttu-id="fcf35-104">L’exemple PRTDemo et le simulateur PRTCmdLine inclus dans le kit de développement logiciel (SDK) DirectX représentent des vecteurs de transfert aux sommets d’une maille.</span><span class="sxs-lookup"><span data-stu-id="fcf35-104">The PRTDemo sample and PRTCmdLine simulator included in the DirectX SDK represent transfer vectors at the vertices of a mesh.</span></span> <span data-ttu-id="fcf35-105">Pour représenter le signal PRT avec précision, cela peut nécessiter des pavages qui ne sont pas pratiques pour les jeux actuels.</span><span class="sxs-lookup"><span data-stu-id="fcf35-105">In order to represent the PRT signal accurately, this can require tessellations that may be impractical for current games.</span></span> <span data-ttu-id="fcf35-106">La représentation des vecteurs de transfert dans les cartes de texture est une approche alternative qui a le même coût des données indépendamment de la complexité du maillage.</span><span class="sxs-lookup"><span data-stu-id="fcf35-106">Representing transfer vectors in texture maps is an alternative approach that has the same data cost independent of mesh complexity.</span></span> <span data-ttu-id="fcf35-107">Il existe plusieurs façons de générer des mappages de texture vecteur de transfert à l’aide de la bibliothèque D3DX PRT.</span><span class="sxs-lookup"><span data-stu-id="fcf35-107">There are several ways to generate transfer vector texture maps using the D3DX PRT Library.</span></span>

## <a name="precomputing-transfer-vectors"></a><span data-ttu-id="fcf35-108">Vecteurs de transfert de précalcul</span><span class="sxs-lookup"><span data-stu-id="fcf35-108">Precomputing Transfer Vectors</span></span>

<span data-ttu-id="fcf35-109">Une approche consisterait à modifier les exemples PRTDemo et PRTCmdLine pour calculer un vecteur de transfert à chaque Texel dans un paramétrage d’une surface.</span><span class="sxs-lookup"><span data-stu-id="fcf35-109">One approach would be to modify the PRTDemo and PRTCmdLine samples to compute a transfer vector at every texel in a parameterization of a surface.</span></span> <span data-ttu-id="fcf35-110">Pour ce faire :</span><span class="sxs-lookup"><span data-stu-id="fcf35-110">To do this:</span></span>

1.  <span data-ttu-id="fcf35-111">Modifiez l’appel à [**D3DXCreatePRTEngine**](d3dxcreateprtengine.md) pour extraire les coordonnées de texture de la maille (ExtractUVs doit avoir la **valeur true**)</span><span class="sxs-lookup"><span data-stu-id="fcf35-111">Modify the call to [**D3DXCreatePRTEngine**](d3dxcreateprtengine.md) to extract texture coordinates from the mesh (ExtractUVs must be **TRUE**)</span></span>
2.  <span data-ttu-id="fcf35-112">Remplacez les appels [**D3DXCreatePRTBuffer**](d3dxcreateprtbuffer.md) par [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) à l’aide de la même taille de texture.</span><span class="sxs-lookup"><span data-stu-id="fcf35-112">Replace [**D3DXCreatePRTBuffer**](d3dxcreateprtbuffer.md) calls with [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) using the same texture size.</span></span>

<span data-ttu-id="fcf35-113">Toutes les méthodes ID3DXPRTEngine fonctionnent avec les simulations par Texel, à l’exception de : ComputeBounceAdaptive, ComputeSSAdaptive, compartss et ComputeDirectLightingSHAdaptive.</span><span class="sxs-lookup"><span data-stu-id="fcf35-113">All ID3DXPRTEngine methods work with per-texel simulations except for: ComputeBounceAdaptive, ComputeSSAdaptive, ComputeSS, and ComputeDirectLightingSHAdaptive.</span></span> <span data-ttu-id="fcf35-114">Bien que la simulation d’espace de texture produise le résultat correct, elle peut souvent être assez lente, car il s’agit probablement de vecteurs de transfert de calcul à haute densité.</span><span class="sxs-lookup"><span data-stu-id="fcf35-114">While texture-space simulation will generate the correct result, it can often be fairly slow since it will most likely be computing transfer vectors at a high density.</span></span>

<span data-ttu-id="fcf35-115">Une autre approche consiste à calculer une simulation adaptative par vertex PRT (avec des coordonnées de texture qui seront utilisées pour les données par Texel), puis à appeler [**ID3DXPRTEngine :: ResampleBuffer**](id3dxprtengine--resamplebuffer.md) (à l’aide d’une mémoire tampon de sortie créée à l’aide de [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) à la résolution appropriée).</span><span class="sxs-lookup"><span data-stu-id="fcf35-115">Another approach is to compute an adaptive per-vertex PRT simulation (with texture coordinates that will be used for the per-texel data) and then call [**ID3DXPRTEngine::ResampleBuffer**](id3dxprtengine--resamplebuffer.md) (using an output buffer created using [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) at the appropriate resolution).</span></span> <span data-ttu-id="fcf35-116">Cela fonctionne avec toutes les fonctionnalités de D3DX PRT dans le kit de développement logiciel (SDK) et peut souvent être bien plus efficace que le calcul direct d’une mémoire tampon de transfert par texture.</span><span class="sxs-lookup"><span data-stu-id="fcf35-116">This works with all D3DX PRT functionality in the SDK and can often be much more efficient than directly computing a per-texel transfer buffer.</span></span>

## <a name="runtime-calculations"></a><span data-ttu-id="fcf35-117">Calculs du Runtime</span><span class="sxs-lookup"><span data-stu-id="fcf35-117">Runtime Calculations</span></span>

<span data-ttu-id="fcf35-118">Si un seul cluster est utilisé, les résultats peuvent être filtrés et MIP-mappé comme n’importe quelle autre texture et le nuanceur de pixels est identique au code du nuanceur de sommets fourni avec PRTDemo.</span><span class="sxs-lookup"><span data-stu-id="fcf35-118">If a single cluster is used the results can be filtered and mip-mapped like any other texture and the pixel shader is identical to the vertex shader code that ships with PRTDemo.</span></span>

<span data-ttu-id="fcf35-119">Si la compression génère plusieurs clusters, vous ne pouvez pas filtrer ou démipmapr les données, car les index de clustering ne sont pas continus.</span><span class="sxs-lookup"><span data-stu-id="fcf35-119">If compression generates multiple clusters, you cannot filter or mipmap the data because clustering indexes are not continuous.</span></span> <span data-ttu-id="fcf35-120">Voici quelques alternatives pour la gestion des données à plusieurs clusters :</span><span class="sxs-lookup"><span data-stu-id="fcf35-120">Here are some alternatives for handling multi-clustered data:</span></span>

-   <span data-ttu-id="fcf35-121">Procédez à la totalité du filtrage dans le nuanceur de pixels.</span><span class="sxs-lookup"><span data-stu-id="fcf35-121">Do all of the filtering yourself in the pixel shader.</span></span> <span data-ttu-id="fcf35-122">Malheureusement, cela n’est généralement pas pratique pour des raisons de performances.</span><span class="sxs-lookup"><span data-stu-id="fcf35-122">Unfortunately, this is generally impractical for performance reasons.</span></span>
-   <span data-ttu-id="fcf35-123">Si les textures sont des textures non mappées à faible résolution (IE : cartes de lumière), il est probablement plus efficace de calculer l’éclairage directement dans l’espace de texture, où aucun filtrage n’est effectué et de restituer l’objet avec une texture ombrée.</span><span class="sxs-lookup"><span data-stu-id="fcf35-123">If the textures are low resolution non mip-mapped textures (ie: light maps), it is most likely more efficient to just compute the lighting directly in texture space - where no filtering will occur, and render the object with a shaded texture.</span></span> <span data-ttu-id="fcf35-124">Il s’agit essentiellement d’une carte d’éclairage dynamique créée entièrement sur le GPU.</span><span class="sxs-lookup"><span data-stu-id="fcf35-124">This is essentially a dynamic light map that is created entirely on the GPU.</span></span>
-   <span data-ttu-id="fcf35-125">Si un Atlas de textures est utilisé (voir [utilisation de UVAtlas (Direct3D 9)](using-uvatlas.md)), vous pouvez mettre manuellement en cluster la scène en faisant en sorte que tous les vecteurs de transfert d’un composant connecté dans l’espace de texture soient dans le même cluster.</span><span class="sxs-lookup"><span data-stu-id="fcf35-125">If a texture atlas is used (see [Using UVAtlas (Direct3D 9)](using-uvatlas.md)), you could manually cluster the scene by having all transfer vectors in a connected component in texture space be in the same cluster.</span></span> <span data-ttu-id="fcf35-126">De cette façon, vous pouvez filtrer la texture, car tous les texels accédés sont dans le même cluster par construction.</span><span class="sxs-lookup"><span data-stu-id="fcf35-126">This way you can filter the texture because all texels accessed would be in the same cluster by construction.</span></span> <span data-ttu-id="fcf35-127">L’ID de cluster d’une face donnée peut être propagé à partir du nuanceur de sommets.</span><span class="sxs-lookup"><span data-stu-id="fcf35-127">The cluster ID for a given face could be propagated from the vertex shader.</span></span>

<span data-ttu-id="fcf35-128">Les nuanceurs de pixels ont beaucoup moins de registres constants qui ne peuvent pas être indexés, le nuanceur de pixels est donc légèrement différent du nuanceur de sommets.</span><span class="sxs-lookup"><span data-stu-id="fcf35-128">Pixel shaders have much fewer constant registers that cannot be indexed, so the pixel shader is somewhat different than the vertex shader.</span></span> <span data-ttu-id="fcf35-129">Le stockage du travail par cluster dans une texture dynamique à faible résolution et l’utilisation de charges de texture est le moyen le plus efficace pour le rendu lors de l’utilisation de plusieurs clusters.</span><span class="sxs-lookup"><span data-stu-id="fcf35-129">Storing the per-cluster work in a low resolution dynamic texture and using texture loads would be the most efficient way to render when using multiple clusters.</span></span>

## <a name="related-topics"></a><span data-ttu-id="fcf35-130">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="fcf35-130">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="fcf35-131">Transfert de luminance précalculé</span><span class="sxs-lookup"><span data-stu-id="fcf35-131">Precomputed Radiance Transfer</span></span>](precomputed-radiance-transfer.md)
</dt> <dt>

<span data-ttu-id="fcf35-132">[PRT, exemple de démonstration](https://msdn.microsoft.com/library/Ee418763(v=VS.85).aspx)</span><span class="sxs-lookup"><span data-stu-id="fcf35-132">[PRT Demo Sample](https://msdn.microsoft.com/library/Ee418763(v=VS.85).aspx)</span></span>
</dt> <dt>

<span data-ttu-id="fcf35-133">[Simulateur PRT (prtcmdline.exe)](https://msdn.microsoft.com/library/Ee418766(v=VS.85).aspx)</span><span class="sxs-lookup"><span data-stu-id="fcf35-133">[PRT Simulator (prtcmdline.exe)](https://msdn.microsoft.com/library/Ee418766(v=VS.85).aspx)</span></span>
</dt> </dl>

 

 



