---
description: Un pool de threads est une collection de threads de travail qui exécutent efficacement des rappels asynchrones pour le compte de l’application.
ms.assetid: abe0798a-0b60-4bdb-a61e-45393f1e958d
title: Pools de threads
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 690aa3eb6fd3ce7a99d71e0f57118529ef79113f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106522036"
---
# <a name="thread-pools"></a><span data-ttu-id="e0e53-103">Pools de threads</span><span class="sxs-lookup"><span data-stu-id="e0e53-103">Thread Pools</span></span>

<span data-ttu-id="e0e53-104">Un *pool de threads* est une collection de threads de travail qui exécutent efficacement des rappels asynchrones pour le compte de l’application.</span><span class="sxs-lookup"><span data-stu-id="e0e53-104">A *thread pool* is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application.</span></span> <span data-ttu-id="e0e53-105">Le pool de threads est principalement utilisé pour réduire le nombre de threads d’application et assurer la gestion des threads de travail.</span><span class="sxs-lookup"><span data-stu-id="e0e53-105">The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.</span></span> <span data-ttu-id="e0e53-106">Les applications peuvent effectuer la mise en file d’attente des éléments de travail, associer un travail à des handles pouvant être programmés, effectuer la file d’attente automatiquement en fonction d’un minuteur et établir une liaison avec</span><span class="sxs-lookup"><span data-stu-id="e0e53-106">Applications can queue work items, associate work with waitable handles, automatically queue based on a timer, and bind with I/O.</span></span>

## <a name="thread-pool-architecture"></a><span data-ttu-id="e0e53-107">Architecture du pool de threads</span><span class="sxs-lookup"><span data-stu-id="e0e53-107">Thread Pool Architecture</span></span>

<span data-ttu-id="e0e53-108">Les applications suivantes peuvent tirer parti de l’utilisation d’un pool de threads :</span><span class="sxs-lookup"><span data-stu-id="e0e53-108">The following applications can benefit from using a thread pool:</span></span>

-   <span data-ttu-id="e0e53-109">Une application hautement parallèle et pouvant distribuer un grand nombre de petits éléments de travail de façon asynchrone (par exemple, la recherche d’index distribuée ou les e/s réseau).</span><span class="sxs-lookup"><span data-stu-id="e0e53-109">An application that is highly parallel and can dispatch a large number of small work items asynchronously (such as distributed index search or network I/O).</span></span>
-   <span data-ttu-id="e0e53-110">Application qui crée et détruit un grand nombre de threads qui s’exécutent chacun pendant une brève période.</span><span class="sxs-lookup"><span data-stu-id="e0e53-110">An application that creates and destroys a large number of threads that each run for a short time.</span></span> <span data-ttu-id="e0e53-111">L’utilisation du pool de threads peut réduire la complexité de la gestion des threads et la surcharge impliquée dans la création et la destruction de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-111">Using the thread pool can reduce the complexity of thread management and the overhead involved in thread creation and destruction.</span></span>
-   <span data-ttu-id="e0e53-112">Application qui traite les éléments de travail indépendants en arrière-plan et en parallèle (tels que le chargement de plusieurs onglets).</span><span class="sxs-lookup"><span data-stu-id="e0e53-112">An application that processes independent work items in the background and in parallel (such as loading multiple tabs).</span></span>
-   <span data-ttu-id="e0e53-113">Application qui doit effectuer une attente exclusive sur les objets de noyau ou un bloc sur les événements entrants sur un objet.</span><span class="sxs-lookup"><span data-stu-id="e0e53-113">An application that must perform an exclusive wait on kernel objects or block on incoming events on an object.</span></span> <span data-ttu-id="e0e53-114">L’utilisation du pool de threads peut réduire la complexité de la gestion des threads et améliorer les performances en réduisant le nombre de changements de contexte.</span><span class="sxs-lookup"><span data-stu-id="e0e53-114">Using the thread pool can reduce the complexity of thread management and increase performance by reducing the number of context switches.</span></span>
-   <span data-ttu-id="e0e53-115">Application qui crée des threads d’attente personnalisés à attendre sur les événements.</span><span class="sxs-lookup"><span data-stu-id="e0e53-115">An application that creates custom waiter threads to wait on events.</span></span>

<span data-ttu-id="e0e53-116">Le pool de threads d’origine a été complètement remanié dans Windows Vista.</span><span class="sxs-lookup"><span data-stu-id="e0e53-116">The original thread pool has been completely rearchitected in Windows Vista.</span></span> <span data-ttu-id="e0e53-117">Le nouveau pool de threads est amélioré, car il fournit un seul type de thread de travail (prend en charge les e/s et non-e/s), n’utilise pas de thread de minuterie, fournit une file d’attente de minuteur unique et fournit un thread persistant dédié.</span><span class="sxs-lookup"><span data-stu-id="e0e53-117">The new thread pool is improved because it provides a single worker thread type (supports both I/O and non-I/O), does not use a timer thread, provides a single timer queue, and provides a dedicated persistent thread.</span></span> <span data-ttu-id="e0e53-118">Il fournit également des groupes de nettoyage, des performances supérieures, plusieurs pools par processus qui sont planifiés indépendamment et une nouvelle API de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-118">It also provides clean-up groups, higher performance, multiple pools per process that are scheduled independently, and a new thread pool API.</span></span>

<span data-ttu-id="e0e53-119">L’architecture du pool de threads se compose des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="e0e53-119">The thread pool architecture consists of the following:</span></span>

-   <span data-ttu-id="e0e53-120">Threads de travail qui exécutent les fonctions de rappel</span><span class="sxs-lookup"><span data-stu-id="e0e53-120">Worker threads that execute the callback functions</span></span>
-   <span data-ttu-id="e0e53-121">Threads d’attente qui attendent plusieurs handles d’attente</span><span class="sxs-lookup"><span data-stu-id="e0e53-121">Waiter threads that wait on multiple wait handles</span></span>
-   <span data-ttu-id="e0e53-122">Une file d’attente de travail</span><span class="sxs-lookup"><span data-stu-id="e0e53-122">A work queue</span></span>
-   <span data-ttu-id="e0e53-123">Pool de threads par défaut pour chaque processus</span><span class="sxs-lookup"><span data-stu-id="e0e53-123">A default thread pool for each process</span></span>
-   <span data-ttu-id="e0e53-124">Une fabrique de travail qui gère les threads de travail</span><span class="sxs-lookup"><span data-stu-id="e0e53-124">A worker factory that manages the worker threads</span></span>

## <a name="best-practices"></a><span data-ttu-id="e0e53-125">Bonnes pratiques</span><span class="sxs-lookup"><span data-stu-id="e0e53-125">Best Practices</span></span>

<span data-ttu-id="e0e53-126">La nouvelle [API de pool de threads](thread-pool-api.md) offre plus de souplesse et de contrôle que l' [API de pool de threads d’origine](thread-pooling.md).</span><span class="sxs-lookup"><span data-stu-id="e0e53-126">The new [thread pool API](thread-pool-api.md) provides more flexibility and control than the [original thread pool API](thread-pooling.md).</span></span> <span data-ttu-id="e0e53-127">Toutefois, il existe quelques différences subtiles mais importantes.</span><span class="sxs-lookup"><span data-stu-id="e0e53-127">However, there are a few subtle but important differences.</span></span> <span data-ttu-id="e0e53-128">Dans l’API d’origine, la réinitialisation de l’attente était automatique ; dans la nouvelle API, l’attente doit être explicitement réinitialisée à chaque fois.</span><span class="sxs-lookup"><span data-stu-id="e0e53-128">In the original API, the wait reset was automatic; in the new API, the wait must be explicitly reset each time.</span></span> <span data-ttu-id="e0e53-129">L’API d’origine gérait l’emprunt d’identité automatiquement, en transférant le contexte de sécurité du processus appelant au thread.</span><span class="sxs-lookup"><span data-stu-id="e0e53-129">The original API handled impersonation automatically, transferring the security context of the calling process to the thread.</span></span> <span data-ttu-id="e0e53-130">Avec la nouvelle API, l’application doit définir explicitement le contexte de sécurité.</span><span class="sxs-lookup"><span data-stu-id="e0e53-130">With the new API, the application must explicitly set the security context.</span></span>

<span data-ttu-id="e0e53-131">Voici les meilleures pratiques lors de l’utilisation d’un pool de threads :</span><span class="sxs-lookup"><span data-stu-id="e0e53-131">The following are best practices when using a thread pool:</span></span>

-   <span data-ttu-id="e0e53-132">Les threads d’un processus partagent le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-132">The threads of a process share the thread pool.</span></span> <span data-ttu-id="e0e53-133">Un seul thread de travail peut exécuter plusieurs fonctions de rappel, une à la fois.</span><span class="sxs-lookup"><span data-stu-id="e0e53-133">A single worker thread can execute multiple callback functions, one at a time.</span></span> <span data-ttu-id="e0e53-134">Ces threads de travail sont gérés par le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-134">These worker threads are managed by the thread pool.</span></span> <span data-ttu-id="e0e53-135">Par conséquent, ne terminez pas un thread du pool de threads en appelant [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) sur le thread ou en appelant [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) à partir d’une fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="e0e53-135">Therefore, do not terminate a thread from the thread pool by calling [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) on the thread or by calling [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) from a callback function.</span></span>
-   <span data-ttu-id="e0e53-136">Une requête d’e/s peut s’exécuter sur n’importe quel thread du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-136">An I/O request can run on any thread in the thread pool.</span></span> <span data-ttu-id="e0e53-137">L’annulation d’e/s sur un thread de pool de threads nécessite une synchronisation, car la fonction Cancel peut s’exécuter sur un thread différent de celui qui gère la requête d’e/s, ce qui peut entraîner l’annulation d’une opération inconnue.</span><span class="sxs-lookup"><span data-stu-id="e0e53-137">Canceling I/O on a thread pool thread requires synchronization because the cancel function might run on a different thread than the one that is handling the I/O request, which can result in cancellation of an unknown operation.</span></span> <span data-ttu-id="e0e53-138">Pour éviter cela, fournissez toujours la structure avec [**chevauchement**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) avec laquelle une demande d’e/s a été initialisée lors de l’appel de [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) pour les e/s asynchrones, ou utilisez votre propre synchronisation pour vous assurer qu’aucune autre e/s ne peut être démarrée sur le thread cible avant d’appeler la fonction [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) ou **CancelIoEx** .</span><span class="sxs-lookup"><span data-stu-id="e0e53-138">To avoid this, always provide the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure with which an I/O request was initiated when calling [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) for asynchronous I/O, or use your own synchronization to ensure that no other I/O can be started on the target thread before calling either the [**CancelSynchronousIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelsynchronousio) or **CancelIoEx** function.</span></span>
-   <span data-ttu-id="e0e53-139">Nettoyez toutes les ressources créées dans la fonction de rappel avant de retourner à partir de la fonction.</span><span class="sxs-lookup"><span data-stu-id="e0e53-139">Clean up all resources created in the callback function before returning from the function.</span></span> <span data-ttu-id="e0e53-140">Celles-ci incluent le protocole TLS, les contextes de sécurité, la priorité des threads et l’inscription COM.</span><span class="sxs-lookup"><span data-stu-id="e0e53-140">These include TLS, security contexts, thread priority, and COM registration.</span></span> <span data-ttu-id="e0e53-141">Les fonctions de rappel doivent également restaurer l’état du thread avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="e0e53-141">Callback functions must also restore the thread state before returning.</span></span>
-   <span data-ttu-id="e0e53-142">Maintenez les handles d’attente et leurs objets associés actifs jusqu’à ce que le pool de threads ait signalé qu’il s’est terminé avec le descripteur.</span><span class="sxs-lookup"><span data-stu-id="e0e53-142">Keep wait handles and their associated objects alive until the thread pool has signaled that it is finished with the handle.</span></span>
-   <span data-ttu-id="e0e53-143">Marquez tous les threads en attente d’opérations de longue durée (par exemple, les vidages d’e/s ou le nettoyage des ressources) afin que le pool de threads puisse allouer de nouveaux threads au lieu d’attendre celui-ci.</span><span class="sxs-lookup"><span data-stu-id="e0e53-143">Mark all threads that are waiting on lengthy operations (such as I/O flushes or resource cleanup) so that the thread pool can allocate new threads instead of waiting for this one.</span></span>
-   <span data-ttu-id="e0e53-144">Avant de décharger une DLL qui utilise le pool de threads, annulez tous les éléments de travail, les e/s, les opérations d’attente et les minuteurs, puis attendez la fin de l’exécution des rappels.</span><span class="sxs-lookup"><span data-stu-id="e0e53-144">Before unloading a DLL that uses the thread pool, cancel all work items, I/O, wait operations, and timers, and wait for executing callbacks to complete.</span></span>
-   <span data-ttu-id="e0e53-145">Évitez les interblocages en éliminant les dépendances entre les éléments de travail et entre les rappels, en vérifiant qu’un rappel n’attend pas son exécution et en préservant la priorité du thread.</span><span class="sxs-lookup"><span data-stu-id="e0e53-145">Avoid deadlocks by eliminating dependencies between work items and between callbacks, by ensuring a callback is not waiting for itself to complete, and by preserving the thread priority.</span></span>
-   <span data-ttu-id="e0e53-146">Ne pas mettre trop d’éléments en file d’attente trop rapidement dans un processus avec d’autres composants à l’aide du pool de threads par défaut.</span><span class="sxs-lookup"><span data-stu-id="e0e53-146">Do not queue too many items too quickly in a process with other components using the default thread pool.</span></span> <span data-ttu-id="e0e53-147">Il existe un pool de threads par défaut par processus, y compris Svchost.exe.</span><span class="sxs-lookup"><span data-stu-id="e0e53-147">There is one default thread pool per process, including Svchost.exe.</span></span> <span data-ttu-id="e0e53-148">Par défaut, chaque pool de threads a un maximum de 500 threads de travail.</span><span class="sxs-lookup"><span data-stu-id="e0e53-148">By default, each thread pool has a maximum of 500 worker threads.</span></span> <span data-ttu-id="e0e53-149">Le pool de threads tente de créer plus de threads de travail lorsque le nombre de threads de travail dans l’état prêt/en cours d’exécution doit être inférieur au nombre de processeurs.</span><span class="sxs-lookup"><span data-stu-id="e0e53-149">The thread pool attempts to create more worker threads when the number of worker threads in the ready/running state must be less than the number of processors.</span></span>
-   <span data-ttu-id="e0e53-150">Évitez le modèle COM à thread unique cloisonné, car il est incompatible avec le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-150">Avoid the COM single-threaded apartment model, as it is incompatible with the thread pool.</span></span> <span data-ttu-id="e0e53-151">STA crée l’état du thread qui peut affecter l’élément de travail suivant pour le thread.</span><span class="sxs-lookup"><span data-stu-id="e0e53-151">STA creates thread state which can affect the next work item for the thread.</span></span> <span data-ttu-id="e0e53-152">La valeur STA est généralement à durée de vie longue et a une affinité de thread, qui est l’inverse du pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-152">STA is generally long-lived and has thread affinity, which is the opposite of the thread pool.</span></span>
-   <span data-ttu-id="e0e53-153">Créez un pool de threads pour contrôler la priorité et l’isolation des threads, créer des caractéristiques personnalisées et éventuellement améliorer la réactivité.</span><span class="sxs-lookup"><span data-stu-id="e0e53-153">Create a new thread pool to control thread priority and isolation, create custom characteristics, and possibly improve responsiveness.</span></span> <span data-ttu-id="e0e53-154">Toutefois, les pools de threads supplémentaires nécessitent davantage de ressources système (threads, mémoire du noyau).</span><span class="sxs-lookup"><span data-stu-id="e0e53-154">However, additional thread pools require more system resources (threads, kernel memory).</span></span> <span data-ttu-id="e0e53-155">Un trop grand nombre de pools augmente le risque de contention de l’UC.</span><span class="sxs-lookup"><span data-stu-id="e0e53-155">Too many pools increases the potential for CPU contention.</span></span>
-   <span data-ttu-id="e0e53-156">Si possible, utilisez un objet d’attente au lieu d’un mécanisme APC pour signaler un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="e0e53-156">If possible, use a waitable object instead of an APC-based mechanism to signal a thread pool thread.</span></span> <span data-ttu-id="e0e53-157">Les APC ne fonctionnent pas aussi bien avec les threads de pool de threads que les autres mécanismes de signalisation car le système contrôle la durée de vie des threads de pool de threads. il est donc possible qu’un thread se termine avant la remise de la notification.</span><span class="sxs-lookup"><span data-stu-id="e0e53-157">APCs do not work as well with thread pool threads as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span>
-   <span data-ttu-id="e0e53-158">Utilisez l’extension du débogueur du pool de threads, ! TP.</span><span class="sxs-lookup"><span data-stu-id="e0e53-158">Use the thread pool debugger extension, !tp.</span></span> <span data-ttu-id="e0e53-159">L’utilisation de cette commande est la suivante :</span><span class="sxs-lookup"><span data-stu-id="e0e53-159">This command has the following usage:</span></span>

    -   <span data-ttu-id="e0e53-160">*indicateurs* d' *adresse* du pool</span><span class="sxs-lookup"><span data-stu-id="e0e53-160">pool *address* *flags*</span></span>
    -   <span data-ttu-id="e0e53-161">*indicateurs* d' *adresse* obj</span><span class="sxs-lookup"><span data-stu-id="e0e53-161">obj *address* *flags*</span></span>
    -   <span data-ttu-id="e0e53-162">*indicateurs* d' *adresse* timpossible</span><span class="sxs-lookup"><span data-stu-id="e0e53-162">tqueue *address* *flags*</span></span>
    -   <span data-ttu-id="e0e53-163">*adresse* d’attente</span><span class="sxs-lookup"><span data-stu-id="e0e53-163">waiter *address*</span></span>
    -   <span data-ttu-id="e0e53-164">*adresse* du Worker</span><span class="sxs-lookup"><span data-stu-id="e0e53-164">worker *address*</span></span>

    <span data-ttu-id="e0e53-165">Pour les pools, les Waiters et les Worker, si l’adresse est égale à zéro, la commande fait un dump de tous les objets.</span><span class="sxs-lookup"><span data-stu-id="e0e53-165">For pool, waiter, and worker, if the address is zero, the command dumps all objects.</span></span> <span data-ttu-id="e0e53-166">Pour l’attente et le Worker, l’omission de l’adresse vide le thread actuel.</span><span class="sxs-lookup"><span data-stu-id="e0e53-166">For waiter and worker, omitting the address dumps the current thread.</span></span> <span data-ttu-id="e0e53-167">Les indicateurs suivants sont définis : 0x1 (sortie sur une seule ligne), 0X2 (membres dump) et 0x4 (file d’attente de travail du pool de vidage).</span><span class="sxs-lookup"><span data-stu-id="e0e53-167">The following flags are defined: 0x1 (single-line output), 0x2 (dump members), and 0x4 (dump pool work queue).</span></span>

## <a name="related-topics"></a><span data-ttu-id="e0e53-168">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="e0e53-168">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e0e53-169">API du pool de threads</span><span class="sxs-lookup"><span data-stu-id="e0e53-169">Thread Pool API</span></span>](thread-pool-api.md)
</dt> <dt>

[<span data-ttu-id="e0e53-170">Utilisation des fonctions de pool de threads</span><span class="sxs-lookup"><span data-stu-id="e0e53-170">Using the Thread Pool Functions</span></span>](using-the-thread-pool-functions.md)
</dt> </dl>

 

 
