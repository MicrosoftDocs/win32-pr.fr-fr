---
description: La planification en mode utilisateur (UMS) est un mécanisme léger que les applications peuvent utiliser pour planifier leurs propres threads.
ms.assetid: f9dd92fe-6d7a-452c-893e-e6df1757e377
title: Planification de la User-Mode
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f3ceea3c4d4e40d73f48414d074bcb5b4f6e911d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106527523"
---
# <a name="user-mode-scheduling"></a><span data-ttu-id="95564-103">Planification de la User-Mode</span><span class="sxs-lookup"><span data-stu-id="95564-103">User-Mode Scheduling</span></span>

<span data-ttu-id="95564-104">La planification en mode utilisateur (UMS) est un mécanisme léger que les applications peuvent utiliser pour planifier leurs propres threads.</span><span class="sxs-lookup"><span data-stu-id="95564-104">User-mode scheduling (UMS) is a lightweight mechanism that applications can use to schedule their own threads.</span></span> <span data-ttu-id="95564-105">Une application peut basculer entre les threads UMS en mode utilisateur sans impliquer le [planificateur système](scheduling.md) et regagner le contrôle du processeur si un thread UMS se bloque dans le noyau.</span><span class="sxs-lookup"><span data-stu-id="95564-105">An application can switch between UMS threads in user mode without involving the [system scheduler](scheduling.md) and regain control of the processor if a UMS thread blocks in the kernel.</span></span> <span data-ttu-id="95564-106">Les threads UMS diffèrent des [fibres](fibers.md) en ce que chaque thread UMS a son propre contexte de thread au lieu de partager le contexte de thread d’un thread unique.</span><span class="sxs-lookup"><span data-stu-id="95564-106">UMS threads differ from [fibers](fibers.md) in that each UMS thread has its own thread context instead of sharing the thread context of a single thread.</span></span> <span data-ttu-id="95564-107">La possibilité de basculer entre les threads en mode utilisateur rend UMS plus efficace que les [pools de threads](thread-pools.md) pour la gestion d’un grand nombre d’éléments de travail à durée réduite qui nécessitent peu d’appels système.</span><span class="sxs-lookup"><span data-stu-id="95564-107">The ability to switch between threads in user mode makes UMS more efficient than [thread pools](thread-pools.md) for managing large numbers of short-duration work items that require few system calls.</span></span>

<span data-ttu-id="95564-108">UMS est recommandé pour les applications avec des exigences de performances élevées qui doivent exécuter efficacement un grand nombre de threads simultanément sur des systèmes multiprocesseurs ou multicœurs.</span><span class="sxs-lookup"><span data-stu-id="95564-108">UMS is recommended for applications with high performance requirements that need to efficiently run many threads concurrently on multiprocessor or multicore systems.</span></span> <span data-ttu-id="95564-109">Pour tirer parti de UMS, une application doit implémenter un composant de planificateur qui gère les threads UMS de l’application et détermine le moment où ils doivent s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="95564-109">To take advantage of UMS, an application must implement a scheduler component that manages the application's UMS threads and determines when they should run.</span></span> <span data-ttu-id="95564-110">Les développeurs doivent déterminer si leurs exigences en matière de performances d’application justifient le travail impliqué dans le développement d’un tel composant.</span><span class="sxs-lookup"><span data-stu-id="95564-110">Developers should consider whether their application performance requirements justify the work involved in developing such a component.</span></span> <span data-ttu-id="95564-111">Les applications avec des exigences de performances modérées peuvent être mieux servies en permettant au planificateur système de planifier leurs threads.</span><span class="sxs-lookup"><span data-stu-id="95564-111">Applications with moderate performance requirements might be better served by allowing the system scheduler to schedule their threads.</span></span>

<span data-ttu-id="95564-112">UMS est disponible pour les applications 64 bits qui s’exécutent sur les versions 64 bits de Windows 7 et Windows Server 2008 R2 ou version ultérieure 64 bits de Windows.</span><span class="sxs-lookup"><span data-stu-id="95564-112">UMS is available for 64-bit applications running on 64-bit versions of Windows 7 and Windows Server 2008 R2 or later 64-bit versions of Windows.</span></span> <span data-ttu-id="95564-113">Cette fonctionnalité n’est pas disponible sur les versions 32 bits de Windows.</span><span class="sxs-lookup"><span data-stu-id="95564-113">This feature is not available on 32-bit versions of Windows.</span></span>

<span data-ttu-id="95564-114">Pour plus d’informations, consultez les sections suivantes :</span><span class="sxs-lookup"><span data-stu-id="95564-114">For details, see the following sections:</span></span>

-   [<span data-ttu-id="95564-115">Planificateur UMS</span><span class="sxs-lookup"><span data-stu-id="95564-115">UMS Scheduler</span></span>](#ums-scheduler)
-   [<span data-ttu-id="95564-116">Thread UMS Scheduler</span><span class="sxs-lookup"><span data-stu-id="95564-116">UMS Scheduler Thread</span></span>](#ums-scheduler-thread)
-   [<span data-ttu-id="95564-117">Threads de travail UMS, contextes de thread et listes de saisie semi-automatique</span><span class="sxs-lookup"><span data-stu-id="95564-117">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>](#ums-worker-threads-thread-contexts-and-completion-lists)
-   [<span data-ttu-id="95564-118">Fonction de point d’entrée du planificateur UMS</span><span class="sxs-lookup"><span data-stu-id="95564-118">UMS Scheduler Entry Point Function</span></span>](#ums-scheduler-entry-point-function)
-   [<span data-ttu-id="95564-119">Exécution du thread UMS</span><span class="sxs-lookup"><span data-stu-id="95564-119">UMS Thread Execution</span></span>](#ums-thread-execution)
-   [<span data-ttu-id="95564-120">Meilleures pratiques pour UMS</span><span class="sxs-lookup"><span data-stu-id="95564-120">UMS Best Practices</span></span>](#ums-best-practices)

## <a name="ums-scheduler"></a><span data-ttu-id="95564-121">Planificateur UMS</span><span class="sxs-lookup"><span data-stu-id="95564-121">UMS Scheduler</span></span>

<span data-ttu-id="95564-122">Le planificateur UMS d’une application est responsable de la création, de la gestion et de la suppression des threads UMS et de la détermination du thread UMS à exécuter.</span><span class="sxs-lookup"><span data-stu-id="95564-122">An application's UMS scheduler is responsible for creating, managing, and deleting UMS threads and determining which UMS thread to run.</span></span> <span data-ttu-id="95564-123">Le planificateur d’une application effectue les tâches suivantes :</span><span class="sxs-lookup"><span data-stu-id="95564-123">An application's scheduler performs the following tasks:</span></span>

-   <span data-ttu-id="95564-124">Crée un thread UMS Scheduler pour chaque processeur sur lequel l’application va exécuter des threads de travail UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-124">Creates one UMS scheduler thread for each processor on which the application will run UMS worker threads.</span></span>
-   <span data-ttu-id="95564-125">Crée des threads de travail UMS pour effectuer le travail de l’application.</span><span class="sxs-lookup"><span data-stu-id="95564-125">Creates UMS worker threads to perform the work of the application.</span></span>
-   <span data-ttu-id="95564-126">Gère sa propre file d’attente de threads de travail prête à être exécutée, et sélectionne les threads à exécuter en fonction des stratégies de planification de l’application.</span><span class="sxs-lookup"><span data-stu-id="95564-126">Maintains its own ready-thread queue of worker threads that are ready to run, and selects threads to run based on the application's scheduling policies.</span></span>
-   <span data-ttu-id="95564-127">Crée et surveille une ou plusieurs listes de saisie semi-automatique dans lesquelles le système met en file d’attente les threads une fois le traitement terminé dans le noyau.</span><span class="sxs-lookup"><span data-stu-id="95564-127">Creates and monitors one or more completion lists where the system queues threads after they finish processing in the kernel.</span></span> <span data-ttu-id="95564-128">Celles-ci incluent les threads de travail nouvellement créés et les threads précédemment bloqués sur un appel système qui a été débloqué.</span><span class="sxs-lookup"><span data-stu-id="95564-128">These include newly created worker threads and threads previously blocked on a system call that become unblocked.</span></span>
-   <span data-ttu-id="95564-129">Fournit une fonction de point d’entrée du planificateur pour gérer les notifications du système.</span><span class="sxs-lookup"><span data-stu-id="95564-129">Provides a scheduler entry point function to handles notifications from the system.</span></span> <span data-ttu-id="95564-130">Le système appelle la fonction de point d’entrée lorsqu’un thread de planificateur est créé, lorsqu’un thread de travail se bloque sur un appel système ou lorsqu’un thread de travail produit explicitement le contrôle.</span><span class="sxs-lookup"><span data-stu-id="95564-130">The system calls the entry point function when a scheduler thread is created, when a worker thread blocks on a system call, or when a worker thread explicitly yields control.</span></span>
-   <span data-ttu-id="95564-131">Effectue des tâches de nettoyage pour les threads de travail dont l’exécution est terminée.</span><span class="sxs-lookup"><span data-stu-id="95564-131">Performs cleanup tasks for worker threads that have finished running.</span></span>
-   <span data-ttu-id="95564-132">Effectue un arrêt ordonné du planificateur lorsqu’il est demandé par l’application.</span><span class="sxs-lookup"><span data-stu-id="95564-132">Performs an orderly shutdown of the scheduler when requested by the application.</span></span>

## <a name="ums-scheduler-thread"></a><span data-ttu-id="95564-133">Thread UMS Scheduler</span><span class="sxs-lookup"><span data-stu-id="95564-133">UMS Scheduler Thread</span></span>

<span data-ttu-id="95564-134">Un thread UMS Scheduler est un thread ordinaire qui s’est converti en UMS en appelant la fonction [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) .</span><span class="sxs-lookup"><span data-stu-id="95564-134">A UMS scheduler thread is an ordinary thread that has converted itself to UMS by calling the [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) function.</span></span> <span data-ttu-id="95564-135">Le planificateur système détermine le moment où le thread du planificateur UMS s’exécute en fonction de sa priorité par rapport à d’autres threads prêts.</span><span class="sxs-lookup"><span data-stu-id="95564-135">The system scheduler determines when the UMS scheduler thread runs based on its priority relative to other ready threads.</span></span> <span data-ttu-id="95564-136">Le processeur sur lequel le thread du planificateur s’exécute est influencé par l’affinité du thread, comme pour les threads non UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-136">The processor on which the scheduler thread runs is influenced by the thread's affinity, same as for non-UMS threads.</span></span>

<span data-ttu-id="95564-137">L’appelant de [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) spécifie une liste de saisie semi-automatique et une fonction de point d’entrée [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) à associer au thread UMS Scheduler.</span><span class="sxs-lookup"><span data-stu-id="95564-137">The caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode) specifies a completion list and a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) entry point function to associate with the UMS scheduler thread.</span></span> <span data-ttu-id="95564-138">Le système appelle la fonction de point d’entrée spécifiée lorsqu’il a fini de convertir le thread appelant en UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-138">The system calls the specified entry point function when it is finished converting the calling thread to UMS.</span></span> <span data-ttu-id="95564-139">La fonction de point d’entrée du planificateur est chargée de déterminer l’action suivante appropriée pour le thread spécifié.</span><span class="sxs-lookup"><span data-stu-id="95564-139">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="95564-140">Pour plus d’informations, consultez [fonction de point d’entrée du planificateur UMS](#ums-scheduler-entry-point-function) plus loin dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="95564-140">For more information, see [UMS Scheduler Entry Point Function](#ums-scheduler-entry-point-function) later in this topic.</span></span>

<span data-ttu-id="95564-141">Une application peut créer un thread UMS Scheduler pour chaque processeur qui sera utilisé pour exécuter des threads UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-141">An application might create one UMS scheduler thread for each processor that will be used to run UMS threads.</span></span> <span data-ttu-id="95564-142">L’application peut également définir l’affinité de chaque thread UMS Scheduler pour un processeur logique spécifique, ce qui a pour effet d’exclure les threads non liés de s’exécuter sur ce processeur, ce qui les réserve efficacement pour ce thread Scheduler.</span><span class="sxs-lookup"><span data-stu-id="95564-142">The application might also set the affinity of each UMS scheduler thread for a specific logical processor, which tends to exclude unrelated threads from running on that processor, effectively reserving it for that scheduler thread.</span></span> <span data-ttu-id="95564-143">N’oubliez pas que la définition de l’affinité des threads de cette manière peut affecter les performances globales du système en privant les autres processus qui peuvent s’exécuter sur le système.</span><span class="sxs-lookup"><span data-stu-id="95564-143">Be aware that setting thread affinity in this way can affect overall system performance by starving other processes that may be running on the system.</span></span> <span data-ttu-id="95564-144">Pour plus d’informations sur l’affinité de thread, consultez [plusieurs processeurs](multiple-processors.md).</span><span class="sxs-lookup"><span data-stu-id="95564-144">For more information about thread affinity, see [Multiple Processors](multiple-processors.md).</span></span>

## <a name="ums-worker-threads-thread-contexts-and-completion-lists"></a><span data-ttu-id="95564-145">Threads de travail UMS, contextes de thread et listes de saisie semi-automatique</span><span class="sxs-lookup"><span data-stu-id="95564-145">UMS Worker Threads, Thread Contexts, and Completion Lists</span></span>

<span data-ttu-id="95564-146">Un thread de travail UMS est créé en appelant [**CreateRemoteThreadEx**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) avec l' \_ attribut de thread UMS de l’attribut de thread proc et en \_ \_ \_ spécifiant un contexte de thread UMS et une liste de saisie semi-automatique.</span><span class="sxs-lookup"><span data-stu-id="95564-146">A UMS worker thread is created by calling [**CreateRemoteThreadEx**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) with the PROC\_THREAD\_ATTRIBUTE\_UMS\_THREAD attribute and specifying a UMS thread context and a completion list.</span></span>

<span data-ttu-id="95564-147">Un contexte de thread UMS représente l’état de thread UMS d’un thread de travail et est utilisé pour identifier le thread de travail dans les appels de fonction UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-147">A UMS thread context represents the UMS thread state of a worker thread and is used to identify the worker thread in UMS function calls.</span></span> <span data-ttu-id="95564-148">Elle est créée en appelant [**CreateUmsThreadContext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext).</span><span class="sxs-lookup"><span data-stu-id="95564-148">It is created by calling [**CreateUmsThreadContext**](/windows/desktop/api/WinBase/nf-winbase-createumsthreadcontext).</span></span>

<span data-ttu-id="95564-149">Une liste de saisie semi-automatique est créée en appelant la fonction [**CreateUmsCompletionList**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) .</span><span class="sxs-lookup"><span data-stu-id="95564-149">A completion list is created by calling the [**CreateUmsCompletionList**](/windows/desktop/api/WinBase/nf-winbase-createumscompletionlist) function.</span></span> <span data-ttu-id="95564-150">Une liste de saisie semi-automatique reçoit les threads de travail UMS dont l’exécution est terminée dans le noyau et qui sont prêts à être exécutés en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="95564-150">A completion list receives UMS worker threads that have completed execution in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="95564-151">Seul le système peut mettre les threads de travail en file d’attente dans une liste de saisie semi-automatique.</span><span class="sxs-lookup"><span data-stu-id="95564-151">Only the system can queue worker threads to a completion list.</span></span> <span data-ttu-id="95564-152">Les nouveaux threads de travail UMS sont automatiquement mis en file d’attente dans la liste de saisie semi-automatique spécifiée lors de la création des threads.</span><span class="sxs-lookup"><span data-stu-id="95564-152">New UMS worker threads are automatically queued to the completion list specified when the threads were created.</span></span> <span data-ttu-id="95564-153">Les threads de travail bloqués précédemment sont également mis en file d’attente dans la liste de saisie semi-automatique lorsqu’ils ne sont plus bloqués.</span><span class="sxs-lookup"><span data-stu-id="95564-153">Previously blocked worker threads are also queued to the completion list when they are no longer blocked.</span></span>

<span data-ttu-id="95564-154">Chaque thread UMS Scheduler est associé à une seule liste de saisie semi-automatique.</span><span class="sxs-lookup"><span data-stu-id="95564-154">Each UMS scheduler thread is associated with a single completion list.</span></span> <span data-ttu-id="95564-155">Toutefois, la même liste de saisie semi-automatique peut être associée à un nombre quelconque de threads de planification UMS, et un thread de planificateur peut récupérer des contextes UMS à partir d’une liste de saisie semi-automatique pour laquelle il a un pointeur.</span><span class="sxs-lookup"><span data-stu-id="95564-155">However, the same completion list can be associated with any number of UMS scheduler threads, and a scheduler thread can retrieve UMS contexts from any completion list for which it has a pointer.</span></span>

<span data-ttu-id="95564-156">Chaque liste de saisie semi-automatique est associée à un événement qui est signalé par le système lorsqu’il met en file d’attente un ou plusieurs threads de travail dans une liste vide.</span><span class="sxs-lookup"><span data-stu-id="95564-156">Each completion list has an associated event that is signaled by the system when it queues one or more worker threads to an empty list.</span></span> <span data-ttu-id="95564-157">La fonction [**GetUmsCompletionListEvent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent) récupère un handle pour l’événement pour une liste de saisie semi-automatique spécifiée.</span><span class="sxs-lookup"><span data-stu-id="95564-157">The [**GetUmsCompletionListEvent**](/windows/desktop/api/WinBase/nf-winbase-getumscompletionlistevent) function retrieves a handle to the event for a specified completion list.</span></span> <span data-ttu-id="95564-158">Une application peut attendre plusieurs événements de liste de saisie semi-automatique et d’autres événements qui ont un sens pour l’application.</span><span class="sxs-lookup"><span data-stu-id="95564-158">An application can wait on more than one completion list event along with other events that make sense for the application.</span></span>

## <a name="ums-scheduler-entry-point-function"></a><span data-ttu-id="95564-159">Fonction de point d’entrée du planificateur UMS</span><span class="sxs-lookup"><span data-stu-id="95564-159">UMS Scheduler Entry Point Function</span></span>

<span data-ttu-id="95564-160">La fonction de point d’entrée du planificateur d’une application est implémentée en tant que fonction [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) .</span><span class="sxs-lookup"><span data-stu-id="95564-160">An application's scheduler entry point function is implemented as a [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function.</span></span> <span data-ttu-id="95564-161">Le système appelle la fonction de point d’entrée du planificateur de l’application aux moments suivants :</span><span class="sxs-lookup"><span data-stu-id="95564-161">The system calls the application's scheduler entry point function at the following times:</span></span>

-   <span data-ttu-id="95564-162">Lorsqu’un thread non UMS est converti en thread UMS Scheduler en appelant [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span><span class="sxs-lookup"><span data-stu-id="95564-162">When a non-UMS thread is converted to a UMS scheduler thread by calling [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span>
-   <span data-ttu-id="95564-163">Quand un thread de travail UMS appelle [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span><span class="sxs-lookup"><span data-stu-id="95564-163">When a UMS worker thread calls [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span>
-   <span data-ttu-id="95564-164">Quand un thread de travail UMS se bloque sur un service système tel qu’un appel système ou une erreur de page.</span><span class="sxs-lookup"><span data-stu-id="95564-164">When a UMS worker thread blocks on a system service such as a system call or a page fault.</span></span>

<span data-ttu-id="95564-165">Le paramètre *reason* de la fonction [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) spécifie la raison pour laquelle la fonction de point d’entrée a été appelée.</span><span class="sxs-lookup"><span data-stu-id="95564-165">The *Reason* parameter of the [*UmsSchedulerProc*](/windows/desktop/api/WinNT/nc-winnt-rtl_ums_scheduler_entry_point) function specifies the reason that the entry point function was called.</span></span> <span data-ttu-id="95564-166">Si la fonction de point d’entrée a été appelée en raison de la création d’un nouveau thread UMS Scheduler, le paramètre *SchedulerParam* contient les données spécifiées par l’appelant de [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span><span class="sxs-lookup"><span data-stu-id="95564-166">If the entry point function was called because a new UMS scheduler thread was created, the *SchedulerParam* parameter contains data specified by the caller of [**EnterUmsSchedulingMode**](/windows/desktop/api/WinBase/nf-winbase-enterumsschedulingmode).</span></span> <span data-ttu-id="95564-167">Si la fonction de point d’entrée a été appelée parce qu’un thread de travail UMS a été généré, le paramètre *SchedulerParam* contient les données spécifiées par l’appelant de [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span><span class="sxs-lookup"><span data-stu-id="95564-167">If the entry point function was called because a UMS worker thread yielded, the *SchedulerParam* parameter contains data specified by the caller of [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield).</span></span> <span data-ttu-id="95564-168">Si la fonction de point d’entrée a été appelée parce qu’un thread de travail UMS a été bloqué dans le noyau, le paramètre *SchedulerParam* a la valeur null.</span><span class="sxs-lookup"><span data-stu-id="95564-168">If the entry point function was called because a UMS worker thread blocked in the kernel, the *SchedulerParam* parameter is NULL.</span></span>

<span data-ttu-id="95564-169">La fonction de point d’entrée du planificateur est chargée de déterminer l’action suivante appropriée pour le thread spécifié.</span><span class="sxs-lookup"><span data-stu-id="95564-169">The scheduler entry point function is responsible for determining the appropriate next action for the specified thread.</span></span> <span data-ttu-id="95564-170">Par exemple, si un thread de travail est bloqué, la fonction de point d’entrée du planificateur peut exécuter le prochain thread de travail UMS prêt disponible.</span><span class="sxs-lookup"><span data-stu-id="95564-170">For example, if a worker thread is blocked, the scheduler entry point function might run the next available ready UMS worker thread.</span></span>

<span data-ttu-id="95564-171">Lorsque la fonction de point d’entrée du planificateur est appelée, le planificateur de l’application doit tenter de récupérer tous les éléments de sa liste de saisie semi-automatique associée en appelant la fonction [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) .</span><span class="sxs-lookup"><span data-stu-id="95564-171">When the scheduler entry point function is called, the application's scheduler should attempt to retrieve all of the items in its associated completion list by calling the [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) function.</span></span> <span data-ttu-id="95564-172">Cette fonction récupère une liste de contextes de thread UMS dont le traitement est terminé dans le noyau et qui sont prêts à être exécutés en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="95564-172">This function retrieves a list of UMS thread contexts that have finished processing in the kernel and are ready to run in user mode.</span></span> <span data-ttu-id="95564-173">Le planificateur de l’application ne doit pas exécuter de threads UMS directement à partir de cette liste, car cela peut provoquer un comportement imprévisible dans l’application.</span><span class="sxs-lookup"><span data-stu-id="95564-173">The application's scheduler should not run UMS threads directly from this list because this can cause unpredictable behavior in the application.</span></span> <span data-ttu-id="95564-174">Au lieu de cela, le planificateur doit récupérer tous les contextes de thread UMS en appelant la fonction [**GetNextUmsListItem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) une fois pour chaque contexte, insérer les contextes de thread UMS dans la file d’attente de threads prête du planificateur, puis exécuter uniquement les threads UMS à partir de la file d’attente de threads prête.</span><span class="sxs-lookup"><span data-stu-id="95564-174">Instead, the scheduler should retrieve all UMS thread contexts by calling the [**GetNextUmsListItem**](/windows/desktop/api/WinBase/nf-winbase-getnextumslistitem) function once for each context, insert the UMS thread contexts in the scheduler’s ready thread queue, and only then run UMS threads from the ready thread queue.</span></span>

<span data-ttu-id="95564-175">Si le planificateur n’a pas besoin d’attendre plusieurs événements, il doit appeler [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) avec un paramètre de délai d’expiration différent de zéro afin que la fonction attende l’événement de liste de saisie semi-automatique avant de retourner.</span><span class="sxs-lookup"><span data-stu-id="95564-175">If the scheduler does not need to wait on multiple events, it should call [**DequeueUmsCompletionListItems**](/windows/desktop/api/WinBase/nf-winbase-dequeueumscompletionlistitems) with a nonzero timeout parameter so the function waits on the completion list event before returning.</span></span> <span data-ttu-id="95564-176">Si le planificateur doit attendre plusieurs événements de liste de saisie semi-automatique, il doit appeler **DequeueUmsCompletionListItems** avec un paramètre timeout égal à zéro pour que la fonction soit retournée immédiatement, même si la liste de saisie semi-automatique est vide.</span><span class="sxs-lookup"><span data-stu-id="95564-176">If the scheduler does need to wait on multiple completion list events, it should call **DequeueUmsCompletionListItems** with a timeout parameter of zero so the function returns immediately, even if the completion list is empty.</span></span> <span data-ttu-id="95564-177">Dans ce cas, le planificateur peut attendre explicitement les événements de la liste de saisie semi-automatique, par exemple, en utilisant [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span><span class="sxs-lookup"><span data-stu-id="95564-177">In this case, the scheduler can wait explicitly on completion list events, for example, by using [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).</span></span>

## <a name="ums-thread-execution"></a><span data-ttu-id="95564-178">Exécution du thread UMS</span><span class="sxs-lookup"><span data-stu-id="95564-178">UMS Thread Execution</span></span>

<span data-ttu-id="95564-179">Un thread de travail UMS nouvellement créé est mis en file d’attente dans la liste de saisie semi-automatique spécifiée et ne commence pas à s’exécuter jusqu’à ce que le planificateur UMS de l’application le sélectionne pour s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="95564-179">A newly created UMS worker thread is queued to the specified completion list and does not begin running until the application's UMS scheduler selects it to run.</span></span> <span data-ttu-id="95564-180">Cela diffère des threads non UMS, que le planificateur système planifie automatiquement d’exécuter à moins que l’appelant ne crée explicitement le thread suspendu.</span><span class="sxs-lookup"><span data-stu-id="95564-180">This differs from non-UMS threads, which the system scheduler automatically schedules to run unless the caller explicitly creates the thread suspended.</span></span>

<span data-ttu-id="95564-181">Le planificateur exécute un thread de travail en appelant [**ExecuteUmsThread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) avec le contexte UMS du thread de travail.</span><span class="sxs-lookup"><span data-stu-id="95564-181">The scheduler runs a worker thread by calling [**ExecuteUmsThread**](/windows/desktop/api/WinBase/nf-winbase-executeumsthread) with the worker thread's UMS context.</span></span> <span data-ttu-id="95564-182">Un thread de travail UMS s’exécute jusqu’à ce qu’il génère en appelant la fonction [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) , des blocs ou des terminaisons.</span><span class="sxs-lookup"><span data-stu-id="95564-182">A UMS worker thread runs until it yields by calling the [**UmsThreadYield**](/windows/desktop/api/WinBase/nf-winbase-umsthreadyield) function, blocks, or terminates.</span></span>

## <a name="ums-best-practices"></a><span data-ttu-id="95564-183">Meilleures pratiques pour UMS</span><span class="sxs-lookup"><span data-stu-id="95564-183">UMS Best Practices</span></span>

<span data-ttu-id="95564-184">Les applications qui implémentent UMS doivent suivre les meilleures pratiques suivantes :</span><span class="sxs-lookup"><span data-stu-id="95564-184">Applications that implement UMS should follow these best practices:</span></span>

-   <span data-ttu-id="95564-185">Les structures sous-jacentes pour les contextes de thread UMS sont gérées par le système et ne doivent pas être modifiées directement.</span><span class="sxs-lookup"><span data-stu-id="95564-185">The underlying structures for UMS thread contexts are managed by the system and should not be modified directly.</span></span> <span data-ttu-id="95564-186">Utilisez plutôt [**QueryUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) et [**SetUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) pour récupérer et définir des informations sur un thread de travail UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-186">Instead, use [**QueryUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-queryumsthreadinformation) and [**SetUmsThreadInformation**](/windows/desktop/api/WinBase/nf-winbase-setumsthreadinformation) to retrieve and set information about a UMS worker thread.</span></span>
-   <span data-ttu-id="95564-187">Pour éviter les blocages, le thread UMS Scheduler ne doit pas partager les verrous avec les threads de travail UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-187">To help prevent deadlocks, the UMS scheduler thread should not share locks with UMS worker threads.</span></span> <span data-ttu-id="95564-188">Cela comprend les verrous créés par l’application et les verrous système acquis indirectement par des opérations telles que l’allocation à partir du tas ou le chargement de dll.</span><span class="sxs-lookup"><span data-stu-id="95564-188">This includes both application-created locks and system locks that are acquired indirectly by operations such as allocating from the heap or loading DLLs.</span></span> <span data-ttu-id="95564-189">Par exemple, supposons que le planificateur exécute un thread de travail UMS qui charge une DLL.</span><span class="sxs-lookup"><span data-stu-id="95564-189">For example, suppose the scheduler runs a UMS worker thread that loads a DLL.</span></span> <span data-ttu-id="95564-190">Le thread de travail acquiert le verrou et les blocs du chargeur.</span><span class="sxs-lookup"><span data-stu-id="95564-190">The worker thread acquires the loader lock and blocks.</span></span> <span data-ttu-id="95564-191">Le système appelle la fonction de point d’entrée du planificateur, qui charge ensuite une DLL.</span><span class="sxs-lookup"><span data-stu-id="95564-191">The system calls the scheduler entry point function, which then loads a DLL.</span></span> <span data-ttu-id="95564-192">Cela provoque un interblocage, car le verrou du chargeur est déjà maintenu et ne peut pas être libéré tant que le premier thread n’est pas débloqué.</span><span class="sxs-lookup"><span data-stu-id="95564-192">This causes a deadlock, because the loader lock is already held and cannot be released until the first thread unblocks.</span></span> <span data-ttu-id="95564-193">Pour éviter ce problème, déléguez le travail qui peut partager des verrous avec les threads de travail UMS avec un thread de travail UMS dédié ou un thread non UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-193">To help avoid this problem, delegate work that might share locks with UMS worker threads to a dedicated UMS worker thread or a non-UMS thread.</span></span>
-   <span data-ttu-id="95564-194">UMS est plus efficace lorsque la plupart des traitements s’effectuent en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="95564-194">UMS is most efficient when most processing is done in user mode.</span></span> <span data-ttu-id="95564-195">Dans la mesure du possible, évitez d’effectuer des appels système dans les threads de travail UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-195">Whenever possible, avoid making system calls in UMS worker threads.</span></span>
-   <span data-ttu-id="95564-196">Les threads de travail UMS ne doivent pas supposer que le planificateur système est en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="95564-196">UMS worker threads should not assume the system scheduler is being used.</span></span> <span data-ttu-id="95564-197">Cette hypothèse peut avoir des effets subtils ; par exemple, si un thread dans le code inconnu définit une priorité ou une affinité de thread, le planificateur UMS peut toujours le remplacer.</span><span class="sxs-lookup"><span data-stu-id="95564-197">This assumption can have subtle effects; for example, if a thread in the unknown code sets a thread priority or affinity, the UMS scheduler might still override it.</span></span> <span data-ttu-id="95564-198">Le code qui suppose que le planificateur système est utilisé peut ne pas se comporter comme prévu et peut s’arrêter lorsqu’il est appelé par un thread UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-198">Code that assumes the system scheduler is being used may not behave as expected and may break when called by a UMS thread.</span></span>
-   <span data-ttu-id="95564-199">Le système peut avoir besoin de verrouiller le contexte de thread d’un thread de travail UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-199">The system may need to lock the thread context of a UMS worker thread.</span></span> <span data-ttu-id="95564-200">Par exemple, un appel de procédure asynchrone en mode noyau (APC) peut modifier le contexte du thread UMS, de sorte que le contexte de thread doit être verrouillé.</span><span class="sxs-lookup"><span data-stu-id="95564-200">For example, a kernel-mode asynchronous procedure call (APC) might change the context of the UMS thread, so the thread context must be locked.</span></span> <span data-ttu-id="95564-201">Si le planificateur tente d’exécuter le contexte de thread UMS pendant qu’il est verrouillé, l’appel échoue.</span><span class="sxs-lookup"><span data-stu-id="95564-201">If the scheduler tries to execute the UMS thread context while it is locked, the call will fail.</span></span> <span data-ttu-id="95564-202">Ce comportement est lié à la conception et le planificateur doit être conçu pour réessayer d’accéder au contexte de thread UMS.</span><span class="sxs-lookup"><span data-stu-id="95564-202">This behavior is by design, and the scheduler should be designed to retry access to the UMS thread context.</span></span>

 

 
