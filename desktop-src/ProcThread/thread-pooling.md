---
description: Il existe de nombreuses applications qui créent des threads qui consacrent beaucoup de temps à l’état de veille en attendant qu’un événement se produise.
ms.assetid: a5e52080-35d4-47f5-9050-90889e3bf2f8
title: Regroupement des threads
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcf3565401dc57b077e333043861d42b683e810c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "103865049"
---
# <a name="thread-pooling"></a><span data-ttu-id="46730-103">Regroupement des threads</span><span class="sxs-lookup"><span data-stu-id="46730-103">Thread Pooling</span></span>

<span data-ttu-id="46730-104">Il existe de nombreuses applications qui créent des threads qui consacrent beaucoup de temps à l’état de veille en attendant qu’un événement se produise.</span><span class="sxs-lookup"><span data-stu-id="46730-104">There are many applications that create threads that spend a great deal of time in the sleeping state waiting for an event to occur.</span></span> <span data-ttu-id="46730-105">D’autres threads peuvent entrer dans un état de veille uniquement pour être mis à jour régulièrement pour demander des informations sur l’état des modifications ou des mises à jour.</span><span class="sxs-lookup"><span data-stu-id="46730-105">Other threads may enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="46730-106">Le *regroupement de threads* vous permet d’utiliser les threads plus efficacement en fournissant à votre application un pool de threads de travail qui sont gérés par le système.</span><span class="sxs-lookup"><span data-stu-id="46730-106">*Thread pooling* enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="46730-107">Au moins un thread surveille l’état de toutes les opérations d’attente en attente dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-107">At least one thread monitors the status of all wait operations queued to the thread pool.</span></span> <span data-ttu-id="46730-108">Quand une opération d’attente est terminée, un thread de travail du pool de threads exécute la fonction de rappel correspondante.</span><span class="sxs-lookup"><span data-stu-id="46730-108">When a wait operation has completed, a worker thread from the thread pool executes the corresponding callback function.</span></span>

<span data-ttu-id="46730-109">Cette rubrique décrit l’API du pool de threads d’origine.</span><span class="sxs-lookup"><span data-stu-id="46730-109">This topic describes the original thread pool API.</span></span> <span data-ttu-id="46730-110">L’API de pool de threads introduite dans Windows Vista est plus simple, plus fiable, offre de meilleures performances et offre davantage de flexibilité aux développeurs.</span><span class="sxs-lookup"><span data-stu-id="46730-110">The thread pool API introduced in Windows Vista is simpler, more reliable, has better performance, and provides more flexibility for developers.</span></span> <span data-ttu-id="46730-111">Pour plus d’informations sur l’API de pool de threads actuelle, consultez [pools de threads](thread-pools.md).</span><span class="sxs-lookup"><span data-stu-id="46730-111">For information on the current thread pool API, see [Thread Pools](thread-pools.md).</span></span>

<span data-ttu-id="46730-112">Vous pouvez également mettre en file d’attente des éléments de travail qui ne sont pas associés à une opération d’attente dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-112">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="46730-113">Pour demander qu’un élément de travail soit géré par un thread dans le pool de threads, appelez la fonction [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) .</span><span class="sxs-lookup"><span data-stu-id="46730-113">To request that a work item be handled by a thread in the thread pool, call the [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) function.</span></span> <span data-ttu-id="46730-114">Cette fonction accepte un paramètre de la fonction qui sera appelée par le thread sélectionné dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-114">This function takes a parameter to the function that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="46730-115">Il n’existe aucun moyen d’annuler un élément de travail après qu’il a été mis en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="46730-115">There is no way to cancel a work item after it has been queued.</span></span>

<span data-ttu-id="46730-116">Les [minuteries de file d’attente](../sync/timer-queues.md) et les [opérations d’attente inscrites](../sync/wait-functions.md) utilisent également le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-116">[Timer-queue timers](../sync/timer-queues.md) and [registered wait operations](../sync/wait-functions.md) also use the thread pool.</span></span> <span data-ttu-id="46730-117">Leurs fonctions de rappel sont mises en file d’attente dans le pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-117">Their callback functions are queued to the thread pool.</span></span> <span data-ttu-id="46730-118">Vous pouvez également utiliser la fonction [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) pour poster des opérations d’e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="46730-118">You can also use the [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback) function to post asynchronous I/O operations.</span></span> <span data-ttu-id="46730-119">À la fin de l’e/s, le rappel est exécuté par un thread de pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-119">On completion of the I/O , the callback is executed by a thread pool thread.</span></span>

<span data-ttu-id="46730-120">Le pool de threads est créé la première fois que vous appelez [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) ou [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), ou lorsqu’un minuteur de file d’attente de minuterie ou une opération d’attente inscrite met en file d’attente une fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="46730-120">The thread pool is created the first time you call [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) or [**BindIoCompletionCallback**](/windows/desktop/api/WinBase/nf-winbase-bindiocompletioncallback), or when a timer-queue timer or registered wait operation queues a callback function.</span></span> <span data-ttu-id="46730-121">Par défaut, le nombre de threads qui peuvent être créés dans le pool de threads est d’environ 500.</span><span class="sxs-lookup"><span data-stu-id="46730-121">By default, the number of threads that can be created in the thread pool is about 500.</span></span> <span data-ttu-id="46730-122">Chaque thread utilise la taille de pile par défaut et s’exécute à la priorité par défaut.</span><span class="sxs-lookup"><span data-stu-id="46730-122">Each thread uses the default stack size and runs at the default priority.</span></span>

<span data-ttu-id="46730-123">Il existe deux types de threads de travail dans le pool de threads : e/s et non-e/s.</span><span class="sxs-lookup"><span data-stu-id="46730-123">There are two types of worker threads in the thread pool: I/O and non-I/O.</span></span> <span data-ttu-id="46730-124">Un *thread de travail d’e/s* est un thread qui attend un état d’attente averti.</span><span class="sxs-lookup"><span data-stu-id="46730-124">An *I/O worker thread* is a thread that waits in an alertable wait state.</span></span> <span data-ttu-id="46730-125">Les éléments de travail sont mis en file d’attente pour les threads de travail d’e/s en tant qu’appels de procédure asynchrone (APC).</span><span class="sxs-lookup"><span data-stu-id="46730-125">Work items are queued to I/O worker threads as asynchronous procedure calls (APC).</span></span> <span data-ttu-id="46730-126">Vous devez mettre un élément de travail en file d’attente sur un thread de travail d’e/s s’il doit être exécuté dans un thread qui attend un état d’alerte.</span><span class="sxs-lookup"><span data-stu-id="46730-126">You should queue a work item to an I/O worker thread if it should be executed in a thread that waits in an alertable state.</span></span>

<span data-ttu-id="46730-127">Un *thread de travail non-e/s* attend sur les ports de terminaison d’e/s.</span><span class="sxs-lookup"><span data-stu-id="46730-127">A *non-I/O worker thread* waits on I/O completion ports.</span></span> <span data-ttu-id="46730-128">L’utilisation de threads de travail non-e/s est plus efficace que l’utilisation de threads de travail d’e/s.</span><span class="sxs-lookup"><span data-stu-id="46730-128">Using non-I/O worker threads is more efficient than using I/O worker threads.</span></span> <span data-ttu-id="46730-129">Par conséquent, vous devez utiliser des threads de travail non-e/s chaque fois que cela est possible.</span><span class="sxs-lookup"><span data-stu-id="46730-129">Therefore, you should use non-I/O worker threads whenever possible.</span></span> <span data-ttu-id="46730-130">Les threads de travail d’e/s et non-e/s ne se ferment pas s’il existe des demandes d’e/s asynchrones en attente.</span><span class="sxs-lookup"><span data-stu-id="46730-130">Both I/O and non-I/O worker threads do not exit if there are pending asynchronous I/O requests.</span></span> <span data-ttu-id="46730-131">Les deux types de threads peuvent être utilisés par les éléments de travail qui initient des demandes d’achèvement d’e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="46730-131">Both types of threads can be used by work items that initiate asynchronous I/O completion requests.</span></span> <span data-ttu-id="46730-132">Toutefois, évitez de publier des demandes de fin d’exécution d’e/s asynchrones dans des threads de travail non-e/s si leur exécution peut prendre beaucoup de temps.</span><span class="sxs-lookup"><span data-stu-id="46730-132">However, avoid posting asynchronous I/O completion requests in non-I/O worker threads if they could take a long time to complete.</span></span>

<span data-ttu-id="46730-133">Pour utiliser le regroupement de threads, les éléments de travail et toutes les fonctions qu’ils appellent doivent être sécurisés par pool de threads.</span><span class="sxs-lookup"><span data-stu-id="46730-133">To use thread pooling, the work items and all the functions they call must be thread-pool safe.</span></span> <span data-ttu-id="46730-134">Une fonction sécurisée ne suppose pas que le thread qui l’exécute est un thread dédié ou persistant.</span><span class="sxs-lookup"><span data-stu-id="46730-134">A safe function does not assume that the thread executing it is a dedicated or persistent thread.</span></span> <span data-ttu-id="46730-135">En général, vous devez éviter d’utiliser le [stockage local des threads](thread-local-storage.md) ou d’effectuer un appel asynchrone qui requiert un thread persistant, tel que la fonction [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) .</span><span class="sxs-lookup"><span data-stu-id="46730-135">In general, you should avoid using [thread local storage](thread-local-storage.md) or making an asynchronous call that requires a persistent thread, such as the [**RegNotifyChangeKeyValue**](/windows/win32/api/winreg/nf-winreg-regnotifychangekeyvalue) function.</span></span> <span data-ttu-id="46730-136">Toutefois, ces fonctions peuvent être appelées sur un thread dédié (créé par l’application) ou mises en file d’attente sur un thread de travail persistant (à l’aide de [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) avec l' \_ option WT EXECUTEINPERSISTENTTHREAD).</span><span class="sxs-lookup"><span data-stu-id="46730-136">However, such functions can be called on a dedicated thread (created by the application) or queued to a persistent worker thread (using [**QueueUserWorkItem**](/windows/win32/api/threadpoollegacyapiset/nf-threadpoollegacyapiset-queueuserworkitem) with the WT\_EXECUTEINPERSISTENTTHREAD option).</span></span>

## <a name="related-topics"></a><span data-ttu-id="46730-137">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="46730-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="46730-138">E/s alertables</span><span class="sxs-lookup"><span data-stu-id="46730-138">Alertable I/O</span></span>](../fileio/alertable-i-o.md)
</dt> <dt>

[<span data-ttu-id="46730-139">Appels de procédure asynchrone</span><span class="sxs-lookup"><span data-stu-id="46730-139">Asynchronous Procedure Calls</span></span>](../sync/asynchronous-procedure-calls.md)
</dt> <dt>

[<span data-ttu-id="46730-140">Ports de terminaison d’e/s</span><span class="sxs-lookup"><span data-stu-id="46730-140">I/O Completion Ports</span></span>](../fileio/i-o-completion-ports.md)
</dt> <dt>

[<span data-ttu-id="46730-141">Pools de threads</span><span class="sxs-lookup"><span data-stu-id="46730-141">Thread Pools</span></span>](thread-pools.md)
</dt> </dl>

 

 
