---
title: fonction glDrawPixels (GL. h)
description: La fonction glDrawPixels écrit un bloc de pixels dans le trame.
ms.assetid: c4eda64f-a75e-4e6d-984d-af49414b94d8
keywords:
- glDrawPixels fonction OpenGL
topic_type:
- apiref
api_name:
- glDrawPixels
api_location:
- opengl32.dll
api_type:
- DllExport
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: e25adc8ad28791086020a37d3a30651e169bfd07
ms.sourcegitcommit: a1494c819bc5200050696e66057f1020f5b142cb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 12/12/2020
ms.locfileid: "104103200"
---
# <a name="gldrawpixels-function"></a><span data-ttu-id="5e98b-104">glDrawPixels fonction)</span><span class="sxs-lookup"><span data-stu-id="5e98b-104">glDrawPixels function</span></span>

<span data-ttu-id="5e98b-105">La fonction **glDrawPixels** écrit un bloc de pixels dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-105">The **glDrawPixels** function writes a block of pixels to the framebuffer.</span></span>

## <a name="syntax"></a><span data-ttu-id="5e98b-106">Syntaxe</span><span class="sxs-lookup"><span data-stu-id="5e98b-106">Syntax</span></span>


```C++
void WINAPI glDrawPixels(
         GLsizei width,
         GLsizei height,
         GLenum  format,
         GLenum  type,
   const GLvoid  *pixels
);
```



## <a name="parameters"></a><span data-ttu-id="5e98b-107">Paramètres</span><span class="sxs-lookup"><span data-stu-id="5e98b-107">Parameters</span></span>

<dl> <dt>

<span data-ttu-id="5e98b-108">*width*</span><span class="sxs-lookup"><span data-stu-id="5e98b-108">*width*</span></span> 
</dt> <dd>

<span data-ttu-id="5e98b-109">Dimension de largeur du rectangle de pixels qui sera écrite dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-109">The width dimension of the pixel rectangle that will be written into the framebuffer.</span></span>

</dd> <dt>

<span data-ttu-id="5e98b-110">*height*</span><span class="sxs-lookup"><span data-stu-id="5e98b-110">*height*</span></span> 
</dt> <dd>

<span data-ttu-id="5e98b-111">Dimension de hauteur du rectangle de pixels qui sera écrite dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-111">The height dimension of the pixel rectangle that will be written into the framebuffer.</span></span>

</dd> <dt>

<span data-ttu-id="5e98b-112">*format*</span><span class="sxs-lookup"><span data-stu-id="5e98b-112">*format*</span></span> 
</dt> <dd>

<span data-ttu-id="5e98b-113">Format des données de pixels.</span><span class="sxs-lookup"><span data-stu-id="5e98b-113">The format of the pixel data.</span></span> <span data-ttu-id="5e98b-114">Les constantes symboliques acceptées sont les suivantes.</span><span class="sxs-lookup"><span data-stu-id="5e98b-114">Acceptable symbolic constants are as follows.</span></span>



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><span data-ttu-id="5e98b-115">Valeur</span><span class="sxs-lookup"><span data-stu-id="5e98b-115">Value</span></span></th>
<th><span data-ttu-id="5e98b-116">Signification</span><span class="sxs-lookup"><span data-stu-id="5e98b-116">Meaning</span></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span id="GL_COLOR_INDEX"></span><span id="gl_color_index"></span><dl> <span data-ttu-id="5e98b-117"><dt><strong>GL_COLOR_INDEX</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-117"><dt><strong>GL_COLOR_INDEX</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-118">Chaque pixel est une valeur unique, un index de couleurs.</span><span class="sxs-lookup"><span data-stu-id="5e98b-118">Each pixel is a single value, a color index.</span></span> <br/>
<ol>
<li><span data-ttu-id="5e98b-119">La fonction <strong>glDrawPixels</strong> convertit chaque pixel en format à virgule fixe, avec un nombre non spécifié de bits à droite du point binaire, quel que soit le type de données de mémoire.</span><span class="sxs-lookup"><span data-stu-id="5e98b-119">The <strong>glDrawPixels</strong> function converts each pixel to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.</span></span> <span data-ttu-id="5e98b-120">Les valeurs à virgule flottante sont converties en valeurs à virgule fixe vraies.</span><span class="sxs-lookup"><span data-stu-id="5e98b-120">Floating-point values convert to true fixed-point values.</span></span> <span data-ttu-id="5e98b-121">La fonction <strong>glDrawPixels</strong> convertit les données entières signées et non signées avec tous les bits de fraction définis sur zéro.</span><span class="sxs-lookup"><span data-stu-id="5e98b-121">The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero.</span></span> <span data-ttu-id="5e98b-122">La fonction convertit les données bitmap en 0,0 ou 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-122">The function converts bitmap data to either 0.0 or 1.0.</span></span></li>
<li><span data-ttu-id="5e98b-123">La fonction <strong>glDrawPixels</strong> décale chaque index à virgule fixe laissé par GL_INDEX_SHIFT bits et l’ajoute à GL_INDEX_OFFSET.</span><span class="sxs-lookup"><span data-stu-id="5e98b-123">The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits and adds it to GL_INDEX_OFFSET.</span></span> <span data-ttu-id="5e98b-124">Si GL_INDEX_SHIFT est négatif, le décalage est à droite.</span><span class="sxs-lookup"><span data-stu-id="5e98b-124">If GL_INDEX_SHIFT is negative, the shift is to the right.</span></span> <span data-ttu-id="5e98b-125">Dans les deux cas, zéro bits remplit les emplacements de bits non spécifiés dans le résultat.</span><span class="sxs-lookup"><span data-stu-id="5e98b-125">In either case, zero bits fill otherwise unspecified bit locations in the result.</span></span></li>
<li><span data-ttu-id="5e98b-126">En mode RVBA, <strong>glDrawPixels</strong> convertit l’index résultant en un pixel RVBA à l’aide des tables GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B et GL_PIXEL_MAP_I_TO_A.</span><span class="sxs-lookup"><span data-stu-id="5e98b-126">When in RGBA mode, <strong>glDrawPixels</strong> converts the resulting index to an RGBA pixel using the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables.</span></span> <span data-ttu-id="5e98b-127">Dans le mode d’index des couleurs et GL_MAP_COLOR a la valeur true, l’index est remplacé par la valeur que <strong>glDrawPixels</strong> référence dans la table de recherche GL_PIXEL_MAP_I_TO_I.</span><span class="sxs-lookup"><span data-stu-id="5e98b-127">When in the color-index mode and GL_MAP_COLOR is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_I_TO_I.</span></span></li>
<li><span data-ttu-id="5e98b-128">Que le remplacement de la recherche de l’index soit effectué ou non, la partie entière de l’index est <strong>et</strong>Ed avec 2<sup>b</sup> - 1, où <em>b</em> est le nombre de bits dans une mémoire tampon d’index de couleurs.</span><span class="sxs-lookup"><span data-stu-id="5e98b-128">Whether the lookup replacement of the index is done or not, the integer part of the index is <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in a color-index buffer.</span></span></li>
<li><span data-ttu-id="5e98b-129">Les index résultants ou les couleurs RVBA sont ensuite convertis en fragments en attachant les coordonnées z-coordonnée <em>z</em>et de texture de la position raster actuelle à chaque pixel, puis en affectant les coordonnées de la fenêtre <em>x</em> et <em>y</em> au <em>n</em>ième fragment, de telle sorte que <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-129">The resulting indexes or RGBA colors are then converted to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>?</span></span><span data-ttu-id="5e98b-130"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>largeur</em></span><span class="sxs-lookup"><span data-stu-id="5e98b-130"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="5e98b-131"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-131"><em>y</em>?</span></span><span data-ttu-id="5e98b-132"> = <em></em><sub>r</sub> + <em>n/largeur</em> o</span><span class="sxs-lookup"><span data-stu-id="5e98b-132"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="5e98b-133">où (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) est la position de la trame actuelle.</span><span class="sxs-lookup"><span data-stu-id="5e98b-133">where (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="5e98b-134">La fonction <strong>glDrawPixels</strong> traite ces fragments de pixel comme les fragments générés par la pixellisation des points, des lignes ou des polygones.</span><span class="sxs-lookup"><span data-stu-id="5e98b-134">The <strong>glDrawPixels</strong> function treats these pixel fragments just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="5e98b-135">Il applique le mappage de texture, le brouillard et toutes les opérations de fragment avant d’écrire les fragments dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-135">It applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="even">
<td><span id="GL_STENCIL_INDEX"></span><span id="gl_stencil_index"></span><dl> <span data-ttu-id="5e98b-136"><dt><strong>GL_STENCIL_INDEX</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-136"><dt><strong>GL_STENCIL_INDEX</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-137">Chaque pixel est une valeur unique, un index de stencil.</span><span class="sxs-lookup"><span data-stu-id="5e98b-137">Each pixel is a single value, a stencil index.</span></span> <br/>
<ol>
<li><span data-ttu-id="5e98b-138">La fonction <strong>glDrawPixels</strong> la convertit au format à virgule fixe, avec un nombre non spécifié de bits à droite du point binaire, quel que soit le type de données de mémoire.</span><span class="sxs-lookup"><span data-stu-id="5e98b-138">The <strong>glDrawPixels</strong> function converts it to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type.</span></span> <span data-ttu-id="5e98b-139">Les valeurs à virgule flottante sont converties en valeurs à virgule fixe vraies.</span><span class="sxs-lookup"><span data-stu-id="5e98b-139">Floating-point values convert to true fixed-point values.</span></span> <span data-ttu-id="5e98b-140">La fonction <strong>glDrawPixels</strong> convertit les données entières signées et non signées avec tous les bits de fraction définis sur zéro.</span><span class="sxs-lookup"><span data-stu-id="5e98b-140">The <strong>glDrawPixels</strong> function converts signed and unsigned integer data with all fraction bits set to zero.</span></span> <span data-ttu-id="5e98b-141">Les données bitmap sont converties en 0,0 ou 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-141">Bitmap data converts to either 0.0 or 1.0.</span></span></li>
<li><span data-ttu-id="5e98b-142">La fonction <strong>glDrawPixels</strong> décale chaque index à virgule fixe laissé par GL_INDEX_SHIFT bits et l’ajoute à GL_INDEX_OFFSET.</span><span class="sxs-lookup"><span data-stu-id="5e98b-142">The <strong>glDrawPixels</strong> function shifts each fixed-point index left by GL_INDEX_SHIFT bits, and adds it to GL_INDEX_OFFSET.</span></span> <span data-ttu-id="5e98b-143">Si GL_INDEX_SHIFT est négatif, le décalage est à droite.</span><span class="sxs-lookup"><span data-stu-id="5e98b-143">If GL_INDEX_SHIFT is negative, the shift is to the right.</span></span> <span data-ttu-id="5e98b-144">Dans les deux cas, zéro bits remplit les emplacements de bits non spécifiés dans le résultat.</span><span class="sxs-lookup"><span data-stu-id="5e98b-144">In either case, zero bits fill otherwise unspecified bit locations in the result.</span></span></li>
<li><span data-ttu-id="5e98b-145">Si GL_MAP_STENCIL a la valeur true, l’index est remplacé par la valeur que <strong>glDrawPixels</strong> référence dans la table de recherche GL_PIXEL_MAP_S_TO_S.</span><span class="sxs-lookup"><span data-stu-id="5e98b-145">If GL_MAP_STENCIL is true, the index is replaced with the value that <strong>glDrawPixels</strong> references in lookup table GL_PIXEL_MAP_S_TO_S.</span></span></li>
<li><span data-ttu-id="5e98b-146">Que le remplacement de la recherche de l’index soit effectué ou non, la partie entière de l’index est ensuite <strong>et</strong>Ed avec 2<sup>b</sup> - 1, où <em>b</em> est le nombre de bits dans la mémoire tampon du stencil.</span><span class="sxs-lookup"><span data-stu-id="5e98b-146">Whether the lookup replacement of the index is done or not, the integer part of the index is then <strong>AND</strong>ed with 2<sup>b</sup> - 1, where <em>b</em> is the number of bits in the stencil buffer.</span></span> <span data-ttu-id="5e98b-147">Les index de stencil résultants sont ensuite écrits dans la mémoire tampon de stencil de telle sorte que le <em>n</em>ième index soit écrit dans l’emplacement <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-147">The resulting stencil indexes are then written to the stencil buffer such that the <em>n</em>th index is written to location <em>x</em>?</span></span><span data-ttu-id="5e98b-148"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>largeur</em></span><span class="sxs-lookup"><span data-stu-id="5e98b-148"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="5e98b-149"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-149"><em>y</em>?</span></span><span data-ttu-id="5e98b-150"> = <em></em><sub>r</sub> + <em>n/largeur</em> o</span><span class="sxs-lookup"><span data-stu-id="5e98b-150"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="5e98b-151">où (<em>x</em><sub>r</sub> , <em></em> y<sub>r</sub> ) est la position de la trame actuelle.</span><span class="sxs-lookup"><span data-stu-id="5e98b-151">where (<em>x</em><sub>r</sub> ,<em></em>y<sub>r</sub> ) is the current raster position.</span></span> <span data-ttu-id="5e98b-152">Seul le test de propriété des pixels, le test de la ciseaux et le stencil writemask affectent ces écritures.</span><span class="sxs-lookup"><span data-stu-id="5e98b-152">Only the pixel ownership test, the scissor test, and the stencil writemask affect these writes.</span></span><br/></li>
</ol></td>
</tr>
<tr class="odd">
<td><span id="GL_DEPTH_COMPONENT"></span><span id="gl_depth_component"></span><dl> <span data-ttu-id="5e98b-153"><dt><strong>GL_DEPTH_COMPONENT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-153"><dt><strong>GL_DEPTH_COMPONENT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-154">Chaque pixel est un composant à profondeur unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-154">Each pixel is a single-depth component.</span></span> <br/>
<ol>
<li><span data-ttu-id="5e98b-155">La fonction <strong>glDrawPixels</strong> convertit les données en virgule flottante directement en un format à virgule flottante interne avec une précision non spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5e98b-155">The <strong>glDrawPixels</strong> function converts floating-point data directly to an internal floating-point format with unspecified precision.</span></span> <span data-ttu-id="5e98b-156">Les données entières signées sont mappées de façon linéaire au format à virgule flottante interne de telle sorte que la valeur entière représentable la plus positive corresponde à 1,0, et la valeur représentable la plus négative correspond à-1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-156">Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.</span></span> <span data-ttu-id="5e98b-157">Les données entières non signées sont mappées de la même façon : la plus grande valeur entière correspond à 1,0, et zéro est mappé à 0,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-157">Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</span></span></li>
<li><span data-ttu-id="5e98b-158">La fonction <strong>glDrawPixels</strong> multiplie la valeur de profondeur à virgule flottante résultante par GL_DEPTH_SCALE et l’ajoute à GL_DEPTH_BIAS.</span><span class="sxs-lookup"><span data-stu-id="5e98b-158">The <strong>glDrawPixels</strong> function multiplies the resulting floating-point depth value by GL_DEPTH_SCALE and adds it to GL_DEPTH_BIAS.</span></span> <span data-ttu-id="5e98b-159">Le résultat est ancré à la plage [0, 1].</span><span class="sxs-lookup"><span data-stu-id="5e98b-159">The result is clamped to the range [0,1].</span></span></li>
<li><span data-ttu-id="5e98b-160">La fonction <strong>glDrawPixels</strong> convertit les composants de profondeur résultants en fragments en joignant la couleur de position raster actuelle ou l’index de couleur et les coordonnées de texture à chaque pixel, puis en affectant les coordonnées de la fenêtre <em>x</em> et <em>y</em> au <em>n</em> ième fragment de telle sorte que <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-160">The <strong>glDrawPixels</strong> function converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, and then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em> th fragment such that <em>x</em>?</span></span><span data-ttu-id="5e98b-161"> = <em></em>x<sub>r</sub> + <em>n</em> mod <em>largeur</em></span><span class="sxs-lookup"><span data-stu-id="5e98b-161"> = <em></em>x<sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="5e98b-162"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-162"><em>y</em>?</span></span><span data-ttu-id="5e98b-163"> = <em></em><sub>r</sub> + <em>n/largeur</em> o</span><span class="sxs-lookup"><span data-stu-id="5e98b-163"> = <em>y</em><sub>r</sub> + <em>n/width</em></span></span><br/> <span data-ttu-id="5e98b-164">où ( <em></em> x<sub>r</sub> ,<em>y</em><sub>r</sub> ) est la position de la trame actuelle.</span><span class="sxs-lookup"><span data-stu-id="5e98b-164">where (<em></em>x<sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="5e98b-165">Ces fragments de pixels sont ensuite traités comme les fragments générés par la pixellisation des points, des lignes ou des polygones.</span><span class="sxs-lookup"><span data-stu-id="5e98b-165">These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="5e98b-166">La fonction <strong>glDrawPixels</strong> applique le mappage de texture, le brouillard et toutes les opérations de fragment avant d’écrire les fragments dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-166">The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="even">
<td><span id="GL_RGBA"></span><span id="gl_rgba"></span><dl> <span data-ttu-id="5e98b-167"><dt><strong>GL_RGBA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-167"><dt><strong>GL_RGBA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-168">Chaque pixel est un groupe à quatre composants dans cet ordre : rouge, vert, bleu, alpha.</span><span class="sxs-lookup"><span data-stu-id="5e98b-168">Each pixel is a four-component group in this order: red, green, blue, alpha.</span></span> <br/>
<ol>
<li><span data-ttu-id="5e98b-169">La fonction <strong>glDrawPixels</strong> convertit les valeurs à virgule flottante directement en un format à virgule flottante interne avec une précision non spécifiée.</span><span class="sxs-lookup"><span data-stu-id="5e98b-169">The <strong>glDrawPixels</strong> function converts floating-point values directly to an internal floating-point format with unspecified precision.</span></span> <span data-ttu-id="5e98b-170">Les valeurs entières signées sont mappées de façon linéaire au format à virgule flottante interne de telle sorte que la valeur entière représentable la plus positive corresponde à 1,0, et la valeur représentable la plus négative correspond à-1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-170">Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to -1.0.</span></span> <span data-ttu-id="5e98b-171">Les données entières non signées sont mappées de la même façon : la plus grande valeur entière correspond à 1,0, et zéro est mappé à 0,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-171">Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and zero maps to 0.0.</span></span></li>
<li><span data-ttu-id="5e98b-172">La fonction <strong>glDrawPixels</strong> multiplie les valeurs de couleur de virgule flottante résultantes par GL_c_SCALE et les ajoute à GL_c_BIAS, où <em>c</em> est rouge, vert, bleu et alpha pour les composants de couleur respectifs.</span><span class="sxs-lookup"><span data-stu-id="5e98b-172">The <strong>glDrawPixels</strong> function multiplies the resulting floating-point color values by GL_c_SCALE and adds them to GL_c_BIAS, where <em>c</em> is RED, GREEN, BLUE, and ALPHA for the respective color components.</span></span> <span data-ttu-id="5e98b-173">Les résultats sont ancrés à la plage [0, 1].</span><span class="sxs-lookup"><span data-stu-id="5e98b-173">The results are clamped to the range [0,1].</span></span></li>
<li><span data-ttu-id="5e98b-174">Si GL_MAP_COLOR a la valeur true, <strong>glDrawPixels</strong> met à l’échelle chaque composant de couleur en fonction de la taille de la table de recherche GL_PIXEL_MAP_c_TO_c, puis remplace le composant par la valeur qu’il référence dans cette table. <em>c</em> est R, G, B ou a, respectivement.</span><span class="sxs-lookup"><span data-stu-id="5e98b-174">If GL_MAP_COLOR is true, <strong>glDrawPixels</strong> scales each color component by the size of lookup table GL_PIXEL_MAP_c_TO_c, and then replaces the component by the value that it references in that table; <em>c</em> is R, G, B, or A, respectively.</span></span></li>
<li><span data-ttu-id="5e98b-175">La fonction <strong>glDrawPixels</strong> convertit les couleurs RVBA obtenues en fragments en attachant la coordonnée <em>z</em>et la coordonnée de texture de la position raster actuelle à chaque pixel, puis en affectant les coordonnées de la fenêtre <em>x</em> et <em>y</em> au <em>n</em>ième fragment, de telle sorte que <em>x</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-175">The <strong>glDrawPixels</strong> function converts the resulting RGBA colors to fragments by attaching the current raster position <em>z</em>-coordinate and texture coordinates to each pixel, then assigning <em>x</em> and <em>y</em> window coordinates to the <em>n</em>th fragment such that <em>x</em>?</span></span><span data-ttu-id="5e98b-176"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>largeur</em></span><span class="sxs-lookup"><span data-stu-id="5e98b-176"> = <em>x</em><sub>r</sub> + <em>n</em> mod <em>width</em></span></span><br/> <span data-ttu-id="5e98b-177"><em>y</em>?</span><span class="sxs-lookup"><span data-stu-id="5e98b-177"><em>y</em>?</span></span><span data-ttu-id="5e98b-178"> = <em>o</em><sub>r</sub> + <em>n/Width</em></span><span class="sxs-lookup"><span data-stu-id="5e98b-178"> = <em>y</em><sub>r</sub> + <em>n /width</em></span></span><br/> <span data-ttu-id="5e98b-179">où (<em>x</em><sub>r</sub> ,<em>y</em><sub>r</sub> ) est la position de la trame actuelle.</span><span class="sxs-lookup"><span data-stu-id="5e98b-179">where (<em>x</em><sub>r</sub> ,<em>y</em><sub>r</sub> ) is the current raster position.</span></span><br/></li>
<li><span data-ttu-id="5e98b-180">Ces fragments de pixels sont ensuite traités comme les fragments générés par la pixellisation des points, des lignes ou des polygones.</span><span class="sxs-lookup"><span data-stu-id="5e98b-180">These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons.</span></span> <span data-ttu-id="5e98b-181">La fonction <strong>glDrawPixels</strong> applique le mappage de texture, le brouillard et toutes les opérations de fragment avant d’écrire les fragments dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-181">The <strong>glDrawPixels</strong> function applies texture mapping, fog, and all the fragment operations before writing the fragments to the framebuffer.</span></span></li>
</ol></td>
</tr>
<tr class="odd">
<td><span id="GL_RED"></span><span id="gl_red"></span><dl> <span data-ttu-id="5e98b-182"><dt><strong>GL_RED</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-182"><dt><strong>GL_RED</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-183">Chaque pixel est un composant rouge unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-183">Each pixel is a single red component.</span></span><br/> <span data-ttu-id="5e98b-184">La fonction <strong>glDrawPixels</strong> convertit ce composant au format à virgule flottante interne de la même façon que le composant rouge d’un pixel RVBA est, puis le convertit en pixel RVBA avec le vert et le bleu réglés sur 0,0 et alpha défini sur 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-184">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with green and blue set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="5e98b-185">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-185">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_GREEN"></span><span id="gl_green"></span><dl> <span data-ttu-id="5e98b-186"><dt><strong>GL_GREEN</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-186"><dt><strong>GL_GREEN</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-187">Chaque pixel est un composant vert unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-187">Each pixel is a single green component.</span></span><br/> <span data-ttu-id="5e98b-188">La fonction <strong>glDrawPixels</strong> convertit ce composant au format à virgule flottante interne de la même façon que le composant vert d’un pixel RVBA est, puis le convertit en pixel RVBA avec rouge et bleu défini sur 0,0 et alpha défini sur 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-188">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the green component of an RGBA pixel is, and then converts it to an RGBA pixel with red and blue set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="5e98b-189">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-189">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_BLUE"></span><span id="gl_blue"></span><dl> <span data-ttu-id="5e98b-190"><dt><strong>GL_BLUE</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-190"><dt><strong>GL_BLUE</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-191">Chaque pixel est un composant bleu unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-191">Each pixel is a single blue component.</span></span><br/> <span data-ttu-id="5e98b-192">La fonction <strong>glDrawPixels</strong> convertit ce composant au format à virgule flottante interne de la même façon que le composant bleu d’un pixel RVBA est, puis le convertit en pixel RVBA avec Red et Green défini sur 0,0, et alpha défini sur 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-192">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the blue component of an RGBA pixel is, and then converts it to an RGBA pixel with red and green set to 0.0, and alpha set to 1.0.</span></span> <span data-ttu-id="5e98b-193">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-193">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_ALPHA"></span><span id="gl_alpha"></span><dl> <span data-ttu-id="5e98b-194"><dt><strong>GL_ALPHA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-194"><dt><strong>GL_ALPHA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-195">Chaque pixel est un composant alpha unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-195">Each pixel is a single alpha component.</span></span><br/> <span data-ttu-id="5e98b-196">La fonction <strong>glDrawPixels</strong> convertit ce composant au format à virgule flottante interne de la même façon que le composant alpha d’un pixel RVBA est, puis le convertit en pixel RVBA avec rouge, vert et bleu défini sur 0,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-196">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the alpha component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to 0.0.</span></span> <span data-ttu-id="5e98b-197">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-197">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_RGB"></span><span id="gl_rgb"></span><dl> <span data-ttu-id="5e98b-198"><dt><strong>GL_RGB</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-198"><dt><strong>GL_RGB</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-199">Chaque pixel est un groupe de trois composants dans cet ordre : rouge, vert, bleu.</span><span class="sxs-lookup"><span data-stu-id="5e98b-199">Each pixel is a group of three components in this order: red, green, blue.</span></span> <span data-ttu-id="5e98b-200">La fonction <strong>glDrawPixels</strong> convertit chaque composant au format à virgule flottante interne de la même façon que les composants rouge, vert et bleu d’un pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-200">The <strong>glDrawPixels</strong> function converts each component to the internal floating-point format in the same way that the red, green, and blue components of an RGBA pixel are.</span></span> <span data-ttu-id="5e98b-201">La triple couleur est convertie en un pixel RVBA avec alpha défini sur 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-201">The color triple is converted to an RGBA pixel with alpha set to 1.0.</span></span> <span data-ttu-id="5e98b-202">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-202">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_LUMINANCE"></span><span id="gl_luminance"></span><dl> <span data-ttu-id="5e98b-203"><dt><strong>GL_LUMINANCE</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-203"><dt><strong>GL_LUMINANCE</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-204">Chaque pixel est un composant de luminance unique.</span><span class="sxs-lookup"><span data-stu-id="5e98b-204">Each pixel is a single luminance component.</span></span><br/> <span data-ttu-id="5e98b-205">La fonction <strong>glDrawPixels</strong> convertit ce composant au format à virgule flottante interne de la même façon que le composant rouge d’un pixel RVBA est, puis le convertit en pixel RVBA avec rouge, vert et bleu défini sur la valeur de luminance convertie, et alpha défini sur 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-205">The <strong>glDrawPixels</strong> function converts this component to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts it to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1.0.</span></span> <span data-ttu-id="5e98b-206">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-206">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_LUMINANCE_ALPHA"></span><span id="gl_luminance_alpha"></span><dl> <span data-ttu-id="5e98b-207"><dt><strong>GL_LUMINANCE_ALPHA</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-207"><dt><strong>GL_LUMINANCE_ALPHA</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-208">Chaque pixel est un groupe de deux composants dans cet ordre : luminance, alpha.</span><span class="sxs-lookup"><span data-stu-id="5e98b-208">Each pixel is a group of two components in this order: luminance, alpha.</span></span><br/> <span data-ttu-id="5e98b-209">La fonction <strong>glDrawPixels</strong> convertit les deux composants au format à virgule flottante interne de la même façon que le composant rouge d’un pixel RVBA est, puis les convertit en un pixel RVBA avec rouge, vert et bleu défini sur la valeur de luminance convertie, et alpha défini sur la valeur alpha convertie.</span><span class="sxs-lookup"><span data-stu-id="5e98b-209">The <strong>glDrawPixels</strong> function converts the two components to the internal floating-point format in the same way that the red component of an RGBA pixel is, and then converts them to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value.</span></span> <span data-ttu-id="5e98b-210">Après cette conversion, le pixel est traité comme s’il avait été lu en tant que pixel RVBA.</span><span class="sxs-lookup"><span data-stu-id="5e98b-210">After this conversion, the pixel is treated just as if it had been read as an RGBA pixel.</span></span><br/></td>
</tr>
<tr class="even">
<td><span id="GL_BGR_EXT"></span><span id="gl_bgr_ext"></span><dl> <span data-ttu-id="5e98b-211"><dt><strong>GL_BGR_EXT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-211"><dt><strong>GL_BGR_EXT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-212">Chaque pixel est un groupe de trois composants dans cet ordre : bleu, vert, rouge.</span><span class="sxs-lookup"><span data-stu-id="5e98b-212">Each pixel is a group of three components in this order: blue, green, red.</span></span><br/> <span data-ttu-id="5e98b-213">GL_BGR_EXT fournit un format qui correspond à la disposition mémoire des bitmaps indépendants du périphérique Windows (DIB).</span><span class="sxs-lookup"><span data-stu-id="5e98b-213">GL_BGR_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs).</span></span> <span data-ttu-id="5e98b-214">Ainsi, vos applications peuvent utiliser les mêmes données avec les appels de fonction Windows et les appels de fonction de pixel OpenGL.</span><span class="sxs-lookup"><span data-stu-id="5e98b-214">Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.</span></span><br/></td>
</tr>
<tr class="odd">
<td><span id="GL_BGRA_EXT"></span><span id="gl_bgra_ext"></span><dl> <span data-ttu-id="5e98b-215"><dt><strong>GL_BGRA_EXT</strong></dt> </span><span class="sxs-lookup"><span data-stu-id="5e98b-215"><dt><strong>GL_BGRA_EXT</strong></dt> </span></span></dl></td>
<td><span data-ttu-id="5e98b-216">Chaque pixel est un groupe de quatre composants dans l’ordre suivant : bleu, vert, rouge, alpha.</span><span class="sxs-lookup"><span data-stu-id="5e98b-216">Each pixel is a group of four components in this order: blue, green, red, alpha.</span></span><br/> <span data-ttu-id="5e98b-217">GL_BGRA_EXT fournit un format qui correspond à la disposition mémoire des bitmaps indépendants du périphérique Windows (DIB).</span><span class="sxs-lookup"><span data-stu-id="5e98b-217">GL_BGRA_EXT provides a format that matches the memory layout of Windows device-independent bitmaps (DIBs).</span></span> <span data-ttu-id="5e98b-218">Ainsi, vos applications peuvent utiliser les mêmes données avec les appels de fonction Windows et les appels de fonction de pixel OpenGL.</span><span class="sxs-lookup"><span data-stu-id="5e98b-218">Thus, your applications can use the same data with Windows function calls and OpenGL pixel function calls.</span></span><br/></td>
</tr>
</tbody>
</table>



 

</dd> <dt>

<span data-ttu-id="5e98b-219">*type*</span><span class="sxs-lookup"><span data-stu-id="5e98b-219">*type*</span></span> 
</dt> <dd>

<span data-ttu-id="5e98b-220">Type de données pour les *pixels*.</span><span class="sxs-lookup"><span data-stu-id="5e98b-220">The data type for *pixels*.</span></span> <span data-ttu-id="5e98b-221">Voici les constantes symboliques acceptées et leurs significations.</span><span class="sxs-lookup"><span data-stu-id="5e98b-221">The following are the accepted symbolic constants and their meanings.</span></span>



| <span data-ttu-id="5e98b-222">Valeur</span><span class="sxs-lookup"><span data-stu-id="5e98b-222">Value</span></span>                                                                                                                                                                      | <span data-ttu-id="5e98b-223">Signification</span><span class="sxs-lookup"><span data-stu-id="5e98b-223">Meaning</span></span>                                           |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| <span id="GL_UNSIGNED_BYTE"></span><span id="gl_unsigned_byte"></span><dl> <span data-ttu-id="5e98b-224"><dt>**\_octet non signé GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-224"><dt>**GL\_UNSIGNED\_BYTE**</dt></span></span> </dl>    | <span data-ttu-id="5e98b-225">Entier 8 bits non signé</span><span class="sxs-lookup"><span data-stu-id="5e98b-225">Unsigned 8-bit integer</span></span><br/>                 |
| <span id="GL_BYTE"></span><span id="gl_byte"></span><dl> <span data-ttu-id="5e98b-226"><dt>**\_octet GL**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-226"><dt>**GL\_BYTE**</dt></span></span> </dl>                                | <span data-ttu-id="5e98b-227">Entier 8 bits signé</span><span class="sxs-lookup"><span data-stu-id="5e98b-227">Signed 8-bit integer</span></span><br/>                   |
| <span id="GL_BITMAP"></span><span id="gl_bitmap"></span><dl> <span data-ttu-id="5e98b-228"><dt>**\_bitmap GL**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-228"><dt>**GL\_BITMAP**</dt></span></span> </dl>                          | <span data-ttu-id="5e98b-229">Bits uniques dans les entiers 8 bits non signés</span><span class="sxs-lookup"><span data-stu-id="5e98b-229">Single bits in unsigned 8-bit integers</span></span><br/> |
| <span id="GL_UNSIGNED_SHORT"></span><span id="gl_unsigned_short"></span><dl> <span data-ttu-id="5e98b-230"><dt>**NON signé dans le GL \_ \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-230"><dt>**GL\_UNSIGNED\_SHORT**</dt></span></span> </dl> | <span data-ttu-id="5e98b-231">Entier 16 bits non signé</span><span class="sxs-lookup"><span data-stu-id="5e98b-231">Unsigned 16-bit integer</span></span><br/>                |
| <span id="GL_SHORT"></span><span id="gl_short"></span><dl> <span data-ttu-id="5e98b-232"><dt>**\_abrégé GL**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-232"><dt>**GL\_SHORT**</dt></span></span> </dl>                             | <span data-ttu-id="5e98b-233">Entier 16 bits signé</span><span class="sxs-lookup"><span data-stu-id="5e98b-233">Signed 16-bit integer</span></span><br/>                  |
| <span id="GL_UNSIGNED_INT"></span><span id="gl_unsigned_int"></span><dl> <span data-ttu-id="5e98b-234"><dt>**\_entier non signé GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-234"><dt>**GL\_UNSIGNED\_INT**</dt></span></span> </dl>       | <span data-ttu-id="5e98b-235">Entier 32 bits non signé</span><span class="sxs-lookup"><span data-stu-id="5e98b-235">Unsigned 32-bit integer</span></span><br/>                |
| <span id="GL_INT"></span><span id="gl_int"></span><dl> <span data-ttu-id="5e98b-236"><dt>**GL \_ int**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-236"><dt>**GL\_INT**</dt></span></span> </dl>                                   | <span data-ttu-id="5e98b-237">Entier de 32 bits</span><span class="sxs-lookup"><span data-stu-id="5e98b-237">32-bit integer</span></span><br/>                         |
| <span id="GL_FLOAT"></span><span id="gl_float"></span><dl> <span data-ttu-id="5e98b-238"><dt>**valeur \_ float du GL**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-238"><dt>**GL\_FLOAT**</dt></span></span> </dl>                             | <span data-ttu-id="5e98b-239">Virgule flottante simple précision</span><span class="sxs-lookup"><span data-stu-id="5e98b-239">Single-precision floating-point</span></span><br/>        |



 

</dd> <dt>

<span data-ttu-id="5e98b-240">*pixels*</span><span class="sxs-lookup"><span data-stu-id="5e98b-240">*pixels*</span></span> 
</dt> <dd>

<span data-ttu-id="5e98b-241">Pointeur vers les données de pixels.</span><span class="sxs-lookup"><span data-stu-id="5e98b-241">A pointer to the pixel data.</span></span>

</dd> </dl>

## <a name="return-value"></a><span data-ttu-id="5e98b-242">Valeur renvoyée</span><span class="sxs-lookup"><span data-stu-id="5e98b-242">Return value</span></span>

<span data-ttu-id="5e98b-243">Cette fonction ne retourne pas de valeur.</span><span class="sxs-lookup"><span data-stu-id="5e98b-243">This function does not return a value.</span></span>

## <a name="error-codes"></a><span data-ttu-id="5e98b-244">Codes d’erreur</span><span class="sxs-lookup"><span data-stu-id="5e98b-244">Error codes</span></span>

<span data-ttu-id="5e98b-245">Les codes d’erreur suivants peuvent être récupérés par la fonction [**glGetError**](glgeterror.md) .</span><span class="sxs-lookup"><span data-stu-id="5e98b-245">The following error codes can be retrieved by the [**glGetError**](glgeterror.md) function.</span></span>



| <span data-ttu-id="5e98b-246">Nom</span><span class="sxs-lookup"><span data-stu-id="5e98b-246">Name</span></span>                                                                                                  | <span data-ttu-id="5e98b-247">Signification</span><span class="sxs-lookup"><span data-stu-id="5e98b-247">Meaning</span></span>                                                                                                                                                                                      |
|-------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <dl> <span data-ttu-id="5e98b-248"><dt>**\_valeur non valide du GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-248"><dt>**GL\_INVALID\_VALUE**</dt></span></span> </dl>     | <span data-ttu-id="5e98b-249">La *largeur* ou la *hauteur* était négative.</span><span class="sxs-lookup"><span data-stu-id="5e98b-249">Either *width* or *height* was negative.</span></span><br/>                                                                                                                                          |
| <dl> <span data-ttu-id="5e98b-250"><dt>**\_enum GL non valide \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-250"><dt>**GL\_INVALID\_ENUM**</dt></span></span> </dl>      | <span data-ttu-id="5e98b-251">Le *format* ou le *type* n’était pas une valeur acceptée.</span><span class="sxs-lookup"><span data-stu-id="5e98b-251">Either *format* or *type* was not an accepted value.</span></span> <br/>                                                                                                                             |
| <dl> <span data-ttu-id="5e98b-252"><dt>**\_opération non valide du GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-252"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="5e98b-253">*format* : GL \_ Red, GL \_ Green, GL \_ Blue, GL \_ alpha, GL \_ RGB, GL \_ RVBA, GL \_ BGR \_ ext, GL \_ BGRA \_ ext, GL \_ luminance ou GL \_ luminance \_ alpha, et OpenGL était en mode d’index des couleurs.</span><span class="sxs-lookup"><span data-stu-id="5e98b-253">*format* was GL\_RED, GL\_GREEN, GL\_BLUE, GL\_ALPHA, GL\_RGB, GL\_RGBA, GL\_BGR\_EXT, GL\_BGRA\_EXT, GL\_LUMINANCE, or GL\_LUMINANCE\_ALPHA, and OpenGL was in color-index mode.</span></span><br/> |
| <dl> <span data-ttu-id="5e98b-254"><dt>**\_enum GL non valide \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-254"><dt>**GL\_INVALID\_ENUM**</dt></span></span> </dl>      | <span data-ttu-id="5e98b-255">le *type* est \_ bitmap GL et le *format* n’est pas un index de couleur GL \_ ou un \_ \_ index de stencils GL \_ .</span><span class="sxs-lookup"><span data-stu-id="5e98b-255">*type* was GL\_BITMAP and *format* was not either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX.</span></span><br/>                                                                                         |
| <dl> <span data-ttu-id="5e98b-256"><dt>**\_opération non valide du GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-256"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="5e98b-257">le *format* était \_ un \_ index de stencils GL et il n’existait pas de tampon de stencil.</span><span class="sxs-lookup"><span data-stu-id="5e98b-257">*format* was GL\_STENCIL\_INDEX and there was no stencil buffer.</span></span><br/>                                                                                                                  |
| <dl> <span data-ttu-id="5e98b-258"><dt>**\_opération non valide du GL \_**</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-258"><dt>**GL\_INVALID\_OPERATION**</dt></span></span> </dl> | <span data-ttu-id="5e98b-259">La fonction a été appelée entre un appel à [**glBegin**](glbegin.md) et l’appel correspondant à [**glEnd**](glend.md).</span><span class="sxs-lookup"><span data-stu-id="5e98b-259">The function was called between a call to [**glBegin**](glbegin.md) and the corresponding call to [**glEnd**](glend.md).</span></span><br/>                                                        |


## <a name="remarks"></a><span data-ttu-id="5e98b-260">Notes</span><span class="sxs-lookup"><span data-stu-id="5e98b-260">Remarks</span></span>

<span data-ttu-id="5e98b-261">La fonction **glDrawPixels** lit les données de pixels de la mémoire et les écrit dans le trame par rapport à la position raster actuelle.</span><span class="sxs-lookup"><span data-stu-id="5e98b-261">The **glDrawPixels** function reads pixel data from memory and writes it into the framebuffer relative to the current raster position.</span></span> <span data-ttu-id="5e98b-262">Utilisez [**glRasterPos**](glrasterpos-functions.md) pour définir la position raster actuelle et utilisez [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) avec l’argument GL \_ Current \_ Raster \_ position pour interroger la position raster.</span><span class="sxs-lookup"><span data-stu-id="5e98b-262">Use [**glRasterPos**](glrasterpos-functions.md) to set the current raster position, and use [**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION to query the raster position.</span></span>

<span data-ttu-id="5e98b-263">Plusieurs paramètres définissent l’encodage des données de pixels en mémoire et contrôlent le traitement des données de pixels avant leur placement dans le trame.</span><span class="sxs-lookup"><span data-stu-id="5e98b-263">Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the framebuffer.</span></span> <span data-ttu-id="5e98b-264">Ces paramètres sont définis avec quatre fonctions : [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md)et [**glPixelZoom**](glpixelzoom.md).</span><span class="sxs-lookup"><span data-stu-id="5e98b-264">These parameters are set with four functions: [**glPixelStore**](glpixelstore-functions.md), [**glPixelTransfer**](glpixeltransfer.md), [**glPixelMap**](glpixelmap.md), and [**glPixelZoom**](glpixelzoom.md).</span></span> <span data-ttu-id="5e98b-265">Cette rubrique décrit les effets sur les **glDrawPixels** de nombreux paramètres spécifiés par ces quatre fonctions.</span><span class="sxs-lookup"><span data-stu-id="5e98b-265">This topic describes the effects on **glDrawPixels** of many, but not all, of the parameters specified by these four functions.</span></span>

<span data-ttu-id="5e98b-266">Les données sont lues à partir de *pixels* comme une séquence d’octets signés ou non signés, des entiers signés ou non signés, des entiers signés ou non signés, ou des valeurs à virgule flottante simple précision, en fonction du *type*.</span><span class="sxs-lookup"><span data-stu-id="5e98b-266">Data is read from *pixels* as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on *type*.</span></span> <span data-ttu-id="5e98b-267">Chacun de ces octets, des shorts, des entiers ou des valeurs à virgule flottante est interprété comme un composant de couleur ou de profondeur, ou un index, en fonction du *format*.</span><span class="sxs-lookup"><span data-stu-id="5e98b-267">Each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on *format*.</span></span> <span data-ttu-id="5e98b-268">Les index sont toujours traités individuellement.</span><span class="sxs-lookup"><span data-stu-id="5e98b-268">Indexes are always treated individually.</span></span> <span data-ttu-id="5e98b-269">Les composants de couleur sont traités comme des groupes d’une, deux, trois ou quatre valeurs, en fonction du *format*.</span><span class="sxs-lookup"><span data-stu-id="5e98b-269">Color components are treated as groups of one, two, three, or four values, again based on *format*.</span></span> <span data-ttu-id="5e98b-270">Les index et les groupes de composants individuels sont appelés pixels.</span><span class="sxs-lookup"><span data-stu-id="5e98b-270">Both individual indexes and groups of components are referred to as pixels.</span></span> <span data-ttu-id="5e98b-271">Si le *type* est \_ bitmap GL, les données doivent être des octets non signés et le *format* doit être un index de couleur GL \_ ou un \_ \_ index de stencils GL \_ .</span><span class="sxs-lookup"><span data-stu-id="5e98b-271">If *type* is GL\_BITMAP, the data must be unsigned bytes, and *format* must be either GL\_COLOR\_INDEX or GL\_STENCIL\_INDEX.</span></span> <span data-ttu-id="5e98b-272">Chaque octet non signé est traité comme un pixel de 8 1 bits, l’ordonnancement des bits étant déterminé par la \_ première décompression \_ LSB \_ (voir [**glPixelStore**](glpixelstore-functions.md)).</span><span class="sxs-lookup"><span data-stu-id="5e98b-272">Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by GL\_UNPACK\_LSB\_FIRST (see [**glPixelStore**](glpixelstore-functions.md)).</span></span>

<span data-ttu-id="5e98b-273">Les pixels de *largeur* par *hauteur* sont lus à partir de la mémoire, en commençant aux *pixels* de l’emplacement.</span><span class="sxs-lookup"><span data-stu-id="5e98b-273">The *width* by *height* pixels are read from memory, starting at location *pixels*.</span></span> <span data-ttu-id="5e98b-274">Par défaut, ces pixels proviennent d’emplacements de mémoire adjacents, sauf qu’une fois tous les pixels de la *largeur* lus, le pointeur de lecture est avancé jusqu’à la limite de 4 octets suivante.</span><span class="sxs-lookup"><span data-stu-id="5e98b-274">By default, these pixels are taken from adjacent memory locations, except that after all *width* pixels are read, the read pointer is advanced to the next 4-byte boundary.</span></span> <span data-ttu-id="5e98b-275">La fonction **glPixelStore** spécifie l’alignement de ligne sur 4 octets avec l' \_ alignement décompresser l’argument GL \_ , et vous pouvez lui affecter la valeur 1, 2, 4 ou 8 octets.</span><span class="sxs-lookup"><span data-stu-id="5e98b-275">The **glPixelStore** function specifies the 4-byte row alignment with argument GL\_UNPACK\_ALIGNMENT, and you can set it to 1, 2, 4, or 8 bytes.</span></span> <span data-ttu-id="5e98b-276">Les autres paramètres de magasin de pixels spécifient des avances de pointeur de lecture différentes, avant la lecture du premier pixel et après la lecture de tous les pixels de *largeur* .</span><span class="sxs-lookup"><span data-stu-id="5e98b-276">Other pixel store parameters specify different read pointer advancements, both before the first pixel is read, and after all *width* pixels are read.</span></span> <span data-ttu-id="5e98b-277">La fonction **glPixelStore** opère sur chacun des pixels de *largeur par hauteur* qu’elle lit à partir de la mémoire de la même manière, en fonction des valeurs de plusieurs paramètres spécifiés par [**glPixelTransfer**](glpixeltransfer.md) et [**glPixelMap**](glpixelmap.md).</span><span class="sxs-lookup"><span data-stu-id="5e98b-277">The **glPixelStore** function operates on each of the *width-by-height* pixels that it reads from memory in the same way, based on the values of several parameters specified by [**glPixelTransfer**](glpixeltransfer.md) and [**glPixelMap**](glpixelmap.md).</span></span> <span data-ttu-id="5e98b-278">Les détails de ces opérations, ainsi que la mémoire tampon cible dans laquelle les pixels sont dessinés, sont spécifiques au format des pixels, comme spécifié par le *format*.</span><span class="sxs-lookup"><span data-stu-id="5e98b-278">The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by *format*.</span></span>

<span data-ttu-id="5e98b-279">La pixellisation décrite jusqu’à présent suppose des facteurs de zoom de pixel de 1,0.</span><span class="sxs-lookup"><span data-stu-id="5e98b-279">The rasterization described thus far assumes pixel zoom factors of 1.0.</span></span> <span data-ttu-id="5e98b-280">Si vous utilisez [**glPixelZoom**](glpixelzoom.md) pour modifier les facteurs de zoom de pixel *x* et *y* , les pixels sont convertis en fragments comme suit.</span><span class="sxs-lookup"><span data-stu-id="5e98b-280">If you use [**glPixelZoom**](glpixelzoom.md) to change the *x* and *y* pixel zoom factors, pixels are converted to fragments as follows.</span></span> <span data-ttu-id="5e98b-281">Si (*XR, YR*) est la position de la trame actuelle, et qu’un pixel donné se trouve dans la *n* ième colonne et *m* énième ligne du rectangle de pixels, les fragments sont générés pour les pixels dont les centres se trouvent dans le rectangle avec des angles</span><span class="sxs-lookup"><span data-stu-id="5e98b-281">If (*xr,yr*) is the current raster position, and a given pixel is in the *n* th column and *m* th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at</span></span>

<span data-ttu-id="5e98b-282">(*x*<sub>r</sub>  +  *Zoom*? *n*, *y*<sub></sub>  +  *Zoom* r <sub>o</sub> *m*)</span><span class="sxs-lookup"><span data-stu-id="5e98b-282">(*x*<sub>r</sub> + *zoom*? *n*, *y*<sub>r</sub> + *zoom*<sub>y</sub> *m*)</span></span>

<span data-ttu-id="5e98b-283">(*x*<sub>r</sub>  +  *Zoom*?</span><span class="sxs-lookup"><span data-stu-id="5e98b-283">(*x*<sub>r</sub> + *zoom*?</span></span> <span data-ttu-id="5e98b-284">(*n* + 1), *o*<sub>r</sub>  +  *Zoom*<sub>y</sub> (*m* + 1))</span><span class="sxs-lookup"><span data-stu-id="5e98b-284">(*n* + 1), *y*<sub>r</sub> + *zoom*<sub>y</sub> (*m* + 1))</span></span>

<span data-ttu-id="5e98b-285">où *Zoom*? est la valeur de zoom \_ GL \_ X et *Zoom*<sub>y</sub> est la valeur de \_ Zoom GL \_ y.</span><span class="sxs-lookup"><span data-stu-id="5e98b-285">where *zoom*? is the value of GL\_ZOOM\_X and *zoom*<sub>y</sub> is the value of GL\_ZOOM\_Y.</span></span>

<span data-ttu-id="5e98b-286">Les fonctions suivantes récupèrent les informations relatives à **glDrawPixels**:</span><span class="sxs-lookup"><span data-stu-id="5e98b-286">The following functions retrieve information related to **glDrawPixels**:</span></span>

<span data-ttu-id="5e98b-287">[**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) avec argument GL \_ Current \_ Raster \_ position</span><span class="sxs-lookup"><span data-stu-id="5e98b-287">[**glGet**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) with argument GL\_CURRENT\_RASTER\_POSITION</span></span>

<span data-ttu-id="5e98b-288">**glGet** avec argument GL \_ Current \_ Raster \_ position \_ valide</span><span class="sxs-lookup"><span data-stu-id="5e98b-288">**glGet** with argument GL\_CURRENT\_RASTER\_POSITION\_VALID</span></span>

## <a name="requirements"></a><span data-ttu-id="5e98b-289">Configuration requise</span><span class="sxs-lookup"><span data-stu-id="5e98b-289">Requirements</span></span>



| <span data-ttu-id="5e98b-290">Condition requise</span><span class="sxs-lookup"><span data-stu-id="5e98b-290">Requirement</span></span> | <span data-ttu-id="5e98b-291">Valeur</span><span class="sxs-lookup"><span data-stu-id="5e98b-291">Value</span></span> |
|-------------------------------------|-----------------------------------------------------------------------------------------|
| <span data-ttu-id="5e98b-292">Client minimal pris en charge</span><span class="sxs-lookup"><span data-stu-id="5e98b-292">Minimum supported client</span></span><br/> | <span data-ttu-id="5e98b-293">Windows 2000 Professionnel - \[Applications de bureau uniquement\]</span><span class="sxs-lookup"><span data-stu-id="5e98b-293">Windows 2000 Professional \[desktop apps only\]</span></span><br/>                              |
| <span data-ttu-id="5e98b-294">Serveur minimal pris en charge</span><span class="sxs-lookup"><span data-stu-id="5e98b-294">Minimum supported server</span></span><br/> | <span data-ttu-id="5e98b-295">Windows 2000 Server - \[Applications de bureau uniquement\]</span><span class="sxs-lookup"><span data-stu-id="5e98b-295">Windows 2000 Server \[desktop apps only\]</span></span><br/>                                    |
| <span data-ttu-id="5e98b-296">En-tête</span><span class="sxs-lookup"><span data-stu-id="5e98b-296">Header</span></span><br/>                   | <dl> <span data-ttu-id="5e98b-297"><dt>GL. h</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-297"><dt>Gl.h</dt></span></span> </dl>         |
| <span data-ttu-id="5e98b-298">Bibliothèque</span><span class="sxs-lookup"><span data-stu-id="5e98b-298">Library</span></span><br/>                  | <dl> <span data-ttu-id="5e98b-299"><dt>Opengl32. lib</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-299"><dt>Opengl32.lib</dt></span></span> </dl> |
| <span data-ttu-id="5e98b-300">DLL</span><span class="sxs-lookup"><span data-stu-id="5e98b-300">DLL</span></span><br/>                      | <dl> <span data-ttu-id="5e98b-301"><dt>Opengl32.dll</dt></span><span class="sxs-lookup"><span data-stu-id="5e98b-301"><dt>Opengl32.dll</dt></span></span> </dl> |



## <a name="see-also"></a><span data-ttu-id="5e98b-302">Voir aussi</span><span class="sxs-lookup"><span data-stu-id="5e98b-302">See also</span></span>

<dl> <dt>

[<span data-ttu-id="5e98b-303">**glAlphaFunc**</span><span class="sxs-lookup"><span data-stu-id="5e98b-303">**glAlphaFunc**</span></span>](glalphafunc.md)
</dt> <dt>

[<span data-ttu-id="5e98b-304">**glBegin**</span><span class="sxs-lookup"><span data-stu-id="5e98b-304">**glBegin**</span></span>](glbegin.md)
</dt> <dt>

[<span data-ttu-id="5e98b-305">**glBlendFunc**</span><span class="sxs-lookup"><span data-stu-id="5e98b-305">**glBlendFunc**</span></span>](glblendfunc.md)
</dt> <dt>

[<span data-ttu-id="5e98b-306">**glCopyPixels**</span><span class="sxs-lookup"><span data-stu-id="5e98b-306">**glCopyPixels**</span></span>](glcopypixels.md)
</dt> <dt>

[<span data-ttu-id="5e98b-307">**glDepthFunc**</span><span class="sxs-lookup"><span data-stu-id="5e98b-307">**glDepthFunc**</span></span>](gldepthfunc.md)
</dt> <dt>

[<span data-ttu-id="5e98b-308">**glEnd**</span><span class="sxs-lookup"><span data-stu-id="5e98b-308">**glEnd**</span></span>](glend.md)
</dt> <dt>

[<span data-ttu-id="5e98b-309">**glGet**</span><span class="sxs-lookup"><span data-stu-id="5e98b-309">**glGet**</span></span>](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md)
</dt> <dt>

[<span data-ttu-id="5e98b-310">**glLogicOp**</span><span class="sxs-lookup"><span data-stu-id="5e98b-310">**glLogicOp**</span></span>](gllogicop.md)
</dt> <dt>

[<span data-ttu-id="5e98b-311">**glPixelMap**</span><span class="sxs-lookup"><span data-stu-id="5e98b-311">**glPixelMap**</span></span>](glpixelmap.md)
</dt> <dt>

[<span data-ttu-id="5e98b-312">**glPixelStore**</span><span class="sxs-lookup"><span data-stu-id="5e98b-312">**glPixelStore**</span></span>](glpixelstore-functions.md)
</dt> <dt>

[<span data-ttu-id="5e98b-313">**glPixelTransfer**</span><span class="sxs-lookup"><span data-stu-id="5e98b-313">**glPixelTransfer**</span></span>](glpixeltransfer.md)
</dt> <dt>

[<span data-ttu-id="5e98b-314">**glPixelZoom**</span><span class="sxs-lookup"><span data-stu-id="5e98b-314">**glPixelZoom**</span></span>](glpixelzoom.md)
</dt> <dt>

[<span data-ttu-id="5e98b-315">**glRasterPos**</span><span class="sxs-lookup"><span data-stu-id="5e98b-315">**glRasterPos**</span></span>](glrasterpos-functions.md)
</dt> <dt>

[<span data-ttu-id="5e98b-316">**glReadPixels**</span><span class="sxs-lookup"><span data-stu-id="5e98b-316">**glReadPixels**</span></span>](glreadpixels.md)
</dt> <dt>

[<span data-ttu-id="5e98b-317">**glScissor**</span><span class="sxs-lookup"><span data-stu-id="5e98b-317">**glScissor**</span></span>](glscissor.md)
</dt> <dt>

[<span data-ttu-id="5e98b-318">**glStencilFunc**</span><span class="sxs-lookup"><span data-stu-id="5e98b-318">**glStencilFunc**</span></span>](glstencilfunc.md)
</dt> </dl>

 

 





