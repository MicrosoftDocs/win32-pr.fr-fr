---
title: Différences entre l’IRIS dans le GL et OpenGL
description: Différences entre l’IRIS dans le GL et OpenGL
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- OpenGL, différences de la comptabilité IRIS
- Portage de l’IRIS dans le GL, différences OpenGL
- Portage à partir de IRIS GL, différences OpenGL
- portage vers OpenGL à partir de IRIS GL, différences de l’IRIS GL
- Portage OpenGL à partir de IRIS GL, différences d’IRIS GL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 369b4945757dd092e969fb87c41f9804aaff8fe7
ms.sourcegitcommit: b32433cc0394159c7263809ae67615ab5792d40d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/30/2021
ms.locfileid: "113119294"
---
# <a name="iris-gl-and-opengl-differences"></a><span data-ttu-id="79efa-108">Différences entre l’IRIS dans le GL et OpenGL</span><span class="sxs-lookup"><span data-stu-id="79efa-108">IRIS GL and OpenGL Differences</span></span>

<span data-ttu-id="79efa-109">Cette annexe répertorie les différences entre OpenGL et IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-109">This appendix lists the differences between OpenGL and IRIS GL.</span></span> <span data-ttu-id="79efa-110">Un terme est donné pour chaque différence, suivi d’une description.</span><span class="sxs-lookup"><span data-stu-id="79efa-110">A term for each difference is given, followed by a description.</span></span>



| <span data-ttu-id="79efa-111">Terme</span><span class="sxs-lookup"><span data-stu-id="79efa-111">Term</span></span>                                     | <span data-ttu-id="79efa-112">Description</span><span class="sxs-lookup"><span data-stu-id="79efa-112">Description</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="79efa-113">encapsulation de l’accumulation</span><span class="sxs-lookup"><span data-stu-id="79efa-113">accumulation wrapping</span></span>                | <span data-ttu-id="79efa-114">L’opération de mémoire tampon d’accumulation OpenGL n’est pas définie lorsque les valeurs de composant dépassent 1,0 ou chutent au-dessous de 1,0.</span><span class="sxs-lookup"><span data-stu-id="79efa-114">The OpenGL accumulation buffer operation is not defined when component values exceed 1.0 or drop below 1.0.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="79efa-115">lignes avec anticrénelage</span><span class="sxs-lookup"><span data-stu-id="79efa-115">antialiased lines</span></span>                    | <span data-ttu-id="79efa-116">OpenGL stipples les lignes AntiAlias.</span><span class="sxs-lookup"><span data-stu-id="79efa-116">OpenGL stipples antialiased lines.</span></span> <span data-ttu-id="79efa-117">IRIS GL ne le fait pas.</span><span class="sxs-lookup"><span data-stu-id="79efa-117">IRIS GL does not.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="79efa-118">arc</span><span class="sxs-lookup"><span data-stu-id="79efa-118">arc</span></span>                                  | <span data-ttu-id="79efa-119">OpenGL prend en charge les arcs dans sa bibliothèque utilitaire.</span><span class="sxs-lookup"><span data-stu-id="79efa-119">OpenGL supports arcs in its utility library.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-120">listes d’attributs</span><span class="sxs-lookup"><span data-stu-id="79efa-120">attribute lists</span></span>                      | <span data-ttu-id="79efa-121">Les attributs envoyés par le pushattributes IRIS GL diffèrent des jeux d’attributs envoyés par le glPushAttrib OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-121">The attributes pushed by the IRIS GL pushattributes differ from any of the attribute sets pushed by the OpenGL glPushAttrib .</span></span> <span data-ttu-id="79efa-122">Étant donné que tous les États OpenGL peuvent être lus, toutefois, vous pouvez implémenter les sémantiques push/pop souhaitées à l’aide de OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-122">Since all OpenGL states can be read back, however, you can implement any desired push/pop semantics using OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="79efa-123">mise à l’échelle automatique des textures</span><span class="sxs-lookup"><span data-stu-id="79efa-123">automatic texture scaling</span></span>            | <span data-ttu-id="79efa-124">L’interface de texture OpenGL ne prend pas en charge la mise à l’échelle automatique des images pour les dimensions Power-of-Two.</span><span class="sxs-lookup"><span data-stu-id="79efa-124">The OpenGL texture interface does not support automatic scaling of images to power-of-two dimensions.</span></span> <span data-ttu-id="79efa-125">Toutefois, le GLU prend en charge la mise à l’échelle des images.</span><span class="sxs-lookup"><span data-stu-id="79efa-125">However, the GLU supports image scaling.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="79efa-126">bbox</span><span class="sxs-lookup"><span data-stu-id="79efa-126">bbox</span></span>                                 | <span data-ttu-id="79efa-127">OpenGL ne prend pas en charge l’exécution conditionnelle des listes d’affichage.</span><span class="sxs-lookup"><span data-stu-id="79efa-127">OpenGL doesn't support conditional execution of display lists.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="79efa-128">callfunc</span><span class="sxs-lookup"><span data-stu-id="79efa-128">callfunc</span></span>                             | <span data-ttu-id="79efa-129">OpenGL ne prend pas en charge le rappel à partir des listes d’affichage.</span><span class="sxs-lookup"><span data-stu-id="79efa-129">OpenGL doesn't support callback from display lists.</span></span> <span data-ttu-id="79efa-130">Notez que IRIS GL ne prend pas en charge cette fonctionnalité lorsque le client et le serveur se trouvent sur des plateformes différentes.</span><span class="sxs-lookup"><span data-stu-id="79efa-130">Note that IRIS GL doesn't support this functionality either, when client and server are on different platforms.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="79efa-131">circle</span><span class="sxs-lookup"><span data-stu-id="79efa-131">circle</span></span>                               | <span data-ttu-id="79efa-132">OpenGL prend en charge les cercles avec GLU.</span><span class="sxs-lookup"><span data-stu-id="79efa-132">OpenGL supports circles with the GLU.</span></span> <span data-ttu-id="79efa-133">Dans OpenGL, les cercles et les arcs (disques et disques partiels) peuvent avoir des trous.</span><span class="sxs-lookup"><span data-stu-id="79efa-133">In OpenGL both circles and arcs (disks and partial disks) can have holes.</span></span> <span data-ttu-id="79efa-134">En outre, vous pouvez modifier la subdivision des primitives dans OpenGL, dont les normales de surface sont disponibles pour l’éclairage.</span><span class="sxs-lookup"><span data-stu-id="79efa-134">In addition, you can change subdivision of the primitives in OpenGL, whose surface normals are available for lighting.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-135">effacer les options</span><span class="sxs-lookup"><span data-stu-id="79efa-135">clear options</span></span>                        | <span data-ttu-id="79efa-136">OpenGL efface en fait les tampons.</span><span class="sxs-lookup"><span data-stu-id="79efa-136">OpenGL actually clears buffers.</span></span> <span data-ttu-id="79efa-137">Elle n’applique pas les opérations de pixels actuellement spécifiées, telles que la fusion et la logicop, quel que soit leur mode.</span><span class="sxs-lookup"><span data-stu-id="79efa-137">It doesn't apply currently specified pixel operations, such as blending and logicop, regardless of their modes.</span></span> <span data-ttu-id="79efa-138">Pour effacer l’utilisation de ces fonctionnalités, vous devez restituer un polygone de taille de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="79efa-138">To clear using such features, you must render a window-size polygon.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="79efa-139">lignes fermées</span><span class="sxs-lookup"><span data-stu-id="79efa-139">closed lines</span></span>                         | <span data-ttu-id="79efa-140">OpenGL effectue le rendu de toutes les lignes avec alias à une seule largeur, de telle sorte que les lignes contiguës ne partagent aucun pixel.</span><span class="sxs-lookup"><span data-stu-id="79efa-140">OpenGL renders all single-width aliased lines such that abutting lines share no pixels.</span></span> <span data-ttu-id="79efa-141">Cela signifie que le dernier pixel d’une ligne indépendante n’est pas dessiné.</span><span class="sxs-lookup"><span data-stu-id="79efa-141">This means that the last pixel of an independent line is not drawn.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="79efa-142">indicateur de couleur/normal</span><span class="sxs-lookup"><span data-stu-id="79efa-142">color/normal flag</span></span>                    | <span data-ttu-id="79efa-143">L’éclairage OpenGL est activé ou désactivé de manière explicite.</span><span class="sxs-lookup"><span data-stu-id="79efa-143">OpenGL lighting is explicitly enabled or disabled.</span></span> <span data-ttu-id="79efa-144">Lorsqu’elle est activée, elle est effective indépendamment de l’ordre dans lequel les couleurs et les normales sont spécifiées.</span><span class="sxs-lookup"><span data-stu-id="79efa-144">When enabled, it is effective regardless of the order in which colors and normals are specified.</span></span> <span data-ttu-id="79efa-145">Vous ne pouvez pas activer ou désactiver l’éclairage entre les commandes OpenGL glBegin et glEnd.</span><span class="sxs-lookup"><span data-stu-id="79efa-145">You cannot enable or disable lighting between OpenGL glBegin and glEnd commands.</span></span> <span data-ttu-id="79efa-146">Pour désactiver l’éclairage entre les glBegin et les glEnd, spécifiez zéro valeur ambiante, diffuse et spéculaire spéculaire, puis définissez l’émission de matériau sur la couleur souhaitée.</span><span class="sxs-lookup"><span data-stu-id="79efa-146">To disable lighting between glBegin and glEnd, specify zero ambient, diffuse, and specular material reflectance, and then set the material emission to the desired color.</span></span>                                                                                                                                                                                                                                                            |
| <span data-ttu-id="79efa-147">polygones concave</span><span class="sxs-lookup"><span data-stu-id="79efa-147">concave polygons</span></span>                     | <span data-ttu-id="79efa-148">L’API OpenGL principale ne gère pas les polygones concave, mais le GLU prend en charge la décomposition des contourages concave, sans auto-intersection, en triangles.</span><span class="sxs-lookup"><span data-stu-id="79efa-148">The core OpenGL API doesn't handle concave polygons, but the GLU supports decomposing concave, non-self-intersecting contours into triangles.</span></span> <span data-ttu-id="79efa-149">Ces triangles peuvent être dessinés immédiatement ou retournés.</span><span class="sxs-lookup"><span data-stu-id="79efa-149">These triangles can either be drawn immediately or returned.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="79efa-150">couleur calculée actuelle</span><span class="sxs-lookup"><span data-stu-id="79efa-150">current computed color</span></span>               | <span data-ttu-id="79efa-151">OpenGL n’a pas d’équivalent à une couleur calculée actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-151">OpenGL has no equivalent to a current computed color.</span></span> <span data-ttu-id="79efa-152">Si vous utilisez OpenGL comme moteur d’éclairage, vous pouvez utiliser les commentaires pour obtenir les couleurs générées par les calculs d’éclairage.</span><span class="sxs-lookup"><span data-stu-id="79efa-152">If you're using OpenGL as a lighting engine, you can use feedback to obtain colors generated by lighting calculations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-153">position graphique actuelle</span><span class="sxs-lookup"><span data-stu-id="79efa-153">current graphics position</span></span>            | <span data-ttu-id="79efa-154">OpenGL ne conserve pas la position graphique actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-154">OpenGL doesn't maintain a current graphics position.</span></span> <span data-ttu-id="79efa-155">Les commandes d’IRIS GL qui dépendent de la position graphique actuelle, telles que les lignes et les polygones relatifs, ne sont pas incluses dans OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-155">IRIS GL commands that depend on current graphics position, such as relative lines and polygons, are not included in OpenGL.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="79efa-156">courbes</span><span class="sxs-lookup"><span data-stu-id="79efa-156">curves</span></span>                               | <span data-ttu-id="79efa-157">OpenGL ne prend pas en charge les courbes de GL d’IRIS.</span><span class="sxs-lookup"><span data-stu-id="79efa-157">OpenGL does not support IRIS GL curves.</span></span> <span data-ttu-id="79efa-158">Il est recommandé d’utiliser des courbes NURBS.</span><span class="sxs-lookup"><span data-stu-id="79efa-158">Use of NURBS curves is recommended.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="79efa-159">defs/Bindings</span><span class="sxs-lookup"><span data-stu-id="79efa-159">defs/binds</span></span>                           | <span data-ttu-id="79efa-160">OpenGL n’a pas le concept d’objets de matériau, de lumière ou de texture ; uniquement des propriétés de matériau, de lumière et de texture.</span><span class="sxs-lookup"><span data-stu-id="79efa-160">OpenGL doesn't have the concept of material, light, or texture objects; only of material, light, and texture properties.</span></span> <span data-ttu-id="79efa-161">Vous pouvez toutefois utiliser des listes d’affichage pour créer leurs propres objets.</span><span class="sxs-lookup"><span data-stu-id="79efa-161">You can use display lists to create their own objects, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="79efa-162">depthcue</span><span class="sxs-lookup"><span data-stu-id="79efa-162">depthcue</span></span>                             | <span data-ttu-id="79efa-163">OpenGL n’offre aucune prise en charge directe des cueing de profondeur, mais sa prise en charge du brouillard est une fonctionnalité plus générale que vous pouvez utiliser facilement pour émuler la fonction Depthcue de l’IRIS du GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-163">OpenGL provides no direct support for depth cueing, but its fog support is a more general capability that you can easily use to emulate the IRIS GL depthcue function.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-164">modifier la liste d’affichage</span><span class="sxs-lookup"><span data-stu-id="79efa-164">display list editing</span></span>                 | <span data-ttu-id="79efa-165">Les listes d’affichage OpenGL ne peuvent pas être créées et détruites editedonly.</span><span class="sxs-lookup"><span data-stu-id="79efa-165">OpenGL display lists can't be editedonly created and destroyed.</span></span> <span data-ttu-id="79efa-166">Étant donné que vous pouvez spécifier des noms d’affichage de liste, vous pouvez toutefois redéfinir des listes d’affichage individuelles dans une hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="79efa-166">Because you can specify display list names, however, you can redefine individual display lists in a hierarchy.</span></span> <span data-ttu-id="79efa-167">Les listes d’affichage OpenGL sont conçues pour la mise en cache des données, et non pour la gestion des bases de données.</span><span class="sxs-lookup"><span data-stu-id="79efa-167">OpenGL display lists are designed for data caching, not for database management.</span></span> <span data-ttu-id="79efa-168">Elles sont garanties d’être stockées sur le serveur dans des environnements client/serveur, de sorte qu’elles ne sont pas limitées par la bande passante réseau pendant l’exécution.</span><span class="sxs-lookup"><span data-stu-id="79efa-168">They are guaranteed to be stored on the server in client/server environments, so they are not limited by network bandwidth during execution.</span></span> <span data-ttu-id="79efa-169">Les listes d’affichage OpenGL peuvent être appelées entre les commandes glBegin et glEnd, de sorte que la hiérarchie de la liste d’affichage peut être rendue suffisamment précise pour pouvoir, en fait, être modifiée.</span><span class="sxs-lookup"><span data-stu-id="79efa-169">OpenGL display lists can be called between glBegin and glEnd commands, so the display list hierarchy can be made fine enough that it can, in effect, be edited.</span></span>                                                                                              |
| <span data-ttu-id="79efa-170">vérification des erreurs</span><span class="sxs-lookup"><span data-stu-id="79efa-170">error checking</span></span>                       | <span data-ttu-id="79efa-171">OpenGL recherche les erreurs plus soigneusement que IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-171">OpenGL checks for errors more carefully than IRIS GL.</span></span> <span data-ttu-id="79efa-172">Par exemple, toutes les fonctions OpenGL qui ne sont pas acceptées entre glBegin et glEnd sont détectées comme des erreurs et n’ont aucun autre effet.</span><span class="sxs-lookup"><span data-stu-id="79efa-172">For example, all OpenGL functions that are not accepted between glBegin and glEnd are detected as errors, and have no other effect.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-173">valeurs de retour d’erreur</span><span class="sxs-lookup"><span data-stu-id="79efa-173">error return values</span></span>                  | <span data-ttu-id="79efa-174">Lorsqu’une commande OpenGL qui retourne une valeur détecte une erreur, elle retourne toujours zéro.</span><span class="sxs-lookup"><span data-stu-id="79efa-174">When an OpenGL command that returns a value detects an error, it always returns zero.</span></span> <span data-ttu-id="79efa-175">Les commandes OpenGL qui renvoient des données via des pointeurs passés n’apportent aucune modification au contenu du tableau si une erreur est détectée.</span><span class="sxs-lookup"><span data-stu-id="79efa-175">OpenGL commands that return data through passed pointers make no change to the array contents if an error is detected.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-176">effets secondaires de l’erreur</span><span class="sxs-lookup"><span data-stu-id="79efa-176">error side effects</span></span>                   | <span data-ttu-id="79efa-177">Lorsqu’une commande OpenGL génère une erreur, son seul effet secondaire est de mettre à jour l’indicateur d’erreur à la valeur appropriée.</span><span class="sxs-lookup"><span data-stu-id="79efa-177">When an OpenGL command results in an error, its only side effect is to update the error flag to the appropriate value.</span></span> <span data-ttu-id="79efa-178">Aucune autre modification d’État n’est apportée.</span><span class="sxs-lookup"><span data-stu-id="79efa-178">No other state changes are made.</span></span> <span data-ttu-id="79efa-179">(Une exception est le \_ \_Erreur de mémoire, ce qui est fatal.)</span><span class="sxs-lookup"><span data-stu-id="79efa-179">(An exception is the OUT\_OF\_MEMORY error, which is fatal.)</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="79efa-180">feedback</span><span class="sxs-lookup"><span data-stu-id="79efa-180">feedback</span></span>                             | <span data-ttu-id="79efa-181">Les commentaires sont standardisés dans OpenGL, de sorte qu’ils ne changent pas d’un ordinateur à un ordinateur.</span><span class="sxs-lookup"><span data-stu-id="79efa-181">Feedback is standardized in OpenGL so it doesn't change from machine to machine.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="79efa-182">polices et chaînes</span><span class="sxs-lookup"><span data-stu-id="79efa-182">fonts and strings</span></span>                    | <span data-ttu-id="79efa-183">OpenGL exige que les glyphes de caractères soient manipulés comme des listes d’affichage individuelles.</span><span class="sxs-lookup"><span data-stu-id="79efa-183">OpenGL requires character glyphs to be manipulated as individual display lists.</span></span> <span data-ttu-id="79efa-184">Il fournit une fonction d’appel de liste d’affichage qui accepte une liste de noms de liste d’affichage, chaque nom représenté par 1, 2 ou 4 octets.</span><span class="sxs-lookup"><span data-stu-id="79efa-184">It provides a display list calling function that accepts a list of display list names, each name represented as 1, 2, or 4 bytes.</span></span> <span data-ttu-id="79efa-185">La fonction glCallLists ajoute un décalage spécifié séparément à chaque nom de liste d’affichage avant l’appel, ce qui permet de traiter les listes de noms de listes d’affichage comme des chaînes.</span><span class="sxs-lookup"><span data-stu-id="79efa-185">The glCallLists function adds a separately specified offset to each display list name before the call, allowing lists of display list names to be treated as strings.</span></span> <span data-ttu-id="79efa-186">Ce mécanisme fournit toutes les fonctionnalités des polices d’IRIS GL, et beaucoup plus encore.</span><span class="sxs-lookup"><span data-stu-id="79efa-186">This mechanism provides all the functionality of IRIS GL fonts, and considerably more.</span></span> <span data-ttu-id="79efa-187">Par exemple, les caractères constitués de triangles peuvent être facilement manipulés.</span><span class="sxs-lookup"><span data-stu-id="79efa-187">For example, characters comprised of triangles can be easily manipulated.</span></span>                                                                                                                  |
| <span data-ttu-id="79efa-188">frontbuffer</span><span class="sxs-lookup"><span data-stu-id="79efa-188">frontbuffer</span></span>                          | <span data-ttu-id="79efa-189">IRIS GL présente des règles complexes pour le rendu du tampon d’avant en mode mémoire tampon unique.</span><span class="sxs-lookup"><span data-stu-id="79efa-189">IRIS GL has complex rules for rendering to the front buffer in single buffer mode.</span></span> <span data-ttu-id="79efa-190">OpenGL gère le rendu dans le tampon d’avant de manière simple.</span><span class="sxs-lookup"><span data-stu-id="79efa-190">OpenGL handles rendering to the front buffer in a straightforward way.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-191">polygones creux</span><span class="sxs-lookup"><span data-stu-id="79efa-191">hollow polygons</span></span>                      | <span data-ttu-id="79efa-192">Vous pouvez utiliser la capacité du stencil OpenGL pour restituer des polygones creux.</span><span class="sxs-lookup"><span data-stu-id="79efa-192">You can use the OpenGL stencil capacity to render hollow polygons.</span></span> <span data-ttu-id="79efa-193">OpenGL ne prend pas en charge d’autres moyens de créer des polygones creux.</span><span class="sxs-lookup"><span data-stu-id="79efa-193">OpenGL doesn't support other means for creating hollow polygons.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="79efa-194">verrouillage d’index</span><span class="sxs-lookup"><span data-stu-id="79efa-194">index clamping</span></span>                       | <span data-ttu-id="79efa-195">Dans la mesure du possible, OpenGL traite les index de couleur et de stencil comme des champs de bits plutôt que des nombres.</span><span class="sxs-lookup"><span data-stu-id="79efa-195">Where possible, OpenGL treats color and stencil indexes as bit fields rather than numbers.</span></span> <span data-ttu-id="79efa-196">Ainsi, les index sont masqués, plutôt que ancrés, à la plage prise en charge du trame.</span><span class="sxs-lookup"><span data-stu-id="79efa-196">Thus indexes are masked, rather than clamped, to the supported range of the framebuffer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="79efa-197">couleurs entières</span><span class="sxs-lookup"><span data-stu-id="79efa-197">integer colors</span></span>                       | <span data-ttu-id="79efa-198">Les composants de couleur d’entier signé (rouge, vert, bleu ou alpha) sont mappés de manière linéaire à des points flottants afin que l’entier le plus négatif soit mappé à 1,0 et que l’entier le plus positif soit mappé à 1,0.</span><span class="sxs-lookup"><span data-stu-id="79efa-198">Signed integer color components (red, green, blue, or alpha) are mapped in linear fashion to floating points so that the most negative integer maps to 1.0 and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="79efa-199">Ce mappage se produit lorsque vous spécifiez la couleur avant que OpenGL remplace la couleur actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-199">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span> <span data-ttu-id="79efa-200">Les composants de couleur d’entier non signé sont mappés de façon linéaire à des points flottants afin que 0 soit mappé à 0,0 et que le plus grand entier corresponde à 1,0.</span><span class="sxs-lookup"><span data-stu-id="79efa-200">Unsigned integer color components are mapped linearly to floating points so that 0 maps to 0.0 and the largest integer maps to 1.0.</span></span> <span data-ttu-id="79efa-201">Ce mappage se produit lorsque vous spécifiez la couleur avant que OpenGL remplace la couleur actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-201">This mapping occurs when you specify the color before OpenGL replaces the current color.</span></span>                                                                                                                                               |
| <span data-ttu-id="79efa-202">normales des entiers</span><span class="sxs-lookup"><span data-stu-id="79efa-202">integer normals</span></span>                      | <span data-ttu-id="79efa-203">Les composants de type entier normaux sont mappés comme les composants de couleur signés.</span><span class="sxs-lookup"><span data-stu-id="79efa-203">Integer normal components are mapped just like signed color components.</span></span> <span data-ttu-id="79efa-204">L’entier le plus négatif est mappé à 1,0, et l’entier le plus positif est mappé à 1,0.</span><span class="sxs-lookup"><span data-stu-id="79efa-204">The most negative integer maps to 1.0, and the most positive integer maps to 1.0.</span></span> <span data-ttu-id="79efa-205">fragments de pixels.</span><span class="sxs-lookup"><span data-stu-id="79efa-205">pixel fragments.</span></span> <span data-ttu-id="79efa-206">Les pixels dessinés par glDrawPixels ou glCopyPixels sont toujours pixellisés et convertis en fragments.</span><span class="sxs-lookup"><span data-stu-id="79efa-206">Pixels drawn by glDrawPixels or glCopyPixels are always rasterized and converted to fragments.</span></span> <span data-ttu-id="79efa-207">Les fragments résultants sont texturés, à la fois dans une mémoire tampon de profondeur, fusionnés, et ainsi de suite, comme s’ils étaient générés à partir de points géométriques.</span><span class="sxs-lookup"><span data-stu-id="79efa-207">The resulting fragments are textured, fogged, depth buffered, blended, and so on, just as if they were generated from geometric points.</span></span> <span data-ttu-id="79efa-208">Les données de fragment qui ne sont pas fournies par les pixels source sont augmentées à partir de la position raster actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-208">Fragment data that isn't provided by the source pixels is augmented from the current raster position.</span></span> <span data-ttu-id="79efa-209">Par exemple, les pixels RVBA prennent la position raster Z et les coordonnées de texture.</span><span class="sxs-lookup"><span data-stu-id="79efa-209">For example, RGBA pixels take the raster position Z and texture coordinates.</span></span> <span data-ttu-id="79efa-210">Les pixels de profondeur prennent la couleur de la position raster et les coordonnées de texture.</span><span class="sxs-lookup"><span data-stu-id="79efa-210">Depth pixels take the raster position color and texture coordinates.</span></span> |
| <span data-ttu-id="79efa-211">l’invariance</span><span class="sxs-lookup"><span data-stu-id="79efa-211">invariance</span></span>                           | <span data-ttu-id="79efa-212">OpenGL garantit une certaine cohérence de l’IRIS du GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-212">OpenGL guarantees a certain consistency that IRIS GL doesn't.</span></span> <span data-ttu-id="79efa-213">Par exemple, OpenGL garantit que les séquences de code identiques envoyées au même système, qui se différencient uniquement dans la fonction de fusion spécifiée, génèrent les mêmes fragments de pixels.</span><span class="sxs-lookup"><span data-stu-id="79efa-213">For example, OpenGL guarantees that identical code sequences sent to the same system, differing only in the specified blending function, will generate the same pixel fragments.</span></span> <span data-ttu-id="79efa-214">(Toutefois, les fragments diffèrent si la fusion est activée puis désactivée.)</span><span class="sxs-lookup"><span data-stu-id="79efa-214">(The fragments differ, however, if blending is enabled and then disabled.)</span></span>                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-215">équation d’éclairage</span><span class="sxs-lookup"><span data-stu-id="79efa-215">lighting equation</span></span>                    | <span data-ttu-id="79efa-216">L’équation d’éclairage OpenGL diffère légèrement de l’équation de l’IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-216">The OpenGL lighting equation differs slightly from the IRIS GL equation.</span></span> <span data-ttu-id="79efa-217">OpenGL prend en charge l’atténuation distincte pour chaque source de lumière, plutôt qu’une atténuation unique pour toutes les sources de lumière comme IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-217">OpenGL supports separate attenuation for each light source, rather than a single attenuation for all the light sources like IRIS GL.</span></span> <span data-ttu-id="79efa-218">OpenGL ajuste l’équation afin que les contributions d’éclairage ambiant, diffuse et spéculaire soient toutes atténuées.</span><span class="sxs-lookup"><span data-stu-id="79efa-218">OpenGL adjusts the equation so that ambient, diffuse, and specular lighting contributions are all attenuated.</span></span> <span data-ttu-id="79efa-219">En outre, OpenGL vous permet de spécifier des couleurs distinctes pour les intensités ambiantes, diffuses et spéculaires des sources lumineuses, ainsi que pour la réflexion ambiante, diffuse et spéculaire des matériaux.</span><span class="sxs-lookup"><span data-stu-id="79efa-219">Also, OpenGL allows you to specify separate colors for the ambient, diffuse, and specular intensities of light sources, as well as for the ambient, diffuse, and specular reflectance of materials.</span></span> <span data-ttu-id="79efa-220">Toutes les couleurs de lumière et de matériau OpenGL incluent alpha.</span><span class="sxs-lookup"><span data-stu-id="79efa-220">All OpenGL light and material colors include alpha.</span></span> <span data-ttu-id="79efa-221">L’affectation de la valeur zéro à l’exposant spéculaire ne fait pas échouer l’éclairage spéculaire dans OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-221">Setting the specular exponent to zero does not defeat specular lighting in OpenGL.</span></span>    |
| <span data-ttu-id="79efa-222">mapw</span><span class="sxs-lookup"><span data-stu-id="79efa-222">mapw</span></span>                                 | <span data-ttu-id="79efa-223">Les utilitaires OpenGL prennent en charge le mappage entre les coordonnées de l’objet et de la fenêtre.</span><span class="sxs-lookup"><span data-stu-id="79efa-223">OpenGL utilities support mapping between object and window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="79efa-224">mode matrice</span><span class="sxs-lookup"><span data-stu-id="79efa-224">matrix mode</span></span>                          | <span data-ttu-id="79efa-225">Lorsque les fonctions d’IRIS GL ortho, ortho2, perspective et fenêtre fonctionnent sur une matrice particulière, toutes les opérations de la matrice OpenGL fonctionnent sur la matrice actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-225">Where the IRIS GL ortho, ortho2, perspective, and window functions operate on a particular matrix, all OpenGL matrix operations work on the current matrix.</span></span> <span data-ttu-id="79efa-226">Toutes les opérations de la matrice OpenGL, à l’exception de glLoadIdentity et glLoadMatrix, multiplient la matrice actuelle au lieu de la remplacer (comme les fonctions ortho, ortho2, perspective et fenêtre dans IRIS GL).</span><span class="sxs-lookup"><span data-stu-id="79efa-226">All OpenGL matrix operations except glLoadIdentity and glLoadMatrix multiply the current matrix rather than replacing it (as do ortho, ortho2, perspective, and window in the IRIS GL).</span></span>                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="79efa-227">des mipmaps, génération automatique</span><span class="sxs-lookup"><span data-stu-id="79efa-227">mipmaps, automatic generation</span></span>        | <span data-ttu-id="79efa-228">L’interface de texture OpenGL ne prend pas en charge la génération automatique d’images mipmap.</span><span class="sxs-lookup"><span data-stu-id="79efa-228">The OpenGL texture interface does not support automatic generation of mipmap images.</span></span> <span data-ttu-id="79efa-229">Toutefois, GLU prend en charge la génération automatique d’images mipmap pour les textures 1D et 2D.</span><span class="sxs-lookup"><span data-stu-id="79efa-229">However, the GLU supports the automatic generation of mipmap images for both 1-D and 2-D textures.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="79efa-230">Move/Draw/pmove/pdraw/PCLOS</span><span class="sxs-lookup"><span data-stu-id="79efa-230">move/draw/pmove/pdraw/pclos</span></span>          | <span data-ttu-id="79efa-231">OpenGL ne prend en charge que les graphiques de style de début/fin, car il ne conserve pas la position graphique actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-231">OpenGL supports only Begin/End style graphics, because it does not maintain a current graphics position.</span></span> <span data-ttu-id="79efa-232">Toutefois, la spécification de paramètre scalaire des anciennes commandes de déplacement/dessin est acceptée par OpenGL pour toutes les commandes liées aux sommets.</span><span class="sxs-lookup"><span data-stu-id="79efa-232">The scalar parameter specification of the old move/draw commands is accepted by OpenGL for all vertex related commands, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-233">mode mprojection</span><span class="sxs-lookup"><span data-stu-id="79efa-233">mprojection mode</span></span>                     | <span data-ttu-id="79efa-234">IRIS GL ne transforme pas la géométrie par la matrice modelview en mode matrice de projection.</span><span class="sxs-lookup"><span data-stu-id="79efa-234">IRIS GL doesn't transform geometry by the modelview matrix while in projection matrix mode.</span></span> <span data-ttu-id="79efa-235">OpenGL transforme toujours à la fois le modelview et la matrice de projection, quel que soit le mode de la matrice.</span><span class="sxs-lookup"><span data-stu-id="79efa-235">OpenGL always transforms by both the modelview and the projection matrix, regardless of matrix mode.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="79efa-236">dessin à plusieurs mémoires tampons</span><span class="sxs-lookup"><span data-stu-id="79efa-236">multi-buffer drawing</span></span>                 | <span data-ttu-id="79efa-237">OpenGL effectue un rendu individuel sur chaque mémoire tampon de couleur, plutôt que de calculer une seule valeur de couleur, basée sur le contenu d’une mémoire tampon de couleur et de l’écrire dans toutes les mémoires tampons de couleur activées, comme le fait IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-237">OpenGL renders to each color buffer individually, rather than computing a single, new, color value based on the contents of one color buffer and writing it to all the enabled color buffers, as IRIS GL does.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="79efa-238">COURBE</span><span class="sxs-lookup"><span data-stu-id="79efa-238">NURBS</span></span>                                | <span data-ttu-id="79efa-239">OpenGL prend en charge NURBS avec une combinaison de fonctionnalités de base (évaluateurs) et de prise en charge GLU.</span><span class="sxs-lookup"><span data-stu-id="79efa-239">OpenGL supports NURBS with a combination of core capability (evaluators) and GLU support.</span></span> <span data-ttu-id="79efa-240">Toutes les fonctionnalités NURBS de l’IRIS GL sont prises en charge.</span><span class="sxs-lookup"><span data-stu-id="79efa-240">All IRIS GL NURBS capabilities are supported.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="79efa-241">mode polygone ancien</span><span class="sxs-lookup"><span data-stu-id="79efa-241">old polygon mode</span></span>                     | <span data-ttu-id="79efa-242">Les polygones OpenGL avec alias sont toujours échantillonnés par point.</span><span class="sxs-lookup"><span data-stu-id="79efa-242">Aliased OpenGL polygons are always point-sampled.</span></span> <span data-ttu-id="79efa-243">Le mode de compatibilité de polygone IRIS GL, où les pixels en dehors du périmètre du polygone sont inclus dans sa pixellisation, n’est pas pris en charge.</span><span class="sxs-lookup"><span data-stu-id="79efa-243">IRIS GL's polygon compatibility mode, where pixels outside the polygon perimeter are included in its rasterization, is not supported.</span></span> <span data-ttu-id="79efa-244">Si votre code utilise ce mode polygone, il s’agit probablement de rectangles.</span><span class="sxs-lookup"><span data-stu-id="79efa-244">If your code uses this polygon mode, it is probably for rectangles.</span></span> <span data-ttu-id="79efa-245">Les anciens rectangles en mode polygone s’affichent à un pixel de plus grande largeur.</span><span class="sxs-lookup"><span data-stu-id="79efa-245">Old polygon mode rectangles appear one pixel wider and higher.</span></span>                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="79efa-246">formats de couleurs compressés</span><span class="sxs-lookup"><span data-stu-id="79efa-246">packed color formats</span></span>                 | <span data-ttu-id="79efa-247">OpenGL accepte les couleurs en tant que composants 8 bits, mais ces composants sont traités comme un tableau d’octets plutôt que comme des octets compressés en mots plus grands.</span><span class="sxs-lookup"><span data-stu-id="79efa-247">OpenGL accepts colors as 8-bit components, but these components are treated as an array of bytes rather than as bytes packed into larger words.</span></span> <span data-ttu-id="79efa-248">En encourageant l’indexation de tableau plutôt que le décalage, OpenGL favorise la programmation invariant en endian.</span><span class="sxs-lookup"><span data-stu-id="79efa-248">By encouraging array indexing rather than shifting, OpenGL promotes endian-invariant programming.</span></span> <span data-ttu-id="79efa-249">De même que IRIS GL accepte les couleurs compressées pour le rendu géométrique et pixel, OpenGL accepte des tableaux de composants de couleur pour le rendu géométrique et de pixels.</span><span class="sxs-lookup"><span data-stu-id="79efa-249">Just as IRIS GL accepts packed colors both for geometric and pixel rendering, OpenGL accepts arrays of color components for geometric and pixel rendering.</span></span>                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-250">correctifs</span><span class="sxs-lookup"><span data-stu-id="79efa-250">patches</span></span>                              | <span data-ttu-id="79efa-251">OpenGL ne prend pas en charge les correctifs du GL IRIS.</span><span class="sxs-lookup"><span data-stu-id="79efa-251">OpenGL doesn't support IRIS GL patches.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| <span data-ttu-id="79efa-252">writemask de couleurs par bit</span><span class="sxs-lookup"><span data-stu-id="79efa-252">per-bit color writemask</span></span>              | <span data-ttu-id="79efa-253">OpenGL writemasks pour les composants de couleur active ou désactive les modifications apportées à l’ensemble du composant (rouge, vert, bleu ou alpha), et non aux bits individuels des composants.</span><span class="sxs-lookup"><span data-stu-id="79efa-253">OpenGL writemasks for color components enable or disable changes to the entire component (red, green, blue, or alpha), not to individual bits of components.</span></span> <span data-ttu-id="79efa-254">Notez cependant que les writemaskss par bit sont pris en charge pour les index de couleurs et les index de stencil.</span><span class="sxs-lookup"><span data-stu-id="79efa-254">Note that per-bit writemasks are supported for both color indexes and stencil indexes, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-255">writemask de profondeur par bit</span><span class="sxs-lookup"><span data-stu-id="79efa-255">per-bit depth writemask</span></span>              | <span data-ttu-id="79efa-256">OpenGL writemasks pour les composants de profondeur active ou désactive les modifications apportées à l’ensemble du composant, et non aux bits individuels du composant de profondeur.</span><span class="sxs-lookup"><span data-stu-id="79efa-256">OpenGL writemasks for depth components enable or disable changes to the entire component, not to individual bits of the depth component.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| <span data-ttu-id="79efa-257">reprend</span><span class="sxs-lookup"><span data-stu-id="79efa-257">pick</span></span>                                 | <span data-ttu-id="79efa-258">La bibliothèque d’utilitaires OpenGL prend en charge la génération d’une matrice Pick.</span><span class="sxs-lookup"><span data-stu-id="79efa-258">The OpenGL Utility library includes support for generating a pick matrix.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-259">coordonnées en pixels</span><span class="sxs-lookup"><span data-stu-id="79efa-259">pixel coordinates</span></span>                    | <span data-ttu-id="79efa-260">Dans OpenGL et IRIS GL, l’origine du système de coordonnées d’une fenêtre se trouve dans son angle inférieur gauche.</span><span class="sxs-lookup"><span data-stu-id="79efa-260">In both OpenGL and IRIS GL, the origin of a window's coordinate system is at its lower left corner.</span></span> <span data-ttu-id="79efa-261">OpenGL place l’origine dans le coin inférieur gauche de ce pixel, tandis que IRIS GL le place au centre du pixel inférieur gauche.</span><span class="sxs-lookup"><span data-stu-id="79efa-261">OpenGL places the origin at the lower left corner of this pixel, however, while IRIS GL places it at the center of the lower left pixel.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <span data-ttu-id="79efa-262">zoom de pixel</span><span class="sxs-lookup"><span data-stu-id="79efa-262">pixel zoom</span></span>                           | <span data-ttu-id="79efa-263">Les facteurs de zoom négatifs OpenGL reflètent la position graphique actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-263">OpenGL negative zoom factors reflect about the current graphics position.</span></span> <span data-ttu-id="79efa-264">IRIS GL ne définit pas l’opération des facteurs de zoom négatifs et fournit à la place des pixmodes de réflexion de droite \_ à \_ gauche et \_ de haut en \_ bas.</span><span class="sxs-lookup"><span data-stu-id="79efa-264">IRIS GL doesn't define the operation of negative zoom factors, and instead provides RIGHT\_TO\_LEFT and TOP\_TO\_BOTTOM reflection pixmodes.</span></span> <span data-ttu-id="79efa-265">Ces modes de réflexion reflètent sur place, plutôt que sur la position raster actuelle.</span><span class="sxs-lookup"><span data-stu-id="79efa-265">These reflection modes reflect in place, rather than about the current raster position.</span></span> <span data-ttu-id="79efa-266">OpenGL ne définit pas les modes de réflexion.</span><span class="sxs-lookup"><span data-stu-id="79efa-266">OpenGL doesn't define reflection modes.</span></span>                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-267">pixmode</span><span class="sxs-lookup"><span data-stu-id="79efa-267">pixmode</span></span>                              | <span data-ttu-id="79efa-268">Les transferts de pixels OpenGL fonctionnent sur des composants de couleur individuels, plutôt que sur des groupes compactés de composants 4 8 bits, comme IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-268">OpenGL pixel transfers operate on individual color components, rather than on packed groups of four 8-bit components as does IRIS GL.</span></span> <span data-ttu-id="79efa-269">Tandis que OpenGL offre une capacité de pixel sensiblement supérieure à celle de IRIS GL, il ne prend pas en charge les constructions de couleur compressées et n’autorise pas la réaffectation des composants de couleur (rouge à vert, rouge à bleu, etc.) pendant les opérations de copie de pixels.</span><span class="sxs-lookup"><span data-stu-id="79efa-269">While OpenGL provides substantially more pixel capability than IRIS GL, it doesn't support packed color constructs, and it doesn't enable color components to be reassigned (red to green, red to blue, and so on) during pixel copy operations.</span></span>                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-270">POLF/poly</span><span class="sxs-lookup"><span data-stu-id="79efa-270">polf/poly</span></span>                            | <span data-ttu-id="79efa-271">OpenGL ne fournit pas de prise en charge directe pour les listes de vertex autres que les listes d’affichage.</span><span class="sxs-lookup"><span data-stu-id="79efa-271">OpenGL provides no direct support for vertex lists other than display lists.</span></span> <span data-ttu-id="79efa-272">Toutefois, les fonctions telles que POLF et poly peuvent être implémentées facilement à l’aide de l’API OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-272">Functions like polf and poly can be implemented easily using the OpenGL API, however.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="79efa-273">vertex provoquant un polygone</span><span class="sxs-lookup"><span data-stu-id="79efa-273">polygon provoking vertex</span></span>             | <span data-ttu-id="79efa-274">Les polygones du GL de l’IRIS à l’écran plat prennent la couleur du dernier vertex spécifié, tandis que les polygones OpenGL prennent la couleur du premier vertex spécifié.</span><span class="sxs-lookup"><span data-stu-id="79efa-274">Flat shaded IRIS GL polygons take the color of the last vertex specified, while OpenGL polygons take the color of the first vertex specified.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="79efa-275">Polygone stipple</span><span class="sxs-lookup"><span data-stu-id="79efa-275">polygon stipple</span></span>                      | <span data-ttu-id="79efa-276">Avec IRIS GL, le modèle Polygon stipple est relatif à l’écran.</span><span class="sxs-lookup"><span data-stu-id="79efa-276">With IRIS GL the polygon stipple pattern is relative to the screen.</span></span> <span data-ttu-id="79efa-277">Avec OpenGL, il est relatif à une fenêtre.</span><span class="sxs-lookup"><span data-stu-id="79efa-277">With OpenGL it is relative to a window.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="79efa-278">nombre de vertex de polygone</span><span class="sxs-lookup"><span data-stu-id="79efa-278">polygon vertex count</span></span>                 | <span data-ttu-id="79efa-279">Il n’existe pas de limite au nombre de vertex entre glBegin et glEnd avec OpenGL, même pour glBegin (POLYGON).</span><span class="sxs-lookup"><span data-stu-id="79efa-279">There is no limit to the number of vertices between glBegin and glEnd with OpenGL, even for glBegin(POLYGON ).</span></span> <span data-ttu-id="79efa-280">Avec IRIS GL, les polygones sont limités à 255 sommets au maximum.</span><span class="sxs-lookup"><span data-stu-id="79efa-280">With IRIS GL, polygons are limited to no more than 255 vertices.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="79efa-281">readdisplay</span><span class="sxs-lookup"><span data-stu-id="79efa-281">readdisplay</span></span>                          | <span data-ttu-id="79efa-282">La lecture des pixels en dehors des limites de la fenêtre est une fonctionnalité du système de fenêtre, plutôt qu’une fonction de rendu.</span><span class="sxs-lookup"><span data-stu-id="79efa-282">Reading pixels outside window boundaries is properly a window system capability, rather than a rendering capability.</span></span> <span data-ttu-id="79efa-283">Utilisez les fonctions Windows pour remplacer la commande IRIS GL readdisplay.</span><span class="sxs-lookup"><span data-stu-id="79efa-283">Use Windows functions to replace the IRIS GL readdisplay command.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-284">Move et Draw/pmove/pdraw/PCLOS</span><span class="sxs-lookup"><span data-stu-id="79efa-284">relative move/draw/pmove/pdraw/pclos</span></span> | <span data-ttu-id="79efa-285">OpenGL ne conserve pas de position graphique actuelle, et par conséquent ne prend pas en charge les opérations de vertex relatives.</span><span class="sxs-lookup"><span data-stu-id="79efa-285">OpenGL doesn't maintain a current graphics position, and therefore doesn't support relative vertex operations.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| <span data-ttu-id="79efa-286">RVBA logicop ()</span><span class="sxs-lookup"><span data-stu-id="79efa-286">RGBA logicop()</span></span>                       | <span data-ttu-id="79efa-287">OpenGL ne prend pas en charge les opérations logiques sur les tampons RVBA.</span><span class="sxs-lookup"><span data-stu-id="79efa-287">OpenGL does not support logical operations on RGBA buffers.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| <span data-ttu-id="79efa-288">sbox()</span><span class="sxs-lookup"><span data-stu-id="79efa-288">sbox()</span></span>                               | <span data-ttu-id="79efa-289">SBOX est une primitive de rectangles de l’IRIS du GL qui est bien définie uniquement si elle est transformée sans rotation.</span><span class="sxs-lookup"><span data-stu-id="79efa-289">sbox is an IRIS GL rectangle primitive that is well-defined only if transformed without rotation.</span></span> <span data-ttu-id="79efa-290">Il est conçu pour être rendu plus rapide que les rectangles standard.</span><span class="sxs-lookup"><span data-stu-id="79efa-290">It is designed to be rendered faster than standard rectangles.</span></span> <span data-ttu-id="79efa-291">Si OpenGL ne prend pas en charge ce type de primitive, il peut être réglé pour afficher des rectangles très rapidement lorsque les matrices et les autres modes sont dans des États qui simplifient les calculs.</span><span class="sxs-lookup"><span data-stu-id="79efa-291">While OpenGL doesn't support such a primitive, it can be tuned to render rectangles very quickly when the matrices and other modes are in states that simplify calculations.</span></span>                                                                                                                                                                                                                                                                                                                             |
| <span data-ttu-id="79efa-292">arguments scalaires</span><span class="sxs-lookup"><span data-stu-id="79efa-292">scalar arguments</span></span>                     | <span data-ttu-id="79efa-293">Toutes les commandes OpenGL acceptées entre glBegin et glEnd ont des points d’entrée qui acceptent des arguments scalaires.</span><span class="sxs-lookup"><span data-stu-id="79efa-293">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept scalar arguments.</span></span> <span data-ttu-id="79efa-294">Par exemple, glColor4f (rouge, vert, bleu, alpha).</span><span class="sxs-lookup"><span data-stu-id="79efa-294">For example, glColor4f (red, green, blue, alpha ).</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| <span data-ttu-id="79efa-295">ciseaux</span><span class="sxs-lookup"><span data-stu-id="79efa-295">scissor</span></span>                              | <span data-ttu-id="79efa-296">La fonction glScissor OpenGL n’effectue pas le suivi de la fenêtre d’affichage.</span><span class="sxs-lookup"><span data-stu-id="79efa-296">The OpenGL glScissor function doesn't track the viewport.</span></span> <span data-ttu-id="79efa-297">La commande IRIS GL Viewport met automatiquement à jour le scrmask.</span><span class="sxs-lookup"><span data-stu-id="79efa-297">The IRIS GL viewport command automatically updates the scrmask.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-298">scrbox()</span><span class="sxs-lookup"><span data-stu-id="79efa-298">scrbox()</span></span>                             | <span data-ttu-id="79efa-299">OpenGL ne prend pas en charge le calcul du cadre englobant.</span><span class="sxs-lookup"><span data-stu-id="79efa-299">OpenGL doesn't support bounding box computation.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| <span data-ttu-id="79efa-300">scrsubdivide()</span><span class="sxs-lookup"><span data-stu-id="79efa-300">scrsubdivide()</span></span>                       | <span data-ttu-id="79efa-301">OpenGL ne prend pas en charge la subdivision d’écran.</span><span class="sxs-lookup"><span data-stu-id="79efa-301">OpenGL doesn't support screen subdivision.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| <span data-ttu-id="79efa-302">mode à matrice unique</span><span class="sxs-lookup"><span data-stu-id="79efa-302">single matrix mode</span></span>                   | <span data-ttu-id="79efa-303">OpenGL gère toujours deux matrices : ModelView et projection.</span><span class="sxs-lookup"><span data-stu-id="79efa-303">OpenGL always maintains two matrices: ModelView and Projection.</span></span> <span data-ttu-id="79efa-304">Alors qu’une implémentation OpenGL peut les consolider dans une matrice unique pour des raisons de performances, elle doit toujours présenter le modèle à deux matrices au programmeur.</span><span class="sxs-lookup"><span data-stu-id="79efa-304">While an OpenGL implementation can consolidate these into a single matrix for performance reasons, it must always present the two-matrix model to the programmer.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| <span data-ttu-id="79efa-305">mode de sous-pixel</span><span class="sxs-lookup"><span data-stu-id="79efa-305">subpixel mode</span></span>                        | <span data-ttu-id="79efa-306">Tout le rendu OpenGL est sous-pixel positionedsubpixel le mode est toujours activé.</span><span class="sxs-lookup"><span data-stu-id="79efa-306">All OpenGL rendering is subpixel positionedsubpixel mode is always on.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <span data-ttu-id="79efa-307">swaptmesh()</span><span class="sxs-lookup"><span data-stu-id="79efa-307">swaptmesh()</span></span>                          | <span data-ttu-id="79efa-308">OpenGL ne prend pas en charge la fonctionnalité swaptmesh.</span><span class="sxs-lookup"><span data-stu-id="79efa-308">OpenGL doesn't support the swaptmesh capability.</span></span> <span data-ttu-id="79efa-309">Elle offre deux types de maillages de triangles : un qui correspond au comportement par défaut « Strip » de l’IRIS GL, et un autre qui correspond à l’appel de swaptmesh avant le troisième et à tous les sommets suivants lors de l’utilisation de IRIS GL.</span><span class="sxs-lookup"><span data-stu-id="79efa-309">It does offer two types of triangle meshes, however: one that corresponds to the default "strip" behavior of the IRIS GL, and another that corresponds to calling swaptmesh prior to the third and all subsequent vertices when using IRIS GL.</span></span>                                                                                                                                                                                                                                                                                                                                                                           |
| <span data-ttu-id="79efa-310">arguments vectoriels</span><span class="sxs-lookup"><span data-stu-id="79efa-310">vector arguments</span></span>                     | <span data-ttu-id="79efa-311">Toutes les commandes OpenGL acceptées entre glBegin et glEnd ont des points d’entrée qui acceptent des arguments de vecteur.</span><span class="sxs-lookup"><span data-stu-id="79efa-311">All OpenGL commands that are accepted between glBegin and glEnd have entry points that accept vector arguments.</span></span> <span data-ttu-id="79efa-312">Par exemple, glColor4fv.</span><span class="sxs-lookup"><span data-stu-id="79efa-312">For example, glColor4fv .</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| <span data-ttu-id="79efa-313">gestion des fenêtres</span><span class="sxs-lookup"><span data-stu-id="79efa-313">window management</span></span>                    | <span data-ttu-id="79efa-314">OpenGL n’intègre aucune commande de système de fenêtre.</span><span class="sxs-lookup"><span data-stu-id="79efa-314">OpenGL includes no window system commands.</span></span> <span data-ttu-id="79efa-315">Elle est toujours prise en charge en tant qu’extension d’une fenêtre ou d’un système d’exploitation qui comprend la fonctionnalité de contrôle des appareils et des fenêtres.</span><span class="sxs-lookup"><span data-stu-id="79efa-315">It is always supported as an extension to a window or operating system that includes capability for device and window control.</span></span> <span data-ttu-id="79efa-316">Chaque extension fournit un mécanisme propre au système pour la création, la destruction et la manipulation des contextes de rendu OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-316">Each extension provides a system-specific mechanism for creating, destroying, and manipulating OpenGL rendering contexts.</span></span> <span data-ttu-id="79efa-317">Par exemple, l’extension OpenGL du système X Window (GLX) comprend environ 10 commandes à cet effet.</span><span class="sxs-lookup"><span data-stu-id="79efa-317">For example, the OpenGL extension to the X window system (GLX) includes roughly 10 commands for this purpose.</span></span> <span data-ttu-id="79efa-318">Les commandes d’IRIS GL telles que gconfig et DrawMode ne sont pas implémentées par OpenGL.</span><span class="sxs-lookup"><span data-stu-id="79efa-318">IRIS GL commands such as gconfig and drawmode are not implemented by OpenGL.</span></span>                                                                                                                                                                            |
| <span data-ttu-id="79efa-319">décalage de la fenêtre</span><span class="sxs-lookup"><span data-stu-id="79efa-319">window offset</span></span>                        | <span data-ttu-id="79efa-320">IRIS GL retourne la fenêtre d’affichage et les positions des caractères dans l’écran, plutôt que les coordonnées de la fenêtre.</span><span class="sxs-lookup"><span data-stu-id="79efa-320">IRIS GL returns viewport and character positions in screen, rather than window, coordinates.</span></span> <span data-ttu-id="79efa-321">OpenGL utilise toujours les coordonnées des fenêtres.</span><span class="sxs-lookup"><span data-stu-id="79efa-321">OpenGL always uses window coordinates.</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span data-ttu-id="79efa-322">rendu z</span><span class="sxs-lookup"><span data-stu-id="79efa-322">z rendering</span></span>                          | <span data-ttu-id="79efa-323">OpenGL ne prend pas en charge le rendu des couleurs dans le tampon de profondeur.</span><span class="sxs-lookup"><span data-stu-id="79efa-323">OpenGL doesn't support rendering colors to the depth buffer.</span></span> <span data-ttu-id="79efa-324">Elle autorise des mémoires tampons de couleurs supplémentaires, qui peuvent être implémentées à l’aide de la même mémoire que celle utilisée pour les mémoires tampons de profondeur dans d’autres configurations de fenêtres.</span><span class="sxs-lookup"><span data-stu-id="79efa-324">It does allow for additional color buffers, which can be implemented using the same memory that is used for depth buffers in other window configurations.</span></span> <span data-ttu-id="79efa-325">Toutefois, ces mémoires tampons de couleurs supplémentaires ne peuvent pas partager la mémoire avec la mémoire tampon de profondeur dans une configuration unique.</span><span class="sxs-lookup"><span data-stu-id="79efa-325">But these additional color buffers cannot share memory with the depth buffer in any single configuration.</span></span>                                                                                                                                                                                                                                                                                                                                          |



 

 

 




