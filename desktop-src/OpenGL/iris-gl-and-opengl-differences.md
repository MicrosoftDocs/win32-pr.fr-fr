---
title: Différences entre l’IRIS dans le GL et OpenGL
description: Différences entre l’IRIS dans le GL et OpenGL
ms.assetid: 1682bcbb-3bfb-4ea3-9ba9-4f4654238169
keywords:
- OpenGL, différences de la comptabilité IRIS
- Portage de l’IRIS dans le GL, différences OpenGL
- Portage à partir de IRIS GL, différences OpenGL
- portage vers OpenGL à partir de IRIS GL, différences de l’IRIS GL
- Portage OpenGL à partir de IRIS GL, différences d’IRIS GL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d6276eb56cf73df6cbdfc115fe67d55452b13bbc
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/16/2019
ms.locfileid: "104309805"
---
# <a name="iris-gl-and-opengl-differences"></a>Différences entre l’IRIS dans le GL et OpenGL

Cette annexe répertorie les différences entre OpenGL et IRIS GL. Un terme est donné pour chaque différence, suivi d’une description.



|                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| encapsulation de l’accumulation                | L’opération de mémoire tampon d’accumulation OpenGL n’est pas définie lorsque les valeurs de composant dépassent 1,0 ou chutent au-dessous de 1,0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| lignes avec anticrénelage                    | OpenGL stipples les lignes AntiAlias. IRIS GL ne le fait pas.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| arc                                  | OpenGL prend en charge les arcs dans sa bibliothèque utilitaire.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| listes d’attributs                      | Les attributs envoyés par le pushattributes IRIS GL diffèrent des jeux d’attributs envoyés par le glPushAttrib OpenGL. Étant donné que tous les États OpenGL peuvent être lus, toutefois, vous pouvez implémenter les sémantiques push/pop souhaitées à l’aide de OpenGL.                                                                                                                                                                                                                                                                                                                                                                                                                           |
| mise à l’échelle automatique des textures            | L’interface de texture OpenGL ne prend pas en charge la mise à l’échelle automatique des images pour les dimensions Power-of-Two. Toutefois, le GLU prend en charge la mise à l’échelle des images.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| bbox                                 | OpenGL ne prend pas en charge l’exécution conditionnelle des listes d’affichage.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| callfunc                             | OpenGL ne prend pas en charge le rappel à partir des listes d’affichage. Notez que IRIS GL ne prend pas en charge cette fonctionnalité lorsque le client et le serveur se trouvent sur des plateformes différentes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| circle                               | OpenGL prend en charge les cercles avec GLU. Dans OpenGL, les cercles et les arcs (disques et disques partiels) peuvent avoir des trous. En outre, vous pouvez modifier la subdivision des primitives dans OpenGL, dont les normales de surface sont disponibles pour l’éclairage.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| effacer les options                        | OpenGL efface en fait les tampons. Elle n’applique pas les opérations de pixels actuellement spécifiées, telles que la fusion et la logicop, quel que soit leur mode. Pour effacer l’utilisation de ces fonctionnalités, vous devez restituer un polygone de taille de fenêtre.                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| lignes fermées                         | OpenGL effectue le rendu de toutes les lignes avec alias à une seule largeur, de telle sorte que les lignes contiguës ne partagent aucun pixel. Cela signifie que le dernier pixel d’une ligne indépendante n’est pas dessiné.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| indicateur de couleur/normal                    | L’éclairage OpenGL est activé ou désactivé de manière explicite. Lorsqu’elle est activée, elle est effective indépendamment de l’ordre dans lequel les couleurs et les normales sont spécifiées. Vous ne pouvez pas activer ou désactiver l’éclairage entre les commandes OpenGL glBegin et glEnd. Pour désactiver l’éclairage entre les glBegin et les glEnd, spécifiez zéro valeur ambiante, diffuse et spéculaire spéculaire, puis définissez l’émission de matériau sur la couleur souhaitée.                                                                                                                                                                                                                                                            |
| polygones concave                     | L’API OpenGL principale ne gère pas les polygones concave, mais le GLU prend en charge la décomposition des contourages concave, sans auto-intersection, en triangles. Ces triangles peuvent être dessinés immédiatement ou retournés.                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| couleur calculée actuelle               | OpenGL n’a pas d’équivalent à une couleur calculée actuelle. Si vous utilisez OpenGL comme moteur d’éclairage, vous pouvez utiliser les commentaires pour obtenir les couleurs générées par les calculs d’éclairage.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| position graphique actuelle            | OpenGL ne conserve pas la position graphique actuelle. Les commandes d’IRIS GL qui dépendent de la position graphique actuelle, telles que les lignes et les polygones relatifs, ne sont pas incluses dans OpenGL.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| courbes                               | OpenGL ne prend pas en charge les courbes de GL d’IRIS. Il est recommandé d’utiliser des courbes NURBS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| defs/Bindings                           | OpenGL n’a pas le concept d’objets de matériau, de lumière ou de texture ; uniquement des propriétés de matériau, de lumière et de texture. Vous pouvez toutefois utiliser des listes d’affichage pour créer leurs propres objets.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| depthcue                             | OpenGL n’offre aucune prise en charge directe des cueing de profondeur, mais sa prise en charge du brouillard est une fonctionnalité plus générale que vous pouvez utiliser facilement pour émuler la fonction Depthcue de l’IRIS du GL.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| modifier la liste d’affichage                 | Les listes d’affichage OpenGL ne peuvent pas être créées et détruites editedonly. Étant donné que vous pouvez spécifier des noms d’affichage de liste, vous pouvez toutefois redéfinir des listes d’affichage individuelles dans une hiérarchie. Les listes d’affichage OpenGL sont conçues pour la mise en cache des données, et non pour la gestion des bases de données. Elles sont garanties d’être stockées sur le serveur dans des environnements client/serveur, de sorte qu’elles ne sont pas limitées par la bande passante réseau pendant l’exécution. Les listes d’affichage OpenGL peuvent être appelées entre les commandes glBegin et glEnd, de sorte que la hiérarchie de la liste d’affichage peut être rendue suffisamment précise pour pouvoir, en fait, être modifiée.                                                                                              |
| vérification des erreurs                       | OpenGL recherche les erreurs plus soigneusement que IRIS GL. Par exemple, toutes les fonctions OpenGL qui ne sont pas acceptées entre glBegin et glEnd sont détectées comme des erreurs et n’ont aucun autre effet.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| valeurs de retour d’erreur                  | Lorsqu’une commande OpenGL qui retourne une valeur détecte une erreur, elle retourne toujours zéro. Les commandes OpenGL qui renvoient des données via des pointeurs passés n’apportent aucune modification au contenu du tableau si une erreur est détectée.                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| effets secondaires de l’erreur                   | Lorsqu’une commande OpenGL génère une erreur, son seul effet secondaire est de mettre à jour l’indicateur d’erreur à la valeur appropriée. Aucune autre modification d’État n’est apportée. (Une exception est le \_ \_Erreur de mémoire, ce qui est fatal.)                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| feedback                             | Les commentaires sont standardisés dans OpenGL, de sorte qu’ils ne changent pas d’un ordinateur à un ordinateur.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| polices et chaînes                    | OpenGL exige que les glyphes de caractères soient manipulés comme des listes d’affichage individuelles. Il fournit une fonction d’appel de liste d’affichage qui accepte une liste de noms de liste d’affichage, chaque nom représenté par 1, 2 ou 4 octets. La fonction glCallLists ajoute un décalage spécifié séparément à chaque nom de liste d’affichage avant l’appel, ce qui permet de traiter les listes de noms de listes d’affichage comme des chaînes. Ce mécanisme fournit toutes les fonctionnalités des polices d’IRIS GL, et beaucoup plus encore. Par exemple, les caractères constitués de triangles peuvent être facilement manipulés.                                                                                                                  |
| frontbuffer                          | IRIS GL présente des règles complexes pour le rendu du tampon d’avant en mode mémoire tampon unique. OpenGL gère le rendu dans le tampon d’avant de manière simple.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| polygones creux                      | Vous pouvez utiliser la capacité du stencil OpenGL pour restituer des polygones creux. OpenGL ne prend pas en charge d’autres moyens de créer des polygones creux.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| verrouillage d’index                       | Dans la mesure du possible, OpenGL traite les index de couleur et de stencil comme des champs de bits plutôt que des nombres. Ainsi, les index sont masqués, plutôt que ancrés, à la plage prise en charge du trame.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| couleurs entières                       | Les composants de couleur d’entier signé (rouge, vert, bleu ou alpha) sont mappés de manière linéaire à des points flottants afin que l’entier le plus négatif soit mappé à 1,0 et que l’entier le plus positif soit mappé à 1,0. Ce mappage se produit lorsque vous spécifiez la couleur avant que OpenGL remplace la couleur actuelle. Les composants de couleur d’entier non signé sont mappés de façon linéaire à des points flottants afin que 0 soit mappé à 0,0 et que le plus grand entier corresponde à 1,0. Ce mappage se produit lorsque vous spécifiez la couleur avant que OpenGL remplace la couleur actuelle.                                                                                                                                               |
| normales des entiers                      | Les composants de type entier normaux sont mappés comme les composants de couleur signés. L’entier le plus négatif est mappé à 1,0, et l’entier le plus positif est mappé à 1,0. fragments de pixels. Les pixels dessinés par glDrawPixels ou glCopyPixels sont toujours pixellisés et convertis en fragments. Les fragments résultants sont texturés, à la fois dans une mémoire tampon de profondeur, fusionnés, et ainsi de suite, comme s’ils étaient générés à partir de points géométriques. Les données de fragment qui ne sont pas fournies par les pixels source sont augmentées à partir de la position raster actuelle. Par exemple, les pixels RVBA prennent la position raster Z et les coordonnées de texture. Les pixels de profondeur prennent la couleur de la position raster et les coordonnées de texture. |
| l’invariance                           | OpenGL garantit une certaine cohérence de l’IRIS du GL. Par exemple, OpenGL garantit que les séquences de code identiques envoyées au même système, qui se différencient uniquement dans la fonction de fusion spécifiée, génèrent les mêmes fragments de pixels. (Toutefois, les fragments diffèrent si la fusion est activée puis désactivée.)                                                                                                                                                                                                                                                                                                                                                 |
| équation d’éclairage                    | L’équation d’éclairage OpenGL diffère légèrement de l’équation de l’IRIS GL. OpenGL prend en charge l’atténuation distincte pour chaque source de lumière, plutôt qu’une atténuation unique pour toutes les sources de lumière comme IRIS GL. OpenGL ajuste l’équation afin que les contributions d’éclairage ambiant, diffuse et spéculaire soient toutes atténuées. En outre, OpenGL vous permet de spécifier des couleurs distinctes pour les intensités ambiantes, diffuses et spéculaires des sources lumineuses, ainsi que pour la réflexion ambiante, diffuse et spéculaire des matériaux. Toutes les couleurs de lumière et de matériau OpenGL incluent alpha. L’affectation de la valeur zéro à l’exposant spéculaire ne fait pas échouer l’éclairage spéculaire dans OpenGL.    |
| mapw                                 | Les utilitaires OpenGL prennent en charge le mappage entre les coordonnées de l’objet et de la fenêtre.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| mode matrice                          | Lorsque les fonctions d’IRIS GL ortho, ortho2, perspective et fenêtre fonctionnent sur une matrice particulière, toutes les opérations de la matrice OpenGL fonctionnent sur la matrice actuelle. Toutes les opérations de la matrice OpenGL, à l’exception de glLoadIdentity et glLoadMatrix, multiplient la matrice actuelle au lieu de la remplacer (comme les fonctions ortho, ortho2, perspective et fenêtre dans IRIS GL).                                                                                                                                                                                                                                                                                                                       |
| des mipmaps, génération automatique        | L’interface de texture OpenGL ne prend pas en charge la génération automatique d’images mipmap. Toutefois, GLU prend en charge la génération automatique d’images mipmap pour les textures 1D et 2D.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| Move/Draw/pmove/pdraw/PCLOS          | OpenGL ne prend en charge que les graphiques de style de début/fin, car il ne conserve pas la position graphique actuelle. Toutefois, la spécification de paramètre scalaire des anciennes commandes de déplacement/dessin est acceptée par OpenGL pour toutes les commandes liées aux sommets.                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| mode mprojection                     | IRIS GL ne transforme pas la géométrie par la matrice modelview en mode matrice de projection. OpenGL transforme toujours à la fois le modelview et la matrice de projection, quel que soit le mode de la matrice.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| dessin à plusieurs mémoires tampons                 | OpenGL effectue un rendu individuel sur chaque mémoire tampon de couleur, plutôt que de calculer une seule valeur de couleur, basée sur le contenu d’une mémoire tampon de couleur et de l’écrire dans toutes les mémoires tampons de couleur activées, comme le fait IRIS GL.                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| COURBE                                | OpenGL prend en charge NURBS avec une combinaison de fonctionnalités de base (évaluateurs) et de prise en charge GLU. Toutes les fonctionnalités NURBS de l’IRIS GL sont prises en charge.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| mode polygone ancien                     | Les polygones OpenGL avec alias sont toujours échantillonnés par point. Le mode de compatibilité de polygone IRIS GL, où les pixels en dehors du périmètre du polygone sont inclus dans sa pixellisation, n’est pas pris en charge. Si votre code utilise ce mode polygone, il s’agit probablement de rectangles. Les anciens rectangles en mode polygone s’affichent à un pixel de plus grande largeur.                                                                                                                                                                                                                                                                                                                                                |
| formats de couleurs compressés                 | OpenGL accepte les couleurs en tant que composants 8 bits, mais ces composants sont traités comme un tableau d’octets plutôt que comme des octets compressés en mots plus grands. En encourageant l’indexation de tableau plutôt que le décalage, OpenGL favorise la programmation invariant en endian. De même que IRIS GL accepte les couleurs compressées pour le rendu géométrique et pixel, OpenGL accepte des tableaux de composants de couleur pour le rendu géométrique et de pixels.                                                                                                                                                                                                                                                              |
| correctifs                              | OpenGL ne prend pas en charge les correctifs du GL IRIS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| writemask de couleurs par bit              | OpenGL writemasks pour les composants de couleur active ou désactive les modifications apportées à l’ensemble du composant (rouge, vert, bleu ou alpha), et non aux bits individuels des composants. Notez cependant que les writemaskss par bit sont pris en charge pour les index de couleurs et les index de stencil.                                                                                                                                                                                                                                                                                                                                                                                                              |
| writemask de profondeur par bit              | OpenGL writemasks pour les composants de profondeur active ou désactive les modifications apportées à l’ensemble du composant, et non aux bits individuels du composant de profondeur.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| reprend                                 | La bibliothèque d’utilitaires OpenGL prend en charge la génération d’une matrice Pick.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| coordonnées en pixels                    | Dans OpenGL et IRIS GL, l’origine du système de coordonnées d’une fenêtre se trouve dans son angle inférieur gauche. OpenGL place l’origine dans le coin inférieur gauche de ce pixel, tandis que IRIS GL le place au centre du pixel inférieur gauche.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| zoom de pixel                           | Les facteurs de zoom négatifs OpenGL reflètent la position graphique actuelle. IRIS GL ne définit pas l’opération des facteurs de zoom négatifs et fournit à la place des pixmodes de réflexion de droite \_ à \_ gauche et \_ de haut en \_ bas. Ces modes de réflexion reflètent sur place, plutôt que sur la position raster actuelle. OpenGL ne définit pas les modes de réflexion.                                                                                                                                                                                                                                                                                                                    |
| pixmode                              | Les transferts de pixels OpenGL fonctionnent sur des composants de couleur individuels, plutôt que sur des groupes compactés de composants 4 8 bits, comme IRIS GL. Tandis que OpenGL offre une capacité de pixel sensiblement supérieure à celle de IRIS GL, il ne prend pas en charge les constructions de couleur compressées et n’autorise pas la réaffectation des composants de couleur (rouge à vert, rouge à bleu, etc.) pendant les opérations de copie de pixels.                                                                                                                                                                                                                                                                                    |
| POLF/poly                            | OpenGL ne fournit pas de prise en charge directe pour les listes de vertex autres que les listes d’affichage. Toutefois, les fonctions telles que POLF et poly peuvent être implémentées facilement à l’aide de l’API OpenGL.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| vertex provoquant un polygone             | Les polygones du GL de l’IRIS à l’écran plat prennent la couleur du dernier vertex spécifié, tandis que les polygones OpenGL prennent la couleur du premier vertex spécifié.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| Polygone stipple                      | Avec IRIS GL, le modèle Polygon stipple est relatif à l’écran. Avec OpenGL, il est relatif à une fenêtre.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| nombre de vertex de polygone                 | Il n’existe pas de limite au nombre de vertex entre glBegin et glEnd avec OpenGL, même pour glBegin (POLYGON). Avec IRIS GL, les polygones sont limités à 255 sommets au maximum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| readdisplay                          | La lecture des pixels en dehors des limites de la fenêtre est une fonctionnalité du système de fenêtre, plutôt qu’une fonction de rendu. Utilisez les fonctions Windows pour remplacer la commande IRIS GL readdisplay.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Move et Draw/pmove/pdraw/PCLOS | OpenGL ne conserve pas de position graphique actuelle, et par conséquent ne prend pas en charge les opérations de vertex relatives.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| RVBA logicop ()                       | OpenGL ne prend pas en charge les opérations logiques sur les tampons RVBA.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| sbox()                               | SBOX est une primitive de rectangles de l’IRIS du GL qui est bien définie uniquement si elle est transformée sans rotation. Il est conçu pour être rendu plus rapide que les rectangles standard. Si OpenGL ne prend pas en charge ce type de primitive, il peut être réglé pour afficher des rectangles très rapidement lorsque les matrices et les autres modes sont dans des États qui simplifient les calculs.                                                                                                                                                                                                                                                                                                                             |
| arguments scalaires                     | Toutes les commandes OpenGL acceptées entre glBegin et glEnd ont des points d’entrée qui acceptent des arguments scalaires. Par exemple, glColor4f (rouge, vert, bleu, alpha).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ciseaux                              | La fonction glScissor OpenGL n’effectue pas le suivi de la fenêtre d’affichage. La commande IRIS GL Viewport met automatiquement à jour le scrmask.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| scrbox()                             | OpenGL ne prend pas en charge le calcul du cadre englobant.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| scrsubdivide()                       | OpenGL ne prend pas en charge la subdivision d’écran.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| mode à matrice unique                   | OpenGL gère toujours deux matrices : ModelView et projection. Alors qu’une implémentation OpenGL peut les consolider dans une matrice unique pour des raisons de performances, elle doit toujours présenter le modèle à deux matrices au programmeur.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| mode de sous-pixel                        | Tout le rendu OpenGL est sous-pixel positionedsubpixel le mode est toujours activé.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| swaptmesh()                          | OpenGL ne prend pas en charge la fonctionnalité swaptmesh. Elle offre deux types de maillages de triangles : un qui correspond au comportement par défaut « Strip » de l’IRIS GL, et un autre qui correspond à l’appel de swaptmesh avant le troisième et à tous les sommets suivants lors de l’utilisation de IRIS GL.                                                                                                                                                                                                                                                                                                                                                                           |
| arguments vectoriels                     | Toutes les commandes OpenGL acceptées entre glBegin et glEnd ont des points d’entrée qui acceptent des arguments de vecteur. Par exemple, glColor4fv.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| gestion des fenêtres                    | OpenGL n’intègre aucune commande de système de fenêtre. Elle est toujours prise en charge en tant qu’extension d’une fenêtre ou d’un système d’exploitation qui comprend la fonctionnalité de contrôle des appareils et des fenêtres. Chaque extension fournit un mécanisme propre au système pour la création, la destruction et la manipulation des contextes de rendu OpenGL. Par exemple, l’extension OpenGL du système X Window (GLX) comprend environ 10 commandes à cet effet. Les commandes d’IRIS GL telles que gconfig et DrawMode ne sont pas implémentées par OpenGL.                                                                                                                                                                            |
| décalage de la fenêtre                        | IRIS GL retourne la fenêtre d’affichage et les positions des caractères dans l’écran, plutôt que les coordonnées de la fenêtre. OpenGL utilise toujours les coordonnées des fenêtres.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| rendu z                          | OpenGL ne prend pas en charge le rendu des couleurs dans le tampon de profondeur. Elle autorise des mémoires tampons de couleurs supplémentaires, qui peuvent être implémentées à l’aide de la même mémoire que celle utilisée pour les mémoires tampons de profondeur dans d’autres configurations de fenêtres. Toutefois, ces mémoires tampons de couleurs supplémentaires ne peuvent pas partager la mémoire avec la mémoire tampon de profondeur dans une configuration unique.                                                                                                                                                                                                                                                                                                                                          |



 

 

 




