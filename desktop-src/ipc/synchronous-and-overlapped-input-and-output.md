---
description: E/s de canal synchrone et e/s de canal asynchrone. Les fonctions ReadFile, WriteFile, TransactNamedPipe et ConnectNamedPipe peuvent effectuer des opérations d’entrée et de sortie sur un canal de manière synchrone ou asynchrone.
ms.assetid: 5ab9bb7f-1f99-4041-bba8-2863f34dbcaf
title: E/s de canal synchrones et avec chevauchement
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3becfb19dfe5fa49d4121246a576fb3200226b1a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106522419"
---
# <a name="synchronous-and-overlapped-pipe-io"></a><span data-ttu-id="e60f4-104">E/s de canal synchrones et avec chevauchement</span><span class="sxs-lookup"><span data-stu-id="e60f4-104">Synchronous and Overlapped Pipe I/O</span></span>

<span data-ttu-id="e60f4-105">Les fonctions [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)et [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) peuvent effectuer des opérations d’entrée et de sortie sur un canal de manière synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="e60f4-105">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can perform input and output operations on a pipe either synchronously or asynchronously.</span></span> <span data-ttu-id="e60f4-106">Lorsqu’une fonction est exécutée de façon synchrone, elle n’est pas retournée tant que l’opération qu’elle exécute n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-106">When a function runs synchronously, it does not return until the operation it is performing is completed.</span></span> <span data-ttu-id="e60f4-107">Cela signifie que l’exécution du thread appelant peut être bloquée pendant une période indéterminée pendant qu’elle attend la fin d’une opération longue.</span><span class="sxs-lookup"><span data-stu-id="e60f4-107">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to be completed.</span></span> <span data-ttu-id="e60f4-108">Lorsqu’une fonction s’exécute de façon asynchrone, elle est retournée immédiatement, même si l’opération n’a pas été effectuée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-108">When a function runs asynchronously, it returns immediately, even if the operation has not been completed.</span></span> <span data-ttu-id="e60f4-109">Cela permet d’exécuter une opération qui prend du temps en arrière-plan pendant que le thread appelant est libre d’effectuer d’autres tâches.</span><span class="sxs-lookup"><span data-stu-id="e60f4-109">This enables a time-consuming operation to be executed in the background while the calling thread is free to perform other tasks.</span></span>

<span data-ttu-id="e60f4-110">L’utilisation d’e/s asynchrones permet à un serveur de canal d’utiliser une boucle qui effectue les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="e60f4-110">Using asynchronous I/O enables a pipe server to use a loop that performs the following steps:</span></span>

1.  <span data-ttu-id="e60f4-111">Spécifiez plusieurs objets d’événement dans un appel à la fonction Wait et attendez que l’un des objets soit défini sur l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="e60f4-111">Specify multiple event objects in a call to the wait function, and wait for one of the objects to be set to the signaled state.</span></span>
2.  <span data-ttu-id="e60f4-112">Utilisez la valeur de retour de la fonction Wait pour déterminer l’opération Overlapped terminée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-112">Use the wait function's return value to determine which overlapped operation has finished.</span></span>
3.  <span data-ttu-id="e60f4-113">Effectuez les tâches nécessaires pour nettoyer l’opération terminée et initier l’opération suivante pour ce handle de canal.</span><span class="sxs-lookup"><span data-stu-id="e60f4-113">Perform the tasks necessary to clean up the completed operation and initiate the next operation for that pipe handle.</span></span> <span data-ttu-id="e60f4-114">Cela peut impliquer le démarrage d’une autre opération avec chevauchement pour le même handle de canal.</span><span class="sxs-lookup"><span data-stu-id="e60f4-114">This can involve starting another overlapped operation for the same pipe handle.</span></span>

<span data-ttu-id="e60f4-115">Les opérations avec chevauchement permettent à un canal de lire et d’écrire des données simultanément et à un thread unique d’effectuer des opérations d’e/s simultanées sur plusieurs descripteurs de canal.</span><span class="sxs-lookup"><span data-stu-id="e60f4-115">Overlapped operations make it possible for one pipe to read and write data simultaneously and for a single thread to perform simultaneous I/O operations on multiple pipe handles.</span></span> <span data-ttu-id="e60f4-116">Cela permet à un serveur de canal à thread unique de gérer efficacement les communications avec plusieurs clients de canal.</span><span class="sxs-lookup"><span data-stu-id="e60f4-116">This enables a single-threaded pipe server to handle communications with multiple pipe clients efficiently.</span></span> <span data-ttu-id="e60f4-117">Pour obtenir un exemple, consultez [serveur de canal nommé utilisant des e/s avec chevauchement](named-pipe-server-using-overlapped-i-o.md).</span><span class="sxs-lookup"><span data-stu-id="e60f4-117">For an example, see [Named Pipe Server Using Overlapped I/O](named-pipe-server-using-overlapped-i-o.md).</span></span>

<span data-ttu-id="e60f4-118">Pour qu’un serveur de canaux utilise des opérations synchrones pour communiquer avec plusieurs clients, il doit créer un thread distinct pour chaque client de canal afin qu’un ou plusieurs threads puissent s’exécuter pendant que d’autres threads sont en attente.</span><span class="sxs-lookup"><span data-stu-id="e60f4-118">For a pipe server to use synchronous operations to communicate with more than one client, it must create a separate thread for each pipe client so that one or more threads can run while other threads are waiting.</span></span> <span data-ttu-id="e60f4-119">Pour obtenir un exemple de serveur de canaux multithread qui utilise des opérations synchrones, consultez [serveur de canal multithread](multithreaded-pipe-server.md).</span><span class="sxs-lookup"><span data-stu-id="e60f4-119">For an example of a multithreaded pipe server that uses synchronous operations, see [Multithreaded Pipe Server](multithreaded-pipe-server.md).</span></span>

## <a name="enabling-asynchronous-operation"></a><span data-ttu-id="e60f4-120">Activation de l’opération asynchrone</span><span class="sxs-lookup"><span data-stu-id="e60f4-120">Enabling Asynchronous Operation</span></span>

<span data-ttu-id="e60f4-121">Les fonctions [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)et [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) peuvent être exécutées de façon asynchrone uniquement si vous activez le mode avec chevauchement pour le handle de canal spécifié et spécifiez un pointeur valide vers une structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="e60f4-121">The [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) functions can be performed asynchronously only if you enable overlapped mode for the specified pipe handle and specify a valid pointer to an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="e60f4-122">Si le pointeur **OVERLAPPED** a la valeur **null**, la valeur de retour de la fonction peut indiquer de manière incorrecte que l’opération a été effectuée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-122">If the **OVERLAPPED** pointer is **NULL**, the function return value can incorrectly indicate that the operation has been completed.</span></span> <span data-ttu-id="e60f4-123">Par conséquent, il est fortement recommandé que si vous créez un handle avec un indicateur de fichier qui \_ \_ chevauche et que vous souhaitiez un comportement asynchrone, vous devez toujours spécifier une structure **OVERLAPPED** valide.</span><span class="sxs-lookup"><span data-stu-id="e60f4-123">Therefore, it is strongly recommended that if you create a handle with FILE\_FLAG\_OVERLAPPED and want asynchronous behavior, you should always specify a valid **OVERLAPPED** structure.</span></span>

<span data-ttu-id="e60f4-124">Le membre **hEvent** de la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) spécifiée doit contenir un handle vers un objet d’événement de réinitialisation manuelle.</span><span class="sxs-lookup"><span data-stu-id="e60f4-124">The **hEvent** member of the specified [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must contain a handle to a manual-reset event object.</span></span> <span data-ttu-id="e60f4-125">Il s’agit d’un objet de synchronisation créé par la fonction [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) .</span><span class="sxs-lookup"><span data-stu-id="e60f4-125">This is a synchronization object created by the [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa) function.</span></span> <span data-ttu-id="e60f4-126">Le thread qui lance l’opération Overlapped utilise l’objet d’événement pour déterminer à quel moment l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-126">The thread that initiates the overlapped operation uses the event object to determine when the operation has finished.</span></span> <span data-ttu-id="e60f4-127">Vous ne devez pas utiliser le handle de canal pour la synchronisation lors de l’exécution d’opérations simultanées sur le même handle, car il n’existe aucun moyen de connaître l’achèvement de l’opération qui a provoqué le signalement du handle de canal.</span><span class="sxs-lookup"><span data-stu-id="e60f4-127">You should not use the pipe handle for synchronization when performing simultaneous operations on the same handle because there is no way of knowing which operation's completion caused the pipe handle to be signaled.</span></span> <span data-ttu-id="e60f4-128">La seule technique fiable pour effectuer des opérations simultanées sur le même handle de canal consiste à utiliser une structure **OVERLAPPED** distincte avec son propre objet d’événement pour chaque opération.</span><span class="sxs-lookup"><span data-stu-id="e60f4-128">The only reliable technique for performing simultaneous operations on the same pipe handle is to use a separate **OVERLAPPED** structure with its own event object for each operation.</span></span> <span data-ttu-id="e60f4-129">Pour plus d’informations sur les objets d’événement, consultez [Synchronization](/windows/desktop/Sync/synchronization).</span><span class="sxs-lookup"><span data-stu-id="e60f4-129">For more information about event objects, see [Synchronization](/windows/desktop/Sync/synchronization).</span></span>

<span data-ttu-id="e60f4-130">En outre, vous pouvez être averti lorsqu’une opération avec chevauchement se termine à l’aide des fonctions [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) ou [**GetQueuedCompletionStatusEx**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) .</span><span class="sxs-lookup"><span data-stu-id="e60f4-130">Also, you can be notified when an overlapped operation completes by using the [**GetQueuedCompletionStatus**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) or [**GetQueuedCompletionStatusEx**](/windows/desktop/FileIO/getqueuedcompletionstatusex-func) functions.</span></span> <span data-ttu-id="e60f4-131">Dans ce cas, vous n’avez pas besoin d’assigner l’événement de réinitialisation manuelle dans la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , et la saisie semi-automatique se produit sur le handle de canal de la même façon qu’une opération asynchrone de lecture ou d’écriture.</span><span class="sxs-lookup"><span data-stu-id="e60f4-131">In this case, you do not need to assign the manual-reset event in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, and the completion happens against the pipe handle in the same way as an asynchronous read or write operation.</span></span> <span data-ttu-id="e60f4-132">Pour plus d’informations, consultez [ports de terminaison d’e/s](/windows/desktop/FileIO/i-o-completion-ports).</span><span class="sxs-lookup"><span data-stu-id="e60f4-132">For more information, see [I/O Completion Ports](/windows/desktop/FileIO/i-o-completion-ports).</span></span>

<span data-ttu-id="e60f4-133">Quand les opérations [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)et [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) sont exécutées de façon asynchrone, l’une des actions suivantes se produit :</span><span class="sxs-lookup"><span data-stu-id="e60f4-133">When [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile), [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile), [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe), and [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) operations are performed asynchronously, one of the following occurs:</span></span>

-   <span data-ttu-id="e60f4-134">Si l’opération est terminée lorsque la fonction retourne, la valeur de retour indique la réussite ou l’échec de l’opération.</span><span class="sxs-lookup"><span data-stu-id="e60f4-134">If the operation is complete when the function returns, the return value indicates the success or failure of the operation.</span></span> <span data-ttu-id="e60f4-135">Si une erreur se produit, la valeur de retour est égale à zéro et la fonction [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) retourne une valeur autre que erreur d' \_ e/s \_ en attente.</span><span class="sxs-lookup"><span data-stu-id="e60f4-135">If an error occurs, the return value is zero and the [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns something other than ERROR\_IO\_PENDING.</span></span>
-   <span data-ttu-id="e60f4-136">Si l’opération n’est pas terminée lorsque la fonction retourne, la valeur de retour est zéro et [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) retourne les \_ e/s d’erreur \_ en attente.</span><span class="sxs-lookup"><span data-stu-id="e60f4-136">If the operation has not finished when the function returns, the return value is zero and [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns ERROR\_IO\_PENDING.</span></span> <span data-ttu-id="e60f4-137">Dans ce cas, le thread appelant doit attendre la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="e60f4-137">In this case, the calling thread must wait until the operation has finished.</span></span> <span data-ttu-id="e60f4-138">Le thread appelant doit ensuite appeler la fonction [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) pour déterminer les résultats.</span><span class="sxs-lookup"><span data-stu-id="e60f4-138">The calling thread must then call the [**GetOverlappedResult**](/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult) function to determine the results.</span></span>

## <a name="using-completion-routines"></a><span data-ttu-id="e60f4-139">Utilisation des routines de saisie semi-automatique</span><span class="sxs-lookup"><span data-stu-id="e60f4-139">Using Completion Routines</span></span>

<span data-ttu-id="e60f4-140">Les fonctions [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) et [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) fournissent une autre forme d’e/s avec chevauchement.</span><span class="sxs-lookup"><span data-stu-id="e60f4-140">The [**ReadFileEx**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) functions provide another form of overlapped I/O.</span></span> <span data-ttu-id="e60f4-141">Contrairement aux fonctions [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) et [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) qui se chevauchent, qui utilisent un objet d’événement pour signaler l’achèvement, les fonctions étendues spécifient une *routine de saisie semi-automatique*.</span><span class="sxs-lookup"><span data-stu-id="e60f4-141">Unlike the overlapped [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) functions, which use an event object to signal completion, the extended functions specify a *completion routine*.</span></span> <span data-ttu-id="e60f4-142">Une routine de saisie semi-automatique est une fonction qui est mise en file d’attente pour l’exécution lorsque l’opération de lecture ou d’écriture est terminée.</span><span class="sxs-lookup"><span data-stu-id="e60f4-142">A completion routine is a function that is queued for execution when the read or write operation is finished.</span></span> <span data-ttu-id="e60f4-143">La routine d’achèvement n’est pas exécutée tant que le thread qui a appelé **ReadFileEx** et **WriteFileEx** n’a pas démarré une opération d' *attente d’alerte* en appelant l’une des [fonctions d’attente alertables](/windows/desktop/Sync/wait-functions) avec le paramètre *fAlertable* défini sur **true**.</span><span class="sxs-lookup"><span data-stu-id="e60f4-143">The completion routine is not executed until the thread that called **ReadFileEx** and **WriteFileEx** starts an *alertable wait operation* by calling one of the [alertable wait functions](/windows/desktop/Sync/wait-functions) with the *fAlertable* parameter set to **TRUE**.</span></span> <span data-ttu-id="e60f4-144">Dans une opération d’attente d’alerte, les fonctions retournent également quand une routine de saisie semi-automatique **ReadFileEx** ou **WriteFileEx** est mise en file d’attente pour exécution.</span><span class="sxs-lookup"><span data-stu-id="e60f4-144">In an alertable wait operation, the functions also return when a **ReadFileEx** or **WriteFileEx** completion routine is queued for execution.</span></span> <span data-ttu-id="e60f4-145">Un serveur de canaux peut utiliser les fonctions étendues pour exécuter une séquence d’opérations de lecture et d’écriture pour chaque client qui se connecte à ce dernier.</span><span class="sxs-lookup"><span data-stu-id="e60f4-145">A pipe server can use the extended functions to perform a sequence of read and write operations for each client that connects to it.</span></span> <span data-ttu-id="e60f4-146">Chaque opération de lecture ou d’écriture dans la séquence spécifie une routine de saisie semi-automatique, et chaque routine de saisie semi-automatique lance l’étape suivante dans la séquence.</span><span class="sxs-lookup"><span data-stu-id="e60f4-146">Each read or write operation in the sequence specifies a completion routine, and each completion routine initiates the next step in the sequence.</span></span> <span data-ttu-id="e60f4-147">Pour obtenir un exemple, consultez [serveur de canaux nommés utilisant les routines de saisie semi-automatique](named-pipe-server-using-completion-routines.md).</span><span class="sxs-lookup"><span data-stu-id="e60f4-147">For an example, see [Named Pipe Server Using Completion Routines](named-pipe-server-using-completion-routines.md).</span></span>

 

 
