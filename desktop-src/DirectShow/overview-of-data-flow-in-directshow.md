---
description: Vue d’ensemble du Data Flow dans DirectShow
ms.assetid: a1b30592-5106-44f5-8ee0-577573670167
title: Vue d’ensemble du Data Flow dans DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5a34444991d6cba62026935f5ec2d7aa4eba77
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104482257"
---
# <a name="overview-of-data-flow-in-directshow"></a><span data-ttu-id="5244c-103">Vue d’ensemble du Data Flow dans DirectShow</span><span class="sxs-lookup"><span data-stu-id="5244c-103">Overview of Data Flow in DirectShow</span></span>

<span data-ttu-id="5244c-104">Cette section fournit une vue d’ensemble générale du fonctionnement du workflow dans DirectShow.</span><span class="sxs-lookup"><span data-stu-id="5244c-104">This section gives a broad overview of how data flow works in DirectShow.</span></span> <span data-ttu-id="5244c-105">Vous trouverez plus d’informations dans d’autres sections de la documentation.</span><span class="sxs-lookup"><span data-stu-id="5244c-105">Details can be found in other sections of the documentation.</span></span>

<span data-ttu-id="5244c-106">Les données sont conservées dans des mémoires tampons, qui sont simplement des tableaux d’octets.</span><span class="sxs-lookup"><span data-stu-id="5244c-106">Data is held in buffers, which are simply arrays of bytes.</span></span> <span data-ttu-id="5244c-107">Chaque mémoire tampon est encapsulée par un objet COM appelé *exemple de média*, qui implémente l’interface [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="5244c-107">Each buffer is wrapped by a COM object called a *media sample*, which implements the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="5244c-108">Les exemples sont créés par un autre type d’objet, appelé Allocator, qui implémente l’interface [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="5244c-108">Samples are created by another type of object, called an allocator, which implements the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="5244c-109">Un allocateur est attribué pour chaque connexion de code confidentiel, bien que deux connexions de code confidentiel ou plus peuvent partager le même allocateur.</span><span class="sxs-lookup"><span data-stu-id="5244c-109">An allocator is assigned for every pin connection, although two or more pin connections might share the same allocator.</span></span> <span data-ttu-id="5244c-110">L’illustration suivante montre ce processus.</span><span class="sxs-lookup"><span data-stu-id="5244c-110">The following image illustrates this process.</span></span>

![mémoires tampons, exemples et allocators](images/dataflow.png)

<span data-ttu-id="5244c-112">Chaque allocateur crée un pool d’exemples de supports et alloue les tampons pour chaque exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-112">Each allocator creates a pool of media samples and allocates the buffers for each sample.</span></span> <span data-ttu-id="5244c-113">Chaque fois qu’un filtre doit remplir une mémoire tampon avec des données, il demande un exemple à partir de l’allocateur en appelant [**IMemAllocator :: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="5244c-113">Whenever a filter needs to fill a buffer with data, it requests a sample from the allocator by calling [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="5244c-114">Si l’allocateur a des échantillons qui ne sont pas actuellement utilisés par un autre filtre, la méthode **GetBuffer** retourne immédiatement avec un pointeur vers l’exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-114">If the allocator has any samples that are not currently in use by another filter, the **GetBuffer** method returns immediately with a pointer to the sample.</span></span> <span data-ttu-id="5244c-115">Si tous les exemples de l’allocateur sont en cours d’utilisation, la méthode se bloque jusqu’à ce qu’un exemple devienne disponible.</span><span class="sxs-lookup"><span data-stu-id="5244c-115">If all of the allocator's samples are in use, the method blocks until a sample becomes available.</span></span> <span data-ttu-id="5244c-116">Lorsque la méthode retourne un exemple, le filtre place les données dans la mémoire tampon, définit les indicateurs appropriés sur l’échantillon (en général, en incluant un horodatage) et remet l’exemple en aval.</span><span class="sxs-lookup"><span data-stu-id="5244c-116">When the method does return a sample, the filter puts data into the buffer, sets the appropriate flags on the sample (typically including a time stamp), and delivers the sample downstream.</span></span>

<span data-ttu-id="5244c-117">Lorsqu’un filtre de convertisseur reçoit un exemple, il vérifie l’horodatage et le maintient sur l’exemple jusqu’à ce que l’horloge de référence du graphique de filtre indique que les données doivent être rendues.</span><span class="sxs-lookup"><span data-stu-id="5244c-117">When a renderer filter receives a sample, it checks the time stamp and holds onto the sample until the filter graph's reference clock indicates that the data should be rendered.</span></span> <span data-ttu-id="5244c-118">Une fois que le filtre a rendu les données, il libère l’exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-118">After the filter renders the data, it releases the sample.</span></span> <span data-ttu-id="5244c-119">L’exemple ne repasse pas dans le pool d’exemples de l’allocateur tant que le nombre de références de l’exemple n’est pas égal à zéro, ce qui signifie que chaque filtre a libéré l’exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-119">The sample does not go back into the allocator's pool of samples until the sample's reference count is zero, meaning that every filter has released the sample.</span></span> <span data-ttu-id="5244c-120">L’illustration suivante montre ce processus.</span><span class="sxs-lookup"><span data-stu-id="5244c-120">The following image illustrates this process.</span></span>

![décodeur en attente d’un exemple de support gratuit](images/dataflow2.png)

<span data-ttu-id="5244c-122">Le filtre en amont peut s’exécuter avant le convertisseur, autrement dit, il peut remplir les mémoires tampons plus rapidement que le convertisseur ne les consomme.</span><span class="sxs-lookup"><span data-stu-id="5244c-122">The upstream filter might run ahead of the renderer — that is, it might fill buffers faster than the renderer consumes them.</span></span> <span data-ttu-id="5244c-123">Même dans ce cas, les exemples ne sont pas rendus tôt, car le convertisseur conserve chaque fois son heure de présentation.</span><span class="sxs-lookup"><span data-stu-id="5244c-123">Even so, samples do not get rendered early, because the renderer holds each until its presentation time.</span></span> <span data-ttu-id="5244c-124">En outre, le filtre amont ne remplace pas les tampons par inadvertance, car **méthode getsample** retourne uniquement des exemples qui ne sont pas en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="5244c-124">Moreover, the upstream filter will not overwrite buffers accidentally, because **GetSample** only returns samples that are not otherwise in use.</span></span> <span data-ttu-id="5244c-125">La quantité d’exécution du filtre en amont est déterminée par le nombre d’échantillons dans le pool de l’allocateur.</span><span class="sxs-lookup"><span data-stu-id="5244c-125">The amount by which the upstream filter can run ahead is determined by the number of samples in the allocator's pool.</span></span>

<span data-ttu-id="5244c-126">Le diagramme précédent n’affiche qu’un seul allocateur, mais il existe généralement plusieurs allocateurs par flux.</span><span class="sxs-lookup"><span data-stu-id="5244c-126">The previous diagram only shows one allocator, but typically there are several allocators per stream.</span></span> <span data-ttu-id="5244c-127">Ainsi, lorsque le convertisseur libère un exemple, il peut avoir un effet en cascade.</span><span class="sxs-lookup"><span data-stu-id="5244c-127">Thus, when the renderer releases a sample, it can have a cascading effect.</span></span> <span data-ttu-id="5244c-128">Le diagramme suivant illustre une situation où un décodeur contient une image vidéo compressée pendant qu’il attend que le convertisseur libère un exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-128">The following diagram shows a situation where a decoder holds a compressed video frame while it waits for the renderer to release a sample.</span></span> <span data-ttu-id="5244c-129">Un filtre d’analyseur attend également que le décodeur libère un exemple.</span><span class="sxs-lookup"><span data-stu-id="5244c-129">A parser filter is also waiting for the decoder to release a sample.</span></span>

![deux filtres en attente d’exemples](images/dataflow3.png)

<span data-ttu-id="5244c-131">Quand le convertisseur libère son exemple, l’appel en attente du décodeur à **GetBuffer** retourne.</span><span class="sxs-lookup"><span data-stu-id="5244c-131">When the renderer releases its sample, the decoder's pending call to **GetBuffer** returns.</span></span> <span data-ttu-id="5244c-132">Le décodeur peut ensuite décoder la trame vidéo compressée et libérer l’exemple qu’il a bloqué, ce qui a pour effet de débloquer l’appel **GetBuffer** en attente de l’analyseur.</span><span class="sxs-lookup"><span data-stu-id="5244c-132">The decoder can then decode the compressed video frame and release the sample it was holding, thereby unblocking the parser's pending **GetBuffer** call.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5244c-133">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="5244c-133">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="5244c-134">Data Flow dans le graphique de filtre</span><span class="sxs-lookup"><span data-stu-id="5244c-134">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



