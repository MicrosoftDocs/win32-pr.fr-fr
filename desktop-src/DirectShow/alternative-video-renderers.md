---
description: Cette rubrique explique comment écrire un convertisseur vidéo personnalisé pour DirectShow.
ms.assetid: abba5113-125f-4dac-b566-99c0d9b5978c
title: Autres convertisseurs vidéo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 070e55375d9d1d5a32c306853aafcb431a76c368
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "103747277"
---
# <a name="alternative-video-renderers"></a><span data-ttu-id="e690c-103">Autres convertisseurs vidéo</span><span class="sxs-lookup"><span data-stu-id="e690c-103">Alternative Video Renderers</span></span>

<span data-ttu-id="e690c-104">Cette rubrique explique comment écrire un convertisseur vidéo personnalisé pour DirectShow.</span><span class="sxs-lookup"><span data-stu-id="e690c-104">This topic describes how to write a custom video renderer for DirectShow.</span></span>

> [!Note]  
> <span data-ttu-id="e690c-105">Au lieu d’écrire un convertisseur vidéo personnalisé, il est recommandé d’écrire un allocateur de plug-in pour le convertisseur de mixage vidéo (VMR) ou le [**convertisseur vidéo amélioré**](enhanced-video-renderer-filter.md) (EVR).</span><span class="sxs-lookup"><span data-stu-id="e690c-105">Instead of writing a custom video renderer, it is recommended that you write a plug-in allocator-presenter for the Video Mixing Renderer (VMR) or [**Enhanced Video Renderer**](enhanced-video-renderer-filter.md) (EVR).</span></span> <span data-ttu-id="e690c-106">Cette approche vous offre tous les avantages de VMR/EVR, y compris la prise en charge de DirectX Video Acceleration (DXVA), le désentrelacement matériel et le pas à pas, et est susceptible d’être plus robuste qu’un convertisseur vidéo personnalisé.</span><span class="sxs-lookup"><span data-stu-id="e690c-106">This approach will give you all of the benefits of the VMR/EVR, including support for DirectX Video Acceleration (DXVA), hardware deinterlacing, and frame stepping, and is likely to be more robust than a custom video renderer.</span></span> <span data-ttu-id="e690c-107">Pour plus d'informations, voir les rubriques suivantes :</span><span class="sxs-lookup"><span data-stu-id="e690c-107">For more information, see the following topics:</span></span>
>
> -   [<span data-ttu-id="e690c-108">Mode de lecture non rendu VMR (Allocator personnalisé-présentateur)</span><span class="sxs-lookup"><span data-stu-id="e690c-108">VMR Renderless Playback Mode (Custom Allocator-Presenters)</span></span>](vmr-renderless-playback-mode--custom-allocator-presenters.md)
> -   [<span data-ttu-id="e690c-109">Comment écrire un présentateur EVR</span><span class="sxs-lookup"><span data-stu-id="e690c-109">How to Write an EVR Presenter</span></span>](/windows/desktop/medfound/how-to-write-an-evr-presenter)

 

## <a name="writing-an-alternative-renderer"></a><span data-ttu-id="e690c-110">Écriture d’un convertisseur de remplacement</span><span class="sxs-lookup"><span data-stu-id="e690c-110">Writing an Alternative Renderer</span></span>

<span data-ttu-id="e690c-111">Microsoft DirectShow fournit un convertisseur vidéo basé sur une fenêtre ; Il fournit également un convertisseur plein écran dans l’installation.</span><span class="sxs-lookup"><span data-stu-id="e690c-111">Microsoft DirectShow provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation.</span></span> <span data-ttu-id="e690c-112">Vous pouvez utiliser les classes de base DirectShow pour écrire d’autres convertisseurs vidéo.</span><span class="sxs-lookup"><span data-stu-id="e690c-112">You can use the DirectShow base classes to write alternative video renderers.</span></span> <span data-ttu-id="e690c-113">Pour que d’autres convertisseurs interagissent correctement avec les applications DirectShow, les convertisseurs doivent respecter les instructions décrites dans cet article.</span><span class="sxs-lookup"><span data-stu-id="e690c-113">For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article.</span></span> <span data-ttu-id="e690c-114">Vous pouvez utiliser les classes [**CBaseRenderer**](cbaserenderer.md) et [**CBaseVideoRenderer**](cbasevideorenderer.md) pour suivre ces instructions lors de l’implémentation d’un rendu de vidéo alternatif.</span><span class="sxs-lookup"><span data-stu-id="e690c-114">You can use the [**CBaseRenderer**](cbaserenderer.md) and [**CBaseVideoRenderer**](cbasevideorenderer.md) classes to help follow these guidelines when implementing an alternative video render.</span></span> <span data-ttu-id="e690c-115">En raison du développement en cours de DirectShow, examinez régulièrement votre implémentation pour vous assurer que les convertisseurs sont compatibles avec la version la plus récente de DirectShow.</span><span class="sxs-lookup"><span data-stu-id="e690c-115">Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.</span></span>

<span data-ttu-id="e690c-116">Cette rubrique traite de nombreuses notifications qu’un convertisseur est responsable de la gestion.</span><span class="sxs-lookup"><span data-stu-id="e690c-116">This topic discusses many notifications that a renderer is responsible for handling.</span></span> <span data-ttu-id="e690c-117">Un bref aperçu des notifications DirectShow peut vous aider à définir la phase.</span><span class="sxs-lookup"><span data-stu-id="e690c-117">A brief review of DirectShow notifications might help to set the stage.</span></span> <span data-ttu-id="e690c-118">Il existe essentiellement trois types de notifications qui se produisent dans DirectShow :</span><span class="sxs-lookup"><span data-stu-id="e690c-118">There are essentially three kinds of notifications that occur in DirectShow:</span></span>

-   <span data-ttu-id="e690c-119">Les *notifications de flux*, qui sont des événements qui se produisent dans le flux de média et sont passées d’un filtre à l’autre.</span><span class="sxs-lookup"><span data-stu-id="e690c-119">*Stream notifications*, which are events that occur in the media stream and are passed from one filter to the next.</span></span> <span data-ttu-id="e690c-120">Il peut s’agir de début, de vidage ou de notifications de fin de flux et sont envoyés en appelant la méthode appropriée sur la broche d’entrée du filtre en aval (par exemple [**IPIN :: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span><span class="sxs-lookup"><span data-stu-id="e690c-120">These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the downstream filter's input pin (for example [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush)).</span></span>
-   <span data-ttu-id="e690c-121">*Filtrez les notifications de graphique*, qui sont des événements envoyés à partir d’un filtre au gestionnaire de graphique de filtre, par exemple [**EC \_ Complete**](ec-complete.md).</span><span class="sxs-lookup"><span data-stu-id="e690c-121">*Filter graph notifications*, which are events sent from a filter to the Filter Graph Manager such as [**EC\_COMPLETE**](ec-complete.md).</span></span> <span data-ttu-id="e690c-122">Pour ce faire, vous devez appeler la méthode [**IMediaEventSink :: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) sur le gestionnaire de graphique de filtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-122">This is accomplished by calling the [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) method on the Filter Graph Manager.</span></span>
-   <span data-ttu-id="e690c-123">Les *notifications d’application*, qui sont récupérées à partir du gestionnaire de graphique de filtre par l’application de contrôle.</span><span class="sxs-lookup"><span data-stu-id="e690c-123">*Application notifications*, which are retrieved from the Filter Graph Manager by the controlling application.</span></span> <span data-ttu-id="e690c-124">Une application appelle la méthode [**IMediaEvent :: GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) sur le gestionnaire de graphique de filtre pour récupérer ces événements.</span><span class="sxs-lookup"><span data-stu-id="e690c-124">An application calls the [**IMediaEvent::GetEvent**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) method on the Filter Graph Manager to retrieve these events.</span></span> <span data-ttu-id="e690c-125">Souvent, le gestionnaire de graphique de filtre traverse les événements qu’il reçoit à l’application.</span><span class="sxs-lookup"><span data-stu-id="e690c-125">Often, the Filter Graph Manager passes through the events it receives to the application.</span></span>

<span data-ttu-id="e690c-126">Cette rubrique décrit la responsabilité du filtre de convertisseur dans la gestion des notifications de flux qu’il reçoit et dans l’envoi de notifications de graphique de filtre appropriées.</span><span class="sxs-lookup"><span data-stu-id="e690c-126">This topic discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph notifications.</span></span>

## <a name="handling-end-of-stream-and-flushing-notifications"></a><span data-ttu-id="e690c-127">Gestion des notifications de fin de flux et de vidage</span><span class="sxs-lookup"><span data-stu-id="e690c-127">Handling End-of-stream and Flushing Notifications</span></span>

<span data-ttu-id="e690c-128">Une notification de fin de flux commence au niveau d’un filtre amont (tel que le filtre source) lorsque ce filtre détecte qu’il ne peut pas envoyer plus de données.</span><span class="sxs-lookup"><span data-stu-id="e690c-128">An end-of-stream notification begins at an upstream filter (such as the source filter) when that filter detects that it can send no more data.</span></span> <span data-ttu-id="e690c-129">Elle est passée par chaque filtre dans le graphique et finit par se terminer au niveau du convertisseur, qui est responsable de l’envoi par la suite d’une notification d' [**\_ achèvement ce**](ec-complete.md) au gestionnaire de graphes de filtres.</span><span class="sxs-lookup"><span data-stu-id="e690c-129">It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e690c-130">Les convertisseurs ont des responsabilités spéciales lorsqu’il s’agit de gérer ces notifications.</span><span class="sxs-lookup"><span data-stu-id="e690c-130">Renderers have special responsibilities when it comes to handling these notifications.</span></span>

<span data-ttu-id="e690c-131">Un convertisseur reçoit une notification de fin de flux lorsque la méthode [**IPIN :: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) de son pin d’entrée est appelée par le filtre amont.</span><span class="sxs-lookup"><span data-stu-id="e690c-131">A renderer receives an end-of-stream notification when its input pin's [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) method is called by the upstream filter.</span></span> <span data-ttu-id="e690c-132">Un convertisseur doit noter cette notification et continuer à afficher toutes les données qu’il a déjà reçues.</span><span class="sxs-lookup"><span data-stu-id="e690c-132">A renderer should note this notification and continue to render any data it has already received.</span></span> <span data-ttu-id="e690c-133">Une fois que toutes les données restantes ont été reçues, le convertisseur doit envoyer une notification d' [**\_ achèvement ce**](ec-complete.md) au gestionnaire de graphes de filtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-133">Once all remaining data has been received, the renderer should send an [**EC\_COMPLETE**](ec-complete.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e690c-134">La notification d' **\_ achèvement ce** ne doit être envoyée qu’une seule fois par un convertisseur à chaque fois qu’elle atteint la fin d’un flux.</span><span class="sxs-lookup"><span data-stu-id="e690c-134">The **EC\_COMPLETE** notification should be sent only once by a renderer each time it reaches the end of a stream.</span></span> <span data-ttu-id="e690c-135">En outre, les notifications d' **\_ achèvement ce** ne doivent jamais être envoyées, sauf lorsque le graphique de filtre est en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="e690c-135">Furthermore, **EC\_COMPLETE** notifications must never be sent except when the filter graph is running.</span></span> <span data-ttu-id="e690c-136">Par conséquent, si le graphique de filtre est suspendu lorsqu’un filtre source envoie une notification de fin de flux, **ce dernier \_** ne doit pas être envoyé tant que le graphique de filtre n’est pas exécuté.</span><span class="sxs-lookup"><span data-stu-id="e690c-136">Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then **EC\_COMPLETE** should not be sent until the filter graph is finally run.</span></span>

<span data-ttu-id="e690c-137">Tous les appels aux méthodes [**IMemInputPin :: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou [**IMemInputPin :: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) après une notification de fin de flux signalée doivent être rejetés.</span><span class="sxs-lookup"><span data-stu-id="e690c-137">Any calls to the [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple) methods after an end-of-stream notification is signaled should be rejected.</span></span> <span data-ttu-id="e690c-138">**E \_ INATTENDU** est le message d’erreur le plus approprié à retourner dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="e690c-138">**E\_UNEXPECTED** is the most appropriate error message to return in this case.</span></span>

<span data-ttu-id="e690c-139">Lorsqu’un graphique de filtre est arrêté, toutes les notifications de fin de flux mises en cache doivent être effacées et ne pas être renvoyées au prochain démarrage.</span><span class="sxs-lookup"><span data-stu-id="e690c-139">When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started.</span></span> <span data-ttu-id="e690c-140">Cela est dû au fait que le gestionnaire de graphique de filtre suspend toujours tous les filtres juste avant de les exécuter afin que le vidage correct se produise.</span><span class="sxs-lookup"><span data-stu-id="e690c-140">This is because the Filter Graph Manager always pauses all filters just before running them so that proper flushing occurs.</span></span> <span data-ttu-id="e690c-141">Ainsi, par exemple, si le graphique de filtre est suspendu et qu’une notification de fin de flux est reçue, puis que le graphique de filtre est arrêté, le convertisseur ne doit pas envoyer de notification d' [**\_ achèvement ce**](ec-complete.md) lorsqu’il est exécuté par la suite.</span><span class="sxs-lookup"><span data-stu-id="e690c-141">So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an [**EC\_COMPLETE**](ec-complete.md) notification when it is subsequently run.</span></span> <span data-ttu-id="e690c-142">Si aucune recherche n’a eu lieu, le filtre source envoie automatiquement une autre notification de fin de flux lors de l’état de pause qui précède un état d’exécution.</span><span class="sxs-lookup"><span data-stu-id="e690c-142">If no seeks have occurred, the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state.</span></span> <span data-ttu-id="e690c-143">Si, en revanche, une recherche s’est produite alors que le graphique de filtre est arrêté, le filtre source peut contenir des données à envoyer, de sorte qu’il n’envoie pas de notification de fin de flux.</span><span class="sxs-lookup"><span data-stu-id="e690c-143">If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.</span></span>

<span data-ttu-id="e690c-144">Les convertisseurs vidéo dépendent souvent des notifications de fin de flux pour plus que l’envoi des notifications [**\_ complètes EC**](ec-complete.md) .</span><span class="sxs-lookup"><span data-stu-id="e690c-144">Video renderers often depend on end-of-stream notifications for more than the sending of [**EC\_COMPLETE**](ec-complete.md) notifications.</span></span> <span data-ttu-id="e690c-145">Par exemple, si un flux a fini de s’exécuter (autrement dit, une notification de fin de flux est envoyée) et qu’une autre fenêtre est glissée sur une fenêtre de convertisseur vidéo, un certain nombre de messages de fenêtre de [**\_ peinture WM**](/windows/desktop/gdi/wm-paint) seront générés.</span><span class="sxs-lookup"><span data-stu-id="e690c-145">For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) window messages will be generated.</span></span> <span data-ttu-id="e690c-146">La pratique courante pour l’exécution de convertisseurs vidéo consiste à ne pas redessiner le frame en cours lors de la réception des messages de **\_ peinture WM** (en partant de l’hypothèse qu’une autre image à dessiner sera reçue).</span><span class="sxs-lookup"><span data-stu-id="e690c-146">The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of **WM\_PAINT** messages (based on the assumption that another frame to be drawn will be received).</span></span> <span data-ttu-id="e690c-147">Toutefois, lorsque la notification de fin de flux a été envoyée, le convertisseur est dans un état d’attente ; Il est toujours en cours d’exécution, mais il est conscient qu’il ne recevra pas de données supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="e690c-147">However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data.</span></span> <span data-ttu-id="e690c-148">Dans ces circonstances, le convertisseur dessine habituellement la zone de lecture en noir.</span><span class="sxs-lookup"><span data-stu-id="e690c-148">Under these circumstances, the renderer customarily draws the playback area black.</span></span>

<span data-ttu-id="e690c-149">La gestion du vidage est une complication supplémentaire pour les convertisseurs.</span><span class="sxs-lookup"><span data-stu-id="e690c-149">Handling flushing is an additional complication for renderers.</span></span> <span data-ttu-id="e690c-150">Le vidage est effectué via une paire de méthodes [**IPIN**](/windows/desktop/api/Strmif/nn-strmif-ipin) appelée [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) et [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="e690c-150">Flushing is carried out through a pair of [**IPin**](/windows/desktop/api/Strmif/nn-strmif-ipin) methods called [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) and [**EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span> <span data-ttu-id="e690c-151">Le vidage est essentiellement un État supplémentaire qui doit être géré par le convertisseur.</span><span class="sxs-lookup"><span data-stu-id="e690c-151">Flushing is essentially an additional state that the renderer must handle.</span></span> <span data-ttu-id="e690c-152">Il est interdit pour un filtre source d’appeler **BeginFlush** sans appeler **EndFlush**, si bien que l’État est short et discret. Toutefois, le convertisseur doit gérer correctement les données ou les notifications qu’il reçoit pendant la transition de vidage.</span><span class="sxs-lookup"><span data-stu-id="e690c-152">It is illegal for a source filter to call **BeginFlush** without calling **EndFlush**, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.</span></span>

<span data-ttu-id="e690c-153">Toutes les données reçues après l’appel de [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) doivent être rejetées immédiatement en renvoyant **S \_ false**.</span><span class="sxs-lookup"><span data-stu-id="e690c-153">Any data received after calling [**BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) should be rejected immediately by returning **S\_FALSE**.</span></span> <span data-ttu-id="e690c-154">En outre, toutes les notifications de fin de flux mises en cache doivent également être effacées lorsqu’un convertisseur est vidé.</span><span class="sxs-lookup"><span data-stu-id="e690c-154">Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed.</span></span> <span data-ttu-id="e690c-155">Un convertisseur est généralement vidé en réponse à une recherche.</span><span class="sxs-lookup"><span data-stu-id="e690c-155">A renderer will typically be flushed in response to a seek.</span></span> <span data-ttu-id="e690c-156">Le vidage garantit que les anciennes données sont effacées du graphique de filtre avant l’envoi des échantillons actualisés.</span><span class="sxs-lookup"><span data-stu-id="e690c-156">The flush ensures that old data is cleared from the filter graph before fresh samples are sent.</span></span> <span data-ttu-id="e690c-157">(En général, la lecture de deux sections d’un flux, l’une après l’autre, est mieux gérée via des commandes différées plutôt que d’attendre la fin d’une section, puis d’émettre une commande Seek.)</span><span class="sxs-lookup"><span data-stu-id="e690c-157">(Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.)</span></span>

## <a name="handling-state-changes-and-pause-completion"></a><span data-ttu-id="e690c-158">Gestion des modifications d’État et suspension de la fin</span><span class="sxs-lookup"><span data-stu-id="e690c-158">Handling State Changes and Pause Completion</span></span>

<span data-ttu-id="e690c-159">Un filtre de convertisseur se comporte de la même façon que n’importe quel autre filtre dans le graphique de filtre quand son état est modifié, avec l’exception suivante.</span><span class="sxs-lookup"><span data-stu-id="e690c-159">A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception.</span></span> <span data-ttu-id="e690c-160">Après avoir été suspendue, le convertisseur aura des données mises en file d’attente, prêtes à être rendues lors de l’exécution ultérieure.</span><span class="sxs-lookup"><span data-stu-id="e690c-160">After being paused, the renderer will have some data queued, ready to be rendered when subsequently run.</span></span> <span data-ttu-id="e690c-161">Quand le convertisseur vidéo est arrêté, il conserve les données en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e690c-161">When the video renderer is stopped, it holds on to this queued data.</span></span> <span data-ttu-id="e690c-162">Il s’agit d’une exception à la règle DirectShow qui indique qu’aucune ressource ne doit être maintenue par les filtres pendant l’arrêt du graphique de filtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-162">This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.</span></span>

<span data-ttu-id="e690c-163">La raison de cette exception est qu’en détenant des ressources, le convertisseur aura toujours une image avec laquelle redessiner la fenêtre si elle reçoit un message [**de \_ peinture WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="e690c-163">The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message.</span></span> <span data-ttu-id="e690c-164">Elle dispose également d’une image pour satisfaire les méthodes, telles que [**CBaseControlVideo :: GetStaticImage**](cbasecontrolvideo-getstaticimage.md), qui demandent une copie de l’image actuelle.</span><span class="sxs-lookup"><span data-stu-id="e690c-164">It also has an image to satisfy methods, such as [**CBaseControlVideo::GetStaticImage**](cbasecontrolvideo-getstaticimage.md), that request a copy of the current image.</span></span> <span data-ttu-id="e690c-165">L’un des autres effets de la conservation des ressources est que la conservation de l’allocation empêche l’allocateur d’être dévalidée, ce qui à son tour rend le changement d’état suivant beaucoup plus rapide, car les mémoires tampons d’images sont déjà allouées.</span><span class="sxs-lookup"><span data-stu-id="e690c-165">Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.</span></span>

<span data-ttu-id="e690c-166">Un convertisseur vidéo ne doit afficher et libérer des exemples qu’en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="e690c-166">A video renderer should render and release samples only while running.</span></span> <span data-ttu-id="e690c-167">Lorsqu’il est suspendu, le filtre peut les restituer (par exemple, lors du dessin d’une image d’affiche statique dans une fenêtre), mais ne doit pas les libérer.</span><span class="sxs-lookup"><span data-stu-id="e690c-167">While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them.</span></span> <span data-ttu-id="e690c-168">Les convertisseurs audio n’effectuent aucun rendu en pause (même s’ils peuvent exécuter d’autres activités, telles que la préparation du périphérique Wave, par exemple).</span><span class="sxs-lookup"><span data-stu-id="e690c-168">Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example).</span></span> <span data-ttu-id="e690c-169">L’heure à laquelle les exemples doivent être rendus est obtenue en combinant le temps de flux dans l’exemple avec le temps de référence passé comme paramètre à la méthode [**IMediaControl :: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) .</span><span class="sxs-lookup"><span data-stu-id="e690c-169">The time at which the samples should be rendered is obtained by combining the stream time in the sample with the reference time passed as a parameter to the [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run) method.</span></span> <span data-ttu-id="e690c-170">Les convertisseurs doivent rejeter les échantillons avec des heures de début inférieures ou égales aux heures de fin.</span><span class="sxs-lookup"><span data-stu-id="e690c-170">Renderers should reject samples with start times less than or equal to end times.</span></span>

<span data-ttu-id="e690c-171">Quand une application suspend un graphique de filtre, le graphique de filtre ne retourne pas à partir de sa méthode [**IMediaControl ::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) jusqu’à ce que des données soient mises en file d’attente au niveau des convertisseurs.</span><span class="sxs-lookup"><span data-stu-id="e690c-171">When an application pauses a filter graph, the filter graph does not return from its [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause) method until there is data queued at the renderers.</span></span> <span data-ttu-id="e690c-172">Pour ce faire, quand un convertisseur est suspendu, il doit retourner S \_ false s’il n’y a aucune donnée en attente d’être rendue.</span><span class="sxs-lookup"><span data-stu-id="e690c-172">In order to ensure this, when a renderer is paused, it should return S\_FALSE if there is no data waiting to be rendered.</span></span> <span data-ttu-id="e690c-173">Si des données sont mises en file d’attente, elles peuvent retourner **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="e690c-173">If it has data queued, then it can return **S\_OK**.</span></span>

<span data-ttu-id="e690c-174">Le gestionnaire de graphique de filtre vérifie toutes les valeurs de retour lors de la suspension d’un graphique de filtre, pour s’assurer que les convertisseurs comportent des données mises en file d’attente.</span><span class="sxs-lookup"><span data-stu-id="e690c-174">The Filter Graph Manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued.</span></span> <span data-ttu-id="e690c-175">Si un ou plusieurs filtres ne sont pas prêts, le gestionnaire de graphes de filtres interroge les filtres dans le graphique en appelant [**IMediaFilter :: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span><span class="sxs-lookup"><span data-stu-id="e690c-175">If one or more filters are not ready, then the Filter Graph Manager polls the filters in the graph by calling [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate).</span></span> <span data-ttu-id="e690c-176">La méthode **GetState** prend un paramètre de délai d’attente.</span><span class="sxs-lookup"><span data-stu-id="e690c-176">The **GetState** method takes a time-out parameter.</span></span> <span data-ttu-id="e690c-177">Un filtre (en général un convertisseur) qui attend toujours l’arrivée des données avant de terminer la modification d’État retourne le niveau intermédiaire de l' **État de VFW \_ \_ \_ S** si la méthode **GetState** expire.</span><span class="sxs-lookup"><span data-stu-id="e690c-177">A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns **VFW\_S\_STATE\_INTERMEDIATE** if the **GetState** method expires.</span></span> <span data-ttu-id="e690c-178">Une fois que les données arrivent au convertisseur, **GetState** doit être renvoyé immédiatement avec la fonction **S \_ OK**.</span><span class="sxs-lookup"><span data-stu-id="e690c-178">Once data arrives at the renderer, **GetState** should be returned immediately with **S\_OK**.</span></span>

<span data-ttu-id="e690c-179">Dans l’état intermédiaire et terminé, l’état du filtre signalé sera \_ suspendu.</span><span class="sxs-lookup"><span data-stu-id="e690c-179">In both the intermediate and completed state, the reported filter state will be State\_Paused.</span></span> <span data-ttu-id="e690c-180">Seule la valeur de retour indique si le filtre est vraiment prêt ou non.</span><span class="sxs-lookup"><span data-stu-id="e690c-180">Only the return value indicates whether the filter is really ready or not.</span></span> <span data-ttu-id="e690c-181">Si, pendant qu’un convertisseur attend que les données arrivent, son filtre source envoie une notification de fin de flux, qui doit également terminer le changement d’État.</span><span class="sxs-lookup"><span data-stu-id="e690c-181">If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.</span></span>

<span data-ttu-id="e690c-182">Une fois que tous les filtres ont des données en attente d’être rendues, le graphique de filtre termine le changement d’état de pause.</span><span class="sxs-lookup"><span data-stu-id="e690c-182">Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.</span></span>

## <a name="handling-termination"></a><span data-ttu-id="e690c-183">Gestion de l’arrêt</span><span class="sxs-lookup"><span data-stu-id="e690c-183">Handling Termination</span></span>

<span data-ttu-id="e690c-184">Les convertisseurs vidéo doivent gérer correctement les événements d’arrêt à partir de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="e690c-184">Video renderers must correctly handle termination events from the user.</span></span> <span data-ttu-id="e690c-185">Cela implique de masquer correctement la fenêtre et de savoir comment faire si une fenêtre est forcée à être affichée par la suite.</span><span class="sxs-lookup"><span data-stu-id="e690c-185">This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed.</span></span> <span data-ttu-id="e690c-186">En outre, les convertisseurs vidéo doivent notifier le gestionnaire de graphique de filtre quand la fenêtre est détruite (ou plus précisément, lorsque le convertisseur est supprimé du graphique de filtre) pour libérer des ressources.</span><span class="sxs-lookup"><span data-stu-id="e690c-186">Also, video renderers must notify the Filter Graph Manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.</span></span>

<span data-ttu-id="e690c-187">Si l’utilisateur ferme la fenêtre vidéo (par exemple en appuyant sur ALT + F4), la Convention consiste à masquer immédiatement la fenêtre et à envoyer une notification [**\_ USERABORT ce**](ec-userabort.md) au gestionnaire du graphique de filtres.</span><span class="sxs-lookup"><span data-stu-id="e690c-187">If the user closes the video window (for instance by pressing ALT+F4), the convention is to hide the window immediately and send an [**EC\_USERABORT**](ec-userabort.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e690c-188">Cette notification est transmise à l’application, ce qui entraîne l’arrêt de la diffusion du graphique.</span><span class="sxs-lookup"><span data-stu-id="e690c-188">This notification is passed through to the application, which will stop the graph playing.</span></span> <span data-ttu-id="e690c-189">Après l’envoi de la **\_ USERABORT EC**, un convertisseur vidéo doit rejeter tous les échantillons supplémentaires qui lui sont livrés.</span><span class="sxs-lookup"><span data-stu-id="e690c-189">After sending **EC\_USERABORT**, a video renderer should reject any additional samples delivered to it.</span></span>

<span data-ttu-id="e690c-190">L’indicateur Graph-Stopped doit être laissé activé par le convertisseur jusqu’à ce qu’il soit arrêté par la suite. à partir de là, il doit être réinitialisé pour qu’une application puisse substituer l’action de l’utilisateur et poursuivre la diffusion du graphique si elle le souhaite.</span><span class="sxs-lookup"><span data-stu-id="e690c-190">The graph-stopped flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an application can override the user action and continue playing the graph if it desires.</span></span> <span data-ttu-id="e690c-191">Si vous appuyez sur ALT + F4 pendant que la vidéo est en cours d’exécution, la fenêtre est masquée et tous les autres exemples livrés sont rejetés.</span><span class="sxs-lookup"><span data-stu-id="e690c-191">If ALT+F4 is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected.</span></span> <span data-ttu-id="e690c-192">Si la fenêtre est affichée par la suite (peut-être par le biais de [**IVideoWindow ::p ut \_ visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), aucune notification de [**\_ redessin ce**](ec-repaint.md) ne doit être générée.</span><span class="sxs-lookup"><span data-stu-id="e690c-192">If the window is subsequently shown (perhaps through [**IVideoWindow::put\_Visible**](/windows/desktop/api/Control/nf-control-ivideowindow-put_visible)), then no [**EC\_REPAINT**](ec-repaint.md) notifications should be generated.</span></span>

<span data-ttu-id="e690c-193">Le convertisseur vidéo doit également envoyer la notification [**\_ \_ détruite de la fenêtre EC**](ec-window-destroyed.md) au graphique de filtre lorsque le convertisseur vidéo se termine.</span><span class="sxs-lookup"><span data-stu-id="e690c-193">The video renderer should also send the [**EC\_WINDOW\_DESTROYED**](ec-window-destroyed.md) notification to the filter graph when the video renderer is terminating.</span></span> <span data-ttu-id="e690c-194">En fait, il est préférable de gérer cela quand la méthode [**IBaseFilter :: JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) du convertisseur est appelée avec un paramètre null (indiquant que le convertisseur est sur le point d’être supprimé du graphique de filtre), au lieu d’attendre la destruction de la fenêtre vidéo réelle.</span><span class="sxs-lookup"><span data-stu-id="e690c-194">In fact, it is best to handle this when the renderer's [**IBaseFilter::JoinFilterGraph**](/windows/desktop/api/Strmif/nf-strmif-ibasefilter-joinfiltergraph) method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed.</span></span> <span data-ttu-id="e690c-195">L’envoi de cette notification permet au serveur de distribution du plug-in du gestionnaire de graphes de filtrer de transmettre les ressources qui dépendent du focus de la fenêtre vers d’autres filtres, tels que les périphériques audio.</span><span class="sxs-lookup"><span data-stu-id="e690c-195">Sending this notification enables the plug-in distributor in the Filter Graph Manager to pass on resources that depend on window focus to other filters, such as audio devices.</span></span>

## <a name="handling-dynamic-format-changes"></a><span data-ttu-id="e690c-196">Gestion des modifications de format dynamique</span><span class="sxs-lookup"><span data-stu-id="e690c-196">Handling Dynamic Format Changes</span></span>

<span data-ttu-id="e690c-197">Dans certains cas, le filtre amont du convertisseur peut tenter de modifier le format vidéo pendant la diffusion de la vidéo.</span><span class="sxs-lookup"><span data-stu-id="e690c-197">In some cases, the renderer's upstream filter might try to change the video format while the video is playing.</span></span> <span data-ttu-id="e690c-198">Il s’agit le plus souvent du Décompresseur vidéo qui lance une modification de format dynamique.</span><span class="sxs-lookup"><span data-stu-id="e690c-198">It is most often the video decompressor that initiates a dynamic format change.</span></span>

<span data-ttu-id="e690c-199">Un filtre amont tentant de modifier les formats de manière dynamique doit toujours appeler la méthode [**IPIN :: QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) sur la broche d’entrée du convertisseur.</span><span class="sxs-lookup"><span data-stu-id="e690c-199">An upstream filter attempting to change formats dynamically should always call the [**IPin::QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) method on the renderer input pin.</span></span> <span data-ttu-id="e690c-200">Un convertisseur vidéo a une certaine liberté quant aux types de modifications de format dynamique qu’il doit prendre en charge.</span><span class="sxs-lookup"><span data-stu-id="e690c-200">A video renderer has some leeway as to what kinds of dynamic format changes it should support.</span></span> <span data-ttu-id="e690c-201">Au minimum, il doit autoriser le filtre en amont à modifier les palettes.</span><span class="sxs-lookup"><span data-stu-id="e690c-201">At a minimum, it should allow the upstream filter to change palettes.</span></span> <span data-ttu-id="e690c-202">Lorsqu’un filtre amont change de type de média, il joint le type de média au premier exemple fourni dans le nouveau format.</span><span class="sxs-lookup"><span data-stu-id="e690c-202">When an upstream filter changes media types, it attaches the media type to the first sample delivered in the new format.</span></span> <span data-ttu-id="e690c-203">Si le convertisseur contient des exemples dans une file d’attente pour le rendu, il ne doit pas modifier le format tant qu’il n’a pas rendu l’exemple avec la modification de type.</span><span class="sxs-lookup"><span data-stu-id="e690c-203">If the renderer holds samples in a queue for rendering, it should not change the format until it renders the sample with the type change.</span></span>

<span data-ttu-id="e690c-204">Un convertisseur vidéo peut également demander une modification de format à partir du décodeur.</span><span class="sxs-lookup"><span data-stu-id="e690c-204">A video renderer can also request a format change from the decoder.</span></span> <span data-ttu-id="e690c-205">Par exemple, il peut demander au décodeur de fournir un format compatible DirectDraw avec une **bihauteur** négative.</span><span class="sxs-lookup"><span data-stu-id="e690c-205">For example, it might ask the decoder to provide a DirectDraw-compatible format with a negative **biHeight**.</span></span> <span data-ttu-id="e690c-206">Quand le convertisseur est suspendu, il doit appeler [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) sur le code confidentiel amont pour voir quels formats le décodeur peut fournir.</span><span class="sxs-lookup"><span data-stu-id="e690c-206">When the renderer is paused, it should call [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) on the upstream pin to see which formats the decoder can provide.</span></span> <span data-ttu-id="e690c-207">Le décodeur peut toutefois ne pas énumérer tous les types qu’il peut accepter, de sorte que le convertisseur doit proposer certains types même si le décodeur ne les publie pas.</span><span class="sxs-lookup"><span data-stu-id="e690c-207">The decoder might not enumerate all of the types that it can accept, however, so the renderer should offer some types even if the decoder does not advertise them.</span></span>

<span data-ttu-id="e690c-208">Si le décodeur peut basculer vers le format demandé, il retourne **S \_ OK** à partir de [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span><span class="sxs-lookup"><span data-stu-id="e690c-208">If the decoder can switch to the requested format, it returns **S\_OK** from [**QueryAccept**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept).</span></span> <span data-ttu-id="e690c-209">Le convertisseur associe ensuite le nouveau type de média à l’exemple de support suivant sur l’allocateur en amont.</span><span class="sxs-lookup"><span data-stu-id="e690c-209">The renderer then attaches the new media type to the next media sample on the upstream allocator.</span></span> <span data-ttu-id="e690c-210">Pour que cela fonctionne, le convertisseur doit fournir un allocateur personnalisé qui implémente une méthode privée pour attacher le type de média à l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="e690c-210">For this to work, the renderer must provide a custom allocator that implements a private method for attaching the media type to the next sample.</span></span> <span data-ttu-id="e690c-211">(Dans cette méthode privée, appelez [**IMediaSample :: SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) pour définir le type.)</span><span class="sxs-lookup"><span data-stu-id="e690c-211">(Within this private method, call [**IMediaSample::SetMediaType**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) to set the type.)</span></span>

<span data-ttu-id="e690c-212">La broche d’entrée du convertisseur doit retourner l’allocateur personnalisé du convertisseur dans la méthode [**IMemInputPin :: GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) .</span><span class="sxs-lookup"><span data-stu-id="e690c-212">The renderer's input pin should return the renderer's custom allocator in the [**IMemInputPin::GetAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-getallocator) method.</span></span> <span data-ttu-id="e690c-213">Remplacez [**IMemInputPin :: NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) afin qu’il échoue si le filtre amont n’utilise pas l’allocateur du convertisseur.</span><span class="sxs-lookup"><span data-stu-id="e690c-213">Override [**IMemInputPin::NotifyAllocator**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator) so that it fails if the upstream filter does not use the renderer's allocator.</span></span>

<span data-ttu-id="e690c-214">Avec certains décodeurs, le fait de définir la **bihauteur** sur un nombre positif sur les types YUV fait que le décodeur dessine l’image à l’envers.</span><span class="sxs-lookup"><span data-stu-id="e690c-214">With some decoders, setting **biHeight** to a positive number on YUV types causes the decoder to draw the image upside down.</span></span> <span data-ttu-id="e690c-215">(Cette erreur est incorrecte et doit être considérée comme un bogue dans le décodeur.)</span><span class="sxs-lookup"><span data-stu-id="e690c-215">(This is incorrect, and should be considered a bug in the decoder.)</span></span>

<span data-ttu-id="e690c-216">Chaque fois qu’une modification de format est détectée par le convertisseur vidéo, elle doit envoyer une notification de [**\_ \_ modification d’affichage EC**](ec-display-changed.md) .</span><span class="sxs-lookup"><span data-stu-id="e690c-216">Whenever a format change is detected by the video renderer, it should send an [**EC\_DISPLAY\_CHANGED**](ec-display-changed.md) notification.</span></span> <span data-ttu-id="e690c-217">La plupart des convertisseurs vidéo sélectionnent un format pendant la connexion afin que le format puisse être dessiné efficacement via GDI.</span><span class="sxs-lookup"><span data-stu-id="e690c-217">Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI.</span></span> <span data-ttu-id="e690c-218">Si l’utilisateur modifie le mode d’affichage actuel sans redémarrer l’ordinateur, un convertisseur peut se retrouver avec une connexion de format d’image incorrecte et doit envoyer cette notification.</span><span class="sxs-lookup"><span data-stu-id="e690c-218">If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification.</span></span> <span data-ttu-id="e690c-219">Le premier paramètre doit être le code confidentiel qui doit se reconnecter.</span><span class="sxs-lookup"><span data-stu-id="e690c-219">The first parameter should be the pin that needs reconnecting.</span></span> <span data-ttu-id="e690c-220">Le gestionnaire de graphes de filtre s’arrange pour que le graphique de filtre soit arrêté et le code confidentiel reconnecté.</span><span class="sxs-lookup"><span data-stu-id="e690c-220">The Filter Graph Manager will arrange for the filter graph to be stopped and the pin reconnected.</span></span> <span data-ttu-id="e690c-221">Lors de la reconnexion suivante, le convertisseur peut accepter un format plus approprié.</span><span class="sxs-lookup"><span data-stu-id="e690c-221">During the subsequent reconnection, the renderer can accept a more appropriate format.</span></span>

<span data-ttu-id="e690c-222">Chaque fois qu’un convertisseur vidéo détecte une modification de la palette dans le flux, il doit envoyer la notification de [**\_ \_ modification de la palette EC**](ec-palette-changed.md) au gestionnaire du graphique de filtres.</span><span class="sxs-lookup"><span data-stu-id="e690c-222">Whenever a video renderer detects a palette change in the stream it should send the [**EC\_PALETTE\_CHANGED**](ec-palette-changed.md) notification to the Filter Graph Manager.</span></span> <span data-ttu-id="e690c-223">Les convertisseurs vidéo DirectShow détectent si une palette a vraiment changé dans le format dynamique.</span><span class="sxs-lookup"><span data-stu-id="e690c-223">The DirectShow video renderers detect whether a palette has really changed in dynamic format or not.</span></span> <span data-ttu-id="e690c-224">Les convertisseurs vidéo permettent non seulement de filtrer le nombre de notifications **\_ \_ modifiées de palette EC** envoyées, mais également de réduire la quantité de création, d’installation et de suppression de palettes requises.</span><span class="sxs-lookup"><span data-stu-id="e690c-224">The video renderers do this not only to filter out the number of **EC\_PALETTE\_CHANGED** notifications sent but also to reduce the amount of palette creation, installation, and deletion required.</span></span>

<span data-ttu-id="e690c-225">Enfin, le convertisseur vidéo peut également détecter que la taille de la vidéo a changé. dans ce cas, il doit envoyer la notification [**de \_ \_ \_ modification**](ec-video-size-changed.md) de la taille de la vidéo ce.</span><span class="sxs-lookup"><span data-stu-id="e690c-225">Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the [**EC\_VIDEO\_SIZE\_CHANGED**](ec-video-size-changed.md) notification.</span></span> <span data-ttu-id="e690c-226">Une application peut utiliser cette notification pour négocier de l’espace dans un document composé.</span><span class="sxs-lookup"><span data-stu-id="e690c-226">An application might use this notification to negotiate space in a compound document.</span></span> <span data-ttu-id="e690c-227">Les dimensions vidéo réelles sont disponibles via l’interface de contrôle [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) .</span><span class="sxs-lookup"><span data-stu-id="e690c-227">The actual video dimensions are available through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) control interface.</span></span> <span data-ttu-id="e690c-228">Les convertisseurs DirectShow détectent si la vidéo a changé de taille ou non avant d’envoyer ces événements.</span><span class="sxs-lookup"><span data-stu-id="e690c-228">The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.</span></span>

## <a name="handling-persistent-properties"></a><span data-ttu-id="e690c-229">Gestion des propriétés persistantes</span><span class="sxs-lookup"><span data-stu-id="e690c-229">Handling Persistent Properties</span></span>

<span data-ttu-id="e690c-230">Toutes les propriétés définies par le biais des interfaces [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) et [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) sont destinées à être persistantes entre les connexions.</span><span class="sxs-lookup"><span data-stu-id="e690c-230">All properties set through the [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) interfaces are meant to be persistent across connections.</span></span> <span data-ttu-id="e690c-231">Par conséquent, la déconnexion et la reconnexion d’un convertisseur doivent n’afficher aucun effet sur la taille, la position ou les styles de la fenêtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-231">Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles.</span></span> <span data-ttu-id="e690c-232">Toutefois, si les dimensions de la vidéo changent entre les connexions, le convertisseur doit réinitialiser les rectangles source et de destination à leurs valeurs par défaut.</span><span class="sxs-lookup"><span data-stu-id="e690c-232">However, if the video dimensions change between connections, the renderer should reset the source and destination rectangles to their defaults.</span></span> <span data-ttu-id="e690c-233">Les positions source et de destination sont définies par le biais de l’interface **IBasicVideo** .</span><span class="sxs-lookup"><span data-stu-id="e690c-233">The source and destination positions are set through the **IBasicVideo** interface.</span></span>

<span data-ttu-id="e690c-234">[**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) et [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) fournissent un accès suffisant aux propriétés pour permettre à une application d’enregistrer et de restaurer toutes les données dans l’interface dans un format persistant.</span><span class="sxs-lookup"><span data-stu-id="e690c-234">Both [**IBasicVideo**](/windows/desktop/api/Control/nn-control-ibasicvideo) and [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format.</span></span> <span data-ttu-id="e690c-235">Cela s’avère utile pour les applications qui doivent enregistrer la configuration exacte et les propriétés des graphiques de filtre au cours d’une session d’édition et les restaurer ultérieurement.</span><span class="sxs-lookup"><span data-stu-id="e690c-235">This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.</span></span>

## <a name="handling-ec_repaint-notifications"></a><span data-ttu-id="e690c-236">Gestion des \_ notifications de REDESSIN ce</span><span class="sxs-lookup"><span data-stu-id="e690c-236">Handling EC\_REPAINT Notifications</span></span>

<span data-ttu-id="e690c-237">La notification de [**\_ redessin ce**](ec-repaint.md) est envoyée uniquement lorsque le convertisseur est suspendu ou arrêté.</span><span class="sxs-lookup"><span data-stu-id="e690c-237">The [**EC\_REPAINT**](ec-repaint.md) notification is sent only when the renderer is either paused or stopped.</span></span> <span data-ttu-id="e690c-238">Cette notification signale au gestionnaire de graphique de filtre que le convertisseur a besoin de données.</span><span class="sxs-lookup"><span data-stu-id="e690c-238">This notification signals to the Filter Graph Manager that the renderer needs data.</span></span> <span data-ttu-id="e690c-239">Si le graphique de filtre est arrêté lorsqu’il reçoit l’une de ces notifications, il suspend le graphique de filtre, attend que tous les filtres reçoivent des données (en appelant [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), puis l’arrête à nouveau.</span><span class="sxs-lookup"><span data-stu-id="e690c-239">If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling [**GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate)), and then stop it again.</span></span> <span data-ttu-id="e690c-240">Lorsqu’il est arrêté, un convertisseur vidéo doit conserver l’image afin que les messages [**de \_ peinture WM**](/windows/desktop/gdi/wm-paint) suivants puissent être gérés.</span><span class="sxs-lookup"><span data-stu-id="e690c-240">When stopped, a video renderer should hold on to the image so that subsequent [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages can be handled.</span></span>

<span data-ttu-id="e690c-241">Par conséquent, si un convertisseur vidéo reçoit un message de [**\_ peinture WM**](/windows/desktop/gdi/wm-paint) lorsqu’il est arrêté ou suspendu, et qu’il n’a rien à faire pour peindre sa fenêtre, il doit l’envoyer au gestionnaire de graphes [**de filtre \_**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="e690c-241">Therefore, if a video renderer receives a [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) message when stopped or paused, and it has nothing with which to paint its window, then it should send [**EC\_REPAINT**](ec-repaint.md) to the Filter Graph Manager.</span></span> <span data-ttu-id="e690c-242">Si une notification de **\_ redessin ce** a été reçue pendant la suspension, le gestionnaire de graphique de filtre appelle [**IMediaPosition ::p ut \_ CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) avec la position actuelle (c’est-à-dire, cherche à la position actuelle).</span><span class="sxs-lookup"><span data-stu-id="e690c-242">If an **EC\_REPAINT** notification is received while paused, then the Filter Graph Manager calls [**IMediaPosition::put\_CurrentPosition**](/windows/desktop/api/Control/nf-control-imediaposition-put_currentposition) with the current position (that is, seeks to the current position).</span></span> <span data-ttu-id="e690c-243">Ainsi, les filtres sources vident le graphique de filtre et entraînent l’envoi de nouvelles données via le graphique de filtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-243">This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.</span></span>

<span data-ttu-id="e690c-244">Un convertisseur ne doit envoyer qu’une seule de ces notifications à la fois.</span><span class="sxs-lookup"><span data-stu-id="e690c-244">A renderer must send only one of these notifications at a time.</span></span> <span data-ttu-id="e690c-245">Par conséquent, une fois que le convertisseur envoie une notification, il doit s’assurer qu’aucun autre n’est envoyé jusqu’à la remise de certains échantillons.</span><span class="sxs-lookup"><span data-stu-id="e690c-245">Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered.</span></span> <span data-ttu-id="e690c-246">La méthode conventionnelle pour effectuer cette opération consiste à avoir un indicateur qui indique qu’un redessin peut être envoyé, ce qui est désactivé après l’envoi d’une notification de [**\_ redessin ce**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="e690c-246">The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an [**EC\_REPAINT**](ec-repaint.md) notification is sent.</span></span> <span data-ttu-id="e690c-247">Cet indicateur doit être réinitialisé une fois que les données sont remises ou lorsque la broche d’entrée est vidée, mais pas si la fin de flux est signalée sur la broche d’entrée.</span><span class="sxs-lookup"><span data-stu-id="e690c-247">This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.</span></span>

<span data-ttu-id="e690c-248">Si le convertisseur ne surveille pas ses notifications de [**\_ redessin EC**](ec-repaint.md) , il inondera le gestionnaire de graphes de filtre avec les demandes de **\_ redessin EC** (qui sont relativement coûteuses à traiter).</span><span class="sxs-lookup"><span data-stu-id="e690c-248">If the renderer does not monitor its [**EC\_REPAINT**](ec-repaint.md) notifications, it will flood the Filter Graph Manager with **EC\_REPAINT** requests (which are relatively expensive to process).</span></span> <span data-ttu-id="e690c-249">Par exemple, si un convertisseur n’a pas d’image à dessiner et qu’une autre fenêtre est glissée dans la fenêtre du convertisseur dans une opération de glissement complet, le convertisseur reçoit plusieurs [**messages \_ WM**](/windows/desktop/gdi/wm-paint) .</span><span class="sxs-lookup"><span data-stu-id="e690c-249">For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple [**WM\_PAINT**](/windows/desktop/gdi/wm-paint) messages.</span></span> <span data-ttu-id="e690c-250">Seule la première d’entre elles doit générer une notification d’événement de **\_ redessin ce** à partir du convertisseur vers le gestionnaire de graphes de filtre.</span><span class="sxs-lookup"><span data-stu-id="e690c-250">Only the first of these should generate an **EC\_REPAINT** event notification from the renderer to the Filter Graph Manager.</span></span>

<span data-ttu-id="e690c-251">Un convertisseur doit envoyer sa broche d’entrée en tant que premier paramètre à la notification de [**\_ redessin ce**](ec-repaint.md) .</span><span class="sxs-lookup"><span data-stu-id="e690c-251">A renderer should send its input pin as the first parameter to the [**EC\_REPAINT**](ec-repaint.md) notification.</span></span> <span data-ttu-id="e690c-252">En procédant ainsi, la broche de sortie attachée sera interrogée pour [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink)et, si elle est prise en charge, la notification **ce \_ Repaint** sera envoyée pour la première fois.</span><span class="sxs-lookup"><span data-stu-id="e690c-252">By doing this, the attached output pin will be queried for [**IMediaEventSink**](/windows/desktop/api/Strmif/nn-strmif-imediaeventsink), and if supported, the **EC\_REPAINT** notification will be sent there first.</span></span> <span data-ttu-id="e690c-253">Cela permet aux broches de sortie de gérer les redessins avant que le graphique de filtre ne soit manipulé.</span><span class="sxs-lookup"><span data-stu-id="e690c-253">This enables output pins to handle repaints before the filter graph must be touched.</span></span> <span data-ttu-id="e690c-254">Cela ne sera pas effectué si le graphique de filtre est arrêté, car aucune mémoire tampon n’est disponible à partir de l’allocateur de convertisseur non validé.</span><span class="sxs-lookup"><span data-stu-id="e690c-254">This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.</span></span>

<span data-ttu-id="e690c-255">Si la broche de sortie ne peut pas gérer la demande et que le graphique de filtre est en cours d’exécution, la notification [**ce \_ Repaint**](ec-repaint.md) est ignorée.</span><span class="sxs-lookup"><span data-stu-id="e690c-255">If the output pin cannot handle the request and the filter graph is running, then the [**EC\_REPAINT**](ec-repaint.md) notification is ignored.</span></span> <span data-ttu-id="e690c-256">Une broche de sortie doit retourner **S \_ OK** à partir de [**IMediaEventSink :: Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) pour signaler qu’elle a correctement traité la demande de Repaint.</span><span class="sxs-lookup"><span data-stu-id="e690c-256">An output pin must return **S\_OK** from [**IMediaEventSink::Notify**](/windows/desktop/api/Strmif/nf-strmif-imediaeventsink-notify) to signal that it processed the repaint request successfully.</span></span> <span data-ttu-id="e690c-257">La broche de sortie sera appelée sur le thread de travail du gestionnaire de graphique de filtre, ce qui évite que le convertisseur n’appelle la broche de sortie directement, ce qui contourner tous les problèmes de blocage.</span><span class="sxs-lookup"><span data-stu-id="e690c-257">The output pin will be called on the Filter Graph Manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues.</span></span> <span data-ttu-id="e690c-258">Si le graphique de filtre est arrêté ou suspendu et que la sortie ne gère pas la demande, le traitement par défaut est effectué.</span><span class="sxs-lookup"><span data-stu-id="e690c-258">If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.</span></span>

## <a name="handling-notifications-in-full-screen-mode"></a><span data-ttu-id="e690c-259">Gestion des notifications en mode Full-Screen</span><span class="sxs-lookup"><span data-stu-id="e690c-259">Handling Notifications in Full-Screen Mode</span></span>

<span data-ttu-id="e690c-260">Le serveur de distribution de plug-in [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) (PID) dans le graphique de filtre gère la lecture en plein écran.</span><span class="sxs-lookup"><span data-stu-id="e690c-260">The [**IVideoWindow**](/windows/desktop/api/Control/nn-control-ivideowindow) plug-in distributor (PID) in the filter graph manages full-screen playback.</span></span> <span data-ttu-id="e690c-261">Il permutera un convertisseur vidéo en sortie pour un convertisseur plein écran spécialisé, étirer une fenêtre d’un convertisseur en plein écran, ou faire en sorte que le convertisseur implémente directement la lecture en plein écran.</span><span class="sxs-lookup"><span data-stu-id="e690c-261">It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer implement full-screen playback directly.</span></span> <span data-ttu-id="e690c-262">Pour interagir avec les protocoles plein écran, un convertisseur vidéo doit envoyer une notification [**d' \_ activation EC**](ec-activate.md) chaque fois que sa fenêtre est activée ou désactivée.</span><span class="sxs-lookup"><span data-stu-id="e690c-262">To interact in full-screen protocols, a video renderer should send an [**EC\_ACTIVATE**](ec-activate.md) notification whenever its window is either activated or deactivated.</span></span> <span data-ttu-id="e690c-263">En d’autres termes, une notification d' **\_ activation EC** doit être envoyée pour chaque \_ message WM ACTIVATEAPP reçu par un convertisseur.</span><span class="sxs-lookup"><span data-stu-id="e690c-263">In other words, an **EC\_ACTIVATE** notification should be sent for each WM\_ACTIVATEAPP message a renderer receives.</span></span>

<span data-ttu-id="e690c-264">Lorsqu’un convertisseur est utilisé en mode plein écran, ces notifications gèrent le basculement vers et à partir de ce mode plein écran.</span><span class="sxs-lookup"><span data-stu-id="e690c-264">When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode.</span></span> <span data-ttu-id="e690c-265">La désactivation de la fenêtre se produit généralement lorsqu’un utilisateur appuie sur ALT + TAB pour basculer vers une autre fenêtre, que le convertisseur de l’écran complet DirectShow utilise comme signal pour revenir au mode de rendu standard.</span><span class="sxs-lookup"><span data-stu-id="e690c-265">Window deactivation typically occurs when a user presses ALT+TAB to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.</span></span>

<span data-ttu-id="e690c-266">Lorsque la notification d' [**\_ activation ce**](ec-activate.md) est envoyée au gestionnaire de graphique de filtre lors du basculement en mode plein écran, le gestionnaire de graphes de filtre envoie une notification de [**\_ \_ perte**](ec-fullscreen-lost.md) de la mise en plein écran à l’application de contrôle.</span><span class="sxs-lookup"><span data-stu-id="e690c-266">When the [**EC\_ACTIVATE**](ec-activate.md) notification is sent to the Filter Graph Manager upon switching out of full-screen mode, the Filter Graph Manager sends an [**EC\_FULLSCREEN\_LOST**](ec-fullscreen-lost.md) notification to the controlling application.</span></span> <span data-ttu-id="e690c-267">L’application peut utiliser cette notification pour restaurer l’état d’un bouton plein écran, par exemple.</span><span class="sxs-lookup"><span data-stu-id="e690c-267">The application might use this notification to restore the state of a full-screen button, for example.</span></span> <span data-ttu-id="e690c-268">Les notifications d' **\_ activation EC** sont utilisées en interne par DirectShow pour gérer le basculement plein écran sur les signaux des convertisseurs vidéo.</span><span class="sxs-lookup"><span data-stu-id="e690c-268">The **EC\_ACTIVATE** notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers.</span></span>

## <a name="summary-of-notifications"></a><span data-ttu-id="e690c-269">Résumé des notifications</span><span class="sxs-lookup"><span data-stu-id="e690c-269">Summary of Notifications</span></span>

<span data-ttu-id="e690c-270">Cette section répertorie les notifications de graphique de filtre qu’un convertisseur peut envoyer.</span><span class="sxs-lookup"><span data-stu-id="e690c-270">This section lists the filter graph notifications that a renderer can send.</span></span>



| <span data-ttu-id="e690c-271">Notification d'événement</span><span class="sxs-lookup"><span data-stu-id="e690c-271">Event notification</span></span>                                        | <span data-ttu-id="e690c-272">Description</span><span class="sxs-lookup"><span data-stu-id="e690c-272">Description</span></span>                                                                                                                                                                                       |
|-----------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [<span data-ttu-id="e690c-273">**\_activation EC**</span><span class="sxs-lookup"><span data-stu-id="e690c-273">**EC\_ACTIVATE**</span></span>](ec-activate.md)                       | <span data-ttu-id="e690c-274">Envoyé par les convertisseurs vidéo en mode de rendu plein écran pour chaque \_ message WM ACTIVATEAPP reçu.</span><span class="sxs-lookup"><span data-stu-id="e690c-274">Sent by video renderers in full-screen rendering mode for each WM\_ACTIVATEAPP message received.</span></span>                                                                                                  |
| [<span data-ttu-id="e690c-275">**EC \_ complet**</span><span class="sxs-lookup"><span data-stu-id="e690c-275">**EC\_COMPLETE**</span></span>](ec-complete.md)                       | <span data-ttu-id="e690c-276">Envoyé par les convertisseurs une fois que toutes les données ont été rendues.</span><span class="sxs-lookup"><span data-stu-id="e690c-276">Sent by renderers after all data has been rendered.</span></span>                                                                                                                                               |
| [<span data-ttu-id="e690c-277">**\_affichage EC \_ modifié**</span><span class="sxs-lookup"><span data-stu-id="e690c-277">**EC\_DISPLAY\_CHANGED**</span></span>](ec-display-changed.md)        | <span data-ttu-id="e690c-278">Envoyé par les convertisseurs vidéo en cas de modification du format d’affichage.</span><span class="sxs-lookup"><span data-stu-id="e690c-278">Sent by video renderers when a display format changes.</span></span>                                                                                                                                            |
| [<span data-ttu-id="e690c-279">**\_palette EC \_ modifiée**</span><span class="sxs-lookup"><span data-stu-id="e690c-279">**EC\_PALETTE\_CHANGED**</span></span>](ec-palette-changed.md)        | <span data-ttu-id="e690c-280">Envoyé chaque fois qu’un convertisseur vidéo détecte une modification de la palette dans le flux.</span><span class="sxs-lookup"><span data-stu-id="e690c-280">Sent whenever a video renderer detects a palette change in the stream.</span></span>                                                                                                                            |
| [<span data-ttu-id="e690c-281">**redessin ce \_**</span><span class="sxs-lookup"><span data-stu-id="e690c-281">**EC\_REPAINT**</span></span>](ec-repaint.md)                         | <span data-ttu-id="e690c-282">Envoyé par les convertisseurs vidéo arrêtés ou suspendus lorsqu’un \_ message de peinture WM est reçu et qu’il n’y a pas de données à afficher.</span><span class="sxs-lookup"><span data-stu-id="e690c-282">Sent by stopped or paused video renderers when a WM\_PAINT message is received and there is no data to display.</span></span> <span data-ttu-id="e690c-283">Le gestionnaire de graphes de filtre génère alors un cadre pour peindre à l’écran.</span><span class="sxs-lookup"><span data-stu-id="e690c-283">This causes the Filter Graph Manager to generate a frame to paint to the display.</span></span> |
| [<span data-ttu-id="e690c-284">**\_USERABORT EC**</span><span class="sxs-lookup"><span data-stu-id="e690c-284">**EC\_USERABORT**</span></span>](ec-userabort.md)                     | <span data-ttu-id="e690c-285">Envoyé par les convertisseurs vidéo pour signaler une fermeture que l’utilisateur a demandée (par exemple, un utilisateur qui ferme la fenêtre vidéo).</span><span class="sxs-lookup"><span data-stu-id="e690c-285">Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window).</span></span>                                                                               |
| [<span data-ttu-id="e690c-286">**taille de la \_ vidéo ce \_ \_ modifiée**</span><span class="sxs-lookup"><span data-stu-id="e690c-286">**EC\_VIDEO\_SIZE\_CHANGED**</span></span>](ec-video-size-changed.md) | <span data-ttu-id="e690c-287">Envoyé par les convertisseurs vidéo chaque fois qu’une modification de la taille de la vidéo native est détectée.</span><span class="sxs-lookup"><span data-stu-id="e690c-287">Sent by video renderers whenever a change in native video size is detected.</span></span>                                                                                                                       |
| [<span data-ttu-id="e690c-288">**\_fenêtre EC \_ détruite**</span><span class="sxs-lookup"><span data-stu-id="e690c-288">**EC\_WINDOW\_DESTROYED**</span></span>](ec-window-destroyed.md)      | <span data-ttu-id="e690c-289">Envoyé par les convertisseurs vidéo lorsque le filtre est supprimé ou détruit afin que les ressources qui dépendent du focus de la fenêtre puissent être passées à d’autres filtres.</span><span class="sxs-lookup"><span data-stu-id="e690c-289">Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.</span></span>                                                     |



 

## <a name="related-topics"></a><span data-ttu-id="e690c-290">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="e690c-290">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="e690c-291">Écriture de convertisseurs vidéo</span><span class="sxs-lookup"><span data-stu-id="e690c-291">Writing Video Renderers</span></span>](writing-video-renderers.md)
</dt> </dl>

 

 
