---
description: Threads de diffusion en continu et d’application
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: Threads de diffusion en continu et d’application
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 432e613ff0322377c042e796d84ef7affdda99c2
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104530244"
---
# <a name="the-streaming-and-application-threads"></a><span data-ttu-id="ee745-103">Threads de diffusion en continu et d’application</span><span class="sxs-lookup"><span data-stu-id="ee745-103">The Streaming and Application Threads</span></span>

<span data-ttu-id="ee745-104">Toute application DirectShow contient au moins deux threads importants : le thread d’application et un ou plusieurs threads de streaming.</span><span class="sxs-lookup"><span data-stu-id="ee745-104">Any DirectShow application contains at least two important threads: the application thread, and one or more streaming threads.</span></span> <span data-ttu-id="ee745-105">Les exemples sont fournis sur les threads de streaming, et les modifications d’État se produisent sur le thread d’application.</span><span class="sxs-lookup"><span data-stu-id="ee745-105">Samples are delivered on the streaming threads, and state changes happen on the application thread.</span></span> <span data-ttu-id="ee745-106">Le thread de streaming principal est créé par un filtre de source ou d’analyseur.</span><span class="sxs-lookup"><span data-stu-id="ee745-106">The main streaming thread is created by a source or parser filter.</span></span> <span data-ttu-id="ee745-107">D’autres filtres peuvent créer des threads de travail qui fournissent des exemples. ceux-ci sont également considérés comme des threads de diffusion en continu.</span><span class="sxs-lookup"><span data-stu-id="ee745-107">Other filters might create worker threads that deliver samples, and these are considered streaming threads as well.</span></span>

<span data-ttu-id="ee745-108">Certaines méthodes sont appelées sur le thread d’application, tandis que d’autres sont appelées sur un thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="ee745-108">Some methods are called on the application thread, while others are called on a streaming thread.</span></span> <span data-ttu-id="ee745-109">Par exemple :</span><span class="sxs-lookup"><span data-stu-id="ee745-109">For example:</span></span>

-   <span data-ttu-id="ee745-110">Thread (s) de diffusion en continu : [**IMemInputPin :: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin :: ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPIN :: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator :: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="ee745-110">Streaming thread(s): [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**IMemInputPin::ReceiveMultiple**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**IPin::EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span>
-   <span data-ttu-id="ee745-111">Thread d’application : [**IMediaFilter ::P ause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter :: Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter :: Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking :: SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPIN :: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPIN :: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span><span class="sxs-lookup"><span data-stu-id="ee745-111">Application thread: [**IMediaFilter::Pause**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**IMediaFilter::Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**IMediaFilter::Stop**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**IMediaSeeking::SetPositions**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).</span></span>
-   <span data-ttu-id="ee745-112">Soit : [**IPIN :: NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span><span class="sxs-lookup"><span data-stu-id="ee745-112">Either: [**IPin::NewSegment**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).</span></span>

<span data-ttu-id="ee745-113">Le fait de disposer d’un thread de streaming distinct permet aux données de circuler dans le graphique alors que le thread d’application attend une entrée de l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="ee745-113">Having a separate streaming thread allows data to flow through the graph while the application thread waits for user input.</span></span> <span data-ttu-id="ee745-114">Toutefois, le risque de plusieurs threads est qu’un filtre peut créer des ressources lorsqu’il s’interrompt (sur le thread d’application), les utiliser à l’intérieur d’une méthode de diffusion en continu et les détruire lorsqu’il s’arrête (également sur le thread d’application).</span><span class="sxs-lookup"><span data-stu-id="ee745-114">The danger of multiple threads, however, is that a filter may create resources when it pauses (on the application thread), use them inside a streaming method, and destroy them when it stops (also on the application thread).</span></span> <span data-ttu-id="ee745-115">Si vous n’êtes pas vigilant, le thread de streaming peut essayer d’utiliser les ressources une fois qu’elles ont été détruites.</span><span class="sxs-lookup"><span data-stu-id="ee745-115">If you are not careful, the streaming thread might try to use the resources after they are destroyed.</span></span> <span data-ttu-id="ee745-116">La solution consiste à protéger les ressources à l’aide de sections critiques et à synchroniser les méthodes de streaming avec les changements d’État.</span><span class="sxs-lookup"><span data-stu-id="ee745-116">The solution is to protect resources using critical sections, and synchronize streaming methods with state changes.</span></span>

<span data-ttu-id="ee745-117">Un filtre a besoin d’une section critique pour protéger l’état du filtre.</span><span class="sxs-lookup"><span data-stu-id="ee745-117">A filter needs one critical section to protect the filter state.</span></span> <span data-ttu-id="ee745-118">La classe [**CBaseFilter**](cbasefilter.md) possède une variable membre pour cette section critique, [**CBaseFilter :: m \_ pLock**](cbasefilter-m-plock.md).</span><span class="sxs-lookup"><span data-stu-id="ee745-118">The [**CBaseFilter**](cbasefilter.md) class has a member variable for this critical section, [**CBaseFilter::m\_pLock**](cbasefilter-m-plock.md).</span></span> <span data-ttu-id="ee745-119">Cette section critique est appelée verrou de filtre.</span><span class="sxs-lookup"><span data-stu-id="ee745-119">This critical section is called the filter lock.</span></span> <span data-ttu-id="ee745-120">En outre, chaque broche d’entrée a besoin d’une section critique pour protéger les ressources utilisées par le thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="ee745-120">Also, each input pin needs a critical section to protect resources used by the streaming thread.</span></span> <span data-ttu-id="ee745-121">Ces sections critiques sont appelées verrous de diffusion en continu. vous devez les déclarer dans votre classe pin dérivée.</span><span class="sxs-lookup"><span data-stu-id="ee745-121">These critical sections are called streaming locks; you must declare them in your derived pin class.</span></span> <span data-ttu-id="ee745-122">Il est plus facile d’utiliser la classe [**CCritSec**](ccritsec.md) , qui encapsule un objet de **\_ section critique** Windows et peut être verrouillée à l’aide de la classe [**CAutoLock**](cautolock.md) .</span><span class="sxs-lookup"><span data-stu-id="ee745-122">It is easiest to use the [**CCritSec**](ccritsec.md) class, which wraps a Windows **CRITICAL\_SECTION** object and can be locked using the [**CAutoLock**](cautolock.md) class.</span></span> <span data-ttu-id="ee745-123">La classe **CCritSec** fournit également des fonctions de débogage utiles.</span><span class="sxs-lookup"><span data-stu-id="ee745-123">The **CCritSec** class also provides some useful debugging functions.</span></span> <span data-ttu-id="ee745-124">Pour plus d’informations, consultez [tâches de débogage de la section critique](critical-section-debugging-functions.md).</span><span class="sxs-lookup"><span data-stu-id="ee745-124">For more information, see [Critical Section Debugging Functions](critical-section-debugging-functions.md).</span></span>

<span data-ttu-id="ee745-125">Lorsqu’un filtre s’arrête ou vide, il doit synchroniser le thread d’application avec le thread de streaming.</span><span class="sxs-lookup"><span data-stu-id="ee745-125">When a filter stops or flushes, it must synchronize the application thread with the streaming thread.</span></span> <span data-ttu-id="ee745-126">Pour éviter le blocage, il doit tout d’abord débloquer le thread de streaming, ce qui peut être bloqué pour plusieurs raisons :</span><span class="sxs-lookup"><span data-stu-id="ee745-126">To avoid deadlocking, it must first unblock the streaming thread, which might be blocked for several reasons:</span></span>

-   <span data-ttu-id="ee745-127">Il attend d’obtenir un exemple à l’intérieur de la méthode [**IMemAllocator :: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , car tous les exemples de l’allocateur sont en cours d’utilisation.</span><span class="sxs-lookup"><span data-stu-id="ee745-127">It is waiting to get a sample inside the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, because all of the allocator's samples are in use.</span></span>
-   <span data-ttu-id="ee745-128">Il attend qu’un autre filtre retourne à partir d’une méthode de streaming, telle que **Receive**.</span><span class="sxs-lookup"><span data-stu-id="ee745-128">It is waiting for another filter to return from a streaming method, such as **Receive**.</span></span>
-   <span data-ttu-id="ee745-129">Elle est en attente dans l’une de ses propres méthodes de diffusion en continu, pour qu’une ressource soit disponible.</span><span class="sxs-lookup"><span data-stu-id="ee745-129">It is waiting inside one of its own streaming methods, for some resource to become available.</span></span>
-   <span data-ttu-id="ee745-130">Il s’agit d’un filtre de convertisseur qui attend l’heure de présentation de l’exemple suivant</span><span class="sxs-lookup"><span data-stu-id="ee745-130">It is a renderer filter waiting for the presentation time of the next sample</span></span>
-   <span data-ttu-id="ee745-131">Il s’agit d’un filtre de convertisseur qui attend à l’intérieur de la méthode **Receive** tout en étant suspendu.</span><span class="sxs-lookup"><span data-stu-id="ee745-131">It is a renderer filter waiting inside the **Receive** method while paused.</span></span>

<span data-ttu-id="ee745-132">Par conséquent, lorsque le filtre s’arrête ou vide, il doit effectuer les opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="ee745-132">Therefore, when the filter stops or flushes, it must do the following:</span></span>

-   <span data-ttu-id="ee745-133">Publiez un échantillon qu’il détient pour une raison quelconque.</span><span class="sxs-lookup"><span data-stu-id="ee745-133">Release any sample it is holding for any reason.</span></span> <span data-ttu-id="ee745-134">Cela débloque la méthode **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="ee745-134">Doing so unblocks the **GetBuffer** method.</span></span>
-   <span data-ttu-id="ee745-135">Retournez à partir de n’importe quelle méthode de diffusion le plus rapidement possible.</span><span class="sxs-lookup"><span data-stu-id="ee745-135">Return from any streaming method as quickly as possible.</span></span> <span data-ttu-id="ee745-136">Si une méthode de streaming attend une ressource, elle doit cesser d’attendre immédiatement.</span><span class="sxs-lookup"><span data-stu-id="ee745-136">If a streaming method is waiting for a resource, it must stop waiting immediately.</span></span>
-   <span data-ttu-id="ee745-137">Commencez à rejeter les exemples dans **Receive**, afin que le thread de streaming n’accède plus à plus de ressources.</span><span class="sxs-lookup"><span data-stu-id="ee745-137">Start rejecting samples in **Receive**, so that the streaming thread does not access any more resources.</span></span> <span data-ttu-id="ee745-138">(La classe [**CBaseInputPin**](cbaseinputpin.md) gère cela automatiquement.)</span><span class="sxs-lookup"><span data-stu-id="ee745-138">(The [**CBaseInputPin**](cbaseinputpin.md) class handles this automatically.)</span></span>
-   <span data-ttu-id="ee745-139">La méthode **Stop doit annuler** la validation de tous les allocateurs du filtre.</span><span class="sxs-lookup"><span data-stu-id="ee745-139">The **Stop** method must decommit all of the filter's allocators.</span></span> <span data-ttu-id="ee745-140">(La classe **CBaseInputPin** gère cela automatiquement.)</span><span class="sxs-lookup"><span data-stu-id="ee745-140">(The **CBaseInputPin** class handles this automatically.)</span></span>

<span data-ttu-id="ee745-141">Le vidage et l’arrêt des deux se produisent sur le thread d’application.</span><span class="sxs-lookup"><span data-stu-id="ee745-141">Flushing and stopping both happen on the application thread.</span></span> <span data-ttu-id="ee745-142">Un filtre s’arrête en réponse à la méthode [**IMediaControl :: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) .</span><span class="sxs-lookup"><span data-stu-id="ee745-142">A filter stops in response to the [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) method.</span></span> <span data-ttu-id="ee745-143">Le gestionnaire de graphe de filtre émet la commande arrêter dans l’ordre amont, en commençant par les convertisseurs et en remontant les filtres sources.</span><span class="sxs-lookup"><span data-stu-id="ee745-143">The Filter Graph Manager issues the stop command in upstream order, starting from the renderers and working backward to the source filters.</span></span> <span data-ttu-id="ee745-144">La commande Stop se produit complètement à l’intérieur de la méthode **CBaseFilter :: Stop** du filtre.</span><span class="sxs-lookup"><span data-stu-id="ee745-144">The stop command happens completely inside the filter's **CBaseFilter::Stop** method.</span></span> <span data-ttu-id="ee745-145">Lorsque la méthode retourne, le filtre doit être arrêté.</span><span class="sxs-lookup"><span data-stu-id="ee745-145">When the method returns, the filter should be in a stopped state.</span></span>

<span data-ttu-id="ee745-146">Le vidage se produit généralement en raison d’une commande Seek.</span><span class="sxs-lookup"><span data-stu-id="ee745-146">Flushing typically occurs because of a seek command.</span></span> <span data-ttu-id="ee745-147">Une commande flush démarre à partir du filtre source ou de l’analyseur et se déplace en aval.</span><span class="sxs-lookup"><span data-stu-id="ee745-147">A flush command starts from the source or parser filter, and travels downstream.</span></span> <span data-ttu-id="ee745-148">Le vidage se produit en deux étapes : la méthode [**IPIN :: BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) informe un filtre d’ignorer toutes les données en attente et entrantes ; la méthode [**IPIN :: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) signale au filtre d’accepter à nouveau les données.</span><span class="sxs-lookup"><span data-stu-id="ee745-148">Flushing happens in two stages: The [**IPin::BeginFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) method informs a filter to discard all pending and incoming data; the [**IPin::EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) method signals the filter to accept data again.</span></span> <span data-ttu-id="ee745-149">Le vidage requiert deux étapes, car l’appel **BeginFlush** se trouve sur le thread d’application, pendant lequel le thread de streaming continue à remettre les données.</span><span class="sxs-lookup"><span data-stu-id="ee745-149">Flushing requires two stages because the **BeginFlush** call is on the application thread, during which the streaming thread continues to deliver data.</span></span> <span data-ttu-id="ee745-150">Par conséquent, certains exemples peuvent arriver après l’appel **BeginFlush** .</span><span class="sxs-lookup"><span data-stu-id="ee745-150">Therefore, some samples may arrive after the **BeginFlush** call.</span></span> <span data-ttu-id="ee745-151">Le filtre doit les ignorer.</span><span class="sxs-lookup"><span data-stu-id="ee745-151">The filter should discard these.</span></span> <span data-ttu-id="ee745-152">Tous les exemples arrivant après l’appel **EndFlush** sont toujours nouveaux et doivent être remis.</span><span class="sxs-lookup"><span data-stu-id="ee745-152">Any samples that arrive after the **EndFlush** call are guaranteed to be new, and should be delivered.</span></span>

<span data-ttu-id="ee745-153">Les sections qui suivent contiennent des exemples de code qui montrent comment implémenter les méthodes de filtre les plus importantes, telles que la **suspension**, la **réception**, etc., de manière à éviter les blocages et les conditions de concurrence critique.</span><span class="sxs-lookup"><span data-stu-id="ee745-153">The sections that follow contain code samples showing how to implement the most important filter methods, such as **Pause**, **Receive**, and so forth, in ways that avoid deadlocks and race conditions.</span></span> <span data-ttu-id="ee745-154">Toutefois, chaque filtre a des exigences différentes. vous devrez donc adapter ces exemples à votre filtre particulier.</span><span class="sxs-lookup"><span data-stu-id="ee745-154">Every filter has different requirements, however, so you will need to adapt these examples to your particular filter.</span></span>

> [!Note]  
> <span data-ttu-id="ee745-155">Les classes de base [**CTransformFilter**](ctransformfilter.md) et [**CTransInPlaceFilter**](ctransinplacefilter.md) gèrent un grand nombre des problèmes décrits dans cet article.</span><span class="sxs-lookup"><span data-stu-id="ee745-155">The [**CTransformFilter**](ctransformfilter.md) and [**CTransInPlaceFilter**](ctransinplacefilter.md) base classes handle many of the issues described in this article.</span></span> <span data-ttu-id="ee745-156">Si vous écrivez un filtre de transformation et que votre filtre n’attend pas d’événements à l’intérieur d’une méthode de diffusion en continu ou si vous maintenez des exemples en dehors de **Receive**, ces classes de base doivent être suffisantes.</span><span class="sxs-lookup"><span data-stu-id="ee745-156">If you are writing a transform filter, and your filter does not wait on events inside a streaming method, or hold onto samples outside of **Receive**, then these base classes should be sufficient.</span></span>

 

 

 



