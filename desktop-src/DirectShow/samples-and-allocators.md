---
description: Exemples et allocators
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Exemples et allocators
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "104561978"
---
# <a name="samples-and-allocators"></a><span data-ttu-id="47b1a-103">Exemples et allocators</span><span class="sxs-lookup"><span data-stu-id="47b1a-103">Samples and Allocators</span></span>

<span data-ttu-id="47b1a-104">Lorsqu’un code PIN transmet des données multimédia à un autre code confidentiel, il ne passe pas de pointeur direct vers la mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="47b1a-104">When a pin delivers media data to another pin, it does not pass a direct pointer to the memory buffer.</span></span> <span data-ttu-id="47b1a-105">Au lieu de cela, il fournit un pointeur vers un objet COM qui gère la mémoire.</span><span class="sxs-lookup"><span data-stu-id="47b1a-105">Instead, it delivers a pointer to a COM object that manages the memory.</span></span> <span data-ttu-id="47b1a-106">Cet objet, appelé *exemple de support*, expose l’interface [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) .</span><span class="sxs-lookup"><span data-stu-id="47b1a-106">This object, called a *media sample*, exposes the [**IMediaSample**](/windows/desktop/api/Strmif/nn-strmif-imediasample) interface.</span></span> <span data-ttu-id="47b1a-107">Le code PIN de réception accède à la mémoire tampon en appelant des méthodes **IMediaSample** , telles que [**IMediaSample :: GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample ::**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)deIMediaSample et [**GetActualDataLength ::**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span><span class="sxs-lookup"><span data-stu-id="47b1a-107">The receiving pin accesses the memory buffer by calling **IMediaSample** methods, such as [**IMediaSample::GetPointer**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**IMediaSample::GetSize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize), and [**IMediaSample::GetActualDataLength**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).</span></span>

<span data-ttu-id="47b1a-108">Les exemples voyagent toujours en aval, de la broche de sortie à la broche d’entrée.</span><span class="sxs-lookup"><span data-stu-id="47b1a-108">Samples always travel downstream, from output pin to input pin.</span></span> <span data-ttu-id="47b1a-109">Dans le modèle push, la broche de sortie fournit un exemple en appelant [**IMemInputPin :: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) sur la broche d’entrée.</span><span class="sxs-lookup"><span data-stu-id="47b1a-109">In the push model, the output pin delivers a sample by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the input pin.</span></span> <span data-ttu-id="47b1a-110">La broche d’entrée traite les données de manière synchrone (c’est-à-dire complètement à l’intérieur de la méthode de **réception** ), ou les traite de façon asynchrone sur un thread de travail.</span><span class="sxs-lookup"><span data-stu-id="47b1a-110">The input pin will either process the data synchronously (that is, completely inside the **Receive** method), or process it asynchronously on a worker thread.</span></span> <span data-ttu-id="47b1a-111">La broche d’entrée est autorisée à bloquer dans la méthode **Receive** , si elle doit attendre des ressources.</span><span class="sxs-lookup"><span data-stu-id="47b1a-111">The input pin is allowed to block within the **Receive** method, if it needs to wait for resources.</span></span>

<span data-ttu-id="47b1a-112">Un autre objet COM, appelé *Allocator*, est responsable de la création et de la gestion des exemples de médias.</span><span class="sxs-lookup"><span data-stu-id="47b1a-112">Another COM object, called an *allocator*, is responsible for creating and managing media samples.</span></span> <span data-ttu-id="47b1a-113">Les allocateurs exposent l’interface [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) .</span><span class="sxs-lookup"><span data-stu-id="47b1a-113">Allocators expose the [**IMemAllocator**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) interface.</span></span> <span data-ttu-id="47b1a-114">Chaque fois qu’un filtre a besoin d’un échantillon de média avec une mémoire tampon vide, il appelle la méthode [**IMemAllocator :: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , qui retourne un pointeur vers l’exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-114">Whenever a filter needs a media sample with an empty buffer, it calls the [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) method, which returns a pointer to the sample.</span></span> <span data-ttu-id="47b1a-115">Chaque connexion de code confidentiel partage un allocateur.</span><span class="sxs-lookup"><span data-stu-id="47b1a-115">Every pin connection shares one allocator.</span></span> <span data-ttu-id="47b1a-116">Lorsque deux codes confidentiels se connectent, ils décident du filtre qui fournira l’allocateur.</span><span class="sxs-lookup"><span data-stu-id="47b1a-116">When two pins connect, they decide which filter will provide the allocator.</span></span> <span data-ttu-id="47b1a-117">Les broches définissent également des propriétés sur l’allocateur, telles que le nombre de mémoires tampons et la taille de chaque mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="47b1a-117">The pins also set properties on the allocator, such as the number of buffers and the size of each buffer.</span></span> <span data-ttu-id="47b1a-118">(Pour plus d’informations, consultez [Comment les filtres se connectent](how-filters-connect.md) et [négocient des allocateurs](negotiating-allocators.md).)</span><span class="sxs-lookup"><span data-stu-id="47b1a-118">(For details, see [How Filters Connect](how-filters-connect.md) and [Negotiating Allocators](negotiating-allocators.md).)</span></span>

<span data-ttu-id="47b1a-119">L’illustration suivante montre les relations entre l’allocateur, les exemples de média et le filtre.</span><span class="sxs-lookup"><span data-stu-id="47b1a-119">The following illustration shows the relationships among the allocator, the media samples, and the filter.</span></span>

![exemples de supports et allocators](images/mediasamples.png)

<span data-ttu-id="47b1a-121">**Exemples de références de média**</span><span class="sxs-lookup"><span data-stu-id="47b1a-121">**Media Sample Reference Counts**</span></span>

<span data-ttu-id="47b1a-122">Un allocateur crée un pool fini d’exemples.</span><span class="sxs-lookup"><span data-stu-id="47b1a-122">An allocator creates a finite pool of samples.</span></span> <span data-ttu-id="47b1a-123">À tout moment, certains exemples peuvent être utilisés, tandis que d’autres sont disponibles pour les appels **GetBuffer** .</span><span class="sxs-lookup"><span data-stu-id="47b1a-123">At any time, some samples may be in use, while others are available for **GetBuffer** calls.</span></span> <span data-ttu-id="47b1a-124">L’allocateur utilise le comptage de références pour effectuer le suivi des exemples.</span><span class="sxs-lookup"><span data-stu-id="47b1a-124">The allocator uses reference counting to keep track of the samples.</span></span> <span data-ttu-id="47b1a-125">La méthode **GetBuffer** retourne un exemple avec un nombre de références de 1.</span><span class="sxs-lookup"><span data-stu-id="47b1a-125">The **GetBuffer** method returns a sample with a reference count of 1.</span></span> <span data-ttu-id="47b1a-126">Si le décompte de références atteint zéro, l’exemple repasse dans le pool de l’allocateur, où il peut être utilisé lors de l’appel **GetBuffer** suivant.</span><span class="sxs-lookup"><span data-stu-id="47b1a-126">If the reference count goes to zero, the sample goes back into the allocator's pool, where it can be used in the next **GetBuffer** call.</span></span> <span data-ttu-id="47b1a-127">Tant que le décompte de références reste au-dessus de zéro, l’exemple n’est pas disponible pour **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="47b1a-127">As long as the reference count remains above zero, the sample is not available to **GetBuffer**.</span></span> <span data-ttu-id="47b1a-128">Si chaque exemple appartenant à l’allocateur est en cours d’utilisation, la méthode **GetBuffer** se bloque jusqu’à ce qu’un exemple devienne disponible.</span><span class="sxs-lookup"><span data-stu-id="47b1a-128">If every sample belonging to the allocator is in use, the **GetBuffer** method blocks until a sample becomes available.</span></span>

<span data-ttu-id="47b1a-129">Supposons, par exemple, qu’une broche d’entrée reçoit un exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-129">For example, suppose that an input pin receives a sample.</span></span> <span data-ttu-id="47b1a-130">S’il traite l’exemple de façon synchrone, à l’intérieur de la méthode **Receive** , il n’incrémente pas le nombre de références.</span><span class="sxs-lookup"><span data-stu-id="47b1a-130">If it processes the sample synchronously, inside the **Receive** method, it does not increment the reference count.</span></span> <span data-ttu-id="47b1a-131">Une fois la **réception** retournée, la broche de sortie libère l’exemple, le décompte de références atteint zéro et l’exemple retourne au pool de l’allocateur.</span><span class="sxs-lookup"><span data-stu-id="47b1a-131">After **Receive** returns, the output pin releases the sample, the reference count goes to zero, and the sample returns to the allocator's pool.</span></span> <span data-ttu-id="47b1a-132">En revanche, si la broche d’entrée traite l’exemple sur un thread de travail, elle incrémente le nombre de références avant de quitter la méthode de **réception** .</span><span class="sxs-lookup"><span data-stu-id="47b1a-132">On the other hand, if the input pin processes the sample on a worker thread, it increments the reference count before leaving the **Receive** method.</span></span> <span data-ttu-id="47b1a-133">Le décompte de références est maintenant 2.</span><span class="sxs-lookup"><span data-stu-id="47b1a-133">The reference count is now 2.</span></span> <span data-ttu-id="47b1a-134">Lorsque la broche de sortie libère l’exemple, le nombre atteint 1 ; l’exemple ne retourne pas encore dans le pool.</span><span class="sxs-lookup"><span data-stu-id="47b1a-134">When the output pin releases the sample, the count goes to 1; the sample does not yet return to the pool.</span></span> <span data-ttu-id="47b1a-135">Une fois que le thread de travail est terminé avec l’exemple, il appelle **Release** pour libérer l’exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-135">After the worker thread is done with the sample, it calls **Release** to free the sample.</span></span> <span data-ttu-id="47b1a-136">À présent, l’exemple retourne au pool.</span><span class="sxs-lookup"><span data-stu-id="47b1a-136">Now the sample returns to the pool.</span></span>

<span data-ttu-id="47b1a-137">Lorsqu’un code confidentiel reçoit un échantillon, il peut copier les données vers un autre exemple, ou il peut modifier l’exemple d’origine et remettre celui-ci au filtre suivant.</span><span class="sxs-lookup"><span data-stu-id="47b1a-137">When a pin receives a sample, it can copy the data to another sample, or it can modify the original sample and deliver that one to the next filter.</span></span> <span data-ttu-id="47b1a-138">Peut-être qu’un exemple parcourt la longueur totale du graphique, chaque filtre appelant **AddRef** et **Release** à son tour.</span><span class="sxs-lookup"><span data-stu-id="47b1a-138">Potentially, a sample can travel the entire length of the graph, each filter calling **AddRef** and **Release** in turn.</span></span> <span data-ttu-id="47b1a-139">Par conséquent, la broche de sortie ne doit jamais réutiliser un exemple après avoir appelé **Receive**, car un filtre en aval peut utiliser l’exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-139">Therefore, the output pin must never re-use a sample after it calls **Receive**, because a downstream filter may be using the sample.</span></span> <span data-ttu-id="47b1a-140">La broche de sortie doit toujours appeler **GetBuffer** pour obtenir un nouvel exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-140">The output pin must always call **GetBuffer** to get a new sample.</span></span>

<span data-ttu-id="47b1a-141">Ce mécanisme réduit la quantité d’allocation de mémoire, car les filtres réutilisent les mêmes tampons.</span><span class="sxs-lookup"><span data-stu-id="47b1a-141">This mechanism reduces the amount of memory allocation, because filters re-use the same buffers.</span></span> <span data-ttu-id="47b1a-142">Il empêche également les filtres d’écrire accidentellement des données qui n’ont pas été traitées, car l’allocateur gère une liste d’exemples disponibles.</span><span class="sxs-lookup"><span data-stu-id="47b1a-142">It also prevents filters from accidentally writing over data that has not been processed, because the allocator maintains a list of available samples.</span></span>

<span data-ttu-id="47b1a-143">Un filtre peut utiliser des allocateurs distincts pour l’entrée et la sortie.</span><span class="sxs-lookup"><span data-stu-id="47b1a-143">A filter can use separate allocators for input and output.</span></span> <span data-ttu-id="47b1a-144">Cela peut se faire si elle développe les données d’entrée (par exemple, en les décompressant).</span><span class="sxs-lookup"><span data-stu-id="47b1a-144">It might do this if it expands the input data (for example, by decompressing it).</span></span> <span data-ttu-id="47b1a-145">Si la sortie n’est pas supérieure à l’entrée, un filtre peut traiter les données en place, sans les copier dans un nouvel exemple.</span><span class="sxs-lookup"><span data-stu-id="47b1a-145">If the output is no larger than the input, a filter might process the data in place, without copying it to a new sample.</span></span> <span data-ttu-id="47b1a-146">Dans ce cas, deux ou plusieurs connexions de code confidentiel peuvent partager un allocateur.</span><span class="sxs-lookup"><span data-stu-id="47b1a-146">In that case, two or more pin connections can share one allocator.</span></span>

<span data-ttu-id="47b1a-147">**Validation et dévalidation des allocateurs**</span><span class="sxs-lookup"><span data-stu-id="47b1a-147">**Committing and Decommitting Allocators**</span></span>

<span data-ttu-id="47b1a-148">Lorsqu’un filtre crée d’abord un allocateur, il n’a pas réservé de mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="47b1a-148">When a filter first creates an allocator, the allocator has not reserved any memory buffers.</span></span> <span data-ttu-id="47b1a-149">À ce stade, tous les appels à la méthode **GetBuffer** échouent.</span><span class="sxs-lookup"><span data-stu-id="47b1a-149">At this point, any calls to the **GetBuffer** method will fail.</span></span> <span data-ttu-id="47b1a-150">Lors du démarrage de la diffusion en continu, la broche de sortie appelle [**IMemAllocator :: Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), qui valide l’allocateur, provoquant l’allocation de mémoire.</span><span class="sxs-lookup"><span data-stu-id="47b1a-150">When streaming starts, the output pin calls [**IMemAllocator::Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), which commits the allocator, causing it to allocate memory.</span></span> <span data-ttu-id="47b1a-151">Les broches peuvent désormais appeler **GetBuffer**.</span><span class="sxs-lookup"><span data-stu-id="47b1a-151">Pins can now call **GetBuffer**.</span></span>

<span data-ttu-id="47b1a-152">Lorsque la diffusion en continu s’arrête, le code PIN appelle [**IMemAllocator ::D ecommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), qui annule l’allocation.</span><span class="sxs-lookup"><span data-stu-id="47b1a-152">When streaming stops, the pin calls [**IMemAllocator::Decommit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), which decommits the allocator.</span></span> <span data-ttu-id="47b1a-153">Tous les appels suivants à **GetBuffer** échouent jusqu’à ce que l’allocateur soit de nouveau validé.</span><span class="sxs-lookup"><span data-stu-id="47b1a-153">All subsequent calls to **GetBuffer** fail until the allocator is committed again.</span></span> <span data-ttu-id="47b1a-154">En outre, si des appels à **GetBuffer** sont bloqués actuellement en attente d’un exemple, ils retournent immédiatement un code d’échec.</span><span class="sxs-lookup"><span data-stu-id="47b1a-154">Also, if any calls to **GetBuffer** are currently blocked waiting for a sample, they immediately return a failure code.</span></span> <span data-ttu-id="47b1a-155">La méthode de **dévalidation** peut ou non libérer la mémoire, en fonction de l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="47b1a-155">The **Decommit** method may or may not free the memory, depending on the implementation.</span></span> <span data-ttu-id="47b1a-156">Par exemple, la classe [**CMemAllocator**](cmemallocator.md) attend que sa méthode de destructeur libère de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="47b1a-156">For example, the [**CMemAllocator**](cmemallocator.md) class waits until its destructor method to free memory.</span></span>

## <a name="related-topics"></a><span data-ttu-id="47b1a-157">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="47b1a-157">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="47b1a-158">Data Flow dans le graphique de filtre</span><span class="sxs-lookup"><span data-stu-id="47b1a-158">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
