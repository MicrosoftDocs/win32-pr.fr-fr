---
description: États de filtre
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: États de filtre
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "106516351"
---
# <a name="filter-states"></a><span data-ttu-id="d5497-103">États de filtre</span><span class="sxs-lookup"><span data-stu-id="d5497-103">Filter States</span></span>

<span data-ttu-id="d5497-104">Les filtres ont trois États possibles : arrêté, suspendu et en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="d5497-104">Filters have three possible states: stopped, paused, and running.</span></span> <span data-ttu-id="d5497-105">L’objectif de l’état suspendu est de signaler des données dans le graphique, afin qu’une commande Run réponde immédiatement.</span><span class="sxs-lookup"><span data-stu-id="d5497-105">The purpose of the paused state is to cue data in the graph, so that a run command responds immediately.</span></span> <span data-ttu-id="d5497-106">Le gestionnaire de graphique de filtre contrôle toutes les transitions d’État.</span><span class="sxs-lookup"><span data-stu-id="d5497-106">The Filter Graph Manager controls all state transitions.</span></span> <span data-ttu-id="d5497-107">Quand une application appelle [**IMediaControl :: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl ::P ause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)ou [**IMediaControl :: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), le gestionnaire de graphique de filtre appelle la méthode [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) correspondante sur tous les filtres.</span><span class="sxs-lookup"><span data-stu-id="d5497-107">When an application calls [**IMediaControl::Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**IMediaControl::Pause**](/windows/desktop/api/Control/nf-control-imediacontrol-pause), or [**IMediaControl::Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), the Filter Graph Manager calls the corresponding [**IMediaFilter**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) method on all of the filters.</span></span> <span data-ttu-id="d5497-108">Les transitions entre arrêt et exécution passent toujours par l’état suspendu. ainsi, si l’application appelle **s’exécuter** sur un graphique arrêté, le gestionnaire de graphes de filtre interrompt le graphique avant de l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="d5497-108">Transitions between stopped and running always go through the paused state, so if the application calls **Run** on a stopped graph, the Filter Graph Manager pauses the graph before running it.</span></span>

<span data-ttu-id="d5497-109">Pour la plupart des filtres, les États en cours d’exécution et en pause sont identiques.</span><span class="sxs-lookup"><span data-stu-id="d5497-109">For most filters, the running and paused states are identical.</span></span> <span data-ttu-id="d5497-110">Examinez le graphique de filtre suivant :</span><span class="sxs-lookup"><span data-stu-id="d5497-110">Consider the following filter graph:</span></span>

<span data-ttu-id="d5497-111">Convertisseur de > de > source</span><span class="sxs-lookup"><span data-stu-id="d5497-111">Source > Transform > Renderer</span></span>

<span data-ttu-id="d5497-112">Supposons que le filtre source ne soit pas une source de capture dynamique.</span><span class="sxs-lookup"><span data-stu-id="d5497-112">Assume for now that the source filter is not a live capture source.</span></span> <span data-ttu-id="d5497-113">Quand le filtre source est suspendu, il crée un thread qui génère de nouvelles données et les écrit dans des exemples de média aussi rapidement que possible.</span><span class="sxs-lookup"><span data-stu-id="d5497-113">When the source filter pauses, it creates a thread that generates new data and writes it into media samples as quickly as possible.</span></span> <span data-ttu-id="d5497-114">Le thread « pousse » les exemples en aval en appelant [**IMemInputPin :: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) sur la broche d’entrée du filtre de transformation.</span><span class="sxs-lookup"><span data-stu-id="d5497-114">The thread "pushes" the samples downstream by calling [**IMemInputPin::Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) on the transform filter's input pin.</span></span> <span data-ttu-id="d5497-115">Le filtre de transformation reçoit les exemples sur le thread du filtre source.</span><span class="sxs-lookup"><span data-stu-id="d5497-115">The transform filter receives the samples on the source filter's thread.</span></span> <span data-ttu-id="d5497-116">Il peut utiliser un thread de travail pour remettre les exemples au convertisseur, mais il les remet généralement sur le même thread.</span><span class="sxs-lookup"><span data-stu-id="d5497-116">It may use a worker thread to deliver the samples to the renderer, but typically it delivers them on the same thread.</span></span> <span data-ttu-id="d5497-117">Pendant que le convertisseur est suspendu, il attend de recevoir un exemple.</span><span class="sxs-lookup"><span data-stu-id="d5497-117">While the renderer is paused, it waits to receive a sample.</span></span> <span data-ttu-id="d5497-118">Une fois qu’il en reçoit un, il bloque et maintient cet exemple indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="d5497-118">After it receives one, it blocks and holds that sample indefinitely.</span></span> <span data-ttu-id="d5497-119">S’il s’agit d’un convertisseur vidéo, il affiche l’échantillon sous la forme d’une image d’affiche, en redessinant l’image si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="d5497-119">If it is a video renderer, it displays the sample as a poster image, repainting the image as necessary.</span></span>

<span data-ttu-id="d5497-120">À ce stade, le flux est entièrement qualifié et prêt pour le rendu.</span><span class="sxs-lookup"><span data-stu-id="d5497-120">At this point, the stream is fully cued and ready for rendering.</span></span> <span data-ttu-id="d5497-121">Si le graphique reste en pause, les échantillons se « accumulent » dans le graphique derrière le premier exemple, jusqu’à ce que chaque filtre soit bloqué dans [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou [**IMemAllocator :: GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="d5497-121">If the graph remains paused, samples will "pile up" in the graph behind the first sample, until every filter is blocked in [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) or [**IMemAllocator::GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="d5497-122">Cependant, aucune donnée n’est perdue.</span><span class="sxs-lookup"><span data-stu-id="d5497-122">No data is lost, though.</span></span> <span data-ttu-id="d5497-123">Une fois que le thread source est débloqué, il reprend simplement à partir du point où il est bloqué.</span><span class="sxs-lookup"><span data-stu-id="d5497-123">Once the source thread is unblocked, it simply resumes from the point where it blocked.</span></span>

<span data-ttu-id="d5497-124">Le filtre source et le filtre de transformation ignorent le passage de l’état suspendu à l’État en cours d’exécution. ils continuent simplement à traiter les données aussi rapidement que possible.</span><span class="sxs-lookup"><span data-stu-id="d5497-124">The source filter and the transform filter ignore the transition from paused to running—they simply continue to process data as fast as possible.</span></span> <span data-ttu-id="d5497-125">Toutefois, lorsque le convertisseur s’exécute, il démarre le rendu des exemples.</span><span class="sxs-lookup"><span data-stu-id="d5497-125">But when the renderer runs, it starts rendering samples.</span></span> <span data-ttu-id="d5497-126">Tout d’abord, il restitue l’exemple qu’il a conservé pendant qu’il a été suspendu.</span><span class="sxs-lookup"><span data-stu-id="d5497-126">First it renders the sample it held while it was paused.</span></span> <span data-ttu-id="d5497-127">Ensuite, chaque fois qu’il reçoit un nouvel échantillon, il calcule l’heure de présentation de l’exemple.</span><span class="sxs-lookup"><span data-stu-id="d5497-127">Then, each time it receives a new sample, it calculates the sample's presentation time.</span></span> <span data-ttu-id="d5497-128">(Pour plus d’informations, consultez [heure et horloges dans DirectShow](time-and-clocks-in-directshow.md).) Le convertisseur conserve chaque échantillon jusqu’à l’heure de la présentation, à partir duquel il affiche l’exemple.</span><span class="sxs-lookup"><span data-stu-id="d5497-128">(For details, see [Time and Clocks in DirectShow](time-and-clocks-in-directshow.md).) The renderer holds each sample until the presentation time, at which point it renders the sample.</span></span> <span data-ttu-id="d5497-129">Pendant qu’il attend l’heure de la présentation, il bloque la méthode de [**réception**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) ou reçoit de nouveaux exemples sur un thread de travail avec une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="d5497-129">While it waits for the presentation time, it either blocks in the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, or receives new samples on a worker thread with a queue.</span></span> <span data-ttu-id="d5497-130">Les filtres en amont du convertisseur ne sont pas impliqués dans la planification.</span><span class="sxs-lookup"><span data-stu-id="d5497-130">Filters upstream from the renderer are not involved in scheduling.</span></span>

<span data-ttu-id="d5497-131">Les sources en direct, telles que les appareils de capture, sont une exception à cette architecture générale.</span><span class="sxs-lookup"><span data-stu-id="d5497-131">Live sources, such as capture devices, are an exception to this general architecture.</span></span> <span data-ttu-id="d5497-132">Avec une source dynamique, il n’est pas approprié de signaler des données à l’avance.</span><span class="sxs-lookup"><span data-stu-id="d5497-132">With a live source, it is not appropriate to cue any data in advance.</span></span> <span data-ttu-id="d5497-133">L’application peut suspendre le graphique et attendre un certain temps avant de l’exécuter.</span><span class="sxs-lookup"><span data-stu-id="d5497-133">The application might pause the graph and then wait for a long time before running it.</span></span> <span data-ttu-id="d5497-134">Le graphique ne doit pas restituer des exemples « obsolètes ».</span><span class="sxs-lookup"><span data-stu-id="d5497-134">The graph should not render "stale" samples.</span></span> <span data-ttu-id="d5497-135">Par conséquent, une source dynamique ne produit aucun échantillon en pause, uniquement lors de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="d5497-135">Therefore, a live source produces no samples while paused, only while running.</span></span> <span data-ttu-id="d5497-136">Pour signaler ce fait au gestionnaire de graphique de filtre, la méthode [**IMediaFilter :: GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) du filtre source retourne \_ VFW \_ s \_ .</span><span class="sxs-lookup"><span data-stu-id="d5497-136">To signal this fact to the Filter Graph Manager, the source filter's [**IMediaFilter::GetState**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) method returns VFW\_S\_CANT\_CUE.</span></span> <span data-ttu-id="d5497-137">Ce code de retour indique que le filtre est passé à l’état suspendu, même si le convertisseur n’a pas reçu de données.</span><span class="sxs-lookup"><span data-stu-id="d5497-137">This return code indicates that the filter has switched to the paused state, even though the renderer did not receive any data.</span></span>

<span data-ttu-id="d5497-138">Lorsqu’un filtre s’arrête, il rejette tout autre échantillon qui lui est remis.</span><span class="sxs-lookup"><span data-stu-id="d5497-138">When a filter stops, it rejects any more samples delivered to it.</span></span> <span data-ttu-id="d5497-139">Les filtres sources arrêtent leurs threads de diffusion en continu et d’autres filtres arrêtent les threads de travail qu’ils ont pu créer.</span><span class="sxs-lookup"><span data-stu-id="d5497-139">Source filters shut down their streaming threads, and other filters shut down any worker threads they may have created.</span></span> <span data-ttu-id="d5497-140">Épingle les allocateurs à la validation.</span><span class="sxs-lookup"><span data-stu-id="d5497-140">Pins decommit their allocators.</span></span>

### <a name="state-transitions"></a><span data-ttu-id="d5497-141">Transitions d’état</span><span class="sxs-lookup"><span data-stu-id="d5497-141">State Transitions</span></span>

<span data-ttu-id="d5497-142">Le gestionnaire de graphique de filtre effectue toutes les transitions d’État dans l’ordre ascendant, en commençant par le convertisseur et en remontant jusqu’au filtre source.</span><span class="sxs-lookup"><span data-stu-id="d5497-142">The Filter Graph Manager carries out all state transitions in upstream order, starting from the renderer and working backward to the source filter.</span></span> <span data-ttu-id="d5497-143">Ce classement est nécessaire pour empêcher la suppression des exemples et empêcher le blocage du graphique.</span><span class="sxs-lookup"><span data-stu-id="d5497-143">This ordering is necessary to prevent samples from being dropped and to prevent the graph from deadlocking.</span></span> <span data-ttu-id="d5497-144">Les transitions d’état les plus importantes sont comprises entre pause et arrêt :</span><span class="sxs-lookup"><span data-stu-id="d5497-144">The most crucial state transitions are between paused and stopped:</span></span>

-   <span data-ttu-id="d5497-145">Arrêté pour être suspendu : lorsque chaque filtre est suspendu, il est prêt à recevoir des exemples à partir du filtre suivant.</span><span class="sxs-lookup"><span data-stu-id="d5497-145">Stopped to paused: As each filter pauses, it becomes ready to receive samples from the next filter.</span></span> <span data-ttu-id="d5497-146">Le filtre source est le dernier à être suspendu.</span><span class="sxs-lookup"><span data-stu-id="d5497-146">The source filter is the last to pause.</span></span> <span data-ttu-id="d5497-147">Il crée le thread de streaming et commence à envoyer des exemples.</span><span class="sxs-lookup"><span data-stu-id="d5497-147">It creates the streaming thread and begins delivering samples.</span></span> <span data-ttu-id="d5497-148">Étant donné que tous les filtres en aval sont suspendus, aucun filtre ne rejette les échantillons.</span><span class="sxs-lookup"><span data-stu-id="d5497-148">Because all of the downstream filters are paused, no filter rejects any samples.</span></span> <span data-ttu-id="d5497-149">Le gestionnaire de graphique de filtre n’effectue pas la transition tant que chaque convertisseur du graphique n’a pas reçu d’exemple (à l’exception des sources en direct, comme décrit précédemment).</span><span class="sxs-lookup"><span data-stu-id="d5497-149">The Filter Graph Manager does not complete the transition until every renderer in the graph has received a sample (with the exception of live sources, as described earlier).</span></span>
-   <span data-ttu-id="d5497-150">Suspendu à arrêté : lorsqu’un filtre s’arrête, il libère tous les exemples qu’il contient, qui débloque les filtres en amont en attente dans [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span><span class="sxs-lookup"><span data-stu-id="d5497-150">Paused to stopped: When a filter stops, it releases any samples that it holds, which unblocks any upstream filters waiting in [**GetBuffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).</span></span> <span data-ttu-id="d5497-151">Si le filtre attend une ressource à l’intérieur de la méthode [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , il cesse d’attendre et retourne de **Receive**, ce qui débloque le filtre appelant.</span><span class="sxs-lookup"><span data-stu-id="d5497-151">If the filter is waiting for a resource inside the [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) method, it stops waiting and returns from **Receive**, which unblocks the calling filter.</span></span> <span data-ttu-id="d5497-152">Par conséquent, lorsque le gestionnaire de graphes de filtres arrête le filtre amont suivant, ce filtre n’est pas bloqué dans **GetBuffer** ou **Receive** et peut répondre à la commande Stop.</span><span class="sxs-lookup"><span data-stu-id="d5497-152">Therefore, when the Filter Graph Manager stops the next upstream filter, that filter is not blocked in either **GetBuffer** or **Receive**, and can respond to the stop command.</span></span> <span data-ttu-id="d5497-153">Le filtre amont peut fournir quelques exemples supplémentaires avant d’obtenir la commande arrêter, mais le filtre en aval les rejette simplement, car il est déjà arrêté.</span><span class="sxs-lookup"><span data-stu-id="d5497-153">The upstream filter might deliver a few extra samples before it gets the stop command, but the downstream filter simply rejects them, because it already stopped.</span></span>

## <a name="related-topics"></a><span data-ttu-id="d5497-154">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="d5497-154">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="d5497-155">Data Flow dans le graphique de filtre</span><span class="sxs-lookup"><span data-stu-id="d5497-155">Data Flow in the Filter Graph</span></span>](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



