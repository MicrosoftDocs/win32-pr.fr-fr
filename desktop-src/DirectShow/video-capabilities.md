---
description: Fonctionnalités vidéo
ms.assetid: 305bd009-f58e-4dcc-9b70-252de87dc86d
title: Fonctionnalités vidéo
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6287839b75bd5044644480c3abcc8248cc46dc0a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104564194"
---
# <a name="video-capabilities"></a><span data-ttu-id="58910-103">Fonctionnalités vidéo</span><span class="sxs-lookup"><span data-stu-id="58910-103">Video Capabilities</span></span>

<span data-ttu-id="58910-104">La méthode [**IAMStreamConfig :: GetStreamCaps**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) présente des fonctionnalités vidéo dans un tableau de paires de structures d' [**\_ \_ \_ embouts de configuration de flux vidéo**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) et de [**\_ \_ type de média am**](/windows/win32/api/strmif/ns-strmif-am_media_type) .</span><span class="sxs-lookup"><span data-stu-id="58910-104">The [**IAMStreamConfig::GetStreamCaps**](/windows/desktop/api/Strmif/nf-strmif-iamstreamconfig-getstreamcaps) method presents video capabilities in an array of pairs of [**AM\_MEDIA\_TYPE**](/windows/win32/api/strmif/ns-strmif-am_media_type) and [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structures.</span></span> <span data-ttu-id="58910-105">Vous pouvez l’utiliser pour exposer tous les formats et résolutions pris en charge sur un code confidentiel, comme indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="58910-105">You can use this to expose all the formats and resolutions supported on a pin as discussed below.</span></span>

<span data-ttu-id="58910-106">Pour obtenir des exemples liés à l’audio de **GetStreamCaps**, consultez [fonctionnalités audio](audio-capabilities.md).</span><span class="sxs-lookup"><span data-stu-id="58910-106">For audio-related examples of **GetStreamCaps**, see [Audio Capabilities](audio-capabilities.md).</span></span>

<span data-ttu-id="58910-107">Supposons que votre carte de capture prend en charge le format JPEG à toutes les résolutions entre 160 x 120 pixels et 320 x 240 pixels, inclus.</span><span class="sxs-lookup"><span data-stu-id="58910-107">Suppose your capture card supports JPEG format at all resolutions between 160 x 120 pixels and 320 x 240 pixels, inclusive.</span></span> <span data-ttu-id="58910-108">Dans ce cas, la différence entre les résolutions prises en charge est le suivant : vous pouvez ajouter ou soustraire un pixel de chaque résolution prise en charge pour bénéficier de la résolution prise en charge suivante.</span><span class="sxs-lookup"><span data-stu-id="58910-108">The difference between supported resolutions is one in this case because you add or subtract one pixel from each supported resolution to get the next supported resolution.</span></span> <span data-ttu-id="58910-109">Cette différence dans les résolutions prises en charge est appelée granularité.</span><span class="sxs-lookup"><span data-stu-id="58910-109">This difference in supported resolutions is called granularity.</span></span>

<span data-ttu-id="58910-110">Supposons que votre carte prenne également en charge la taille 640 x 480.</span><span class="sxs-lookup"><span data-stu-id="58910-110">Suppose your card also supports the size 640 x 480.</span></span> <span data-ttu-id="58910-111">L’exemple suivant illustre cette résolution unique et la plage de résolutions ci-dessus (toutes les tailles comprises entre 160 x 120 pixels et 320 x 240 pixels).</span><span class="sxs-lookup"><span data-stu-id="58910-111">The following illustrates this single resolution and the above range of resolutions (all sizes between 160 x 120 pixels and 320 x 240 pixels).</span></span>

![résolution de 160 x 120 à 320 x 240 pixels, plus 640 x 480](images/strmcap1.png)

<span data-ttu-id="58910-113">Par ailleurs, supposez qu’il prend en charge le format RVB de couleur 24 bits à des résolutions comprises entre 160 x 120 et 320 x 240, mais avec une granularité de 8.</span><span class="sxs-lookup"><span data-stu-id="58910-113">Also, suppose it supports 24-bit color RGB format at resolutions between 160 x 120 and 320 x 240, but with a granularity of 8.</span></span> <span data-ttu-id="58910-114">L’illustration suivante montre certaines des tailles valides dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="58910-114">The following illustration shows some of the valid sizes in this case.</span></span>

![résolution de 160 x 120 à 320 à 240, avec une granularité égale à 8](images/strmcap3.png)

<span data-ttu-id="58910-116">Pour en faire une autre façon et en répertoriant davantage de résolutions, les éléments suivants se trouvent dans la liste des résolutions valides.</span><span class="sxs-lookup"><span data-stu-id="58910-116">To put it another way, and listing more resolutions, the following are all among the list of valid resolutions.</span></span>

-   <span data-ttu-id="58910-117">160 x 120</span><span class="sxs-lookup"><span data-stu-id="58910-117">160 x 120</span></span>
-   <span data-ttu-id="58910-118">168 x 120</span><span class="sxs-lookup"><span data-stu-id="58910-118">168 x 120</span></span>
-   <span data-ttu-id="58910-119">168 x 128</span><span class="sxs-lookup"><span data-stu-id="58910-119">168 x 128</span></span>
-   <span data-ttu-id="58910-120">176 x 128</span><span class="sxs-lookup"><span data-stu-id="58910-120">176 x 128</span></span>
-   <span data-ttu-id="58910-121">176 x 136</span><span class="sxs-lookup"><span data-stu-id="58910-121">176 x 136</span></span>
-   <span data-ttu-id="58910-122">... résolutions supplémentaires...</span><span class="sxs-lookup"><span data-stu-id="58910-122">... additional resolutions ...</span></span>
-   <span data-ttu-id="58910-123">312 x 232</span><span class="sxs-lookup"><span data-stu-id="58910-123">312 x 232</span></span>
-   <span data-ttu-id="58910-124">320 x 240</span><span class="sxs-lookup"><span data-stu-id="58910-124">320 x 240</span></span>

<span data-ttu-id="58910-125">Utilisez **GetStreamCaps** pour exposer ces fonctionnalités de format et de dimension en offrant un type de média 320 x 240 JPEG (s’il s’agit de votre taille par défaut ou par défaut) associé aux fonctionnalités minimales de 160 x 120, aux capacités maximales de 320 x 240 et à une granularité de 1.</span><span class="sxs-lookup"><span data-stu-id="58910-125">Use **GetStreamCaps** to expose these color format and dimension capabilities by offering a media type of 320 x 240 JPEG (if that is your default or preferred size) coupled with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 1.</span></span> <span data-ttu-id="58910-126">La paire suivante que vous exposez à l’aide de **GetStreamCaps** est un type de média 640 x 480 JPEG couplé avec au minimum 640 x 480 et un maximum de 640 x 480 et une granularité de 0.</span><span class="sxs-lookup"><span data-stu-id="58910-126">The next pair you expose by using **GetStreamCaps** is a media type of 640 x 480 JPEG coupled with a minimum of 640 x 480 and a maximum of 640 x 480 and a granularity of 0.</span></span> <span data-ttu-id="58910-127">La troisième paire comprend un type de support 320 x 240, RGB 24 bits avec des fonctionnalités minimales de 160 x 120, des capacités maximales de 320 x 240 et une granularité de 8.</span><span class="sxs-lookup"><span data-stu-id="58910-127">The third pair includes a media type of 320 x 240, 24-bit RGB with minimum capabilities of 160 x 120, maximum capabilities of 320 x 240, and a granularity of 8.</span></span> <span data-ttu-id="58910-128">De cette façon, vous pouvez publier presque tout le format et les capacités que votre carte peut prendre en charge.</span><span class="sxs-lookup"><span data-stu-id="58910-128">In this way you can publish almost every format and capability your card might support.</span></span> <span data-ttu-id="58910-129">Une application qui doit connaître les formats de compression que vous fournissez peut obtenir toutes les paires et dresser la liste de tous les sous-types uniques des types de médias.</span><span class="sxs-lookup"><span data-stu-id="58910-129">An application that must know what compression formats you provide can get all the pairs and make a list of all the unique subtypes of the media types.</span></span>

<span data-ttu-id="58910-130">Un filtre obtient ses rectangles source de type de média et cible à partir des membres **rcSource** et **rcTarget** de la structure [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) , respectivement.</span><span class="sxs-lookup"><span data-stu-id="58910-130">A filter obtains its media type source and target rectangles from the [**VIDEOINFOHEADER**](/previous-versions/windows/desktop/api/amvideo/ns-amvideo-videoinfoheader) structure's **rcSource** and **rcTarget** members, respectively.</span></span> <span data-ttu-id="58910-131">Les filtres n’ont pas besoin de prendre en charge les rectangles source et cible.</span><span class="sxs-lookup"><span data-stu-id="58910-131">Filters do not have to support source and target rectangles.</span></span>

<span data-ttu-id="58910-132">Le rectangle de rognage décrit dans la documentation [**IAMStreamConfig**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) est le même que le rectangle **rcSource** de la structure **VIDEOINFOHEADER** pour la broche de sortie.</span><span class="sxs-lookup"><span data-stu-id="58910-132">The cropping rectangle described throughout the [**IAMStreamConfig**](/windows/desktop/api/Strmif/nn-strmif-iamstreamconfig) documentation is the same as the **VIDEOINFOHEADER** structure's **rcSource** rectangle for the output pin.</span></span>

<span data-ttu-id="58910-133">Le rectangle de sortie décrit dans la documentation **IAMStreamConfig** est le même que celui des membres **bilargeur** et **biheight** de la structure **BITMAPINFOHEADER** du code confidentiel de sortie (consultez [données DV dans le format de fichier AVI](dv-data-in-the-avi-file-format.md)).</span><span class="sxs-lookup"><span data-stu-id="58910-133">The output rectangle described throughout the **IAMStreamConfig** documentation is the same as the **biWidth** and **biHeight** members of the output pin's **BITMAPINFOHEADER** structure (see [DV Data in the AVI File Format](dv-data-in-the-avi-file-format.md).).</span></span>

<span data-ttu-id="58910-134">Si la broche de sortie d’un filtre est connectée à un type de média avec des rectangles sources et cibles non vides, votre filtre est requis pour étirer le sous-rectangle source du format d’entrée dans le sous-rectangle cible du format de sortie.</span><span class="sxs-lookup"><span data-stu-id="58910-134">If a filter's output pin is connected to a media type with nonempty source and target rectangles, then your filter is required to stretch the input format's source subrectangle into the output format's target subrectangle.</span></span> <span data-ttu-id="58910-135">Le sous-rectangle source est stocké dans le membre **Inputs** de la structure de [**\_ configuration de flux \_ \_ vidéo**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) .</span><span class="sxs-lookup"><span data-stu-id="58910-135">The source subrectangle is stored in the [**VIDEO\_STREAM\_CONFIG\_CAPS**](/windows/win32/api/strmif/ns-strmif-video_stream_config_caps) structure's **InputSize** member.</span></span>

<span data-ttu-id="58910-136">Par exemple, considérez le scénario de compresseur vidéo suivant : l’image d’entrée est au format RVB et a une taille de 160 x 120 pixels.</span><span class="sxs-lookup"><span data-stu-id="58910-136">For example, consider the following video compressor scenario: The input image is in RGB format and has a size of 160 x 120 pixels.</span></span> <span data-ttu-id="58910-137">L’angle supérieur gauche du rectangle source est à la coordonnée (20, 20) et son coin inférieur droit est à (30, 30).</span><span class="sxs-lookup"><span data-stu-id="58910-137">The source rectangle's upper-left corner is at coordinate (20,20), and its lower-right corner is at (30,30).</span></span> <span data-ttu-id="58910-138">L’image de sortie est au format MPEG avec une taille de 320 x 240.</span><span class="sxs-lookup"><span data-stu-id="58910-138">The output image is in MPEG format with a size of 320 x 240.</span></span> <span data-ttu-id="58910-139">L’angle supérieur gauche du rectangle cible se trouve à (0,0) et son coin inférieur droit est à (100 100).</span><span class="sxs-lookup"><span data-stu-id="58910-139">The target rectangle's upper-left corner is at (0,0) and its lower-right corner is at (100,100).</span></span> <span data-ttu-id="58910-140">Dans ce cas, le filtre doit prendre une partie de 10 x 10 de l’image bitmap source RVB 160 x 120, et le faire remplir la première zone de 100 x 100 d’une image bitmap 320 x 240, laissant le reste de la bitmap 320 x 240 intact.</span><span class="sxs-lookup"><span data-stu-id="58910-140">In this case, the filter should take a 10 x 10 piece of the 160 x 120 RGB source bitmap, and make it fill the top 100 x 100 area of a 320 x 240 bitmap, leaving the rest of the 320 x 240 bitmap untouched.</span></span> <span data-ttu-id="58910-141">L’illustration suivante montre ce scénario.</span><span class="sxs-lookup"><span data-stu-id="58910-141">The following illustration shows this scenario.</span></span>

![étirement de sous-rectangles](images/strmcap4.png)

<span data-ttu-id="58910-143">Un filtre ne prend peut-être pas en charge cette opération et peut échouer pour se connecter à un type de média où **rcSource** et **rcTarget** ne sont pas vides.</span><span class="sxs-lookup"><span data-stu-id="58910-143">A filter might not support this and can fail to connect with a media type where **rcSource** and **rcTarget** are not empty.</span></span>

<span data-ttu-id="58910-144">La structure **VIDEOINFOHEADER** expose des informations sur les capacités de débit de données d’un filtre.</span><span class="sxs-lookup"><span data-stu-id="58910-144">The **VIDEOINFOHEADER** structure exposes information about a filter's data rate capabilities.</span></span> <span data-ttu-id="58910-145">Par exemple, supposons que vous avez connecté votre broche de sortie au filtre suivant avec un certain type de média (soit directement, soit à l’aide du type de support passé par la fonction [**CMediaType :: SetFormat**](cmediatype-setformat.md) ).</span><span class="sxs-lookup"><span data-stu-id="58910-145">For example, suppose you connected your output pin to the next filter with a certain media type (either directly or by using the media type passed by the [**CMediaType::SetFormat**](cmediatype-setformat.md) function).</span></span> <span data-ttu-id="58910-146">Examinez le membre **dwBitRate** de la structure de format **VIDEOINFOHEADER** de ce type de média pour déterminer le débit de données à partir duquel vous souhaitez compresser la vidéo.</span><span class="sxs-lookup"><span data-stu-id="58910-146">Look at the **dwBitRate** member of that media type's **VIDEOINFOHEADER** format structure to see what data rate you should compress the video to.</span></span> <span data-ttu-id="58910-147">Si vous multipliez le nombre d’unités de temps par Frame dans le membre **AvgTimePerFrame** de la structure **VIDEOINFOHEADER** par le débit de données dans le membre **dwBitRate** et divisez par 10 millions (nombre d’unités par seconde), vous pouvez déterminer le nombre d’octets de chaque trame.</span><span class="sxs-lookup"><span data-stu-id="58910-147">If you multiply the number of units of time per frame in the **VIDEOINFOHEADER** structure's **AvgTimePerFrame** member by the data rate in the **dwBitRate** member and divide by 10,000,000 (the number of units per second), you can figure out how many bytes each frame should be.</span></span> <span data-ttu-id="58910-148">Vous pouvez produire un cadre de taille inférieure, mais jamais un plus grand.</span><span class="sxs-lookup"><span data-stu-id="58910-148">You can produce a smaller sized frame, but never a larger one.</span></span> <span data-ttu-id="58910-149">Pour déterminer la fréquence d’images d’un compresseur vidéo ou d’un filtre de capture, utilisez **AvgTimePerFrame** à partir du type de média de votre broche de sortie.</span><span class="sxs-lookup"><span data-stu-id="58910-149">To determine the frame rate for a video compressor or for a capture filter, use **AvgTimePerFrame** from your output pin's media type.</span></span>

 

 



