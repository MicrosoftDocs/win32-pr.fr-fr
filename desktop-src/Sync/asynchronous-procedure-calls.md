---
description: Un appel de procédure asynchrone (APC) est une fonction qui s’exécute de façon asynchrone dans le contexte d’un thread particulier.
ms.assetid: 0197d78e-a4dc-414b-88ba-c5ec5f2ed614
title: Appels de procédure asynchrone
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dd95e9afd663e2a462335b3c47bfe99462b449e7
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "103952495"
---
# <a name="asynchronous-procedure-calls"></a><span data-ttu-id="a2426-103">Appels de procédure asynchrone</span><span class="sxs-lookup"><span data-stu-id="a2426-103">Asynchronous Procedure Calls</span></span>

<span data-ttu-id="a2426-104">Un *appel de procédure asynchrone* (APC) est une fonction qui s’exécute de façon asynchrone dans le contexte d’un thread particulier.</span><span class="sxs-lookup"><span data-stu-id="a2426-104">An *asynchronous procedure call* (APC) is a function that executes asynchronously in the context of a particular thread.</span></span> <span data-ttu-id="a2426-105">Lorsqu’un APC est mis en file d’attente sur un thread, le système émet une interruption logicielle.</span><span class="sxs-lookup"><span data-stu-id="a2426-105">When an APC is queued to a thread, the system issues a software interrupt.</span></span> <span data-ttu-id="a2426-106">La prochaine fois que le thread sera planifié, il exécutera la fonction APC.</span><span class="sxs-lookup"><span data-stu-id="a2426-106">The next time the thread is scheduled, it will run the APC function.</span></span> <span data-ttu-id="a2426-107">Un APC généré par le système est appelé *APC en mode noyau*.</span><span class="sxs-lookup"><span data-stu-id="a2426-107">An APC generated by the system is called a *kernel-mode APC*.</span></span> <span data-ttu-id="a2426-108">Un APC généré par une application est appelé *APC en mode utilisateur*.</span><span class="sxs-lookup"><span data-stu-id="a2426-108">An APC generated by an application is called a *user-mode APC*.</span></span> <span data-ttu-id="a2426-109">Un thread doit être dans un état d’alerte pour exécuter un APC en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="a2426-109">A thread must be in an alertable state to run a user-mode APC.</span></span>

<span data-ttu-id="a2426-110">Chaque thread possède sa propre file d’attente APC.</span><span class="sxs-lookup"><span data-stu-id="a2426-110">Each thread has its own APC queue.</span></span> <span data-ttu-id="a2426-111">Une application met en file d’attente un APC sur un thread en appelant la fonction [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) .</span><span class="sxs-lookup"><span data-stu-id="a2426-111">An application queues an APC to a thread by calling the [**QueueUserAPC**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc) function.</span></span> <span data-ttu-id="a2426-112">Le thread appelant spécifie l’adresse d’une fonction APC dans l’appel à **QueueUserAPC**.</span><span class="sxs-lookup"><span data-stu-id="a2426-112">The calling thread specifies the address of an APC function in the call to **QueueUserAPC**.</span></span> <span data-ttu-id="a2426-113">La mise en file d’attente d’un APC est une demande pour que le thread appelle la fonction APC.</span><span class="sxs-lookup"><span data-stu-id="a2426-113">The queuing of an APC is a request for the thread to call the APC function.</span></span>

<span data-ttu-id="a2426-114">Lorsqu’un APC en mode utilisateur est mis en file d’attente, le thread dans lequel il est mis en file d’attente n’est pas dirigé vers l’appel de la fonction APC, sauf s’il est dans un état d’alerte.</span><span class="sxs-lookup"><span data-stu-id="a2426-114">When a user-mode APC is queued, the thread to which it is queued is not directed to call the APC function unless it is in an alertable state.</span></span> <span data-ttu-id="a2426-115">Un thread entre dans un état d’alerte quand il appelle la fonction [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex)ou [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) .</span><span class="sxs-lookup"><span data-stu-id="a2426-115">A thread enters an alertable state when it calls the [**SleepEx**](/windows/win32/api/synchapi/nf-synchapi-sleepex), [**SignalObjectAndWait**](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), [**MsgWaitForMultipleObjectsEx**](/windows/desktop/api/Winuser/nf-winuser-msgwaitformultipleobjectsex), [**WaitForMultipleObjectsEx**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), or [**WaitForSingleObjectEx**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex) function.</span></span> <span data-ttu-id="a2426-116">Si l’attente est satisfaite avant que l’APC ne soit mis en file d’attente, le thread n’est plus dans un état d’attente d’alerte, de sorte que la fonction APC ne sera pas exécutée.</span><span class="sxs-lookup"><span data-stu-id="a2426-116">If the wait is satisfied before the APC is queued, the thread is no longer in an alertable wait state so the APC function will not be executed.</span></span> <span data-ttu-id="a2426-117">Toutefois, l’APC est toujours mis en file d’attente, de sorte que la fonction APC est exécutée lorsque le thread appelle une autre fonction d’attente alertable.</span><span class="sxs-lookup"><span data-stu-id="a2426-117">However, the APC is still queued, so the APC function will be executed when the thread calls another alertable wait function.</span></span>

<span data-ttu-id="a2426-118">Les fonctions [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex)et [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) sont implémentées à l’aide d’un APC comme mécanisme de rappel de notification d’achèvement.</span><span class="sxs-lookup"><span data-stu-id="a2426-118">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex), [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer), [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions are implemented using an APC as the completion notification callback mechanism.</span></span>

<span data-ttu-id="a2426-119">Si vous utilisez un [pool de threads](../procthread/thread-pools.md), Notez que les APC ne fonctionnent pas et d’autres mécanismes de signalisation, car le système contrôle la durée de vie des threads du pool de threads. il est donc possible qu’un thread se termine avant la remise de la notification.</span><span class="sxs-lookup"><span data-stu-id="a2426-119">If you are using a [thread pool](../procthread/thread-pools.md), note that APCs do not work as well as other signaling mechanisms because the system controls the lifetime of thread pool threads, so it is possible for a thread to be terminated before the notification is delivered.</span></span> <span data-ttu-id="a2426-120">Au lieu d’utiliser un mécanisme de signalisation basé sur APC, tel que le paramètre *pfnCompletionRoutine* de [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) ou [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), utilisez un objet d’attente, tel qu’un Timer créé avec [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span><span class="sxs-lookup"><span data-stu-id="a2426-120">Instead of using an APC-based signaling mechanism such as the *pfnCompletionRoutine* parameter of [**SetWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) or [**SetWaitableTimerEx**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimerex), use a waitable object such as a timer created with [**CreateThreadpoolTimer**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer).</span></span> <span data-ttu-id="a2426-121">Pour les e/s, utilisez un objet de fin d’e/s créé avec [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) ou une [**structure OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) basée sur *hEvent* où l’événement peut être passé à la fonction [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) .</span><span class="sxs-lookup"><span data-stu-id="a2426-121">For I/O, use an I/O completion object created with [**CreateThreadpoolIo**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpoolio) or an *hEvent*-based [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure where the event can be passed to the [**SetThreadpoolWait**](/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-setthreadpoolwait) function.</span></span>

## <a name="synchronization-internals"></a><span data-ttu-id="a2426-122">Éléments internes de la synchronisation</span><span class="sxs-lookup"><span data-stu-id="a2426-122">Synchronization Internals</span></span>

<span data-ttu-id="a2426-123">Lorsqu’une demande d’e/s est émise, une structure est allouée pour représenter la demande.</span><span class="sxs-lookup"><span data-stu-id="a2426-123">When an I/O request is issued, a structure is allocated to represent the request.</span></span> <span data-ttu-id="a2426-124">Cette structure est appelée paquet de demande d’e/s (IRP).</span><span class="sxs-lookup"><span data-stu-id="a2426-124">This structure is called an I/O request packet (IRP).</span></span> <span data-ttu-id="a2426-125">Avec les e/s synchrones, le thread génère l’IRP, l’envoie à la pile de l’appareil et attend que l’IRP se termine.</span><span class="sxs-lookup"><span data-stu-id="a2426-125">With synchronous I/O, the thread builds the IRP, sends it to the device stack, and waits in the kernel for the IRP to complete.</span></span> <span data-ttu-id="a2426-126">Avec les e/s asynchrones, le thread génère l’IRP et l’envoie à la pile de l’appareil.</span><span class="sxs-lookup"><span data-stu-id="a2426-126">With asynchronous I/O, the thread builds the IRP and sends it to the device stack.</span></span> <span data-ttu-id="a2426-127">La pile peut effectuer immédiatement la IRP, ou elle peut retourner un état d’attente indiquant que la demande est en cours.</span><span class="sxs-lookup"><span data-stu-id="a2426-127">The stack might complete the IRP immediately, or it might return a pending status indicating that the request is in progress.</span></span> <span data-ttu-id="a2426-128">Dans ce cas, la IRP est toujours associée au thread, donc elle sera annulée si le thread se termine ou appelle une fonction telle que [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span><span class="sxs-lookup"><span data-stu-id="a2426-128">When this happens, the IRP is still associated with the thread, so it will be canceled if the thread terminates or calls a function such as [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio).</span></span> <span data-ttu-id="a2426-129">Dans le même temps, le thread peut continuer à exécuter d’autres tâches pendant que la pile de l’appareil continue à traiter l’IRP.</span><span class="sxs-lookup"><span data-stu-id="a2426-129">In the meantime, the thread can continue to perform other tasks while the device stack continues to process the IRP.</span></span>

<span data-ttu-id="a2426-130">Le système peut indiquer plusieurs méthodes pour indiquer que la IRP est terminée :</span><span class="sxs-lookup"><span data-stu-id="a2426-130">There are several ways that the system can indicate that the IRP has completed:</span></span>

-   <span data-ttu-id="a2426-131">Mettez à jour la structure OVERLAPPED avec le résultat de l’opération afin que le thread puisse interroger pour déterminer si l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="a2426-131">Update the overlapped structure with the result of the operation so the thread can poll to determine whether the operation has completed.</span></span>
-   <span data-ttu-id="a2426-132">Signalez l’événement dans la structure OVERLAPPED pour qu’un thread puisse se synchroniser sur l’événement et être réveillée lorsque l’opération se termine.</span><span class="sxs-lookup"><span data-stu-id="a2426-132">Signal the event in the overlapped structure so a thread can synchronize on the event and be woken when the operation completes.</span></span>
-   <span data-ttu-id="a2426-133">Met en file d’attente l’IRP vers l’APC en attente du thread afin que le thread exécute la routine APC lorsqu’il entre dans un état d’attente alerté et retourne à partir de l’opération d’attente avec un état indiquant qu’il a exécuté une ou plusieurs routines APC.</span><span class="sxs-lookup"><span data-stu-id="a2426-133">Queue the IRP to the thread's pending APC so that the thread will execute the APC routine when it enters an alertable wait state and return from the wait operation with a status indicating that it executed one or more APC routines.</span></span>
-   <span data-ttu-id="a2426-134">Mettre l’IRP en file d’attente sur un port de terminaison d’e/s, où il sera exécuté par le thread suivant qui attend le port de terminaison.</span><span class="sxs-lookup"><span data-stu-id="a2426-134">Queue the IRP to an I/O completion port, where it will be executed by the next thread that waits on the completion port.</span></span>

<span data-ttu-id="a2426-135">Les threads qui attendent un port de terminaison d’e/s n’attendent pas dans un état d’alerte.</span><span class="sxs-lookup"><span data-stu-id="a2426-135">Threads that wait on an I/O completion port do not wait in an alertable state.</span></span> <span data-ttu-id="a2426-136">Par conséquent, si ces threads émettent des IRP qui sont définis pour s’exécuter comme des APC pour le thread, ces achèvements IPC ne se produiront pas dans les délais. ils se produisent uniquement si le thread récupère une demande à partir du port de terminaison d’e/s, puis qu’il passe à une attente d’alerte.</span><span class="sxs-lookup"><span data-stu-id="a2426-136">Therefore, if those threads issue IRPs that are set to complete as APCs to the thread, those IPC completions will not occur in a timely manner; they will occur only if the thread picks up a request from the I/O completion port and then happens to enter an alertable wait.</span></span>

## <a name="related-topics"></a><span data-ttu-id="a2426-137">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="a2426-137">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="a2426-138">Utilisation d’un minuteur qui peut être utilisé avec un appel de procédure asynchrone</span><span class="sxs-lookup"><span data-stu-id="a2426-138">Using a Waitable Timer with an Asynchronous Procedure Call</span></span>](using-a-waitable-timer-with-an-asynchronous-procedure-call.md)
</dt> </dl>

 

 
