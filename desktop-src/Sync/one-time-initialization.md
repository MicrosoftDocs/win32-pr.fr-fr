---
description: Les composants sont souvent conçus pour effectuer des tâches d’initialisation lorsqu’ils sont appelés pour la première fois, plutôt que lorsqu’ils sont chargés.
ms.assetid: 404c083c-7bee-44c2-b8e7-da1901b6ab2f
title: Initialisation One-Time
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 16f451e3c51716b4ff6f33b55d8d8602b5d5c28f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106529452"
---
# <a name="one-time-initialization"></a><span data-ttu-id="8ea37-103">Initialisation One-Time</span><span class="sxs-lookup"><span data-stu-id="8ea37-103">One-Time Initialization</span></span>

<span data-ttu-id="8ea37-104">Les composants sont souvent conçus pour effectuer des tâches d’initialisation lorsqu’ils sont appelés pour la première fois, plutôt que lorsqu’ils sont chargés.</span><span class="sxs-lookup"><span data-stu-id="8ea37-104">Components are often designed to perform initialization tasks when they are first called, rather than when they are loaded.</span></span> <span data-ttu-id="8ea37-105">Les fonctions d’initialisation ponctuelles garantissent que cette initialisation se produit une seule fois, même lorsque plusieurs threads peuvent tenter l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-105">The one-time initialization functions ensure that this initialization occurs only once, even when multiple threads may attempt the initialization.</span></span>

<span data-ttu-id="8ea37-106">**Windows Server 2003 et Windows XP :** Les applications doivent fournir leur propre synchronisation pour une initialisation unique à l’aide des [fonctions bloquées](interlocked-variable-access.md) ou d’un autre mécanisme de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-106">**Windows Server 2003 and Windows XP:** Applications must provide their own synchronization for one-time initialization by using the [interlocked functions](interlocked-variable-access.md) or other synchronization mechanism.</span></span> <span data-ttu-id="8ea37-107">Les fonctions d’initialisation unique sont disponibles à partir de Windows Vista et de Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="8ea37-107">The one-time initialization functions are available starting with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="8ea37-108">Les fonctions d’initialisation unique fournissent des avantages significatifs pour s’assurer qu’un seul thread effectue l’initialisation :</span><span class="sxs-lookup"><span data-stu-id="8ea37-108">The one-time initialization functions provide significant advantages to ensure that only one thread performs the initialization:</span></span>

-   <span data-ttu-id="8ea37-109">Ils sont optimisés pour la vitesse.</span><span class="sxs-lookup"><span data-stu-id="8ea37-109">They are optimized for speed.</span></span>
-   <span data-ttu-id="8ea37-110">Ils créent les barrières appropriées sur les architectures de processeur qui en ont besoin.</span><span class="sxs-lookup"><span data-stu-id="8ea37-110">They create the appropriate barriers on processor architectures that require them.</span></span>
-   <span data-ttu-id="8ea37-111">Ils prennent en charge l’initialisation verrouillée et parallèle.</span><span class="sxs-lookup"><span data-stu-id="8ea37-111">They support both locked and parallel initialization.</span></span>
-   <span data-ttu-id="8ea37-112">Ils évitent le verrouillage interne afin que le code puisse fonctionner de manière asynchrone ou synchrone.</span><span class="sxs-lookup"><span data-stu-id="8ea37-112">They avoid internal locking so the code can operate asynchronously or synchronously.</span></span>

<span data-ttu-id="8ea37-113">Le système gère le processus d’initialisation par le biais d’une structure **init opaque \_ une fois** qui contient des données et des informations d’État.</span><span class="sxs-lookup"><span data-stu-id="8ea37-113">The system manages the initialization process through an opaque **INIT\_ONCE** structure that contains data and state information.</span></span> <span data-ttu-id="8ea37-114">L’appelant alloue cette structure et l’initialise en appelant [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (pour initialiser la structure dynamiquement) ou en affectant l’initialisation de constante **\_ une fois \_ \_** l’initialisation statique à la variable de structure (pour initialiser la structure de manière statique).</span><span class="sxs-lookup"><span data-stu-id="8ea37-114">The caller allocates this structure and initializes it by either calling [**InitOnceInitialize**](/windows/win32/api/synchapi/nf-synchapi-initonceinitialize) (to initialize the structure dynamically) or assigning the constant **INIT\_ONCE\_STATIC\_INIT** to the structure variable (to initialize the structure statically).</span></span> <span data-ttu-id="8ea37-115">Initialement, les données stockées dans la structure d’initialisation à usage unique ont la valeur NULL et son état n’est pas initialisé.</span><span class="sxs-lookup"><span data-stu-id="8ea37-115">Initially, the data stored in the one-time initialization structure is NULL and its state is uninitialized.</span></span>

<span data-ttu-id="8ea37-116">Les structures d’initialisation à usage unique ne peuvent pas être partagées entre les processus.</span><span class="sxs-lookup"><span data-stu-id="8ea37-116">One-time initialization structures cannot be shared across processes.</span></span>

<span data-ttu-id="8ea37-117">Le thread qui effectue l’initialisation peut éventuellement définir un contexte qui est disponible pour l’appelant une fois l’initialisation terminée.</span><span class="sxs-lookup"><span data-stu-id="8ea37-117">The thread that performs the initialization can optionally set a context that is available to the caller after initialization is complete.</span></span> <span data-ttu-id="8ea37-118">Il peut s’agir d’un objet de synchronisation ou d’une valeur ou d’une structure de données.</span><span class="sxs-lookup"><span data-stu-id="8ea37-118">The context can be a synchronization object or it can be a value or data structure.</span></span> <span data-ttu-id="8ea37-119">Si le contexte est une valeur, son initialisation de poids **faible \_ une fois que les \_ \_ \_ bits réservés CTX** doivent être nuls.</span><span class="sxs-lookup"><span data-stu-id="8ea37-119">If the context is a value, its low-order **INIT\_ONCE\_CTX\_RESERVED\_BITS** must be zero.</span></span> <span data-ttu-id="8ea37-120">Si le contexte est une structure de données, la structure de données doit être alignée sur la **valeur DWORD**.</span><span class="sxs-lookup"><span data-stu-id="8ea37-120">If the context is a data structure, the data structure must be **DWORD**-aligned.</span></span> <span data-ttu-id="8ea37-121">Le contexte est retourné à l’appelant dans le paramètre de sortie *lpContext* de la fonction [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) ou [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) .</span><span class="sxs-lookup"><span data-stu-id="8ea37-121">The context is returned to the caller in the *lpContext* output parameter of the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) or [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function.</span></span>

<span data-ttu-id="8ea37-122">Une initialisation unique peut être effectuée de façon synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8ea37-122">One-time initialization can be performed synchronously or asynchronously.</span></span> <span data-ttu-id="8ea37-123">Une fonction de rappel facultative peut être utilisée pour une initialisation unique synchrone.</span><span class="sxs-lookup"><span data-stu-id="8ea37-123">An optional callback function can be used for synchronous one-time initialization.</span></span>

## <a name="synchronous-one-time-initialization"></a><span data-ttu-id="8ea37-124">Initialisation unique synchrone</span><span class="sxs-lookup"><span data-stu-id="8ea37-124">Synchronous One-time Initialization</span></span>

<span data-ttu-id="8ea37-125">Les étapes suivantes décrivent une initialisation unique synchrone qui n’utilise pas de fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="8ea37-125">The following steps describe synchronous one-time initialization that does not use a callback function.</span></span>

1.  <span data-ttu-id="8ea37-126">Le premier thread à appeler la fonction [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) réussit à démarrer l’initialisation unique.</span><span class="sxs-lookup"><span data-stu-id="8ea37-126">The first thread to call the [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) function successfully causes one-time initialization to begin.</span></span> <span data-ttu-id="8ea37-127">Pour une initialisation unique synchrone, **InitOnceBeginInitialize** doit être appelé sans l’indicateur **Async init \_ once \_** .</span><span class="sxs-lookup"><span data-stu-id="8ea37-127">For synchronous one-time initialization, **InitOnceBeginInitialize** must be called without the **INIT\_ONCE\_ASYNC** flag.</span></span>
2.  <span data-ttu-id="8ea37-128">Les threads suivants qui tentent d’effectuer une initialisation sont bloqués jusqu’à ce que le premier thread ait terminé l’initialisation ou échoue.</span><span class="sxs-lookup"><span data-stu-id="8ea37-128">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="8ea37-129">Si le premier thread échoue, le thread suivant est autorisé à tenter l’initialisation, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="8ea37-129">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="8ea37-130">Une fois l’initialisation terminée, le thread appelle la fonction [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="8ea37-130">When initialization is finished, the thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="8ea37-131">Le thread peut éventuellement créer un objet de synchronisation (ou d’autres données de contexte) et le spécifier dans le paramètre *lpContext* de la fonction **InitOnceComplete** .</span><span class="sxs-lookup"><span data-stu-id="8ea37-131">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of the **InitOnceComplete** function.</span></span>
4.  <span data-ttu-id="8ea37-132">Si l’initialisation est réussie, l’état de la structure d’initialisation à usage unique est remplacé par Initialized et le handle *lpContext* (le cas échéant) est stocké dans la structure d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-132">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="8ea37-133">Les tentatives d’initialisation suivantes retournent ces données de contexte.</span><span class="sxs-lookup"><span data-stu-id="8ea37-133">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="8ea37-134">Si l’initialisation échoue, les données ont la **valeur null**.</span><span class="sxs-lookup"><span data-stu-id="8ea37-134">If the initialization fails, the data is **NULL**.</span></span>

<span data-ttu-id="8ea37-135">Les étapes suivantes décrivent l’initialisation unique synchrone qui utilise une fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="8ea37-135">The following steps describe synchronous one-time initialization that uses a callback function.</span></span>

1.  <span data-ttu-id="8ea37-136">Le premier thread à appeler avec succès la fonction [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) passe un pointeur vers une fonction de rappel [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) définie par l’application et toutes les données requises par la fonction de rappel.</span><span class="sxs-lookup"><span data-stu-id="8ea37-136">The first thread to successfully call the [**InitOnceExecuteOnce**](/windows/win32/api/synchapi/nf-synchapi-initonceexecuteonce) function passes a pointer to an application-defined [*InitOnceCallback*](/windows/win32/api/synchapi/nc-synchapi-pinit_once_fn) callback function and any data required by the callback function.</span></span> <span data-ttu-id="8ea37-137">Si l’appel réussit, la fonction de rappel *InitOnceCallback* s’exécute.</span><span class="sxs-lookup"><span data-stu-id="8ea37-137">If the call succeeds, the *InitOnceCallback* callback function executes.</span></span>
2.  <span data-ttu-id="8ea37-138">Les threads suivants qui tentent d’effectuer une initialisation sont bloqués jusqu’à ce que le premier thread ait terminé l’initialisation ou échoue.</span><span class="sxs-lookup"><span data-stu-id="8ea37-138">Subsequent threads that attempt initialization are blocked until the first thread either completes initialization or fails.</span></span> <span data-ttu-id="8ea37-139">Si le premier thread échoue, le thread suivant est autorisé à tenter l’initialisation, et ainsi de suite.</span><span class="sxs-lookup"><span data-stu-id="8ea37-139">If the first thread fails, the next thread is allowed to attempt the initialization, and so on.</span></span>
3.  <span data-ttu-id="8ea37-140">Une fois l’initialisation terminée, la fonction de rappel retourne.</span><span class="sxs-lookup"><span data-stu-id="8ea37-140">When initialization is finished, the callback function returns.</span></span> <span data-ttu-id="8ea37-141">La fonction de rappel peut éventuellement créer un objet de synchronisation (ou d’autres données de contexte) et la spécifier dans son paramètre de sortie *Context* .</span><span class="sxs-lookup"><span data-stu-id="8ea37-141">The callback function can optionally create a synchronization object (or other context data) and specify it in its *Context* output parameter.</span></span>
4.  <span data-ttu-id="8ea37-142">Si l’initialisation est réussie, l’état de la structure d’initialisation à usage unique est remplacé par Initialized et le handle de *contexte* (le cas échéant) est stocké dans la structure d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-142">If the initialization succeeds, the state of the one-time initialization structure is changed to initialized and the *Context* handle (if any) is stored in the initialization structure.</span></span> <span data-ttu-id="8ea37-143">Les tentatives d’initialisation suivantes retournent ces données de contexte.</span><span class="sxs-lookup"><span data-stu-id="8ea37-143">Subsequent initialization attempts return this context data.</span></span> <span data-ttu-id="8ea37-144">Si l’initialisation échoue, les données ont la **valeur null**.</span><span class="sxs-lookup"><span data-stu-id="8ea37-144">If the initialization fails, the data is **NULL**.</span></span>

## <a name="asynchronous-one-time-initialization"></a><span data-ttu-id="8ea37-145">Initialisation unique asynchrone</span><span class="sxs-lookup"><span data-stu-id="8ea37-145">Asynchronous One-time Initialization</span></span>

<span data-ttu-id="8ea37-146">Les étapes suivantes décrivent l’initialisation unique asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8ea37-146">The following steps describe asynchronous one-time initialization.</span></span>

1.  <span data-ttu-id="8ea37-147">Si plusieurs threads tentent simultanément de commencer l’initialisation en appelant [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) avec **init \_ une fois \_ Async**, la fonction parvient à tous les threads avec le paramètre *fPending* défini sur **true**.</span><span class="sxs-lookup"><span data-stu-id="8ea37-147">If multiple threads simultaneously attempt to begin initialization by calling [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_ASYNC**, the function succeeds for all of the threads with the *fPending* parameter set to **TRUE**.</span></span> <span data-ttu-id="8ea37-148">Un seul thread parviendra en fait au moment de l’initialisation. les autres tentatives simultanées ne modifient pas l’état d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-148">Only one thread will actually succeed at initialization; other concurrent attempts do not change the initialization state.</span></span>
2.  <span data-ttu-id="8ea37-149">Quand [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) retourne, le paramètre *fPending* indique l’état d’initialisation :</span><span class="sxs-lookup"><span data-stu-id="8ea37-149">When [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) returns, the *fPending* parameter indicates the initialization status:</span></span>
    -   <span data-ttu-id="8ea37-150">Si *fPending* a la **valeur false**, un thread a réussi à s’initialiser.</span><span class="sxs-lookup"><span data-stu-id="8ea37-150">If *fPending* is **FALSE**, one thread has succeeded at initialization.</span></span> <span data-ttu-id="8ea37-151">Les autres threads doivent nettoyer les données de contexte qu’ils ont créées et utiliser les données de contexte dans le paramètre de sortie *lpContext* de [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span><span class="sxs-lookup"><span data-stu-id="8ea37-151">Other threads should clean up any context data they have created and use the context data in the *lpContext* output parameter of [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize).</span></span>
    -   <span data-ttu-id="8ea37-152">Si *fPending* a la **valeur true**, l’initialisation n’est pas encore terminée et les autres threads doivent continuer.</span><span class="sxs-lookup"><span data-stu-id="8ea37-152">If *fPending* is **TRUE**, initialization has not yet completed and other threads should continue.</span></span>
3.  <span data-ttu-id="8ea37-153">Chaque thread appelle la fonction [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) .</span><span class="sxs-lookup"><span data-stu-id="8ea37-153">Each thread calls the [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) function.</span></span> <span data-ttu-id="8ea37-154">Le thread peut éventuellement créer un objet de synchronisation (ou d’autres données de contexte) et le spécifier dans le paramètre *lpContext* de **InitOnceComplete**.</span><span class="sxs-lookup"><span data-stu-id="8ea37-154">The thread can optionally create a synchronization object (or other context data) and specify it in the *lpContext* parameter of **InitOnceComplete**.</span></span>
4.  <span data-ttu-id="8ea37-155">Quand [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) retourne, sa valeur de retour indique si le thread appelant a réussi lors de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-155">When [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) returns, its return value indicates whether the calling thread succeeded at initialization.</span></span>
    -   <span data-ttu-id="8ea37-156">Si [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) réussit, le thread appelant a réussi lors de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-156">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) succeeds, the calling thread has succeeded at initialization.</span></span> <span data-ttu-id="8ea37-157">L’état de la structure d’initialisation à usage unique est remplacé par Initialized et le handle *lpContext* (le cas échéant) est stocké dans la structure d’initialisation.</span><span class="sxs-lookup"><span data-stu-id="8ea37-157">The state of the one-time initialization structure is changed to initialized and the *lpContext* handle (if any) is stored in the initialization structure.</span></span>
    -   <span data-ttu-id="8ea37-158">Si [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) échoue, un autre thread a réussi à s’initialiser.</span><span class="sxs-lookup"><span data-stu-id="8ea37-158">If [**InitOnceComplete**](/windows/win32/api/synchapi/nf-synchapi-initoncecomplete) fails, another thread has succeeded at initialization.</span></span> <span data-ttu-id="8ea37-159">Le thread appelant doit nettoyer toutes les données de contexte qu’il a créées et appeler [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) à l’aide de la fonction **init \_ une fois la \_ vérification \_ uniquement** pour récupérer les données de contexte stockées dans la structure d’initialisation à usage unique.</span><span class="sxs-lookup"><span data-stu-id="8ea37-159">The calling thread should clean up any context data it has created and call [**InitOnceBeginInitialize**](/windows/win32/api/synchapi/nf-synchapi-initoncebegininitialize) with **INIT\_ONCE\_CHECK\_ONLY** to retrieve any context data stored in the one-time initialization structure.</span></span>

## <a name="calling-one-time-initialization-from-multiple-sites"></a><span data-ttu-id="8ea37-160">Appel One-Time l’initialisation à partir de plusieurs sites</span><span class="sxs-lookup"><span data-stu-id="8ea37-160">Calling One-Time Initialization from multiple sites</span></span>

<span data-ttu-id="8ea37-161">Une initialisation unique protégée par une seule structure **init \_** unique peut être effectuée à partir de sites multiples ; un rappel différent peut être passé à partir de chaque site, et la synchronisation avec et sans rappel peut être mélangée.</span><span class="sxs-lookup"><span data-stu-id="8ea37-161">One-time initialization guarded by a single **INIT\_ONCE** structure may be performed from mutiple sites; different callback may be passed from each site, and synchronization with and without callback may be mixed.</span></span> <span data-ttu-id="8ea37-162">L’initialisation est toujours garantie pour exécuter sucesfully une seule fois.</span><span class="sxs-lookup"><span data-stu-id="8ea37-162">Initialization is still guaranted to perform sucesfully just once.</span></span>

<span data-ttu-id="8ea37-163">Toutefois, l’initialisation asynchrone et synchrone ne peut pas être mixte : une fois l’initialisation asynchrone tentée, les tentatives de démarrage de l’initialisation synchrone échouent.</span><span class="sxs-lookup"><span data-stu-id="8ea37-163">However, asynchronous and synchronous initialization cannot be mixed: once asynchronous initialization is attempted, attempts to start synchronous initialization would fail.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8ea37-164">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="8ea37-164">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="8ea37-165">Utilisation de One-Time initialisation</span><span class="sxs-lookup"><span data-stu-id="8ea37-165">Using One-Time Initialization</span></span>](using-one-time-initialization.md)
</dt> </dl>

 

 
