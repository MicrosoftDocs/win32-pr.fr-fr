---
description: Vous pouvez effectuer des opérations d’e/s synchrones ou asynchrones (également appelées « superposées ») sur des fichiers, des canaux nommés et des appareils de communication série.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Synchronisation et entrée et sortie avec chevauchement
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e263bb39badc7cbfadd67d80eb169dc1fe6d6c35
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106526257"
---
# <a name="synchronization-and-overlapped-input-and-output"></a><span data-ttu-id="f81a3-103">Synchronisation et entrée et sortie avec chevauchement</span><span class="sxs-lookup"><span data-stu-id="f81a3-103">Synchronization and Overlapped Input and Output</span></span>

<span data-ttu-id="f81a3-104">Vous pouvez effectuer des opérations d’e/s synchrones ou asynchrones (également appelées « superposées ») sur des fichiers, des canaux nommés et des appareils de communication série.</span><span class="sxs-lookup"><span data-stu-id="f81a3-104">You can perform either synchronous or asynchronous (also called overlapped) I/O operations on files, named pipes, and serial communications devices.</span></span> <span data-ttu-id="f81a3-105">Les fonctions [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)et [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) peuvent être exécutées de façon synchrone ou asynchrone.</span><span class="sxs-lookup"><span data-stu-id="f81a3-105">The [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**WaitCommEvent**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**ConnectNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe), and [**TransactNamedPipe**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) functions can be performed either synchronously or asynchronously.</span></span> <span data-ttu-id="f81a3-106">Les fonctions [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) et [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) peuvent être exécutées uniquement de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="f81a3-106">The [**ReadFileEx**](/windows/win32/api/fileapi/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/win32/api/fileapi/nf-fileapi-writefileex) functions can be performed only asynchronously.</span></span>

<span data-ttu-id="f81a3-107">Lorsqu’une fonction est exécutée de façon synchrone, elle n’est pas retournée tant que l’opération n’est pas terminée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-107">When a function is executed synchronously, it does not return until the operation has been completed.</span></span> <span data-ttu-id="f81a3-108">Cela signifie que l’exécution du thread appelant peut être bloquée pendant une période indéterminée pendant qu’elle attend la fin d’une opération longue.</span><span class="sxs-lookup"><span data-stu-id="f81a3-108">This means that the execution of the calling thread can be blocked for an indefinite period while it waits for a time-consuming operation to finish.</span></span> <span data-ttu-id="f81a3-109">Les fonctions appelées pour une opération avec chevauchement peuvent être retournées immédiatement, même si l’opération n’a pas été effectuée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-109">Functions called for overlapped operation can return immediately, even though the operation has not been completed.</span></span> <span data-ttu-id="f81a3-110">Cela permet l’exécution d’une opération d’e/s qui prend du temps en arrière-plan pendant que le thread appelant est libre d’effectuer d’autres tâches.</span><span class="sxs-lookup"><span data-stu-id="f81a3-110">This enables a time-consuming I/O operation to be executed in the background while the calling thread is free to perform other tasks.</span></span> <span data-ttu-id="f81a3-111">Par exemple, un thread unique peut effectuer des opérations d’e/s simultanées sur des handles différents ou même des opérations de lecture et d’écriture simultanées sur le même handle.</span><span class="sxs-lookup"><span data-stu-id="f81a3-111">For example, a single thread can perform simultaneous I/O operations on different handles, or even simultaneous read and write operations on the same handle.</span></span>

<span data-ttu-id="f81a3-112">Pour synchroniser son exécution avec la fin de l’opération Overlapped, le thread appelant utilise la fonction [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , la fonction [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) ou l’une des [fonctions Wait](wait-functions.md) pour déterminer à quel moment l’opération Overlapped est terminée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-112">To synchronize its execution with the completion of the overlapped operation, the calling thread uses the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, the [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function, or one of the [wait functions](wait-functions.md) to determine when the overlapped operation has been completed.</span></span> <span data-ttu-id="f81a3-113">Vous pouvez également utiliser la macro [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) pour interroger l’achèvement.</span><span class="sxs-lookup"><span data-stu-id="f81a3-113">You can also use the [**HasOverlappedIoCompleted**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) macro to poll for completion.</span></span>

<span data-ttu-id="f81a3-114">Pour annuler toutes les opérations d’e/s asynchrones en attente, utilisez la fonction [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) et fournissez une structure [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) qui spécifie la demande d’annulation.</span><span class="sxs-lookup"><span data-stu-id="f81a3-114">To cancel all pending asynchronous I/O operations, use the [**CancelIoEx**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) function and provide an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure that specifies the request to cancel.</span></span> <span data-ttu-id="f81a3-115">Utilisez la fonction [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) pour annuler les opérations d’e/s asynchrones en attente émises par le thread appelant pour le handle de fichier spécifié.</span><span class="sxs-lookup"><span data-stu-id="f81a3-115">Use the [**CancelIo**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) function to cancel pending asynchronous I/O operations issued by the calling thread for the specified file handle.</span></span>

<span data-ttu-id="f81a3-116">Les opérations avec chevauchement requièrent un fichier, un canal nommé ou un appareil de communication qui a été créé avec l’indicateur **fichier \_ indicateur de \_ chevauchement** .</span><span class="sxs-lookup"><span data-stu-id="f81a3-116">Overlapped operations require a file, named pipe, or communications device that was created with the **FILE\_FLAG\_OVERLAPPED** flag.</span></span> <span data-ttu-id="f81a3-117">Quand un thread appelle une fonction (telle que la fonction [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) ) pour effectuer une opération avec chevauchement, le thread appelant doit spécifier un pointeur vers une structure [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="f81a3-117">When a thread calls a function (such as the [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) function) to perform an overlapped operation, the calling thread must specify a pointer to an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="f81a3-118">(Si ce pointeur est **null**, la valeur de retour de la fonction peut indiquer de manière incorrecte que l’opération est terminée.) Tous les membres de la structure **OVERLAPPED** doivent être initialisés à zéro, sauf si un événement est utilisé pour signaler la fin d’une opération d’e/s.</span><span class="sxs-lookup"><span data-stu-id="f81a3-118">(If this pointer is **NULL**, the function return value may incorrectly indicate that the operation completed.) All of the members of the **OVERLAPPED** structure must be initialized to zero unless an event will be used to signal completion of an I/O operation.</span></span> <span data-ttu-id="f81a3-119">Si un événement est utilisé, le membre **hEvent** de la structure **OVERLAPPED** spécifie un handle vers l’objet d’événement alloué.</span><span class="sxs-lookup"><span data-stu-id="f81a3-119">If an event is used, the **hEvent** member of the **OVERLAPPED** structure specifies a handle to the allocated event object.</span></span> <span data-ttu-id="f81a3-120">Le système définit l’état de l’objet d’événement comme étant non signalé lorsqu’un appel à la fonction d’e/s retourne une valeur avant que l’opération ne soit terminée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-120">The system sets the state of the event object to nonsignaled when a call to the I/O function returns before the operation has been completed.</span></span> <span data-ttu-id="f81a3-121">Le système définit l’état de l’objet d’événement comme étant signalé lorsque l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-121">The system sets the state of the event object to signaled when the operation has been completed.</span></span> <span data-ttu-id="f81a3-122">Un événement est nécessaire uniquement s’il y a plus d’une opération d’e/s en suspens en même temps.</span><span class="sxs-lookup"><span data-stu-id="f81a3-122">An event is needed only if there will be more than one outstanding I/O operation at the same time.</span></span> <span data-ttu-id="f81a3-123">Si un événement n’est pas utilisé, chaque opération d’e/s terminée signale le fichier, le canal nommé ou l’appareil de communication.</span><span class="sxs-lookup"><span data-stu-id="f81a3-123">If an event is not used, each completed I/O operation will signal the file, named pipe, or communications device.</span></span>

<span data-ttu-id="f81a3-124">Lorsqu’une fonction est appelée pour effectuer une opération avec chevauchement, l’opération peut être effectuée avant le retour de la fonction.</span><span class="sxs-lookup"><span data-stu-id="f81a3-124">When a function is called to perform an overlapped operation, the operation might be completed before the function returns.</span></span> <span data-ttu-id="f81a3-125">Dans ce cas, les résultats sont traités comme si l’opération avait été exécutée de façon synchrone.</span><span class="sxs-lookup"><span data-stu-id="f81a3-125">When this happens, the results are handled as if the operation had been performed synchronously.</span></span> <span data-ttu-id="f81a3-126">Toutefois, si l’opération n’a pas été effectuée, la valeur de retour de la fonction est **false** et la fonction [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) retourne les **\_ e/s d’erreur \_ en attente**.</span><span class="sxs-lookup"><span data-stu-id="f81a3-126">If the operation was not completed, however, the function's return value is **FALSE**, and the [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns **ERROR\_IO\_PENDING**.</span></span>

<span data-ttu-id="f81a3-127">Un thread peut gérer des opérations superposées à l’aide de l’une des deux méthodes suivantes :</span><span class="sxs-lookup"><span data-stu-id="f81a3-127">A thread can manage overlapped operations by either of two methods:</span></span>

-   <span data-ttu-id="f81a3-128">Utilisez la fonction [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) ou [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) pour attendre la fin de l’opération avec chevauchement.</span><span class="sxs-lookup"><span data-stu-id="f81a3-128">Use the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) function to wait for the overlapped operation to be completed.</span></span> <span data-ttu-id="f81a3-129">Si **GetOverlappedResultEx** est utilisé, le thread appelant peut spécifier un délai d’attente pour l’opération Overlapped ou exécuter une attente alertable.</span><span class="sxs-lookup"><span data-stu-id="f81a3-129">If **GetOverlappedResultEx** is used, the calling thread can specify a timeout for the overlapped operation or perform an alertable wait.</span></span>
-   <span data-ttu-id="f81a3-130">Spécifiez un handle pour l’objet d’événement de réinitialisation manuelle de la structure [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) dans l’une des [fonctions Wait](wait-functions.md) , puis, après le retour de la fonction Wait, appelez [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) ou [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex).</span><span class="sxs-lookup"><span data-stu-id="f81a3-130">Specify a handle to the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure's manual-reset event object in one of the [wait functions](wait-functions.md) and then, after the wait function returns, call [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) or [**GetOverlappedResultEx**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex).</span></span> <span data-ttu-id="f81a3-131">La fonction retourne les résultats de l’opération Overlapped terminée et, pour les fonctions dans lesquelles ces informations sont appropriées, elle signale le nombre réel d’octets qui ont été transférés.</span><span class="sxs-lookup"><span data-stu-id="f81a3-131">The function returns the results of the completed overlapped operation, and for functions in which such information is appropriate, it reports the actual number of bytes that were transferred.</span></span>

<span data-ttu-id="f81a3-132">Lors de l’exécution de plusieurs opérations simultanées avec chevauchement sur un seul thread, le thread appelant doit spécifier une structure [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) pour chaque opération.</span><span class="sxs-lookup"><span data-stu-id="f81a3-132">When performing multiple simultaneous overlapped operations on a single thread, the calling thread must specify an [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure for each operation.</span></span> <span data-ttu-id="f81a3-133">Chaque structure **OVERLAPPED** doit spécifier un handle vers un objet d’événement de réinitialisation manuelle différent.</span><span class="sxs-lookup"><span data-stu-id="f81a3-133">Each **OVERLAPPED** structure must specify a handle to a different manual-reset event object.</span></span> <span data-ttu-id="f81a3-134">Pour attendre la fin de l’une des opérations avec chevauchement, le thread spécifie tous les descripteurs d’événement de réinitialisation manuelle comme critères d’attente dans l’une des [fonctions d’attente](wait-functions.md)à plusieurs objets.</span><span class="sxs-lookup"><span data-stu-id="f81a3-134">To wait for any one of the overlapped operations to be completed, the thread specifies all the manual-reset event handles as wait criteria in one of the multiple-object [wait functions](wait-functions.md).</span></span> <span data-ttu-id="f81a3-135">La valeur de retour de la fonction d’attente d’objets multiples indique l’objet d’événement de réinitialisation manuelle qui a été signalé, de sorte que le thread peut déterminer quelle opération avec chevauchement a provoqué l’exécution de l’opération d’attente.</span><span class="sxs-lookup"><span data-stu-id="f81a3-135">The return value of the multiple-object wait function indicates which manual-reset event object was signaled, so the thread can determine which overlapped operation caused the wait operation to be completed.</span></span>

<span data-ttu-id="f81a3-136">Il est plus sûr d’utiliser un objet d’événement distinct pour chaque opération avec chevauchement, au lieu de ne pas spécifier d’objet d’événement ou de réutiliser le même objet d’événement pour plusieurs opérations.</span><span class="sxs-lookup"><span data-stu-id="f81a3-136">It is safer to use a separate event object for each overlapped operation, rather than specify no event object or reuse the same event object for multiple operations.</span></span> <span data-ttu-id="f81a3-137">Si aucun objet d’événement n’est spécifié dans la structure [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , le système signale l’état du fichier, du canal nommé ou du périphérique de communication lorsque l’opération Overlapped est terminée.</span><span class="sxs-lookup"><span data-stu-id="f81a3-137">If no event object is specified in the [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure, the system signals the state of the file, named pipe, or communications device when the overlapped operation has been completed.</span></span> <span data-ttu-id="f81a3-138">Ainsi, vous pouvez spécifier ces handles en tant qu’objets de synchronisation dans une fonction Wait, bien que leur utilisation à cet effet puisse être difficile à gérer car, lors de l’exécution simultanée d’opérations avec chevauchement sur le même fichier, le canal nommé ou le périphérique de communication, il n’existe aucun moyen de savoir quelle opération a provoqué le signalement de l’état de l’objet.</span><span class="sxs-lookup"><span data-stu-id="f81a3-138">Thus, you can specify these handles as synchronization objects in a wait function, though their use for this purpose can be difficult to manage because, when performing simultaneous overlapped operations on the same file, named pipe, or communications device, there is no way to know which operation caused the object's state to be signaled.</span></span>

<span data-ttu-id="f81a3-139">Un thread ne doit pas réutiliser un événement en partant du principe que l’événement est signalé uniquement par l’opération Overlapped de ce thread.</span><span class="sxs-lookup"><span data-stu-id="f81a3-139">A thread should not reuse an event with the assumption that the event will be signaled only by that thread's overlapped operation.</span></span> <span data-ttu-id="f81a3-140">Un événement est signalé sur le même thread que l’opération Overlapped qui se termine.</span><span class="sxs-lookup"><span data-stu-id="f81a3-140">An event is signaled on the same thread as the overlapped operation that is completing.</span></span> <span data-ttu-id="f81a3-141">L’utilisation du même événement sur plusieurs threads peut aboutir à une condition de concurrence dans laquelle l’événement est signalé correctement pour le thread dont l’opération se termine en premier et prématurément pour d’autres threads utilisant cet événement.</span><span class="sxs-lookup"><span data-stu-id="f81a3-141">Using the same event on multiple threads can lead to a race condition in which the event is signaled correctly for the thread whose operation completes first and prematurely for other threads using that event.</span></span> <span data-ttu-id="f81a3-142">Ensuite, lorsque l’opération Overlapped suivante est terminée, l’événement est de nouveau signalé pour tous les threads qui utilisent cet événement, et ainsi de suite jusqu’à ce que toutes les opérations avec chevauchement soient terminées.</span><span class="sxs-lookup"><span data-stu-id="f81a3-142">Then, when the next overlapped operation completes, the event is signaled again for all threads using that event, and so on until all overlapped operations are complete.</span></span>

<span data-ttu-id="f81a3-143">Pour obtenir des exemples qui illustrent l’utilisation d’opérations avec chevauchement, les routines de saisie semi-automatique et la fonction [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , consultez [utilisation de canaux](../ipc/using-pipes.md).</span><span class="sxs-lookup"><span data-stu-id="f81a3-143">For examples that illustrate the use of overlapped operations, completion routines, and the [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) function, see [Using Pipes](../ipc/using-pipes.md).</span></span>

<span data-ttu-id="f81a3-144">\* \* Windows Vista, Windows Server 2003 et Windows XP : \* \*</span><span class="sxs-lookup"><span data-stu-id="f81a3-144">\*\*Windows Vista, Windows Server 2003 and Windows XP:  \*\*</span></span>

<span data-ttu-id="f81a3-145">Soyez vigilant lorsque vous réutilisez des structures avec [**chevauchement**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="f81a3-145">Be careful when reusing [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structures.</span></span> <span data-ttu-id="f81a3-146">Si les structures avec **chevauchement** sont réutilisées sur plusieurs threads et que [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) est appelé avec le paramètre *bWait* défini sur **true**, le thread appelant doit s’assurer que l’événement associé est signalé avant de réutiliser la structure.</span><span class="sxs-lookup"><span data-stu-id="f81a3-146">If **OVERLAPPED** structures are reused on multiple threads and [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) is called with the *bWait* parameter set to **TRUE**, the calling thread must ensure that the associated event is signaled before reusing the structure.</span></span> <span data-ttu-id="f81a3-147">Pour ce faire, vous pouvez utiliser la fonction [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) après avoir appelé **GetOverlappedResult** pour forcer le thread à attendre la fin de l’opération.</span><span class="sxs-lookup"><span data-stu-id="f81a3-147">This can be accomplished by using the [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) function after calling **GetOverlappedResult** to force the thread to wait until the operation completes.</span></span> <span data-ttu-id="f81a3-148">Notez que l’objet d’événement doit être un objet d’événement de réinitialisation manuelle.</span><span class="sxs-lookup"><span data-stu-id="f81a3-148">Note that the event object must be a manual-reset event object.</span></span> <span data-ttu-id="f81a3-149">Si un objet d’événement de réinitialisation est utilisé, l’appel à **GetOverlappedResult** avec le paramètre *BWait* défini sur **true** entraîne le blocage indéfiniment de la fonction.</span><span class="sxs-lookup"><span data-stu-id="f81a3-149">If an autoreset event object is used, calling **GetOverlappedResult** with the *bWait* parameter set to **TRUE** causes the function to be blocked indefinitely.</span></span> <span data-ttu-id="f81a3-150">Ce comportement a été modifié à partir de Windows 7 et de Windows Server 2008 R2 pour les applications qui spécifient Windows 7 comme système d’exploitation pris en charge dans le manifeste de l’application.</span><span class="sxs-lookup"><span data-stu-id="f81a3-150">This behavior changed starting with Windows 7 and Windows Server 2008 R2 for applications that specify Windows 7 as the supported operating system in the application manifest.</span></span> <span data-ttu-id="f81a3-151">Pour plus d’informations, consultez [manifestes d’application](/previous-versions/windows/desktop/adrms_sdk/application-manifests).</span><span class="sxs-lookup"><span data-stu-id="f81a3-151">For more information see [Application Manifests](/previous-versions/windows/desktop/adrms_sdk/application-manifests).</span></span>

## <a name="related-topics"></a><span data-ttu-id="f81a3-152">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="f81a3-152">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f81a3-153">Concepts d’e/s</span><span class="sxs-lookup"><span data-stu-id="f81a3-153">I/O Concepts</span></span>](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
