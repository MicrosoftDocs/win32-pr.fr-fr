---
description: Les objets nommés offrent un moyen simple pour les processus de partager des handles d’objets.
ms.assetid: 00a00227-45fc-49a1-8ff5-aeccb172d16a
title: Noms d'objets
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: ee746150a41f335a4073cb4b5ba282d17ad706f9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106541887"
---
# <a name="object-names"></a><span data-ttu-id="f8313-103">Noms d'objets</span><span class="sxs-lookup"><span data-stu-id="f8313-103">Object Names</span></span>

<span data-ttu-id="f8313-104">Les objets nommés offrent un moyen simple pour les processus de partager des handles d’objets.</span><span class="sxs-lookup"><span data-stu-id="f8313-104">Named objects provide an easy way for processes to share object handles.</span></span> <span data-ttu-id="f8313-105">Une fois qu’un processus a créé un objet nommé Event, mutex, Semaphore ou Timer, les autres processus peuvent utiliser le nom pour appeler la fonction appropriée ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew)ou [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) afin d’ouvrir un handle vers l’objet.</span><span class="sxs-lookup"><span data-stu-id="f8313-105">After a process has created a named event, mutex, semaphore, or timer object, other processes can use the name to call the appropriate function ( [**OpenEvent**](/windows/win32/api/synchapi/nf-synchapi-openeventa), [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw), [**OpenSemaphore**](/windows/win32/api/synchapi/nf-synchapi-opensemaphorew), or [**OpenWaitableTimer**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw)) to open a handle to the object.</span></span> <span data-ttu-id="f8313-106">La comparaison des noms respecte la casse.</span><span class="sxs-lookup"><span data-stu-id="f8313-106">Name comparison is case sensitive.</span></span>

<span data-ttu-id="f8313-107">Les noms de l’événement, du sémaphore, du mutex, du minuteur d’attente, du mappage de fichiers et des objets de travail partagent le même espace de noms.</span><span class="sxs-lookup"><span data-stu-id="f8313-107">The names of event, semaphore, mutex, waitable timer, file-mapping, and job objects share the same namespace.</span></span> <span data-ttu-id="f8313-108">Si vous essayez de créer un objet à l’aide d’un nom qui est utilisé par un objet d’un autre type, la fonction échoue et [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) retourne l' **erreur \_ \_ handle non valide**.</span><span class="sxs-lookup"><span data-stu-id="f8313-108">If you try to create an object using a name that is in use by an object of another type, the function fails and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_INVALID\_HANDLE**.</span></span> <span data-ttu-id="f8313-109">Par conséquent, lors de la création d’objets nommés, utilisez des noms uniques et veillez à vérifier les valeurs de retour de fonction pour les erreurs de nom en double.</span><span class="sxs-lookup"><span data-stu-id="f8313-109">Therefore, when creating named objects, use unique names and be sure to check function return values for duplicate-name errors.</span></span>

<span data-ttu-id="f8313-110">Si vous essayez de créer un objet à l’aide d’un nom qui est utilisé par un objet du même type, la fonction est exécutée, retourne un handle à l’objet existant et [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) retourne l' **erreur \_ déjà \_** existante.</span><span class="sxs-lookup"><span data-stu-id="f8313-110">If you try to create an object using a name that is in use by an object of same type, the function succeeds, returning a handle to the existing object, and [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) returns **ERROR\_ALREADY\_EXISTS**.</span></span> <span data-ttu-id="f8313-111">Par exemple, si le nom spécifié dans un appel à la fonction [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) correspond au nom d’un objet mutex existant, la fonction retourne un handle vers l’objet existant.</span><span class="sxs-lookup"><span data-stu-id="f8313-111">For example, if the name specified in a call to the [**CreateMutex**](/windows/win32/api/synchapi/nf-synchapi-createmutexa) function matches the name of an existing mutex object, the function returns a handle to the existing object.</span></span> <span data-ttu-id="f8313-112">Dans ce cas, l’appel à **CreateMutex** est équivalent à un appel à la fonction [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) .</span><span class="sxs-lookup"><span data-stu-id="f8313-112">In this case, the call to **CreateMutex** is equivalent to a call to the [**OpenMutex**](/windows/win32/api/synchapi/nf-synchapi-openmutexw) function.</span></span> <span data-ttu-id="f8313-113">Le fait d’avoir plusieurs processus utilisant **CreateMutex** pour le même Mutex revient donc à avoir un processus qui appelle **CreateMutex** alors que les autres processus appellent **OpenMutex**, à ceci près qu’il élimine la nécessité de s’assurer que le processus de création est démarré en premier.</span><span class="sxs-lookup"><span data-stu-id="f8313-113">Having multiple processes use **CreateMutex** for the same mutex is therefore equivalent to having one process that calls **CreateMutex** while the other processes call **OpenMutex**, except that it eliminates the need to ensure that the creating process is started first.</span></span> <span data-ttu-id="f8313-114">Toutefois, lors de l’utilisation de cette technique pour les objets mutex, aucun des processus appelant ne doit demander immédiatement la propriété du mutex.</span><span class="sxs-lookup"><span data-stu-id="f8313-114">When using this technique for mutex objects, however, none of the calling processes should request immediate ownership of the mutex.</span></span> <span data-ttu-id="f8313-115">Si plusieurs processus demandent la propriété immédiate, il peut être difficile de prédire quel processus obtient réellement la propriété initiale.</span><span class="sxs-lookup"><span data-stu-id="f8313-115">If multiple processes do request immediate ownership, it can be difficult to predict which process actually gets the initial ownership.</span></span>

<span data-ttu-id="f8313-116">Un environnement de services Terminal Server dispose d’un espace de noms global pour les événements, les sémaphores, les mutex, les minuteries, les objets de mappage de fichiers et les objets de traitement.</span><span class="sxs-lookup"><span data-stu-id="f8313-116">A Terminal Services environment has a global namespace for events, semaphores, mutexes, waitable timers, file-mapping objects, and job objects.</span></span> <span data-ttu-id="f8313-117">En outre, chaque session cliente des services Terminal Server a son propre espace de noms distinct pour ces objets.</span><span class="sxs-lookup"><span data-stu-id="f8313-117">In addition, each Terminal Services client session has its own separate namespace for these objects.</span></span> <span data-ttu-id="f8313-118">Les processus clients des services Terminal Server peuvent utiliser des noms d’objets avec un \\ préfixe « global » ou « local \\ » pour créer explicitement un objet dans l’espace de noms global ou de session.</span><span class="sxs-lookup"><span data-stu-id="f8313-118">Terminal Services client processes can use object names with a "Global\\" or "Local\\" prefix to explicitly create an object in the global or session namespace.</span></span> <span data-ttu-id="f8313-119">Pour plus d’informations, consultez [espaces de noms d’objets noyau](../termserv/kernel-object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="f8313-119">For more information, see [Kernel Object Namespaces](../termserv/kernel-object-namespaces.md).</span></span> <span data-ttu-id="f8313-120">Le changement rapide d’utilisateur est implémenté à l’aide de sessions des services Terminal Server (chaque utilisateur se connecte à une autre session).</span><span class="sxs-lookup"><span data-stu-id="f8313-120">Fast user switching is implemented using Terminal Services sessions (each user logs into a different session).</span></span> <span data-ttu-id="f8313-121">Les noms d’objets de noyau doivent respecter les instructions indiquées pour les services Terminal Server afin que les applications puissent prendre en charge plusieurs utilisateurs.</span><span class="sxs-lookup"><span data-stu-id="f8313-121">Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.</span></span>

<span data-ttu-id="f8313-122">Les objets de synchronisation peuvent être créés dans un espace de noms privé.</span><span class="sxs-lookup"><span data-stu-id="f8313-122">Synchronization objects can be created in a private namespace.</span></span> <span data-ttu-id="f8313-123">Pour plus d’informations, consultez [espaces de noms d’objets](object-namespaces.md).</span><span class="sxs-lookup"><span data-stu-id="f8313-123">For more information, see [Object Namespaces](object-namespaces.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="f8313-124">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="f8313-124">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="f8313-125">Utilisation d’objets nommés</span><span class="sxs-lookup"><span data-stu-id="f8313-125">Using Named Objects</span></span>](using-named-objects.md)
</dt> </dl>

 

 
