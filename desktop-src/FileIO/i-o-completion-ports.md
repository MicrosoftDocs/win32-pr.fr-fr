---
description: Les ports de terminaison d’e/s fournissent un modèle de thread efficace pour traiter plusieurs demandes d’e/s asynchrones sur un système multiprocesseur.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Ports de terminaison d’e/s
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 882363ef99821a0b0b40810f45d609c5b5f7760c
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106530742"
---
# <a name="io-completion-ports"></a><span data-ttu-id="37f1b-103">Ports de terminaison d’e/s</span><span class="sxs-lookup"><span data-stu-id="37f1b-103">I/O Completion Ports</span></span>

<span data-ttu-id="37f1b-104">Les ports de terminaison d’e/s fournissent un modèle de thread efficace pour traiter plusieurs demandes d’e/s asynchrones sur un système multiprocesseur.</span><span class="sxs-lookup"><span data-stu-id="37f1b-104">I/O completion ports provide an efficient threading model for processing multiple asynchronous I/O requests on a multiprocessor system.</span></span> <span data-ttu-id="37f1b-105">Lorsqu’un processus crée un port de terminaison d’e/s, le système crée un objet de file d’attente associé pour les demandes dont l’unique objectif est de traiter ces demandes.</span><span class="sxs-lookup"><span data-stu-id="37f1b-105">When a process creates an I/O completion port, the system creates an associated queue object for requests whose sole purpose is to service these requests.</span></span> <span data-ttu-id="37f1b-106">Les processus qui gèrent de nombreuses demandes d’e/s asynchrones simultanées peuvent le faire plus rapidement et efficacement en utilisant des ports de terminaison d’e/s conjointement à un pool de threads pré-alloués que en créant des threads au moment où ils reçoivent une demande d’e/s.</span><span class="sxs-lookup"><span data-stu-id="37f1b-106">Processes that handle many concurrent asynchronous I/O requests can do so more quickly and efficiently by using I/O completion ports in conjunction with a pre-allocated thread pool than by creating threads at the time they receive an I/O request.</span></span>

## <a name="how-io-completion-ports-work"></a><span data-ttu-id="37f1b-107">Fonctionnement des ports de terminaison d’e/s</span><span class="sxs-lookup"><span data-stu-id="37f1b-107">How I/O Completion Ports Work</span></span>

<span data-ttu-id="37f1b-108">La fonction [**CreateIoCompletionPort**](createiocompletionport.md) crée un port de terminaison d’e/s et associe un ou plusieurs descripteurs de fichiers à ce port.</span><span class="sxs-lookup"><span data-stu-id="37f1b-108">The [**CreateIoCompletionPort**](createiocompletionport.md) function creates an I/O completion port and associates one or more file handles with that port.</span></span> <span data-ttu-id="37f1b-109">Lorsqu’une opération d’e/s asynchrone sur l’un de ces descripteurs de fichiers se termine, un paquet d’achèvement d’e/s est mis en file d’attente dans l’ordre FIFO (premier entré, premier sorti) du port d’achèvement d’e/s associé.</span><span class="sxs-lookup"><span data-stu-id="37f1b-109">When an asynchronous I/O operation on one of these file handles completes, an I/O completion packet is queued in first-in-first-out (FIFO) order to the associated I/O completion port.</span></span> <span data-ttu-id="37f1b-110">Une utilisation puissante de ce mécanisme consiste à combiner le point de synchronisation pour plusieurs descripteurs de fichiers en un seul objet, bien qu’il y ait également d’autres applications utiles.</span><span class="sxs-lookup"><span data-stu-id="37f1b-110">One powerful use for this mechanism is to combine the synchronization point for multiple file handles into a single object, although there are also other useful applications.</span></span> <span data-ttu-id="37f1b-111">Notez que, si les paquets sont mis en file d’attente dans l’ordre FIFO, ils peuvent être déplacés dans la file d’attente dans un ordre différent.</span><span class="sxs-lookup"><span data-stu-id="37f1b-111">Please note that while the packets are queued in FIFO order they may be dequeued in a different order.</span></span>

> [!Note]
>
> <span data-ttu-id="37f1b-112">Le terme *descripteur de fichier* utilisé ici fait référence à une abstraction système représentant un point de terminaison d’e/s avec chevauchement, et non un fichier sur le disque.</span><span class="sxs-lookup"><span data-stu-id="37f1b-112">The term *file handle* as used here refers to a system abstraction representing an overlapped I/O endpoint, not only a file on disk.</span></span> <span data-ttu-id="37f1b-113">Par exemple, il peut s’agir d’un point de terminaison réseau, d’un socket TCP, d’un canal nommé ou d’un emplacement de messagerie.</span><span class="sxs-lookup"><span data-stu-id="37f1b-113">For example, it can be a network endpoint, TCP socket, named pipe, or mail slot.</span></span> <span data-ttu-id="37f1b-114">Tout objet système qui prend en charge les e/s avec chevauchement peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="37f1b-114">Any system object that supports overlapped I/O can be used.</span></span> <span data-ttu-id="37f1b-115">Pour obtenir la liste des fonctions d’e/s associées, consultez la fin de cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="37f1b-115">For a list of related I/O functions, see the end of this topic.</span></span>

 

<span data-ttu-id="37f1b-116">Lorsqu’un descripteur de fichier est associé à un port de terminaison, le bloc d’état transmis n’est pas mis à jour tant que le paquet n’a pas été supprimé du port de terminaison.</span><span class="sxs-lookup"><span data-stu-id="37f1b-116">When a file handle is associated with a completion port, the status block passed in will not be updated until the packet is removed from the completion port.</span></span> <span data-ttu-id="37f1b-117">La seule exception est si l’opération d’origine retourne en mode synchrone avec une erreur.</span><span class="sxs-lookup"><span data-stu-id="37f1b-117">The only exception is if the original operation returns synchronously with an error.</span></span> <span data-ttu-id="37f1b-118">Un thread (soit créé par le thread principal, soit le thread principal lui-même) utilise la fonction [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) pour attendre la mise en file d’attente d’un paquet d’achèvement vers le port de terminaison d’e/s, au lieu d’attendre directement la fin des e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="37f1b-118">A thread (either one created by the main thread or the main thread itself) uses the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function to wait for a completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete.</span></span> <span data-ttu-id="37f1b-119">Les threads qui bloquent leur exécution sur un port de terminaison d’e/s sont libérés dans l’ordre LIFO (dernier entré, premier sorti) et le paquet d’achèvement suivant est extrait de la file d’attente FIFO du port de terminaison d’e/s pour ce thread.</span><span class="sxs-lookup"><span data-stu-id="37f1b-119">Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order, and the next completion packet is pulled from the I/O completion port's FIFO queue for that thread.</span></span> <span data-ttu-id="37f1b-120">Cela signifie que, lorsqu’un paquet de saisie semi-automatique est libéré sur un thread, le système libère le dernier thread (le plus récent) associé à ce port, en lui transmettant les informations de saisie semi-automatique des e/s les plus anciennes.</span><span class="sxs-lookup"><span data-stu-id="37f1b-120">This means that, when a completion packet is released to a thread, the system releases the last (most recent) thread associated with that port, passing it the completion information for the oldest I/O completion.</span></span>

<span data-ttu-id="37f1b-121">Même si un nombre quelconque de threads peut appeler [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) pour un port de terminaison d’e/s spécifié, lorsqu’un thread spécifié appelle **GetQueuedCompletionStatus** la première fois, il est associé au port de terminaison d’e/s spécifié jusqu’à ce que l’un des trois événements se produise : le thread se termine, spécifie un autre port de terminaison d’e</span><span class="sxs-lookup"><span data-stu-id="37f1b-121">Although any number of threads can call [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) for a specified I/O completion port, when a specified thread calls **GetQueuedCompletionStatus** the first time, it becomes associated with the specified I/O completion port until one of three things occurs: The thread exits, specifies a different I/O completion port, or closes the I/O completion port.</span></span> <span data-ttu-id="37f1b-122">En d’autres termes, un seul thread peut être associé, au plus, à un port de terminaison d’e/s.</span><span class="sxs-lookup"><span data-stu-id="37f1b-122">In other words, a single thread can be associated with, at most, one I/O completion port.</span></span>

<span data-ttu-id="37f1b-123">Lorsqu’un paquet de saisie semi-automatique est mis en file d’attente sur un port de terminaison d’e/s, le système vérifie d’abord le nombre de threads associés à ce port en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="37f1b-123">When a completion packet is queued to an I/O completion port, the system first checks how many threads associated with that port are running.</span></span> <span data-ttu-id="37f1b-124">Si le nombre de threads en cours d’exécution est inférieur à la valeur d’accès concurrentiel (décrite dans la section suivante), l’un des threads en attente (le plus récent) est autorisé à traiter le paquet d’achèvement.</span><span class="sxs-lookup"><span data-stu-id="37f1b-124">If the number of threads running is less than the concurrency value (discussed in the next section), one of the waiting threads (the most recent one) is allowed to process the completion packet.</span></span> <span data-ttu-id="37f1b-125">Lorsqu’un thread en cours d’exécution termine son traitement, il appelle généralement à nouveau [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , à savoir qu’il retourne avec le paquet d’achèvement suivant ou attend si la file d’attente est vide.</span><span class="sxs-lookup"><span data-stu-id="37f1b-125">When a running thread completes its processing, it typically calls [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) again, at which point it either returns with the next completion packet or waits if the queue is empty.</span></span>

<span data-ttu-id="37f1b-126">Les threads peuvent utiliser la fonction [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) pour placer les paquets de saisie semi-automatique dans la file d’attente d’un port de terminaison d’e/s.</span><span class="sxs-lookup"><span data-stu-id="37f1b-126">Threads can use the [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) function to place completion packets in an I/O completion port's queue.</span></span> <span data-ttu-id="37f1b-127">En procédant ainsi, le port de terminaison peut être utilisé pour recevoir des communications d’autres threads du processus, en plus de recevoir des paquets de terminaison d’e/s du système d’e/s.</span><span class="sxs-lookup"><span data-stu-id="37f1b-127">By doing so, the completion port can be used to receive communications from other threads of the process, in addition to receiving I/O completion packets from the I/O system.</span></span> <span data-ttu-id="37f1b-128">La fonction **PostQueuedCompletionStatus** permet à une application de faire la file d’attente de ses propres paquets d’achèvement à usage spécial sur le port de terminaison d’e/s sans démarrer une opération d’e/s asynchrone.</span><span class="sxs-lookup"><span data-stu-id="37f1b-128">The **PostQueuedCompletionStatus** function allows an application to queue its own special-purpose completion packets to the I/O completion port without starting an asynchronous I/O operation.</span></span> <span data-ttu-id="37f1b-129">Cela est utile pour notifier les threads de travail des événements externes, par exemple.</span><span class="sxs-lookup"><span data-stu-id="37f1b-129">This is useful for notifying worker threads of external events, for example.</span></span>

<span data-ttu-id="37f1b-130">Le descripteur de port de terminaison d’e/s et chaque descripteur de fichier associé à ce port de terminaison d’e/s particulier sont appelés *références au port de terminaison d’e/s*.</span><span class="sxs-lookup"><span data-stu-id="37f1b-130">The I/O completion port handle and every file handle associated with that particular I/O completion port are known as *references to the I/O completion port*.</span></span> <span data-ttu-id="37f1b-131">Le port de terminaison d’e/s est libéré lorsqu’il n’y a plus de références à celui-ci.</span><span class="sxs-lookup"><span data-stu-id="37f1b-131">The I/O completion port is released when there are no more references to it.</span></span> <span data-ttu-id="37f1b-132">Par conséquent, tous ces handles doivent être correctement fermés pour libérer le port de terminaison d’e/s et les ressources système qui lui sont associées.</span><span class="sxs-lookup"><span data-stu-id="37f1b-132">Therefore, all of these handles must be properly closed to release the I/O completion port and its associated system resources.</span></span> <span data-ttu-id="37f1b-133">Une fois ces conditions satisfaites, une application doit fermer le descripteur de port de terminaison d’e/s en appelant la fonction [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .</span><span class="sxs-lookup"><span data-stu-id="37f1b-133">After these conditions are satisfied, an application should close the I/O completion port handle by calling the [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) function.</span></span>

> [!Note]
>
> <span data-ttu-id="37f1b-134">Un port de terminaison d’e/s est associé au processus qui l’a créé et il n’est pas partageable entre les processus.</span><span class="sxs-lookup"><span data-stu-id="37f1b-134">An I/O completion port is associated with the process that created it and is not sharable between processes.</span></span> <span data-ttu-id="37f1b-135">Toutefois, un seul descripteur peut être partagé entre les threads du même processus.</span><span class="sxs-lookup"><span data-stu-id="37f1b-135">However, a single handle is sharable between threads in the same process.</span></span>

 

## <a name="threads-and-concurrency"></a><span data-ttu-id="37f1b-136">Threads et accès concurrentiel</span><span class="sxs-lookup"><span data-stu-id="37f1b-136">Threads and Concurrency</span></span>

<span data-ttu-id="37f1b-137">La propriété la plus importante d’un port de terminaison d’e/s à prendre en compte avec soin est la valeur d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="37f1b-137">The most important property of an I/O completion port to consider carefully is the concurrency value.</span></span> <span data-ttu-id="37f1b-138">La valeur d’accès concurrentiel d’un port de terminaison est spécifiée lorsqu’elle est créée avec [**CreateIoCompletionPort**](createiocompletionport.md) via le paramètre *NumberOfConcurrentThreads* .</span><span class="sxs-lookup"><span data-stu-id="37f1b-138">The concurrency value of a completion port is specified when it is created with [**CreateIoCompletionPort**](createiocompletionport.md) via the *NumberOfConcurrentThreads* parameter.</span></span> <span data-ttu-id="37f1b-139">Cette valeur limite le nombre de threads exécutables associés au port de terminaison.</span><span class="sxs-lookup"><span data-stu-id="37f1b-139">This value limits the number of runnable threads associated with the completion port.</span></span> <span data-ttu-id="37f1b-140">Lorsque le nombre total de threads exécutables associés au port de terminaison atteint la valeur d’accès concurrentiel, le système bloque l’exécution de tous les threads suivants associés à ce port de terminaison jusqu’à ce que le nombre de threads exécutables descend sous la valeur d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="37f1b-140">When the total number of runnable threads associated with the completion port reaches the concurrency value, the system blocks the execution of any subsequent threads associated with that completion port until the number of runnable threads drops below the concurrency value.</span></span>

<span data-ttu-id="37f1b-141">Le scénario le plus efficace se produit lorsqu’il y a des paquets d’achèvement en attente dans la file d’attente, mais qu’aucune attente ne peut être satisfaite, car le port a atteint sa limite de concurrence.</span><span class="sxs-lookup"><span data-stu-id="37f1b-141">The most efficient scenario occurs when there are completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit.</span></span> <span data-ttu-id="37f1b-142">Examinez ce qui se passe avec une valeur d’accès concurrentiel d’un et plusieurs threads en attente dans l’appel de fonction [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .</span><span class="sxs-lookup"><span data-stu-id="37f1b-142">Consider what happens with a concurrency value of one and multiple threads waiting in the [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) function call.</span></span> <span data-ttu-id="37f1b-143">Dans ce cas, si la file d’attente a toujours des paquets d’achèvement en attente, lorsque le thread en cours d’exécution appelle **GetQueuedCompletionStatus**, il ne bloque pas l’exécution car, comme mentionné précédemment, la file d’attente de threads est LIFO.</span><span class="sxs-lookup"><span data-stu-id="37f1b-143">In this case, if the queue always has completion packets waiting, when the running thread calls **GetQueuedCompletionStatus**, it will not block execution because, as mentioned earlier, the thread queue is LIFO.</span></span> <span data-ttu-id="37f1b-144">Au lieu de cela, ce thread récupère immédiatement le paquet de fin de mise en file d’attente suivant.</span><span class="sxs-lookup"><span data-stu-id="37f1b-144">Instead, this thread will immediately pick up the next queued completion packet.</span></span> <span data-ttu-id="37f1b-145">Aucun changement de contexte de thread ne se produit, car le thread en cours d’exécution collecte continuellement des paquets d’achèvement et les autres threads ne peuvent pas s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="37f1b-145">No thread context switches will occur, because the running thread is continually picking up completion packets and the other threads are unable to run.</span></span>

> [!Note]
>
> <span data-ttu-id="37f1b-146">Dans l’exemple précédent, les threads supplémentaires semblent inutiles et ne s’exécutent jamais, mais cela suppose que le thread en cours d’exécution n’est jamais placé en état d’attente par un autre mécanisme, se termine ou ferme le port de terminaison d’e/s associé.</span><span class="sxs-lookup"><span data-stu-id="37f1b-146">In the previous example, the extra threads appear to be useless and never run, but that assumes that the running thread never gets put in a wait state by some other mechanism, terminates, or otherwise closes its associated I/O completion port.</span></span> <span data-ttu-id="37f1b-147">Tenez compte de toutes ces ramifications d’exécution de thread lors de la conception de l’application.</span><span class="sxs-lookup"><span data-stu-id="37f1b-147">Consider all such thread execution ramifications when designing the application.</span></span>

 

<span data-ttu-id="37f1b-148">La meilleure valeur globale maximale à sélectionner pour la valeur d’accès concurrentiel est le nombre de processeurs sur l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="37f1b-148">The best overall maximum value to pick for the concurrency value is the number of CPUs on the computer.</span></span> <span data-ttu-id="37f1b-149">Si votre transaction requiert un calcul de longue durée, une plus grande valeur d’accès concurrentiel permettra l’exécution d’un plus grand nombre de threads.</span><span class="sxs-lookup"><span data-stu-id="37f1b-149">If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run.</span></span> <span data-ttu-id="37f1b-150">Chaque paquet d’achèvement peut durer plus longtemps, mais plus de paquets d’achèvement seront traités en même temps.</span><span class="sxs-lookup"><span data-stu-id="37f1b-150">Each completion packet may take longer to finish, but more completion packets will be processed at the same time.</span></span> <span data-ttu-id="37f1b-151">Vous pouvez expérimenter la valeur d’accès concurrentiel conjointement avec les outils de profilage pour obtenir le meilleur effet pour votre application.</span><span class="sxs-lookup"><span data-stu-id="37f1b-151">You can experiment with the concurrency value in conjunction with profiling tools to achieve the best effect for your application.</span></span>

<span data-ttu-id="37f1b-152">Le système permet également à un thread qui attend [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) de traiter un paquet d’achèvement si un autre thread en cours d’exécution associé au même port de terminaison d’e/s entre dans un état d’attente pour d’autres raisons, par exemple la fonction [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) .</span><span class="sxs-lookup"><span data-stu-id="37f1b-152">The system also allows a thread waiting in [**GetQueuedCompletionStatus**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) to process a completion packet if another running thread associated with the same I/O completion port enters a wait state for other reasons, for example the [**SuspendThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) function.</span></span> <span data-ttu-id="37f1b-153">Lorsque le thread de l’état d’attente commence à s’exécuter à nouveau, il peut y avoir une courte période lorsque le nombre de threads actifs dépasse la valeur d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="37f1b-153">When the thread in the wait state begins running again, there may be a brief period when the number of active threads exceeds the concurrency value.</span></span> <span data-ttu-id="37f1b-154">Toutefois, le système réduit rapidement ce nombre en n’autorisant pas de nouveaux threads actifs jusqu’à ce que le nombre de threads actifs passe sous la valeur d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="37f1b-154">However, the system quickly reduces this number by not allowing any new active threads until the number of active threads falls below the concurrency value.</span></span> <span data-ttu-id="37f1b-155">C’est l’une des raisons pour lesquelles votre application crée plus de threads dans son pool de threads que la valeur d’accès concurrentiel.</span><span class="sxs-lookup"><span data-stu-id="37f1b-155">This is one reason to have your application create more threads in its thread pool than the concurrency value.</span></span> <span data-ttu-id="37f1b-156">La gestion des pools de threads dépasse le cadre de cette rubrique, mais une bonne règle empirique consiste à avoir un minimum de deux fois plus de threads dans le pool de threads qu’il n’y a de processeurs sur le système.</span><span class="sxs-lookup"><span data-stu-id="37f1b-156">Thread pool management is beyond the scope of this topic, but a good rule of thumb is to have a minimum of twice as many threads in the thread pool as there are processors on the system.</span></span> <span data-ttu-id="37f1b-157">Pour plus d’informations sur le regroupement de threads, consultez [pools de threads](/windows/desktop/ProcThread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="37f1b-157">For additional information about thread pooling, see [Thread Pools](/windows/desktop/ProcThread/thread-pools).</span></span>

## <a name="supported-io-functions"></a><span data-ttu-id="37f1b-158">Fonctions d’e/s prises en charge</span><span class="sxs-lookup"><span data-stu-id="37f1b-158">Supported I/O Functions</span></span>

<span data-ttu-id="37f1b-159">Les fonctions suivantes peuvent être utilisées pour démarrer des opérations d’e/s qui se terminent à l’aide de ports de terminaison d’e/s.</span><span class="sxs-lookup"><span data-stu-id="37f1b-159">The following functions can be used to start I/O operations that complete by using I/O completion ports.</span></span> <span data-ttu-id="37f1b-160">Vous devez passer à la fonction une instance de la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) et un handle de fichier précédemment associé à un port de terminaison d’e/s (par un appel à [**CreateIoCompletionPort**](createiocompletionport.md)) pour activer le mécanisme de port de terminaison d’e/s :</span><span class="sxs-lookup"><span data-stu-id="37f1b-160">You must pass the function an instance of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure and a file handle previously associated with an I/O completion port (by a call to [**CreateIoCompletionPort**](createiocompletionport.md)) to enable the I/O completion port mechanism:</span></span>

-   [<span data-ttu-id="37f1b-161">**ConnectNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="37f1b-161">**ConnectNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [<span data-ttu-id="37f1b-162">**DeviceIoControl**</span><span class="sxs-lookup"><span data-stu-id="37f1b-162">**DeviceIoControl**</span></span>](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [<span data-ttu-id="37f1b-163">**LockFileEx**</span><span class="sxs-lookup"><span data-stu-id="37f1b-163">**LockFileEx**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [<span data-ttu-id="37f1b-164">**ReadDirectoryChangesW**</span><span class="sxs-lookup"><span data-stu-id="37f1b-164">**ReadDirectoryChangesW**</span></span>](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [<span data-ttu-id="37f1b-165">**ReadFile**</span><span class="sxs-lookup"><span data-stu-id="37f1b-165">**ReadFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [<span data-ttu-id="37f1b-166">**TransactNamedPipe**</span><span class="sxs-lookup"><span data-stu-id="37f1b-166">**TransactNamedPipe**</span></span>](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [<span data-ttu-id="37f1b-167">**WaitCommEvent**</span><span class="sxs-lookup"><span data-stu-id="37f1b-167">**WaitCommEvent**</span></span>](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [<span data-ttu-id="37f1b-168">**WriteFile**</span><span class="sxs-lookup"><span data-stu-id="37f1b-168">**WriteFile**</span></span>](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [<span data-ttu-id="37f1b-169">**WSASendMsg**</span><span class="sxs-lookup"><span data-stu-id="37f1b-169">**WSASendMsg**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [<span data-ttu-id="37f1b-170">**WSASendTo**</span><span class="sxs-lookup"><span data-stu-id="37f1b-170">**WSASendTo**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [<span data-ttu-id="37f1b-171">**WSASend**</span><span class="sxs-lookup"><span data-stu-id="37f1b-171">**WSASend**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [<span data-ttu-id="37f1b-172">**WSARecvFrom**</span><span class="sxs-lookup"><span data-stu-id="37f1b-172">**WSARecvFrom**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [<span data-ttu-id="37f1b-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span><span class="sxs-lookup"><span data-stu-id="37f1b-173">**LPFN_WSARECVMSG (WSARecvMsg)**</span></span>](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [<span data-ttu-id="37f1b-174">**WSARecv**</span><span class="sxs-lookup"><span data-stu-id="37f1b-174">**WSARecv**</span></span>](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a><span data-ttu-id="37f1b-175">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="37f1b-175">Related topics</span></span>

<dl> <span data-ttu-id="37f1b-176"><dt>


</dt> <dt></span><span class="sxs-lookup"><span data-stu-id="37f1b-176"><dt>


</dt> <dt></span></span>

[<span data-ttu-id="37f1b-177">À propos des processus et des threads</span><span class="sxs-lookup"><span data-stu-id="37f1b-177">About Processes and Threads</span></span>](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[<span data-ttu-id="37f1b-178">**BindIoCompletionCallback**</span><span class="sxs-lookup"><span data-stu-id="37f1b-178">**BindIoCompletionCallback**</span></span>](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[<span data-ttu-id="37f1b-179">**CreateIoCompletionPort**</span><span class="sxs-lookup"><span data-stu-id="37f1b-179">**CreateIoCompletionPort**</span></span>](createiocompletionport.md)
</dt> <dt>

[<span data-ttu-id="37f1b-180">**GetQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="37f1b-180">**GetQueuedCompletionStatus**</span></span>](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[<span data-ttu-id="37f1b-181">**GetQueuedCompletionStatusEx**</span><span class="sxs-lookup"><span data-stu-id="37f1b-181">**GetQueuedCompletionStatusEx**</span></span>](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[<span data-ttu-id="37f1b-182">**PostQueuedCompletionStatus**</span><span class="sxs-lookup"><span data-stu-id="37f1b-182">**PostQueuedCompletionStatus**</span></span>](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
