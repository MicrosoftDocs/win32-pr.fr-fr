---
description: Une opération de clonage de bloc indique au système de fichiers de copier une plage d’octets de fichier pour le compte d’une application.
ms.assetid: E18E8D79-3985-40B8-A4C5-A73A21E5C527
title: Clonage de bloc
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b33aa1c1eee693b6ed4b502aedc6da6176ece3e9
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104530009"
---
# <a name="block-cloning"></a><span data-ttu-id="2dc28-103">Clonage de bloc</span><span class="sxs-lookup"><span data-stu-id="2dc28-103">Block Cloning</span></span>

<span data-ttu-id="2dc28-104">Une opération de *clonage de bloc* indique au système de fichiers de copier une plage d’octets de fichier pour le compte d’une application.</span><span class="sxs-lookup"><span data-stu-id="2dc28-104">A *block clone* operation instructs the file system to copy a range of file bytes on behalf of an application.</span></span> <span data-ttu-id="2dc28-105">Le fichier de destination peut être le même que le fichier source, ou être différent de celui-ci.</span><span class="sxs-lookup"><span data-stu-id="2dc28-105">The destination file may be the same as, or different from, the source file.</span></span>

<span data-ttu-id="2dc28-106">Un système de fichiers gère les mappages de [clusters et d’étendues](clusters-and-extents.md)et peut être en mesure d’effectuer la copie en modifiant le numéro de cluster virtuel (VCN) en mappages de nombre de clusters logiques (LCN) comme une opération de métadonnées à faible coût, au lieu de lire et d’écrire les données du fichier sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="2dc28-106">A file system manages the mappings of [Clusters and Extents](clusters-and-extents.md), and may be able to perform the copy by altering the virtual cluster number (VCN) to logical cluster number (LCN) mappings as a low-cost metadata operation, rather than reading and writing the underlying file data.</span></span> <span data-ttu-id="2dc28-107">Cela permet à la copie de s’exécuter plus rapidement et génère moins d’e/s sur le stockage sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="2dc28-107">This allows the copy to complete faster and generates less I/O to the underlying storage.</span></span> <span data-ttu-id="2dc28-108">En outre, plusieurs fichiers peuvent maintenant partager des clusters logiques après le clone de bloc, ce qui évite de stocker les clusters identiques plusieurs fois sur le disque.</span><span class="sxs-lookup"><span data-stu-id="2dc28-108">Moreover, multiple files may now share logical clusters after the block clone, saving capacity by not storing identical clusters multiple times on disk.</span></span>

<span data-ttu-id="2dc28-109">Une opération de clonage de bloc n’interrompt pas l’isolation fournie entre les fichiers.</span><span class="sxs-lookup"><span data-stu-id="2dc28-109">A block clone operation does not break the isolation provided between files.</span></span> <span data-ttu-id="2dc28-110">Une fois le clone de bloc terminé, les écritures dans le fichier source n’apparaissent pas dans la destination, ou vice versa.</span><span class="sxs-lookup"><span data-stu-id="2dc28-110">After a block clone completes, writes to the source file do not appear in the destination, or vice versa.</span></span>

<span data-ttu-id="2dc28-111">Le clonage de bloc est disponible uniquement sur le type de [système de fichiers ReFS](/windows/desktop/w8cookbook/resilient-file-system--refs-) à partir de Windows Server 2016.</span><span class="sxs-lookup"><span data-stu-id="2dc28-111">Block cloning is available only on the [ReFS file system](/windows/desktop/w8cookbook/resilient-file-system--refs-) type beginning with Windows Server 2016.</span></span>

## <a name="block-cloning-on-refs"></a><span data-ttu-id="2dc28-112">Clonage de bloc sur ReFS</span><span class="sxs-lookup"><span data-stu-id="2dc28-112">Block Cloning on ReFS</span></span>

<span data-ttu-id="2dc28-113">ReFS sur Windows Server 2016 implémente le clonage de bloc en remappant les clusters logiques (c’est-à-dire les emplacements physiques sur un volume) de la région source vers la région de destination.</span><span class="sxs-lookup"><span data-stu-id="2dc28-113">ReFS on Windows Server 2016 implements block cloning by remapping logical clusters (that is, physical locations on a volume) from the source region to the destination region.</span></span> <span data-ttu-id="2dc28-114">Il utilise ensuite un mécanisme d’allocation sur écriture pour garantir l’isolement entre ces régions.</span><span class="sxs-lookup"><span data-stu-id="2dc28-114">It then uses an allocate-on-write mechanism to ensure isolation between those regions.</span></span> <span data-ttu-id="2dc28-115">Les régions source et de destination peuvent être dans des fichiers identiques ou différents.</span><span class="sxs-lookup"><span data-stu-id="2dc28-115">The source and destination regions may be in the same, or different, files.</span></span>

<span data-ttu-id="2dc28-116">Cette implémentation requiert que les offsets de fichier de début et de fin soient alignés sur les limites du cluster.</span><span class="sxs-lookup"><span data-stu-id="2dc28-116">This implementation requires that the starting and ending file offsets be aligned to cluster boundaries.</span></span> <span data-ttu-id="2dc28-117">Dans ReFS sur Windows Server 2016, les clusters ont une taille de 4 Ko par défaut, mais peuvent éventuellement avoir la valeur 64 Ko.</span><span class="sxs-lookup"><span data-stu-id="2dc28-117">In ReFS on Windows Server 2016, clusters are 4KB in size by default, but can optionally be set to 64KB.</span></span> <span data-ttu-id="2dc28-118">La taille du cluster est un paramètre au niveau du volume défini au moment de la mise en forme.</span><span class="sxs-lookup"><span data-stu-id="2dc28-118">The cluster size is a volume-wide parameter set at format time.</span></span>

## <a name="restrictions-and-remarks"></a><span data-ttu-id="2dc28-119">Restrictions et remarques</span><span class="sxs-lookup"><span data-stu-id="2dc28-119">Restrictions and Remarks</span></span>

-   <span data-ttu-id="2dc28-120">Les régions source et de destination doivent commencer et se terminer à une limite de cluster.</span><span class="sxs-lookup"><span data-stu-id="2dc28-120">The source and destination regions must begin and end at a cluster boundary.</span></span>
-   <span data-ttu-id="2dc28-121">La taille de la région clonée doit être inférieure à 4 Go.</span><span class="sxs-lookup"><span data-stu-id="2dc28-121">The cloned region must be less than 4GB in length.</span></span>
-   <span data-ttu-id="2dc28-122">La région de destination ne doit pas s’étendre au-delà de la fin du fichier.</span><span class="sxs-lookup"><span data-stu-id="2dc28-122">The destination region must not extend past the end of file.</span></span> <span data-ttu-id="2dc28-123">Si l’application souhaite étendre la destination avec des données clonées, elle doit d’abord appeler [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span><span class="sxs-lookup"><span data-stu-id="2dc28-123">If the application wishes to extend the destination with cloned data, it must first call [**SetEndOfFile**](/windows/desktop/api/FileAPI/nf-fileapi-setendoffile).</span></span>
-   <span data-ttu-id="2dc28-124">Si les régions source et de destination se trouvent dans le même fichier, elles ne doivent pas se chevaucher.</span><span class="sxs-lookup"><span data-stu-id="2dc28-124">If the source and destination regions are in the same file, they must not overlap.</span></span> <span data-ttu-id="2dc28-125">(L’application peut se poursuivre en fractionnant l’opération de clonage de bloc en plusieurs clones de bloc qui ne se chevauchent plus.)</span><span class="sxs-lookup"><span data-stu-id="2dc28-125">(The application may able to proceed by splitting up the block clone operation into multiple block clones that no longer overlap.)</span></span>
-   <span data-ttu-id="2dc28-126">Les fichiers source et de destination doivent se trouver sur le même volume ReFS.</span><span class="sxs-lookup"><span data-stu-id="2dc28-126">The source and destination files must be on the same ReFS volume.</span></span>
-   <span data-ttu-id="2dc28-127">Les fichiers source et de destination doivent avoir le même paramètre [**flux d’intégrité**](file-attribute-constants.md) (autrement dit, les flux d’intégrité doivent être activés dans les deux fichiers ou désactivés dans les deux fichiers).</span><span class="sxs-lookup"><span data-stu-id="2dc28-127">The source and destination files must have the same [**Integrity Streams**](file-attribute-constants.md) setting (that is, Integrity Streams must be enabled in both files, or disabled in both files).</span></span>
-   <span data-ttu-id="2dc28-128">Si le fichier source est partiellement alloué, le fichier de destination doit l’être également.</span><span class="sxs-lookup"><span data-stu-id="2dc28-128">If the source file is sparse, the destination file must also be sparse.</span></span>
-   <span data-ttu-id="2dc28-129">L’opération de clonage de bloc interrompt les verrous opportunistes partagés (également appelés [verrous opportunistes de niveau 2](types-of-opportunistic-locks.md)).</span><span class="sxs-lookup"><span data-stu-id="2dc28-129">The block clone operation will break Shared Opportunistic Locks (also known as [Level 2 Opportunistic Locks](types-of-opportunistic-locks.md)).</span></span>
-   <span data-ttu-id="2dc28-130">Le volume ReFS doit avoir été formaté avec Windows Server 2016 et, si le clustering de basculement Windows est en cours d’utilisation, le niveau fonctionnel de clustering doit avoir été Windows Server 2016 ou une version ultérieure au format heure.</span><span class="sxs-lookup"><span data-stu-id="2dc28-130">The ReFS volume must have been formatted with Windows Server 2016, and if Windows Failover Clustering is in use, the Clustering Functional Level must have been Windows Server 2016 or later at format time.</span></span>

## <a name="example"></a><span data-ttu-id="2dc28-131">Exemple</span><span class="sxs-lookup"><span data-stu-id="2dc28-131">Example</span></span>

<span data-ttu-id="2dc28-132">Supposons que nous ayons deux fichiers, X et Y, où chaque fichier est composé de 3 régions distinctes.</span><span class="sxs-lookup"><span data-stu-id="2dc28-132">Suppose we have two files, X and Y, where each file is composed of 3 distinct regions.</span></span> <span data-ttu-id="2dc28-133">Chaque région de fichier est stockée dans une région distincte du volume.</span><span class="sxs-lookup"><span data-stu-id="2dc28-133">Each file region is stored on a distinct region of the volume.</span></span> <span data-ttu-id="2dc28-134">Le système de fichiers stocke la connaissance que chacune de ces régions de volume est référencée dans une région de fichier :</span><span class="sxs-lookup"><span data-stu-id="2dc28-134">The file system stores the knowledge that each of those volume regions is referenced in one file region:</span></span>

![avant le clonage](images/before-clone.png)

<span data-ttu-id="2dc28-136">Supposons à présent qu’une application génère une opération de clonage de bloc dans le fichier X, sur les régions de fichier A et B, vers le fichier Y à l’offset où E est actuellement.</span><span class="sxs-lookup"><span data-stu-id="2dc28-136">Now suppose an application issues a block clone operation from File X, over file regions A and B, to File Y at the offset where E currently is.</span></span> <span data-ttu-id="2dc28-137">L’état du système de fichiers suivant se produit :</span><span class="sxs-lookup"><span data-stu-id="2dc28-137">The following file system state would result:</span></span>

![après le clonage](images/after-clone.png)

<span data-ttu-id="2dc28-139">Les données dans les régions A et B ont été dupliquées du fichier X vers le fichier Y en modifiant les mappages VCN à LCN au sein du volume ReFS.</span><span class="sxs-lookup"><span data-stu-id="2dc28-139">The data in regions A and B were effectively duplicated from File X to File Y by altering the VCN to LCN mappings within the ReFS volume.</span></span> <span data-ttu-id="2dc28-140">Les étendues de disque qui sauvegardent les régions A et B n’ont pas été lues, et les étendues de disque sauvegardaient les anciennes régions E et F remplacées pendant l’opération.</span><span class="sxs-lookup"><span data-stu-id="2dc28-140">The disk extents backing regions A and B were not read, nor were the disk extents backing the old regions E and F overwritten during the operation.</span></span>

<span data-ttu-id="2dc28-141">Les fichiers X et Y partagent désormais des clusters logiques sur le disque.</span><span class="sxs-lookup"><span data-stu-id="2dc28-141">Files X and Y now share logical clusters on disk.</span></span> <span data-ttu-id="2dc28-142">Cela se répercute dans le nombre de références indiqué dans le tableau.</span><span class="sxs-lookup"><span data-stu-id="2dc28-142">This is reflected in the reference counts shown in the table.</span></span> <span data-ttu-id="2dc28-143">Le partage se traduit par une consommation de capacité de volume inférieure à celle des régions A et B qui étaient dupliquées sur le volume sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="2dc28-143">The sharing results in lower volume capacity consumption than if regions A and B were duplicated on the underlying volume.</span></span>

<span data-ttu-id="2dc28-144">Supposons à présent que l’application remplace la région A dans le fichier X. ReFS crée une copie dupliquée d’un, que nous appelons maintenant G. ReFS, puis mappe G dans le fichier X et applique la modification.</span><span class="sxs-lookup"><span data-stu-id="2dc28-144">Now, suppose the application overwrites region A in File X. ReFS makes a duplicate copy of A, which we’ll now call G. ReFS then maps G into File X, and applies the modification.</span></span> <span data-ttu-id="2dc28-145">Cela permet de préserver l’isolation entre les fichiers.</span><span class="sxs-lookup"><span data-stu-id="2dc28-145">This ensures that isolation between the files is preserved.</span></span> <span data-ttu-id="2dc28-146">Les décomptes de références sont mis à jour de manière appropriée :</span><span class="sxs-lookup"><span data-stu-id="2dc28-146">Reference counts are updated appropriately:</span></span>

![après la modification de l’écriture](images/after-modifying-write.png)

<span data-ttu-id="2dc28-148">Après la modification de l’écriture, la région B est toujours partagée sur le disque.</span><span class="sxs-lookup"><span data-stu-id="2dc28-148">After the modifying write, region B is still shared on disk.</span></span> <span data-ttu-id="2dc28-149">Notez que si la région A avait été plus grande qu’un cluster, seul le cluster modifié aurait été dupliqué, et la partie restante aurait continué à être partagée.</span><span class="sxs-lookup"><span data-stu-id="2dc28-149">Note that if region A were larger than a cluster, only the modified cluster would have been duplicated, and the remaining portion would have remained shared.</span></span>

## <a name="related-topics"></a><span data-ttu-id="2dc28-150">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="2dc28-150">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="2dc28-151">**DUPLIQUer les \_ données d’étendues \_**</span><span class="sxs-lookup"><span data-stu-id="2dc28-151">**DUPLICATE\_EXTENTS\_DATA**</span></span>](/windows/desktop/api/WinIoCtl/ns-winioctl-duplicate_extents_data)
</dt> <dt>

[<span data-ttu-id="2dc28-152">**FSCTL \_ les \_ Extensions dupliquées dans le \_ \_ fichier**</span><span class="sxs-lookup"><span data-stu-id="2dc28-152">**FSCTL\_DUPLICATE\_EXTENTS\_TO\_FILE**</span></span>](/windows/win32/api/winioctl/ni-winioctl-fsctl_duplicate_extents_to_file)
</dt> </dl>

 

 
