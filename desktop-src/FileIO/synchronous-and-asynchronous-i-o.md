---
description: 'Il existe deux types de synchronisation d’entrée/sortie (e/s) : e/s synchrone et e/s asynchrones. Les e/s asynchrones sont également appelées e/s avec chevauchement.'
ms.assetid: ade51d98-cc9d-4b33-9c52-559a9cb14707
title: E/s synchrones et asynchrones
ms.topic: article
ms.date: 05/31/2018
ms.custom: project-verbatim
ms.openlocfilehash: 071dd2943537dcb6aff67a95cb5e2c3d514f4c1a
ms.sourcegitcommit: af120ad5c30da2fc5eb717ca2a1c4c45878efd71
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/20/2021
ms.locfileid: "106525915"
---
# <a name="synchronous-and-asynchronous-io"></a><span data-ttu-id="4e26a-104">E/s synchrones et asynchrones</span><span class="sxs-lookup"><span data-stu-id="4e26a-104">Synchronous and Asynchronous I/O</span></span>

<span data-ttu-id="4e26a-105">Consultez également [les exemples d’applications liées aux e/s](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span><span class="sxs-lookup"><span data-stu-id="4e26a-105">Also see [I/O-related sample applications](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/winbase/io).</span></span>

<span data-ttu-id="4e26a-106">Il existe deux types de synchronisation d’entrée/sortie (e/s) : e/s synchrone et e/s asynchrones.</span><span class="sxs-lookup"><span data-stu-id="4e26a-106">There are two types of input/output (I/O) synchronization: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="4e26a-107">Les e/s asynchrones sont également appelées e/s avec chevauchement.</span><span class="sxs-lookup"><span data-stu-id="4e26a-107">Asynchronous I/O is also referred to as overlapped I/O.</span></span>

<span data-ttu-id="4e26a-108">Dans les *e/s de fichier synchrones*, un thread démarre une opération d’e/s et entre immédiatement dans un état d’attente jusqu’à ce que la demande d’e/s soit terminée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-108">In *synchronous file I/O*, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed.</span></span> <span data-ttu-id="4e26a-109">Un thread effectuant des *e/s de fichier asynchrones* envoie une requête d’e/s au noyau en appelant une fonction appropriée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-109">A thread performing *asynchronous file I/O* sends an I/O request to the kernel by calling an appropriate function.</span></span> <span data-ttu-id="4e26a-110">Si la demande est acceptée par le noyau, le thread appelant continue à traiter un autre travail jusqu’à ce que le noyau signale au thread que l’opération d’e/s est terminée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-110">If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete.</span></span> <span data-ttu-id="4e26a-111">Il interrompt ensuite son travail en cours et traite les données de l’opération d’e/s en fonction des besoins.</span><span class="sxs-lookup"><span data-stu-id="4e26a-111">It then interrupts its current job and processes the data from the I/O operation as necessary.</span></span>

<span data-ttu-id="4e26a-112">Les deux types de synchronisation sont illustrés dans la figure suivante.</span><span class="sxs-lookup"><span data-stu-id="4e26a-112">The two synchronization types are illustrated in the following figure.</span></span>

![e/s synchrones et asynchrones](images/fig2bedit.png)

<span data-ttu-id="4e26a-114">Dans les situations où une demande d’e/s est supposée prendre beaucoup de temps, par exemple une actualisation ou une sauvegarde d’une base de données volumineuse ou d’une liaison de communication lente, les e/s asynchrones constituent généralement un bon moyen d’optimiser l’efficacité du traitement.</span><span class="sxs-lookup"><span data-stu-id="4e26a-114">In situations where an I/O request is expected to take a large amount of time, such as a refresh or backup of a large database or a slow communications link, asynchronous I/O is generally a good way to optimize processing efficiency.</span></span> <span data-ttu-id="4e26a-115">Toutefois, pour les opérations d’e/s relativement rapides, la surcharge liée au traitement des demandes d’e/s de noyau et des signaux de noyau peut rendre les e/s asynchrones moins bénéfiques, en particulier si de nombreuses opérations d’e/s rapides doivent être effectuées.</span><span class="sxs-lookup"><span data-stu-id="4e26a-115">However, for relatively fast I/O operations, the overhead of processing kernel I/O requests and kernel signals may make asynchronous I/O less beneficial, particularly if many fast I/O operations need to be made.</span></span> <span data-ttu-id="4e26a-116">Dans ce cas, les e/s synchrones seraient préférables.</span><span class="sxs-lookup"><span data-stu-id="4e26a-116">In this case, synchronous I/O would be better.</span></span> <span data-ttu-id="4e26a-117">Les mécanismes et les détails d’implémentation de l’exécution de ces tâches varient en fonction du type de descripteur d’appareil utilisé et des besoins spécifiques de l’application.</span><span class="sxs-lookup"><span data-stu-id="4e26a-117">The mechanisms and implementation details of how to accomplish these tasks vary depending on the type of device handle that is used and the particular needs of the application.</span></span> <span data-ttu-id="4e26a-118">En d’autres termes, il existe généralement plusieurs façons de résoudre le problème.</span><span class="sxs-lookup"><span data-stu-id="4e26a-118">In other words, there are usually multiple ways to solve the problem.</span></span>

## <a name="synchronous-and-asynchronous-io-considerations"></a><span data-ttu-id="4e26a-119">Considérations relatives aux e/s synchrones et asynchrones</span><span class="sxs-lookup"><span data-stu-id="4e26a-119">Synchronous and Asynchronous I/O Considerations</span></span>

<span data-ttu-id="4e26a-120">Si un fichier ou un appareil est ouvert pour des e/s synchrones (c’est-à-dire que l' **indicateur de fichier \_ \_ OVERLAPPED** n’est pas spécifié), les appels suivants à des fonctions telles que [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) peuvent bloquer l’exécution du thread appelant jusqu’à ce que l’un des événements suivants se produise :</span><span class="sxs-lookup"><span data-stu-id="4e26a-120">If a file or device is opened for synchronous I/O (that is, **FILE\_FLAG\_OVERLAPPED** is not specified), subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) can block execution of the calling thread until one of the following events occurs:</span></span>

-   <span data-ttu-id="4e26a-121">L’opération d’e/s se termine (dans cet exemple, une écriture de données).</span><span class="sxs-lookup"><span data-stu-id="4e26a-121">The I/O operation completes (in this example, a data write).</span></span>
-   <span data-ttu-id="4e26a-122">Une erreur d’E/S se produit.</span><span class="sxs-lookup"><span data-stu-id="4e26a-122">An I/O error occurs.</span></span> <span data-ttu-id="4e26a-123">(Par exemple, le canal est fermé à partir de l’autre extrémité.)</span><span class="sxs-lookup"><span data-stu-id="4e26a-123">(For example, the pipe is closed from the other end.)</span></span>
-   <span data-ttu-id="4e26a-124">Une erreur s’est produite dans l’appel lui-même (par exemple, un ou plusieurs paramètres ne sont pas valides).</span><span class="sxs-lookup"><span data-stu-id="4e26a-124">An error was made in the call itself (for example, one or more parameters are not valid).</span></span>
-   <span data-ttu-id="4e26a-125">Un autre thread du processus appelle la fonction [**CancelSynchronousIo**](cancelsynchronousio-func.md) à l’aide du handle de thread du thread bloqué, qui met fin à l’e/s de ce thread, ce qui a échoué lors de l’opération d’e/s.</span><span class="sxs-lookup"><span data-stu-id="4e26a-125">Another thread in the process calls the [**CancelSynchronousIo**](cancelsynchronousio-func.md) function using the blocked thread's thread handle, which terminates I/O for that thread, failing the I/O operation.</span></span>
-   <span data-ttu-id="4e26a-126">Le thread bloqué se termine par le système ; par exemple, le processus lui-même est terminé, ou un autre thread appelle la fonction [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) à l’aide du handle du thread bloqué.</span><span class="sxs-lookup"><span data-stu-id="4e26a-126">The blocked thread is terminated by the system; for example, the process itself is terminated, or another thread calls the [**TerminateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-terminatethread) function using the blocked thread's handle.</span></span> <span data-ttu-id="4e26a-127">(Il s’agit généralement d’un dernier recours et non d’une conception d’application correcte.)</span><span class="sxs-lookup"><span data-stu-id="4e26a-127">(This is generally considered a last resort and not good application design.)</span></span>

<span data-ttu-id="4e26a-128">Dans certains cas, ce délai peut être inacceptable pour la conception et l’objectif de l’application, de sorte que les concepteurs d’applications doivent envisager d’utiliser des e/s asynchrones avec des objets de synchronisation de threads appropriés, tels que les [ports de terminaison d’e/s](i-o-completion-ports.md).</span><span class="sxs-lookup"><span data-stu-id="4e26a-128">In some cases, this delay may be unacceptable to the application's design and purpose, so application designers should consider using asynchronous I/O with appropriate thread synchronization objects such as [I/O completion ports](i-o-completion-ports.md).</span></span> <span data-ttu-id="4e26a-129">Pour plus d’informations sur la synchronisation des threads, consultez [à propos](/windows/desktop/Sync/about-synchronization)de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="4e26a-129">For more information about thread synchronization, see [About Synchronization](/windows/desktop/Sync/about-synchronization).</span></span>

<span data-ttu-id="4e26a-130">Un processus ouvre un fichier pour les e/s asynchrones dans son appel à [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) en spécifiant l’indicateur de **\_ \_ chevauchement** de l’indicateur de fichier dans le paramètre *dwFlagsAndAttributes* .</span><span class="sxs-lookup"><span data-stu-id="4e26a-130">A process opens a file for asynchronous I/O in its call to [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) by specifying the **FILE\_FLAG\_OVERLAPPED** flag in the *dwFlagsAndAttributes* parameter.</span></span> <span data-ttu-id="4e26a-131">Si l' **indicateur de fichier avec \_ \_ chevauchement** n’est pas spécifié, le fichier est ouvert pour les e/s synchrones.</span><span class="sxs-lookup"><span data-stu-id="4e26a-131">If **FILE\_FLAG\_OVERLAPPED** is not specified, the file is opened for synchronous I/O.</span></span> <span data-ttu-id="4e26a-132">Quand le fichier a été ouvert pour des e/s asynchrones, un pointeur vers une structure [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) est passé dans l’appel à [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) et [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="4e26a-132">When the file has been opened for asynchronous I/O, a pointer to an [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure is passed into the call to [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="4e26a-133">Lors de l’exécution d’e/s synchrones, cette structure n’est pas requise dans les appels à **ReadFile** et **WriteFile**.</span><span class="sxs-lookup"><span data-stu-id="4e26a-133">When performing synchronous I/O, this structure is not required in calls to **ReadFile** and **WriteFile**.</span></span>

> [!Note]  
> <span data-ttu-id="4e26a-134">Si un fichier ou un appareil est ouvert pour des e/s asynchrones, les appels suivants à des fonctions telles que [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) à l’aide de ce handle sont généralement retournés immédiatement, mais peuvent également se comporter de façon synchrone en ce qui concerne l’exécution bloquée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-134">If a file or device is opened for asynchronous I/O, subsequent calls to functions such as [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) using that handle generally return immediately but can also behave synchronously with respect to blocked execution.</span></span> <span data-ttu-id="4e26a-135">Pour plus d’informations, consultez [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span><span class="sxs-lookup"><span data-stu-id="4e26a-135">For more information, see [https://support.microsoft.com/kb/156932](https://support.microsoft.com/kb/156932).</span></span>

 

<span data-ttu-id="4e26a-136">Bien que [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) soit la fonction la plus courante à utiliser pour ouvrir des fichiers, des volumes de disque, des canaux anonymes et d’autres périphériques similaires, les opérations d’e/s peuvent également être effectuées à l’aide d’un descripteur de *conversion* à partir d’autres objets système tels qu’un socket créé par le [**Socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) ou des fonctions [**Accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) .</span><span class="sxs-lookup"><span data-stu-id="4e26a-136">Although [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) is the most common function to use for opening files, disk volumes, anonymous pipes, and other similar devices, I/O operations can also be performed using a handle *typecast* from other system objects such as a socket created by the [**socket**](/windows/desktop/api/winsock2/nf-winsock2-socket) or [**accept**](/windows/desktop/api/winsock2/nf-winsock2-accept) functions.</span></span>

<span data-ttu-id="4e26a-137">Les handles des objets d’annuaire sont obtenus en appelant la fonction [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) avec l’attribut sémantique de sauvegarde de l' **indicateur de fichier \_ \_ \_** .</span><span class="sxs-lookup"><span data-stu-id="4e26a-137">Handles to directory objects are obtained by calling the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function with the **FILE\_FLAG\_BACKUP\_SEMANTICS** attribute.</span></span> <span data-ttu-id="4e26a-138">Les handles de répertoires sont presque jamais utilisés : les applications de sauvegarde sont l’une des quelques applications qui les utilisent généralement.</span><span class="sxs-lookup"><span data-stu-id="4e26a-138">Directory handles are almost never used—backup applications are one of the few applications that will typically use them.</span></span>

<span data-ttu-id="4e26a-139">Après l’ouverture de l’objet fichier pour les e/s asynchrones, une structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) doit être correctement créée, initialisée et transmise à chaque appel à des fonctions telles que [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) et [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="4e26a-139">After opening the file object for asynchronous I/O, an [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure must be properly created, initialized, and passed into each call to functions such as [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) and [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span> <span data-ttu-id="4e26a-140">Gardez à l’esprit les points suivants lors de l’utilisation de la structure [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) dans des opérations de lecture et d’écriture asynchrones :</span><span class="sxs-lookup"><span data-stu-id="4e26a-140">Keep the following in mind when using the [**OVERLAPPED**](/windows/desktop/api/MinWinBase/ns-minwinbase-overlapped_entry) structure in asynchronous read and write operations:</span></span>

-   <span data-ttu-id="4e26a-141">Ne libérez pas ou ne modifiez pas la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ou la mémoire tampon de données tant que toutes les opérations d’e/s asynchrones n’ont pas été effectuées sur l’objet fichier.</span><span class="sxs-lookup"><span data-stu-id="4e26a-141">Do not deallocate or modify the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure or the data buffer until all asynchronous I/O operations to the file object have been completed.</span></span>
-   <span data-ttu-id="4e26a-142">Si vous déclarez votre pointeur vers la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) en tant que variable locale, ne quittez pas la fonction locale tant que toutes les opérations d’e/s asynchrones n’ont pas été effectuées sur l’objet fichier.</span><span class="sxs-lookup"><span data-stu-id="4e26a-142">If you declare your pointer to the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure as a local variable, do not exit the local function until all asynchronous I/O operations to the file object have been completed.</span></span> <span data-ttu-id="4e26a-143">Si la fonction locale est fermée prématurément, la structure **OVERLAPPED** est hors de portée et elle est inaccessible aux fonctions [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) ou [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) qu’elle rencontre en dehors de cette fonction.</span><span class="sxs-lookup"><span data-stu-id="4e26a-143">If the local function is exited prematurely, the **OVERLAPPED** structure will go out of scope and it will be inaccessible to any [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) functions it encounters outside of that function.</span></span>

<span data-ttu-id="4e26a-144">Vous pouvez également créer un événement et placer le descripteur dans la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) ; les [fonctions Wait](/windows/desktop/Sync/wait-functions) peuvent ensuite être utilisées pour attendre que l’opération d’e/s se termine en attendant le handle d’événement.</span><span class="sxs-lookup"><span data-stu-id="4e26a-144">You can also create an event and put the handle in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure; the [wait functions](/windows/desktop/Sync/wait-functions) can then be used to wait for the I/O operation to complete by waiting on the event handle.</span></span>

<span data-ttu-id="4e26a-145">Comme indiqué précédemment, lors de l’utilisation d’un descripteur asynchrone, les applications doivent faire attention au moment où il faut libérer des ressources associées à une opération d’e/s spécifiée sur ce handle.</span><span class="sxs-lookup"><span data-stu-id="4e26a-145">As previously stated, when working with an asynchronous handle, applications should use care when making determinations about when to free resources associated with a specified I/O operation on that handle.</span></span> <span data-ttu-id="4e26a-146">Si le descripteur est libéré prématurément, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) ou [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) peut signaler de façon incorrecte que l’opération d’e/s est terminée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-146">If the handle is deallocated prematurely, [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile) or [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) may incorrectly report that the I/O operation is complete.</span></span> <span data-ttu-id="4e26a-147">En outre, la fonction **WriteFile** retourne parfois **true** avec une valeur [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) de **\_ succès d’erreur**, même si elle utilise un handle asynchrone (qui peut également retourner **false** avec l' **erreur \_ e/s \_ en attente**).</span><span class="sxs-lookup"><span data-stu-id="4e26a-147">Further, the **WriteFile** function will sometimes return **TRUE** with a [**GetLastError**](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) value of **ERROR\_SUCCESS**, even though it is using an asynchronous handle (which can also return **FALSE** with **ERROR\_IO\_PENDING**).</span></span> <span data-ttu-id="4e26a-148">Les programmeurs habitués à la conception d’e/s synchrones vont généralement libérer des **ressources de tampon** de données à ce stade, car la **\_ réussite** et l’erreur signifient que l’opération est terminée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-148">Programmers accustomed to synchronous I/O design will usually release data buffer resources at this point because **TRUE** and **ERROR\_SUCCESS** signify the operation is complete.</span></span> <span data-ttu-id="4e26a-149">Toutefois, si les [ports de terminaison d’e/s](i-o-completion-ports.md) sont utilisés avec ce handle asynchrone, un paquet d’achèvement est également envoyé même si l’opération d’e/s a été effectuée immédiatement.</span><span class="sxs-lookup"><span data-stu-id="4e26a-149">However, if [I/O completion ports](i-o-completion-ports.md) are being used with this asynchronous handle, a completion packet will also be sent even though the I/O operation completed immediately.</span></span> <span data-ttu-id="4e26a-150">En d’autres termes, si l’application libère des ressources après que **WriteFile** a retourné la **valeur true** avec une **erreur de \_ réussite** en plus de dans la routine de port de terminaison d’e/s, elle aura une condition d’erreur double.</span><span class="sxs-lookup"><span data-stu-id="4e26a-150">In other words, if the application frees resources after **WriteFile** returns **TRUE** with **ERROR\_SUCCESS** in addition to in the I/O completion port routine, it will have a double-free error condition.</span></span> <span data-ttu-id="4e26a-151">Dans cet exemple, il est recommandé de permettre à la routine de port de fin d’être entièrement responsable de toutes les opérations de libération pour ces ressources.</span><span class="sxs-lookup"><span data-stu-id="4e26a-151">In this example, the recommendation would be to allow the completion port routine to be solely responsible for all freeing operations for such resources.</span></span>

<span data-ttu-id="4e26a-152">Le système ne conserve pas le pointeur de fichier sur les handles asynchrones des fichiers et des appareils qui prennent en charge les pointeurs de fichier (autrement dit, les périphériques de recherche). par conséquent, la position de fichier doit être passée aux fonctions de lecture et d’écriture dans les membres de données de décalage associés de la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) .</span><span class="sxs-lookup"><span data-stu-id="4e26a-152">The system does not maintain the file pointer on asynchronous handles to files and devices that support file pointers (that is, seeking devices), therefore the file position must be passed to the read and write functions in the related offset data members of the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure.</span></span> <span data-ttu-id="4e26a-153">Pour plus d’informations, consultez [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) et [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span><span class="sxs-lookup"><span data-stu-id="4e26a-153">For more information, see [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) and [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile).</span></span>

<span data-ttu-id="4e26a-154">La position du pointeur de fichier pour un handle synchrone est conservée par le système lorsque les données sont lues ou écrites et peut également être mise à jour à l’aide de la fonction [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) ou [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) .</span><span class="sxs-lookup"><span data-stu-id="4e26a-154">File pointer position for a synchronous handle is maintained by the system as data is read or written and can also be updated using the [**SetFilePointer**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointer) or [**SetFilePointerEx**](/windows/desktop/api/FileAPI/nf-fileapi-setfilepointerex) function.</span></span>

<span data-ttu-id="4e26a-155">Une application peut également attendre le descripteur de fichier pour synchroniser l’achèvement d’une opération d’e/s, mais cela nécessite une extrême prudence.</span><span class="sxs-lookup"><span data-stu-id="4e26a-155">An application can also wait on the file handle to synchronize the completion of an I/O operation, but doing so requires extreme caution.</span></span> <span data-ttu-id="4e26a-156">Chaque fois qu’une opération d’e/s démarre, le système d’exploitation définit le descripteur de fichier à l’état non signalé.</span><span class="sxs-lookup"><span data-stu-id="4e26a-156">Each time an I/O operation is started, the operating system sets the file handle to the nonsignaled state.</span></span> <span data-ttu-id="4e26a-157">À chaque fois qu’une opération d’e/s est terminée, le système d’exploitation définit le descripteur de fichier à l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="4e26a-157">Each time an I/O operation is completed, the operating system sets the file handle to the signaled state.</span></span> <span data-ttu-id="4e26a-158">Par conséquent, si une application démarre deux opérations d’e/s et attend le descripteur de fichier, il n’existe aucun moyen de déterminer l’opération qui se termine lorsque le descripteur est défini sur l’état signalé.</span><span class="sxs-lookup"><span data-stu-id="4e26a-158">Therefore, if an application starts two I/O operations and waits on the file handle, there is no way to determine which operation is finished when the handle is set to the signaled state.</span></span> <span data-ttu-id="4e26a-159">Si une application doit effectuer plusieurs opérations d’e/s asynchrones sur un seul fichier, elle doit attendre le handle d’événement dans la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) spécifique pour chaque opération d’e/s, plutôt que sur le descripteur de fichier commun.</span><span class="sxs-lookup"><span data-stu-id="4e26a-159">If an application must perform multiple asynchronous I/O operations on a single file, it should wait on the event handle in the specific [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure for each I/O operation, rather than on the common file handle.</span></span>

<span data-ttu-id="4e26a-160">Pour annuler toutes les opérations d’e/s asynchrones en attente, utilisez l’une des deux opérations suivantes :</span><span class="sxs-lookup"><span data-stu-id="4e26a-160">To cancel all pending asynchronous I/O operations, use either:</span></span>

-   <span data-ttu-id="4e26a-161">[**CancelIo**](cancelio.md): cette fonction annule uniquement les opérations émises par le thread appelant pour le handle de fichier spécifié.</span><span class="sxs-lookup"><span data-stu-id="4e26a-161">[**CancelIo**](cancelio.md)—this function only cancels operations issued by the calling thread for the specified file handle.</span></span>
-   <span data-ttu-id="4e26a-162">[**CancelIoEx**](cancelioex-func.md): cette fonction annule toutes les opérations émises par les threads pour le handle de fichier spécifié.</span><span class="sxs-lookup"><span data-stu-id="4e26a-162">[**CancelIoEx**](cancelioex-func.md)—this function cancels all operations issued by the threads for the specified file handle.</span></span>

<span data-ttu-id="4e26a-163">Utilisez [**CancelSynchronousIo**](cancelsynchronousio-func.md) pour annuler les opérations d’e/s synchrones en attente.</span><span class="sxs-lookup"><span data-stu-id="4e26a-163">Use [**CancelSynchronousIo**](cancelsynchronousio-func.md) to cancel pending synchronous I/O operations.</span></span>

<span data-ttu-id="4e26a-164">Les fonctions [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) et [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) permettent à une application de spécifier une routine à exécuter (consultez [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) lorsque la requête d’e/s asynchrone est terminée.</span><span class="sxs-lookup"><span data-stu-id="4e26a-164">The [**ReadFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-readfileex) and [**WriteFileEx**](/windows/desktop/api/FileAPI/nf-fileapi-writefileex) functions enable an application to specify a routine to execute (see [**FileIOCompletionRoutine**](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine)) when the asynchronous I/O request is completed.</span></span>

 

 
