---
description: Décrit les éléments à prendre en considération pour le contrôle d’application de la mise en mémoire tampon des fichiers, également appelée entrée/sortie (e/s) de fichiers non mis en mémoire tampon.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Mise en mémoire tampon du fichier
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104210262"
---
# <a name="file-buffering"></a><span data-ttu-id="3ae61-103">Mise en mémoire tampon du fichier</span><span class="sxs-lookup"><span data-stu-id="3ae61-103">File Buffering</span></span>

<span data-ttu-id="3ae61-104">Cette rubrique couvre les différents éléments à prendre en considération pour le contrôle d’application de la mise en mémoire tampon des fichiers, également appelée entrée/sortie de fichier non mis en mémoire tampon.</span><span class="sxs-lookup"><span data-stu-id="3ae61-104">This topic covers the various considerations for application control of file buffering, also known as unbuffered file input/output (I/O).</span></span> <span data-ttu-id="3ae61-105">La mise en mémoire tampon des fichiers est généralement gérée par le système en arrière-plan et est considérée comme faisant partie de la [mise en cache des fichiers](file-caching.md) au sein du système d’exploitation Windows, sauf indication contraire.</span><span class="sxs-lookup"><span data-stu-id="3ae61-105">File buffering is usually handled by the system behind the scenes and is considered part of [file caching](file-caching.md) within the Windows operating system unless otherwise specified.</span></span> <span data-ttu-id="3ae61-106">Bien que les conditions de *mise en cache* et de mise en *mémoire tampon* soient parfois utilisées de manière interchangeable, cette rubrique utilise le terme de *mise en mémoire tampon* , spécifiquement dans le contexte de l’interaction avec les données qui ne sont pas mises en cache (mises en mémoire tampon) par le système, dans le cas contraire du contrôle direct des applications en mode utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3ae61-106">Although the terms *caching* and *buffering* are sometimes used interchangeably, this topic uses the term *buffering* specifically in the context of explaining how to interact with data that is not being cached (buffered) by the system, where it is otherwise largely out of the direct control of user-mode applications.</span></span>

<span data-ttu-id="3ae61-107">Lors de l’ouverture ou de la création d’un fichier avec la fonction [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) , l’indicateur de **fichier aucun indicateur de mise en \_ \_ \_ mémoire tampon** peut être spécifié pour désactiver la mise en cache du système des données lues ou écrites dans le fichier.</span><span class="sxs-lookup"><span data-stu-id="3ae61-107">When opening or creating a file with the [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) function, the **FILE\_FLAG\_NO\_BUFFERING** flag can be specified to disable system caching of data being read from or written to the file.</span></span> <span data-ttu-id="3ae61-108">Bien que cela offre un contrôle complet et direct sur la mise en mémoire tampon des e/s des données, dans le cas de fichiers et d’appareils similaires, des exigences d’alignement des données doivent être prises en compte.</span><span class="sxs-lookup"><span data-stu-id="3ae61-108">Although this gives complete and direct control over data I/O buffering, in the case of files and similar devices there are data alignment requirements that must be considered.</span></span>

> [!Note]  
> <span data-ttu-id="3ae61-109">Ces informations d’alignement s’appliquent aux e/s sur les appareils tels que les fichiers qui prennent en charge la recherche et le concept de pointeurs (ou de *décalages*) de position de fichier.</span><span class="sxs-lookup"><span data-stu-id="3ae61-109">This alignment information applies to I/O on devices such as files that support seeking and the concept of file position pointers (or *offsets*).</span></span> <span data-ttu-id="3ae61-110">Pour les appareils qui ne recherchent pas, tels que les canaux nommés ou les appareils de communication, la désactivation de la mise en mémoire tampon peut ne pas nécessiter d’alignement particulier.</span><span class="sxs-lookup"><span data-stu-id="3ae61-110">For devices that do not seek, such as named pipes or communications devices, turning off buffering may not require any particular alignment.</span></span> <span data-ttu-id="3ae61-111">Les limitations ou les gains d’efficacité qui peuvent être obtenus par l’alignement dans ce cas dépendent de la technologie sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="3ae61-111">Any limitations or efficiencies that may be gained by alignment in that case are dependent on the underlying technology.</span></span>

 

<span data-ttu-id="3ae61-112">Dans un exemple simple, l’application ouvre un fichier pour l’accès en écriture avec l’indicateur de **fichier aucun indicateur de \_ mise en \_ \_ mémoire tampon** , puis effectue un appel à la fonction [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) à l’aide d’une mémoire tampon de données définie dans l’application.</span><span class="sxs-lookup"><span data-stu-id="3ae61-112">In a simple example, the application would open a file for write access with the **FILE\_FLAG\_NO\_BUFFERING** flag and then perform a call to the [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) function using a data buffer defined within the application.</span></span> <span data-ttu-id="3ae61-113">Cette mémoire tampon locale est, dans ces cas, la seule mémoire tampon de fichier qui existe pour cette opération.</span><span class="sxs-lookup"><span data-stu-id="3ae61-113">This local buffer is, in these circumstances, effectively the only file buffer that exists for this operation.</span></span> <span data-ttu-id="3ae61-114">En raison de la disposition du disque physique, de la disposition du stockage du système de fichiers et du suivi de position du pointeur de fichier au niveau système, cette opération d’écriture échoue, sauf si les tampons de données définis localement répondent à certains critères d’alignement, décrits dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="3ae61-114">Because of physical disk layout, file system storage layout, and system-level file pointer position tracking, this write operation will fail unless the locally-defined data buffers meet certain alignment criteria, discussed in the following section.</span></span>

> [!Note]  
> <span data-ttu-id="3ae61-115">La discussion sur la mise en cache ne tient pas compte de la mise en cache matérielle sur le disque physique lui-même, ce qui n’est pas garanti dans le contrôle direct du système dans tous les cas.</span><span class="sxs-lookup"><span data-stu-id="3ae61-115">Discussion of caching does not consider any hardware caching on the physical disk itself, which is not guaranteed to be within the direct control of the system in any case.</span></span> <span data-ttu-id="3ae61-116">Cela n’a aucun effet sur les spécifications spécifiées dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="3ae61-116">This has no effect on the requirements specified in this topic.</span></span>

 

<span data-ttu-id="3ae61-117">Pour plus d’informations sur la façon dont l' **indicateur de fichier \_ \_ sans \_ mise en mémoire tampon** interagit avec d’autres indicateurs liés au cache, consultez [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span><span class="sxs-lookup"><span data-stu-id="3ae61-117">For more information on how **FILE\_FLAG\_NO\_BUFFERING** interacts with other cache-related flags, see [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).</span></span>

## <a name="alignment-and-file-access-requirements"></a><span data-ttu-id="3ae61-118">Exigences d’alignement et d’accès aux fichiers</span><span class="sxs-lookup"><span data-stu-id="3ae61-118">Alignment and File Access Requirements</span></span>

<span data-ttu-id="3ae61-119">Comme indiqué précédemment, une application doit répondre à certaines exigences lors de l’utilisation de fichiers ouverts avec l' **indicateur de fichier \_ \_ sans \_ mise en mémoire tampon**.</span><span class="sxs-lookup"><span data-stu-id="3ae61-119">As previously discussed, an application must meet certain requirements when working with files opened with **FILE\_FLAG\_NO\_BUFFERING**.</span></span> <span data-ttu-id="3ae61-120">Les caractéristiques suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="3ae61-120">The following specifics apply:</span></span>

-   <span data-ttu-id="3ae61-121">Les tailles d’accès aux fichiers, y compris l’offset de fichier facultatif dans la structure [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , s’ils sont spécifiés, doivent être pour un nombre d’octets qui est un entier multiple de la taille du secteur du volume.</span><span class="sxs-lookup"><span data-stu-id="3ae61-121">File access sizes, including the optional file offset in the [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) structure, if specified, must be for a number of bytes that is an integer multiple of the volume sector size.</span></span> <span data-ttu-id="3ae61-122">Par exemple, si la taille de secteur est de 512 octets, une application peut demander des lectures et des écritures de 512, 1 024, 1 536 ou 2 048 octets, mais pas de 335, 981 ou 7 171 octets.</span><span class="sxs-lookup"><span data-stu-id="3ae61-122">For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1,024, 1,536, or 2,048 bytes, but not of 335, 981, or 7,171 bytes.</span></span>
-   <span data-ttu-id="3ae61-123">Les adresses de mémoire tampon d’accès aux fichiers pour les opérations de lecture et d’écriture doivent être alignées sur un secteur physique, ce qui signifie qu’elles sont alignées sur les adresses en mémoire qui sont des nombres entiers de la taille de secteur physique du volume.</span><span class="sxs-lookup"><span data-stu-id="3ae61-123">File access buffer addresses for read and write operations should be physical sector-aligned, which means aligned on addresses in memory that are integer multiples of the volume's physical sector size.</span></span> <span data-ttu-id="3ae61-124">Selon le disque, cette exigence ne peut pas être appliquée.</span><span class="sxs-lookup"><span data-stu-id="3ae61-124">Depending on the disk, this requirement may not be enforced.</span></span>

<span data-ttu-id="3ae61-125">Les développeurs d’applications doivent prendre note de nouveaux types de périphériques de stockage introduits sur le marché avec une taille de secteur de média physique de 4 096 octets.</span><span class="sxs-lookup"><span data-stu-id="3ae61-125">Application developers should take note of new types of storage devices being introduced into the market with a physical media sector size of 4,096 bytes.</span></span> <span data-ttu-id="3ae61-126">Le nom du secteur pour ces appareils est « format avancé ».</span><span class="sxs-lookup"><span data-stu-id="3ae61-126">The industry name for these devices is "Advanced Format".</span></span> <span data-ttu-id="3ae61-127">Comme il peut y avoir des problèmes de compatibilité avec l’introduction directe de 4 096 octets comme unité d’adressage pour le support, une solution de compatibilité temporaire consiste à introduire des appareils qui émulent un périphérique de stockage de secteur de 512 octets standard, mais qui proposent des informations sur la taille réelle de secteur par le biais de commandes ATA et SCSI standard.</span><span class="sxs-lookup"><span data-stu-id="3ae61-127">As there may be compatibility issues with directly introducing 4,096 bytes as the unit of addressing for the media, a temporary compatibility solution is to introduce devices that emulate a regular 512-byte sector storage device but make available information about the true sector size through standard ATA and SCSI commands.</span></span>

<span data-ttu-id="3ae61-128">À la suite de cette émulation, il y a deux tailles de secteur que les développeurs devront comprendre :</span><span class="sxs-lookup"><span data-stu-id="3ae61-128">As a result of this emulation, there are in essence two sector sizes that developers will need to understand:</span></span>

-   <span data-ttu-id="3ae61-129">Secteur logique : unité utilisée pour l’adressage de bloc logique pour le média.</span><span class="sxs-lookup"><span data-stu-id="3ae61-129">Logical Sector: The unit that is used for logical block addressing for the media.</span></span> <span data-ttu-id="3ae61-130">Nous pouvons également considérer qu’il s’agit de la plus petite unité d’écriture que le stockage peut accepter.</span><span class="sxs-lookup"><span data-stu-id="3ae61-130">We can also think of it as the smallest unit of write that the storage can accept.</span></span> <span data-ttu-id="3ae61-131">Il s’agit de l' « émulation ».</span><span class="sxs-lookup"><span data-stu-id="3ae61-131">This is the "emulation".</span></span>
-   <span data-ttu-id="3ae61-132">Secteur physique : l’unité pour laquelle les opérations de lecture et d’écriture sur l’appareil sont effectuées en une seule opération.</span><span class="sxs-lookup"><span data-stu-id="3ae61-132">Physical Sector: The unit for which read and write operations to the device are completed in a single operation.</span></span> <span data-ttu-id="3ae61-133">Il s’agit de l’unité d’écriture atomique et de l’alignement des e/s non mises en mémoire tampon sur afin d’obtenir des caractéristiques de performances et de fiabilité optimales.</span><span class="sxs-lookup"><span data-stu-id="3ae61-133">This is the unit of atomic write, and what unbuffered I/O will need to be aligned to in order to have optimal performance and reliability characteristics.</span></span>

<span data-ttu-id="3ae61-134">La plupart des API Windows actuelles, comme [**IOCTL \_ Disk obtiennent un \_ \_ lecteur \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) et [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), retournent la taille de secteur logique, mais la taille de secteur physique peut être récupérée par le biais du code de contrôle de propriété de  [**\_ \_ requête \_ de stockage IOCTL**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , avec les informations pertinentes contenues dans le membre BytesPerPhysicalSector dans la structure du [**\_ \_ \_ descripteur d’alignement de l’accès au stockage**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) .</span><span class="sxs-lookup"><span data-stu-id="3ae61-134">Most current Windows APIs, such as [**IOCTL\_DISK\_GET\_DRIVE\_GEOMETRY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) and [**GetDiskFreeSpace**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), will return the logical sector size, but the physical sector size can be retrieved through the [**IOCTL\_STORAGE\_QUERY\_PROPERTY**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) control code, with the relevant information contained in the **BytesPerPhysicalSector** member in the [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure.</span></span> <span data-ttu-id="3ae61-135">Pour obtenir un exemple, consultez l’exemple de code du [**\_ \_ \_ descripteur d’alignement**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor)de l’accès au stockage.</span><span class="sxs-lookup"><span data-stu-id="3ae61-135">For an example, see the sample code at [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor).</span></span> <span data-ttu-id="3ae61-136">Microsoft recommande vivement aux développeurs d’aligner les e/s non mises en mémoire tampon sur la taille de secteur physique comme indiqué par le code de contrôle de la **\_ propriété de \_ requête \_ de stockage IOCTL** pour garantir que leurs applications sont préparées pour cette transition de taille de secteur.</span><span class="sxs-lookup"><span data-stu-id="3ae61-136">Microsoft strongly recommends that developers align unbuffered I/O to the physical sector size as reported by the **IOCTL\_STORAGE\_QUERY\_PROPERTY** control code to help ensure their applications are prepared for this sector size transition.</span></span>

<span data-ttu-id="3ae61-137">**Windows Server 2003 et Windows XP :** La structure du [**\_ \_ \_ descripteur d’alignement de l’accès au stockage**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) n’est pas disponible.</span><span class="sxs-lookup"><span data-stu-id="3ae61-137">**Windows Server 2003 and Windows XP:** The [**STORAGE\_ACCESS\_ALIGNMENT\_DESCRIPTOR**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) structure is not available.</span></span> <span data-ttu-id="3ae61-138">Il a été introduit avec Windows Vista et Windows Server 2008.</span><span class="sxs-lookup"><span data-stu-id="3ae61-138">It was introduced with Windows Vista and Windows Server 2008.</span></span>

<span data-ttu-id="3ae61-139">Étant donné que les adresses de mémoire tampon pour les opérations de lecture et d’écriture doivent être alignées sur les secteurs, l’application doit contrôler directement la manière dont ces mémoires tampons sont allouées.</span><span class="sxs-lookup"><span data-stu-id="3ae61-139">Because buffer addresses for read and write operations must be sector-aligned, the application must have direct control of how these buffers are allocated.</span></span> <span data-ttu-id="3ae61-140">L’une des façons d’aligner les mémoires tampons consiste à utiliser la fonction [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) pour allouer les mémoires tampons.</span><span class="sxs-lookup"><span data-stu-id="3ae61-140">One way to sector-align buffers is to use the [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function to allocate the buffers.</span></span> <span data-ttu-id="3ae61-141">Tenez compte des éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="3ae61-141">Consider the following:</span></span>

-   <span data-ttu-id="3ae61-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) alloue de la mémoire qui est alignée sur les adresses qui sont des multiples de type entier de la taille de page du système.</span><span class="sxs-lookup"><span data-stu-id="3ae61-142">[**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) allocates memory that is aligned on addresses that are integer multiples of the system's page size.</span></span> <span data-ttu-id="3ae61-143">La taille de la page est de 4 096 octets sur x64 et x86 ou 8 192 octets pour les systèmes Itanium.</span><span class="sxs-lookup"><span data-stu-id="3ae61-143">Page size is 4,096 bytes on x64 and x86 or 8,192 bytes for Itanium-based systems.</span></span> <span data-ttu-id="3ae61-144">Pour plus d’informations, consultez la fonction [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .</span><span class="sxs-lookup"><span data-stu-id="3ae61-144">For additional information, see the [**GetSystemInfo**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) function.</span></span>
-   <span data-ttu-id="3ae61-145">La taille du secteur est généralement de 512 à 4 096 octets pour les périphériques de stockage à accès direct (disques durs) et de 2 048 octets pour les CD-ROM.</span><span class="sxs-lookup"><span data-stu-id="3ae61-145">Sector size is typically 512 to 4,096 bytes for direct-access storage devices (hard drives) and 2,048 bytes for CD-ROMs.</span></span>
-   <span data-ttu-id="3ae61-146">Les tailles des pages et des secteurs sont les puissances de 2.</span><span class="sxs-lookup"><span data-stu-id="3ae61-146">Both page and sector sizes are powers of 2.</span></span>

<span data-ttu-id="3ae61-147">Par conséquent, dans la plupart des cas, la mémoire alignée sur la page est également alignée sur les secteurs, car le cas où la taille du secteur est plus grande que la taille de la page est rare.</span><span class="sxs-lookup"><span data-stu-id="3ae61-147">Therefore, in most situations, page-aligned memory will also be sector-aligned, because the case where the sector size is larger than the page size is rare.</span></span>

<span data-ttu-id="3ae61-148">Une autre façon d’obtenir des tampons de mémoire alignés manuellement consiste à utiliser la fonction [ \_ \_ malloc alignée](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) à partir de la bibliothèque de Run-Time C.</span><span class="sxs-lookup"><span data-stu-id="3ae61-148">Another way to obtain manually-aligned memory buffers is to use the [\_aligned\_malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) function from the C Run-Time library.</span></span> <span data-ttu-id="3ae61-149">Pour obtenir un exemple de la façon de contrôler manuellement l’alignement de la mémoire tampon, consultez l’exemple de code du langage C++ dans la section exemple de code de [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span><span class="sxs-lookup"><span data-stu-id="3ae61-149">For an example of how to manually control buffer alignment, see the C++ language code example in the Example Code section of [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).</span></span>

 

 
