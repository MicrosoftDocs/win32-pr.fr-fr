---
description: Ce document présente les scénarios courants de transfert de données de Shell et explique comment les implémenter dans votre application.
ms.assetid: 7fce555c-a93d-4414-9119-7ae9acdd4d89
title: Gestion des scénarios de transfert de données de Shell
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35855b66e4108580d5bac305855837563ca59785
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "104972030"
---
# <a name="handling-shell-data-transfer-scenarios"></a><span data-ttu-id="78d60-103">Gestion des scénarios de transfert de données de Shell</span><span class="sxs-lookup"><span data-stu-id="78d60-103">Handling Shell Data Transfer Scenarios</span></span>

<span data-ttu-id="78d60-104">Le document d' [objet de données Shell](dataobject.md) a abordé l’approche générale utilisée pour transférer des données de Shell avec glisser-déplacer ou le presse-papiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-104">The [Shell Data Object](dataobject.md) document discussed the general approach that is used to transfer Shell data with drag-and-drop or the Clipboard.</span></span> <span data-ttu-id="78d60-105">Toutefois, pour implémenter le transfert de données de Shell dans votre application, vous devez également comprendre comment appliquer ces principes généraux et techniques à différents moyens de transférer les données de l’interpréteur de commandes.</span><span class="sxs-lookup"><span data-stu-id="78d60-105">However, to implement Shell data transfer in your application, you must also understand how to apply these general principles and techniques to the variety of ways that Shell data can be transferred.</span></span> <span data-ttu-id="78d60-106">Ce document présente les scénarios courants de transfert de données de Shell et explique comment les implémenter dans votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-106">This document presents common Shell data transfer scenarios and discusses how to implement each one in your application.</span></span>

-   [<span data-ttu-id="78d60-107">Recommandations générales</span><span class="sxs-lookup"><span data-stu-id="78d60-107">General Guidelines</span></span>](#general-guidelines)
-   [<span data-ttu-id="78d60-108">Copie de noms de fichier du presse-papiers vers une application</span><span class="sxs-lookup"><span data-stu-id="78d60-108">Copying File Names from the Clipboard to an Application</span></span>](#copying-file-names-from-the-clipboard-to-an-application)
    -   [<span data-ttu-id="78d60-109">Extraction des noms de fichiers de l’objet de données</span><span class="sxs-lookup"><span data-stu-id="78d60-109">Extracting the File Names from the Data Object</span></span>](#extracting-the-file-names-from-the-data-object)
-   [<span data-ttu-id="78d60-110">Copie du contenu d’un fichier déplacé dans une application</span><span class="sxs-lookup"><span data-stu-id="78d60-110">Copying the Contents of a Dropped File into an Application</span></span>](#copying-the-contents-of-a-dropped-file-into-an-application)
    -   [<span data-ttu-id="78d60-111">Utilisation du \_ format CFSTR FILECONTENTS pour extraire des données d’un fichier</span><span class="sxs-lookup"><span data-stu-id="78d60-111">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>](/windows)
-   [<span data-ttu-id="78d60-112">Gestion des opérations de déplacement optimisées</span><span class="sxs-lookup"><span data-stu-id="78d60-112">Handling Optimized Move Operations</span></span>](#handling-optimized-move-operations)
-   [<span data-ttu-id="78d60-113">Gestion des opérations de suppression sur le collage</span><span class="sxs-lookup"><span data-stu-id="78d60-113">Handling Delete-on-Paste Operations</span></span>](#handling-delete-on-paste-operations)
-   [<span data-ttu-id="78d60-114">Transfert de données vers et à partir de dossiers virtuels</span><span class="sxs-lookup"><span data-stu-id="78d60-114">Transfering Data to and from Virtual Folders</span></span>](#transfering-data-to-and-from-virtual-folders)
    -   [<span data-ttu-id="78d60-115">Acceptation de données à partir d’un dossier virtuel</span><span class="sxs-lookup"><span data-stu-id="78d60-115">Accepting Data from a Virtual Folder</span></span>](#accepting-data-from-a-virtual-folder)
    -   [<span data-ttu-id="78d60-116">Transfert de données vers et à partir d’une extension d’espace de noms</span><span class="sxs-lookup"><span data-stu-id="78d60-116">Transferring Data to and from a NameSpace Extension</span></span>](#transferring-data-to-and-from-a-namespace-extension)
-   [<span data-ttu-id="78d60-117">Suppression de fichiers dans la corbeille</span><span class="sxs-lookup"><span data-stu-id="78d60-117">Dropping Files on the Recycle Bin</span></span>](#dropping-files-on-the-recycle-bin)
-   [<span data-ttu-id="78d60-118">Création et importation de fichiers bribes</span><span class="sxs-lookup"><span data-stu-id="78d60-118">Creating and Importing Scrap Files</span></span>](#creating-and-importing-scrap-files)
    -   [<span data-ttu-id="78d60-119">Prise en charge des allers-retours</span><span class="sxs-lookup"><span data-stu-id="78d60-119">Round-trip Support</span></span>](#round-trip-support)
    -   [<span data-ttu-id="78d60-120">Formats de données mis en cache</span><span class="sxs-lookup"><span data-stu-id="78d60-120">Cached Data Formats</span></span>](#cached-data-formats)
    -   [<span data-ttu-id="78d60-121">Rendu différé</span><span class="sxs-lookup"><span data-stu-id="78d60-121">Delayed Rendering</span></span>](#delayed-rendering)
-   [<span data-ttu-id="78d60-122">Glisser-déplacer des objets Shell de manière asynchrone</span><span class="sxs-lookup"><span data-stu-id="78d60-122">Dragging and Dropping Shell Objects Asynchronously</span></span>](#dragging-and-dropping-shell-objects-asynchronously)
    -   [<span data-ttu-id="78d60-123">Utilisation de IASyncOperation/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="78d60-123">Using IASyncOperation/IDataObjectAsyncCapability</span></span>](#using-iasyncoperationidataobjectasynccapability)

> [!Note]  
> <span data-ttu-id="78d60-124">Bien que chacun de ces scénarios traite d’une opération de transfert de données spécifique, un grand nombre d’entre eux s’appliquent à un large éventail de scénarios associés.</span><span class="sxs-lookup"><span data-stu-id="78d60-124">Although each of these scenarios discusses a specific data transfer operation, many of them apply to a variety of related scenarios.</span></span> <span data-ttu-id="78d60-125">Par exemple, la principale différence entre le presse-papiers et les transferts par glisser-déplacer réside dans la façon dont l’objet de données arrive à la cible.</span><span class="sxs-lookup"><span data-stu-id="78d60-125">For instance, the primary difference between most Clipboard and drag-and-drop transfers is in how the data object arrives at the target.</span></span> <span data-ttu-id="78d60-126">Une fois que la cible a un pointeur vers l’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de l’objet de données, les procédures d’extraction d’informations sont en grande partie les mêmes pour les deux types de transfert de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-126">Once the target has a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, the procedures for extracting information are largely the same for both types of data transfer.</span></span> <span data-ttu-id="78d60-127">Toutefois, certains scénarios sont limités à un type d’opération spécifique.</span><span class="sxs-lookup"><span data-stu-id="78d60-127">However, some of the scenarios are limited to a specific type of operation.</span></span> <span data-ttu-id="78d60-128">Pour plus d’informations, reportez-vous au scénario individuel.</span><span class="sxs-lookup"><span data-stu-id="78d60-128">Refer to the individual scenario for details.</span></span>

 

## <a name="general-guidelines"></a><span data-ttu-id="78d60-129">Instructions générales</span><span class="sxs-lookup"><span data-stu-id="78d60-129">General Guidelines</span></span>

<span data-ttu-id="78d60-130">Chacune des sections suivantes décrit un scénario de transfert de données unique et relativement spécifique.</span><span class="sxs-lookup"><span data-stu-id="78d60-130">Each of the following sections discusses a single, fairly specific data transfer scenario.</span></span> <span data-ttu-id="78d60-131">Toutefois, les transferts de données sont souvent plus complexes et peuvent impliquer des aspects de plusieurs scénarios.</span><span class="sxs-lookup"><span data-stu-id="78d60-131">However, data transfers are often more complex and might involve aspects of several scenarios.</span></span> <span data-ttu-id="78d60-132">En général, vous ne savez pas, à l’avance, le scénario que vous devrez gérer.</span><span class="sxs-lookup"><span data-stu-id="78d60-132">You typically do not know, in advance, which scenario you will actually need to handle.</span></span> <span data-ttu-id="78d60-133">Voici quelques recommandations générales à prendre en compte.</span><span class="sxs-lookup"><span data-stu-id="78d60-133">Here are a few general guidelines to keep in mind.</span></span>

<span data-ttu-id="78d60-134">Pour les sources de données :</span><span class="sxs-lookup"><span data-stu-id="78d60-134">For data sources:</span></span>

-   <span data-ttu-id="78d60-135">Les formats du presse-papiers de l’interpréteur de commandes, à l’exception de [CF \_ HDROP](clipboard.md), ne sont pas prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="78d60-135">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="78d60-136">Chaque format que vous souhaitez utiliser doit être inscrit en appelant [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="78d60-136">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="78d60-137">Les formats dans les objets de données sont fournis dans l’ordre de préférence à partir de la source.</span><span class="sxs-lookup"><span data-stu-id="78d60-137">The formats in the data objects are provided in the order of preference from the source.</span></span> <span data-ttu-id="78d60-138">Énumérez l’objet de données et choisissez le premier que vous pouvez consommer.</span><span class="sxs-lookup"><span data-stu-id="78d60-138">Enumerate the data object and pick the first one you can consume.</span></span>
-   <span data-ttu-id="78d60-139">Incluez autant de formats que vous pouvez en prendre en charge.</span><span class="sxs-lookup"><span data-stu-id="78d60-139">Include as many formats as you can support.</span></span> <span data-ttu-id="78d60-140">En général, vous ne savez pas où l’objet de données sera supprimé.</span><span class="sxs-lookup"><span data-stu-id="78d60-140">You generally do not know where the data object will be dropped.</span></span> <span data-ttu-id="78d60-141">Cette pratique améliore les chances que l’objet de données contienne un format que la cible de déplacement peut accepter.</span><span class="sxs-lookup"><span data-stu-id="78d60-141">This practice improves the odds that the data object will contain a format that the drop target can accept.</span></span>
-   <span data-ttu-id="78d60-142">Les fichiers existants doivent être fournis avec le format [CF \_ HDROP](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-142">Existing files should be offered with the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="78d60-143">Offrez des données de type fichier avec des formats [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-143">Offer file-like data with [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="78d60-144">Cette approche permet à la cible de créer un fichier à partir d’un objet de données sans avoir besoin de connaître le stockage de données sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="78d60-144">This approach allows the target to create a file from a data object without needing to know anything about the underlying data storage.</span></span> <span data-ttu-id="78d60-145">Normalement, vous devez présenter les données sous la forme d’une interface [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="78d60-145">You should normally present the data as an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="78d60-146">Ce mécanisme de transfert de données est plus souple qu’un objet de mémoire globale et utilise moins de mémoire.</span><span class="sxs-lookup"><span data-stu-id="78d60-146">This data transfer mechanism is more flexible than a global memory object and uses much less memory.</span></span>
-   <span data-ttu-id="78d60-147">Les sources de glissement doivent offrir le format [CFSTR \_ SHELLIDLIST](clipboard.md) lorsque vous faites glisser des éléments de Shell.</span><span class="sxs-lookup"><span data-stu-id="78d60-147">Drag sources should offer the [CFSTR\_SHELLIDLIST](clipboard.md) format when dragging Shell items.</span></span> <span data-ttu-id="78d60-148">Les objets de données pour les éléments peuvent être obtenus via les méthodes [**IShellFolder :: GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) ou [**IShellItem :: BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) .</span><span class="sxs-lookup"><span data-stu-id="78d60-148">Data objects for items can be acquired through either the [**IShellFolder::GetUIObjectOf**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) or [**IShellItem::BindToHandler**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) methods.</span></span> <span data-ttu-id="78d60-149">Les sources de données peuvent créer une implémentation d’objet de données standard qui prend en charge le format [CFSTR \_ SHELLIDLIST](clipboard.md) à l’aide de [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span><span class="sxs-lookup"><span data-stu-id="78d60-149">Data sources can create a standard data object implementation that supports the [CFSTR\_SHELLIDLIST](clipboard.md) format by using [**SHCreateDataObject**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).</span></span>
-   <span data-ttu-id="78d60-150">Les cibles de dépôt qui souhaitent avoir un motif sur les éléments glissés à l’aide du modèle de programmation d’élément de Shell peuvent convertir un IDataObject en [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) à l’aide de [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span><span class="sxs-lookup"><span data-stu-id="78d60-150">Drop targets that want to reason about the items being dragged using the shell item programming model can convert an IDataObject into an [**IShellItemArray**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) using [**SHCreateShellItemArrayFromDataObject**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).</span></span>
-   <span data-ttu-id="78d60-151">Utilisez des curseurs de commentaires standard.</span><span class="sxs-lookup"><span data-stu-id="78d60-151">Use standard feedback cursors.</span></span>
-   <span data-ttu-id="78d60-152">Prenez en charge le déplacement vers la gauche et vers la droite.</span><span class="sxs-lookup"><span data-stu-id="78d60-152">Support left and right drag.</span></span>
-   <span data-ttu-id="78d60-153">Utilisez l’objet de données lui-même à partir d’un objet incorporé.</span><span class="sxs-lookup"><span data-stu-id="78d60-153">Use the data object itself from an embedded object.</span></span> <span data-ttu-id="78d60-154">Cette approche permet à votre application de récupérer tous les formats supplémentaires que l’objet de données doit offrir et évite de créer une couche supplémentaire de relation contenant-contenu.</span><span class="sxs-lookup"><span data-stu-id="78d60-154">This approach allows your application to retrieve any extra formats the data object has to offer and avoids creating an extra layer of containment.</span></span> <span data-ttu-id="78d60-155">Par exemple, un objet incorporé du serveur A est glissé à partir du serveur/conteneur B et déposé sur le conteneur C. C doit créer un objet incorporé du serveur A, et non un objet incorporé du serveur B contenant un objet incorporé du serveur A.</span><span class="sxs-lookup"><span data-stu-id="78d60-155">For instance, an embedded object from server A is dragged from server/container B and dropped on container C. C should create an embedded object of server A, not an embedded object of server B containing an embedded object of server A.</span></span>
-   <span data-ttu-id="78d60-156">N’oubliez pas que l’interpréteur de commandes peut utiliser des opérations de déplacement ou [de suppression](#handling-delete-on-paste-operations) en déplacement [optimisées](#handling-optimized-move-operations) lors du déplacement de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-156">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="78d60-157">Votre application doit être en mesure de reconnaître ces opérations et de répondre de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="78d60-157">Your application should be able to recognize these operations and respond appropriately.</span></span>

<span data-ttu-id="78d60-158">Pour les cibles de données :</span><span class="sxs-lookup"><span data-stu-id="78d60-158">For data targets:</span></span>

-   <span data-ttu-id="78d60-159">Les formats du presse-papiers de l’interpréteur de commandes, à l’exception de [CF \_ HDROP](clipboard.md), ne sont pas prédéfinis.</span><span class="sxs-lookup"><span data-stu-id="78d60-159">The Shell Clipboard formats, with the exception of [CF\_HDROP](clipboard.md), are not predefined.</span></span> <span data-ttu-id="78d60-160">Chaque format que vous souhaitez utiliser doit être inscrit en appelant [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span><span class="sxs-lookup"><span data-stu-id="78d60-160">Each format you want to use must be registered by calling [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).</span></span>
-   <span data-ttu-id="78d60-161">Implémenter et inscrire une cible de dépôt OLE.</span><span class="sxs-lookup"><span data-stu-id="78d60-161">Implement and register an OLE drop target.</span></span> <span data-ttu-id="78d60-162">Évitez d’utiliser des cibles Windows 3,1 ou le message [**WM \_ DROPFILES**](wm-dropfiles.md) , si possible.</span><span class="sxs-lookup"><span data-stu-id="78d60-162">Avoid using Windows 3.1 targets or the [**WM\_DROPFILES**](wm-dropfiles.md) message, if possible.</span></span>
-   <span data-ttu-id="78d60-163">Les formats contenus dans un objet de données varient selon l’origine de l’objet.</span><span class="sxs-lookup"><span data-stu-id="78d60-163">The formats contained by a data object vary, depending on where the object comes from.</span></span> <span data-ttu-id="78d60-164">Étant donné que vous ne connaissez pas à l’avance l’origine d’un objet de données, ne supposez pas qu’un format particulier sera présent.</span><span class="sxs-lookup"><span data-stu-id="78d60-164">Since you generally do not know in advance where a data object comes from, do not assume that a particular format will be present.</span></span> <span data-ttu-id="78d60-165">L’objet de données doit énumérer les formats par ordre de qualité, en commençant par le meilleur.</span><span class="sxs-lookup"><span data-stu-id="78d60-165">The data object should enumerate the formats in order of quality, starting with the best.</span></span> <span data-ttu-id="78d60-166">Ainsi, pour obtenir le meilleur format disponible, les applications énumèrent normalement les formats disponibles et utilisent le premier format de l’énumération qu’elles peuvent prendre en charge.</span><span class="sxs-lookup"><span data-stu-id="78d60-166">Thus, to get the best available format, applications normally enumerate the available formats and use the first format in the enumeration that they can support.</span></span>
-   <span data-ttu-id="78d60-167">Prenez en charge le glisser-déplacer.</span><span class="sxs-lookup"><span data-stu-id="78d60-167">Support right-drag.</span></span> <span data-ttu-id="78d60-168">Vous pouvez personnaliser le menu contextuel du glissement en créant un [Gestionnaire de glisser-déplacer](context-menu-handlers.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-168">You can customize the drag shortcut menu by creating a [drag-and-drop handler](context-menu-handlers.md).</span></span>
-   <span data-ttu-id="78d60-169">Si votre application accepte des fichiers existants, elle doit être en mesure de gérer le format [CF \_ HDROP](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-169">If your application will accept existing files, it must be able to handle the [CF\_HDROP](clipboard.md) format.</span></span>
-   <span data-ttu-id="78d60-170">En général, les applications qui acceptent des fichiers doivent également gérer les formats [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-170">In general, applications that accept files should also handle the [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md) formats.</span></span> <span data-ttu-id="78d60-171">Tandis que les fichiers du système de fichiers ont le format [CF \_ HDROP](clipboard.md) , les fichiers des fournisseurs comme les extensions d’espace de noms utilisent généralement [CFSTR \_ FILECONTENTS](clipboard.md) / [CFSTR \_ FILEDESCRIPTOR](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-171">While files from the file system have the [CF\_HDROP](clipboard.md) format, files from providers such as namespace extensions generally use [CFSTR\_FILECONTENTS](clipboard.md)/[CFSTR\_FILEDESCRIPTOR](clipboard.md).</span></span> <span data-ttu-id="78d60-172">Exemples : dossiers Windows CE, dossiers protocole FTP (FTP), dossiers Web et dossiers CAB.</span><span class="sxs-lookup"><span data-stu-id="78d60-172">Examples include Windows CE folders, File Transfer Protocol (FTP) folders, web folders, and CAB folders.</span></span> <span data-ttu-id="78d60-173">La source implémente normalement une interface [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) pour présenter les données de son stockage sous la forme d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-173">The source normally implements an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface to present data from its storage as a file.</span></span>
-   <span data-ttu-id="78d60-174">N’oubliez pas que l’interpréteur de commandes peut utiliser des opérations de déplacement ou [de suppression](#handling-delete-on-paste-operations) en déplacement [optimisées](#handling-optimized-move-operations) lors du déplacement de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-174">Remember that the Shell might use [optimized moves](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operations when moving files.</span></span> <span data-ttu-id="78d60-175">Votre application doit être en mesure de reconnaître ces opérations et de répondre de manière appropriée.</span><span class="sxs-lookup"><span data-stu-id="78d60-175">Your application should be able to recognize these operations and respond appropriately.</span></span>

## <a name="copying-file-names-from-the-clipboard-to-an-application"></a><span data-ttu-id="78d60-176">Copie de noms de fichier du presse-papiers vers une application</span><span class="sxs-lookup"><span data-stu-id="78d60-176">Copying File Names from the Clipboard to an Application</span></span>

<span data-ttu-id="78d60-177">**Scénario :** Un utilisateur sélectionne un ou plusieurs fichiers dans l’Explorateur Windows et les copie dans le presse-papiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-177">**Scenario:** A user selects one or more files in Windows Explorer and copies them to the Clipboard.</span></span> <span data-ttu-id="78d60-178">Votre application extrait les noms de fichiers et les colle dans le document.</span><span class="sxs-lookup"><span data-stu-id="78d60-178">Your application extracts the file names and pastes them into the document.</span></span>

<span data-ttu-id="78d60-179">Ce scénario peut être utilisé, par exemple, pour permettre à un utilisateur de créer un lien HTML en coupant et collant le fichier dans votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-179">This scenario could be used, for instance, to allow a user to create an HTML link by cutting and pasting the file to your application.</span></span> <span data-ttu-id="78d60-180">Votre application peut ensuite extraire le nom de fichier de l’objet de données et la traiter pour créer une balise d’ancrage.</span><span class="sxs-lookup"><span data-stu-id="78d60-180">Your application can then extract the file name from the data object and process it to create an anchor tag.</span></span>

<span data-ttu-id="78d60-181">Quand un utilisateur sélectionne un fichier dans l’Explorateur Windows et le copie dans le presse-papiers, l’interpréteur de commandes crée un objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-181">When a user selects a file in Windows Explorer and copies it to the Clipboard, the Shell creates a data object.</span></span> <span data-ttu-id="78d60-182">Il appelle ensuite [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) pour placer un pointeur vers l’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de l’objet de données dans le presse-papiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-182">It then calls [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span>

<span data-ttu-id="78d60-183">Lorsque l’utilisateur sélectionne la commande **coller** dans le menu ou la barre d’outils de votre application :</span><span class="sxs-lookup"><span data-stu-id="78d60-183">When the user selects the **Paste** command from your application's menu or toolbar:</span></span>

1.  <span data-ttu-id="78d60-184">Appelez [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) pour récupérer l’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-184">Call [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) to retrieve the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span>
2.  <span data-ttu-id="78d60-185">Appelez [**IDataObject :: EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) pour demander un objet énumérateur.</span><span class="sxs-lookup"><span data-stu-id="78d60-185">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) to request an enumerator object.</span></span>
3.  <span data-ttu-id="78d60-186">Utilisez l’interface [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) de l’objet Enumerator pour énumérer les formats contenus dans l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-186">Use the enumerator object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface to enumerate the formats contained by the data object.</span></span>

> [!Note]  
> <span data-ttu-id="78d60-187">Les deux dernières étapes de cette procédure sont incluses par exhaustivité.</span><span class="sxs-lookup"><span data-stu-id="78d60-187">The final two steps in this procedure are included for completeness.</span></span> <span data-ttu-id="78d60-188">Ils ne sont généralement pas nécessaires pour les transferts de fichiers simples.</span><span class="sxs-lookup"><span data-stu-id="78d60-188">They are typically not necessary for simple file transfers.</span></span> <span data-ttu-id="78d60-189">Tous les objets de données utilisés pour ce type de transfert de données doivent contenir le format [CF \_ HDROP](clipboard.md) , qui peut être utilisé pour déterminer les noms des fichiers contenus dans l’objet.</span><span class="sxs-lookup"><span data-stu-id="78d60-189">All data objects used for this type of data transfer should contain the [CF\_HDROP](clipboard.md) format, which can be used to determine the names of the files contained by the object.</span></span> <span data-ttu-id="78d60-190">Toutefois, pour les transferts de données plus généraux, vous devez énumérer les formats et sélectionner le meilleur que votre application peut gérer.</span><span class="sxs-lookup"><span data-stu-id="78d60-190">However, for more general data transfers, you should enumerate the formats and select the best one that your application can handle.</span></span>

 

### <a name="extracting-the-file-names-from-the-data-object"></a><span data-ttu-id="78d60-191">Extraction des noms de fichiers de l’objet de données</span><span class="sxs-lookup"><span data-stu-id="78d60-191">Extracting the File Names from the Data Object</span></span>

<span data-ttu-id="78d60-192">L’étape suivante consiste à extraire un ou plusieurs noms de fichiers de l’objet de données et à les coller dans votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-192">The next step is to extract one or more file names from the data object and paste them into your application.</span></span> <span data-ttu-id="78d60-193">Notez que la procédure décrite dans cette section pour l’extraction d’un nom de fichier à partir d’un objet de données s’applique également aux transferts par glisser-déplacer.</span><span class="sxs-lookup"><span data-stu-id="78d60-193">Note that the procedure discussed in this section for extracting a file name from a data object applies equally well to drag-and-drop transfers.</span></span>

<span data-ttu-id="78d60-194">Le moyen le plus simple de récupérer des noms de fichiers à partir d’un objet de données est le format [CF \_ HDROP](clipboard.md) :</span><span class="sxs-lookup"><span data-stu-id="78d60-194">The simplest way to retrieve file names from a data object is the [CF\_HDROP](clipboard.md) format:</span></span>

1.  <span data-ttu-id="78d60-195">Appelez [**IDataObject :: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span><span class="sxs-lookup"><span data-stu-id="78d60-195">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="78d60-196">Définissez le membre **cfFormat** de la structure [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) sur [CF \_ HDROP](clipboard.md) et le membre **TYMED** sur [TYMED \_ HGLOBAL](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-196">Set the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [CF\_HDROP](clipboard.md) and the **tymed** member to [TYMED\_HGLOBAL](dataobject.md).</span></span> <span data-ttu-id="78d60-197">Le membre **dwAspect** est normalement défini sur le \_ contenu DVASPECT.</span><span class="sxs-lookup"><span data-stu-id="78d60-197">The **dwAspect** member is normally set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="78d60-198">Toutefois, si le chemin d’accès au fichier est au format short (8,3), définissez **dwAspect** sur DVASPECT \_ short.</span><span class="sxs-lookup"><span data-stu-id="78d60-198">However, if you need to have the file's path in short (8.3) format, set **dwAspect** to DVASPECT\_SHORT.</span></span>

    <span data-ttu-id="78d60-199">Lorsque [**IDataObject :: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) retourne, le membre **hGlobal** de la structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) pointe vers un objet mémoire global qui contient les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-199">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object that contains the data.</span></span>

2.  <span data-ttu-id="78d60-200">Créez une variable HDROP et affectez-lui le membre **hGlobal** de la structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="78d60-200">Create an HDROP variable and set it to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="78d60-201">La variable HDROP est désormais un handle vers une structure [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) suivie d’une chaîne double se terminant par un caractère NULL contenant les chemins d’accès complets des fichiers copiés.</span><span class="sxs-lookup"><span data-stu-id="78d60-201">The HDROP variable is now a handle to a [**DROPFILES**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) structure followed by a double null-terminated string containing the fully qualified file paths of the copied files.</span></span>
3.  <span data-ttu-id="78d60-202">Déterminez le nombre de chemins d’accès aux fichiers figurant dans la liste en appelant [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) avec le paramètre *iFile* défini sur 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="78d60-202">Determine how many file paths are in the list by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) with the *iFile* parameter set to 0xFFFFFFFF.</span></span> <span data-ttu-id="78d60-203">La fonction retourne le nombre de chemins d’accès de fichiers dans la liste.</span><span class="sxs-lookup"><span data-stu-id="78d60-203">The function returns the number of file paths in the list.</span></span> <span data-ttu-id="78d60-204">L’index de base zéro du chemin d’accès de fichier de cette liste est utilisé à l’étape suivante pour identifier un chemin d’accès particulier.</span><span class="sxs-lookup"><span data-stu-id="78d60-204">The file path's zero-based index in this list is used in the next step to identify a particular path.</span></span>
4.  <span data-ttu-id="78d60-205">Extrayez les chemins d’accès de fichier de l’objet de mémoire globale en appelant [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) une fois pour chaque fichier, avec *iFile* défini sur l’index du fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-205">Extract the file paths from the global memory object by calling [**DragQueryFile**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) once for each file, with *iFile* set to the file's index.</span></span>
5.  <span data-ttu-id="78d60-206">Traitez les chemins d’accès des fichiers en fonction des besoins et collez-les dans votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-206">Process the file paths as needed and paste them into your application.</span></span>
6.  <span data-ttu-id="78d60-207">Appelez [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) et transmettez le pointeur vers la structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) que vous avez passée à [**IDataObject :: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) à l’étape 1.</span><span class="sxs-lookup"><span data-stu-id="78d60-207">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) and pass in the pointer to the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that you passed to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) in step 1.</span></span> <span data-ttu-id="78d60-208">Une fois que vous avez libéré la structure, la valeur HDROP que vous avez créée à l’étape 2 n’est plus valide et ne doit pas être utilisée.</span><span class="sxs-lookup"><span data-stu-id="78d60-208">Once you have released the structure, the HDROP value that you created in step 2 is no longer valid and should not be used.</span></span>

## <a name="copying-the-contents-of-a-dropped-file-into-an-application"></a><span data-ttu-id="78d60-209">Copie du contenu d’un fichier déplacé dans une application</span><span class="sxs-lookup"><span data-stu-id="78d60-209">Copying the Contents of a Dropped File into an Application</span></span>

<span data-ttu-id="78d60-210">**Scénario :** Un utilisateur fait glisser un ou plusieurs fichiers à partir de l’Explorateur Windows et les dépose dans la fenêtre de votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-210">**Scenario:** A user drags one or more files from Windows Explorer and drops them on your application's window.</span></span> <span data-ttu-id="78d60-211">Votre application extrait le contenu du ou des fichiers et les colle dans l’application.</span><span class="sxs-lookup"><span data-stu-id="78d60-211">Your application extracts the content of the file (s) and pastes it into the application.</span></span>

<span data-ttu-id="78d60-212">Ce scénario utilise le glisser-déplacer pour transférer les fichiers de l’Explorateur Windows vers l’application.</span><span class="sxs-lookup"><span data-stu-id="78d60-212">This scenario uses drag-and-drop to transfer the files from Windows Explorer to the application.</span></span> <span data-ttu-id="78d60-213">Avant l’opération, votre application doit :</span><span class="sxs-lookup"><span data-stu-id="78d60-213">Prior to the operation, your application must:</span></span>

1.  <span data-ttu-id="78d60-214">Appelez [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) pour enregistrer les formats de presse-papiers Shell nécessaires.</span><span class="sxs-lookup"><span data-stu-id="78d60-214">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to register any needed Shell Clipboard formats.</span></span>
2.  <span data-ttu-id="78d60-215">Appelez [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) pour inscrire une fenêtre cible et l’interface [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) de votre application.</span><span class="sxs-lookup"><span data-stu-id="78d60-215">Call [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) to register a target window and your application's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="78d60-216">Une fois que l’utilisateur a lancé l’opération en sélectionnant un ou plusieurs fichiers et en commençant à les faire glisser :</span><span class="sxs-lookup"><span data-stu-id="78d60-216">After the user initiates the operation by selecting one or more files and starting to drag them:</span></span>

1.  <span data-ttu-id="78d60-217">L’Explorateur Windows crée un objet de données et y charge les formats pris en charge.</span><span class="sxs-lookup"><span data-stu-id="78d60-217">Windows Explorer creates a data object and loads the supported formats into it.</span></span>
2.  <span data-ttu-id="78d60-218">L’Explorateur Windows appelle [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) pour initier la boucle de glissement.</span><span class="sxs-lookup"><span data-stu-id="78d60-218">Windows Explorer calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) to initiate the drag loop.</span></span>
3.  <span data-ttu-id="78d60-219">Lorsque l’image de glissement atteint votre fenêtre cible, le système vous avertit en appelant [**IDropTarget ::D ragenter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span><span class="sxs-lookup"><span data-stu-id="78d60-219">When the drag image reaches your target window, the system notifies you by calling [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span>
4.  <span data-ttu-id="78d60-220">Pour déterminer ce que contient l’objet de données, appelez la méthode [**IDataObject :: EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) de l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-220">To determine what the data object contains, call the data object's [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) method.</span></span> <span data-ttu-id="78d60-221">Utilisez l’objet énumérateur retourné par la méthode pour énumérer les formats contenus dans l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-221">Use the enumerator object returned by the method to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="78d60-222">Si votre application ne souhaite pas accepter l’un de ces formats, retournez DROPEFFECT \_ None.</span><span class="sxs-lookup"><span data-stu-id="78d60-222">If your application does not want to accept any of these formats, return DROPEFFECT\_NONE.</span></span> <span data-ttu-id="78d60-223">Dans le cadre de ce scénario, votre application doit ignorer tous les objets de données qui ne contiennent pas de formats utilisés pour transférer des fichiers, tels que [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-223">For the purposes of this scenario, your application should ignore any data objects that do not contain formats used to transfer files, such as [CF\_HDROP](clipboard.md).</span></span>
5.  <span data-ttu-id="78d60-224">Lorsque l’utilisateur supprime les données, le système appelle [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span><span class="sxs-lookup"><span data-stu-id="78d60-224">When the user drops the data, the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).</span></span>
6.  <span data-ttu-id="78d60-225">Utilisez l’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) pour extraire le contenu des fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-225">Use the [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface to extract the contents of the files.</span></span>

<span data-ttu-id="78d60-226">Il existe différentes façons d’extraire le contenu d’un objet Shell d’un objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-226">There are several different ways to extract the contents of a Shell object from a data object.</span></span> <span data-ttu-id="78d60-227">En général, utilisez l’ordre suivant :</span><span class="sxs-lookup"><span data-stu-id="78d60-227">In general, use the following order:</span></span>

-   <span data-ttu-id="78d60-228">Si le fichier contient un format de [ \_ texte CF](clipboard.md) , les données sont du texte ANSI.</span><span class="sxs-lookup"><span data-stu-id="78d60-228">If the file contains a [CF\_TEXT](clipboard.md) format, the data is ANSI text.</span></span> <span data-ttu-id="78d60-229">Vous pouvez utiliser le \_ format de texte CF pour extraire les données au lieu d’ouvrir le fichier lui-même.</span><span class="sxs-lookup"><span data-stu-id="78d60-229">You can use the CF\_TEXT format to extract the data, rather than opening the file itself.</span></span>
-   <span data-ttu-id="78d60-230">Si le fichier contient un objet OLE lié ou incorporé, l’objet de données contient un \_ format CF EMBEDDEDOBJECT.</span><span class="sxs-lookup"><span data-stu-id="78d60-230">If the file contains a linked or embedded OLE object, the data object contains a CF\_EMBEDDEDOBJECT format.</span></span> <span data-ttu-id="78d60-231">Utilisez les techniques OLE standard pour extraire les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-231">Use standard OLE techniques to extract the data.</span></span> <span data-ttu-id="78d60-232">Les [fichiers bribes](#creating-and-importing-scrap-files) contiennent toujours un \_ format CF EMBEDDEDOBJECT.</span><span class="sxs-lookup"><span data-stu-id="78d60-232">[Scrap files](#creating-and-importing-scrap-files) always contain a CF\_EMBEDDEDOBJECT format.</span></span>
-   <span data-ttu-id="78d60-233">Si l’objet Shell provient du système de fichiers, l’objet de données contient un format [CF \_ HDROP](clipboard.md) avec les noms des fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-233">If the Shell object is from the file system, the data object contains a [CF\_HDROP](clipboard.md) format with the names of the files.</span></span> <span data-ttu-id="78d60-234">Extrayez le nom de fichier de [CF \_ HDROP](clipboard.md) et appelez [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) pour créer un nouvel objet lié ou incorporé.</span><span class="sxs-lookup"><span data-stu-id="78d60-234">Extract the file name from [CF\_HDROP](clipboard.md) and call [**OleCreateFromFile**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) to create a new linked or embedded object.</span></span> <span data-ttu-id="78d60-235">Pour plus d’informations sur la récupération d’un nom de fichier à partir d’un format [CF \_ HDROP](clipboard.md) , consultez [copie de noms de fichiers à partir du presse-papiers vers une application](#copying-file-names-from-the-clipboard-to-an-application).</span><span class="sxs-lookup"><span data-stu-id="78d60-235">For a discussion of how to retrieve a file name from a [CF\_HDROP](clipboard.md) format, see [Copying File Names from the Clipboard to an Application](#copying-file-names-from-the-clipboard-to-an-application).</span></span>
-   <span data-ttu-id="78d60-236">Si l’objet de données contient un format [CFSTR \_ FILEDESCRIPTOR](clipboard.md) , vous pouvez extraire le contenu d’un fichier à partir du format [CFSTR \_ FILECONTENTS](clipboard.md) du fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-236">If the data object contains a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format, you can extract a file's contents from the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="78d60-237">Pour plus d’informations sur cette procédure, consultez [utilisation du \_ format CFSTR FILECONTENTS pour extraire des données d’un fichier](/windows).</span><span class="sxs-lookup"><span data-stu-id="78d60-237">For a discussion of this procedure, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>
-   <span data-ttu-id="78d60-238">Avant la [version 4,71](versions.md)de Shell, une application indiquait qu’elle transférait un type de fichier de raccourci en définissant **FD \_ LINKUI** dans le membre **dwFlags** de la structure [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="78d60-238">Prior to Shell [version 4.71](versions.md), an application indicated that it was transferring a shortcut file type by setting **FD\_LINKUI** in the **dwFlags** member of the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structure.</span></span> <span data-ttu-id="78d60-239">Pour les versions ultérieures de l’interpréteur de commandes, la meilleure façon d’indiquer que les raccourcis sont transférés consiste à utiliser le format [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) défini sur le \_ lien DROPEFFECT.</span><span class="sxs-lookup"><span data-stu-id="78d60-239">For later versions of the Shell, the preferred way to indicate that shortcuts are being transferred is to use the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_LINK.</span></span> <span data-ttu-id="78d60-240">Cette approche est bien plus efficace que l’extraction de la structure **FILEDESCRIPTOR** uniquement pour vérifier un indicateur.</span><span class="sxs-lookup"><span data-stu-id="78d60-240">This approach is much more efficient than extracting the **FILEDESCRIPTOR** structure just to check a flag.</span></span>

<span data-ttu-id="78d60-241">Si le processus d’extraction de données est long, vous souhaiterez peut-être effectuer l’opération de façon asynchrone sur un thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="78d60-241">If the data extraction process will be lengthy, you might want to do the operation asynchronously on a background thread.</span></span> <span data-ttu-id="78d60-242">Votre thread principal peut alors continuer sans délai inutile.</span><span class="sxs-lookup"><span data-stu-id="78d60-242">Your primary thread can then proceed without unnecessary delays.</span></span> <span data-ttu-id="78d60-243">Pour plus d’informations sur la gestion de l’extraction asynchrone des données, consultez [glisser-déplacer des objets Shell de manière asynchrone](#dragging-and-dropping-shell-objects-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="78d60-243">For a discussion of how to handle asynchronous data extraction, see [Dragging and Dropping Shell Objects Asynchronously](#dragging-and-dropping-shell-objects-asynchronously).</span></span>

### <a name="using-the-cfstr_filecontents-format-to-extract-data-from-a-file"></a><span data-ttu-id="78d60-244">Utilisation du \_ format CFSTR FILECONTENTS pour extraire des données d’un fichier</span><span class="sxs-lookup"><span data-stu-id="78d60-244">Using the CFSTR\_FILECONTENTS Format to Extract Data from a File</span></span>

<span data-ttu-id="78d60-245">Le format [CFSTR \_ FILECONTENTS](clipboard.md) offre un moyen très flexible et puissant de transférer le contenu d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-245">The [CFSTR\_FILECONTENTS](clipboard.md) format provides a very flexible and powerful way to transfer the contents of a file.</span></span> <span data-ttu-id="78d60-246">Il n’est même pas nécessaire de stocker les données en tant que fichier unique.</span><span class="sxs-lookup"><span data-stu-id="78d60-246">It is not even necessary for the data to be stored as a single file.</span></span> <span data-ttu-id="78d60-247">Tout ce qui est requis pour ce format est que l’objet de données présente les données à la cible comme s’il s’agissait d’un fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-247">All that is required for this format is that the data object present the data to the target as if it were a file.</span></span> <span data-ttu-id="78d60-248">Par exemple, les données réelles peuvent être une section d’un document texte ou un bloc de données extraites d’une base de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-248">For instance, the actual data might be a section of a text document or a block of data extracted from a database.</span></span> <span data-ttu-id="78d60-249">La cible peut traiter les données en tant que fichier et n’a pas besoin de savoir quoi que ce soit sur le mécanisme de stockage sous-jacent.</span><span class="sxs-lookup"><span data-stu-id="78d60-249">The target can treat the data as a file and does not need to know anything about the underlying storage mechanism.</span></span>

<span data-ttu-id="78d60-250">Les extensions d’espace de noms utilisent normalement [CFSTR \_ FILECONTENTS](clipboard.md) pour transférer des données, car ce format ne prend pas en compte un mécanisme de stockage particulier.</span><span class="sxs-lookup"><span data-stu-id="78d60-250">Namespace extensions normally use [CFSTR\_FILECONTENTS](clipboard.md) to transfer data because this format does not assume any particular storage mechanism.</span></span> <span data-ttu-id="78d60-251">Une extension d’espace de noms peut utiliser n’importe quel mécanisme de stockage pratique et utiliser ce format pour présenter ses objets aux applications comme s’il s’agissait de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-251">A namespace extension can use whatever storage mechanism is convenient, and use this format to present its objects to applications as if they were files.</span></span>

<span data-ttu-id="78d60-252">Le mécanisme de transfert de données pour [CFSTR \_ FILECONTENTS](clipboard.md) est normalement [TYMED \_ ISTREAM](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-252">The data transfer mechanism for [CFSTR\_FILECONTENTS](clipboard.md) is normally [TYMED\_ISTREAM](dataobject.md).</span></span> <span data-ttu-id="78d60-253">Le transfert d’un pointeur d’interface [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) nécessite une quantité de mémoire inférieure à celle du chargement des données dans un objet de mémoire globale, et **IStream** est un moyen plus simple de représenter des données que [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="78d60-253">Transferring an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface pointer requires much less memory than loading the data into a global memory object, and **IStream** is a simpler way to represent data than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span>

<span data-ttu-id="78d60-254">Un format [CFSTR \_ FILECONTENTS](clipboard.md) est toujours accompagné d’un format [CFSTR \_ FILEDESCRIPTOR](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-254">A [CFSTR\_FILECONTENTS](clipboard.md) format is always accompanied by a [CFSTR\_FILEDESCRIPTOR](clipboard.md) format.</span></span> <span data-ttu-id="78d60-255">Vous devez d’abord examiner le contenu de ce format.</span><span class="sxs-lookup"><span data-stu-id="78d60-255">You must examine the contents of this format first.</span></span> <span data-ttu-id="78d60-256">Si plusieurs fichiers sont en cours de transfert, l’objet de données contient en fait plusieurs formats [CFSTR \_ FILECONTENTS](clipboard.md) , un pour chaque fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-256">If more than one file is being transferred, the data object will actually contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, one for each file.</span></span> <span data-ttu-id="78d60-257">Le format [CFSTR \_ FILEDESCRIPTOR](clipboard.md) contient le nom et les attributs de chaque fichier et fournit une valeur d’index pour chaque fichier nécessaire pour extraire le format [CFSTR \_ FILECONTENTS](clipboard.md) d’un fichier particulier.</span><span class="sxs-lookup"><span data-stu-id="78d60-257">The [CFSTR\_FILEDESCRIPTOR](clipboard.md) format contains the name and attributes of each file, and provides an index value for each file that is needed to extract a particular file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span>

<span data-ttu-id="78d60-258">Pour extraire un format [CFSTR \_ FILECONTENTS](clipboard.md) :</span><span class="sxs-lookup"><span data-stu-id="78d60-258">To extract a [CFSTR\_FILECONTENTS](clipboard.md) format:</span></span>

1.  <span data-ttu-id="78d60-259">Extrayez le format [CFSTR \_ FILEDESCRIPTOR](clipboard.md) en tant que valeur de [ \_ HGLOBAL TYMED](dataobject.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-259">Extract the [CFSTR\_FILEDESCRIPTOR](clipboard.md) format as a [TYMED\_HGLOBAL](dataobject.md) value.</span></span>
2.  <span data-ttu-id="78d60-260">Le membre **hGlobal** de la structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) retournée pointe vers un objet mémoire global.</span><span class="sxs-lookup"><span data-stu-id="78d60-260">The **hGlobal** member of the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure points to a global memory object.</span></span> <span data-ttu-id="78d60-261">Verrouillez cet objet en passant la valeur **hGlobal** à [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span><span class="sxs-lookup"><span data-stu-id="78d60-261">Lock that object by passing the **hGlobal** value to [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock).</span></span>
3.  <span data-ttu-id="78d60-262">Cast du pointeur retourné par [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) en pointeur [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) .</span><span class="sxs-lookup"><span data-stu-id="78d60-262">Cast the pointer returned by [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to a [**FILEGROUPDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) pointer.</span></span> <span data-ttu-id="78d60-263">Il pointe vers une structure **FILEGROUPDESCRIPTOR** suivie d’une ou de plusieurs structures [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) .</span><span class="sxs-lookup"><span data-stu-id="78d60-263">It will point to a **FILEGROUPDESCRIPTOR** structure followed by one or more [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures.</span></span> <span data-ttu-id="78d60-264">Chaque structure **FILEDESCRIPTOR** contient une description d’un fichier qui est contenu dans l’un des formats [CFSTR \_ FILECONTENTS](clipboard.md) associés.</span><span class="sxs-lookup"><span data-stu-id="78d60-264">Each **FILEDESCRIPTOR** structure contains a description of a file that is contained by one of the accompanying [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>
4.  <span data-ttu-id="78d60-265">Examinez les structures [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) pour déterminer celle qui correspond au fichier que vous souhaitez extraire.</span><span class="sxs-lookup"><span data-stu-id="78d60-265">Examine the [**FILEDESCRIPTOR**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) structures to determine which one corresponds to the file you want to extract.</span></span> <span data-ttu-id="78d60-266">L’index de base zéro de cette structure **FILEDESCRIPTOR** est utilisé pour identifier le format [CFSTR \_ FILECONTENTS](clipboard.md) du fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-266">The zero-based index of that **FILEDESCRIPTOR** structure is used to identify the file's [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="78d60-267">Étant donné que la taille d’un bloc de mémoire globale n’est pas précise en octets, utilisez les membres **nFileSizeLow** et **nFileSizeHigh** de la structure pour déterminer le nombre d’octets représentant le fichier dans l’objet mémoire globale.</span><span class="sxs-lookup"><span data-stu-id="78d60-267">Because the size of a global memory block is not byte-precise, use the structure's **nFileSizeLow** and **nFileSizeHigh** members to determine how many bytes represent the file in the global memory object.</span></span>
5.  <span data-ttu-id="78d60-268">Appelez [**IDataObject :: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) avec le membre **cfFormat** de la structure [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) défini sur la valeur [CFSTR \_ FILECONTENTS](clipboard.md) et le membre **Lindex** défini sur l’index que vous avez déterminé à l’étape précédente.</span><span class="sxs-lookup"><span data-stu-id="78d60-268">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) with the **cfFormat** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure set to the [CFSTR\_FILECONTENTS](clipboard.md) value and the **lIndex** member set to the index that you determined in the previous step.</span></span> <span data-ttu-id="78d60-269">Le membre **TYMED** est généralement défini sur [TYMED \_ HGLOBAL](dataobject.md) \| TYMED \_ ISTREAM \| TYMED \_ ISTORAGE.</span><span class="sxs-lookup"><span data-stu-id="78d60-269">The **tymed** member is typically set to [TYMED\_HGLOBAL](dataobject.md) \| TYMED\_ISTREAM \| TYMED\_ISTORAGE.</span></span> <span data-ttu-id="78d60-270">L’objet de données peut ensuite choisir son mécanisme de transfert de données par défaut.</span><span class="sxs-lookup"><span data-stu-id="78d60-270">The data object can then choose its preferred data transfer mechanism.</span></span>
6.  <span data-ttu-id="78d60-271">La structure [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) que [**IDataObject :: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) retourne contient un pointeur vers les données du fichier.</span><span class="sxs-lookup"><span data-stu-id="78d60-271">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns will contain a pointer to the file's data.</span></span> <span data-ttu-id="78d60-272">Examinez le membre **TYMED** de la structure pour déterminer le mécanisme de transfert de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-272">Examine the **tymed** member of the structure to determine the data transfer mechanism.</span></span>
7.  <span data-ttu-id="78d60-273">Si **TYMED** a la valeur [TYMED \_ ISTREAM](dataobject.md) ou TYMED \_ ISTORAGE, utilisez l’interface pour extraire les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-273">If **tymed** is set to [TYMED\_ISTREAM](dataobject.md) or TYMED\_ISTORAGE, use the interface to extract the data.</span></span> <span data-ttu-id="78d60-274">Si **TYMED** a la valeur TYMED \_ HGLOBAL, les données sont contenues dans un objet mémoire global.</span><span class="sxs-lookup"><span data-stu-id="78d60-274">If **tymed** is set to TYMED\_HGLOBAL, the data is contained in a global memory object.</span></span> <span data-ttu-id="78d60-275">Pour plus d’informations sur l’extraction de données à partir d’un objet mémoire global, consultez la section *extraction d’un objet mémoire global d’un* objet de données [Shell](dataobject.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-275">For a discussion of how to extract data from a global memory object, see the *Extracting a global memory object from a data object* section of [Shell Data Object](dataobject.md).</span></span>
8.  <span data-ttu-id="78d60-276">Appelez [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) pour déverrouiller l’objet mémoire global que vous avez verrouillé à l’étape 2.</span><span class="sxs-lookup"><span data-stu-id="78d60-276">Call [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) to unlock the global memory object that you locked in step 2.</span></span>

## <a name="handling-optimized-move-operations"></a><span data-ttu-id="78d60-277">Gestion des opérations de déplacement optimisées</span><span class="sxs-lookup"><span data-stu-id="78d60-277">Handling Optimized Move Operations</span></span>

<span data-ttu-id="78d60-278">**Scénario :** Un fichier est déplacé du système de fichiers vers une extension d’espace de noms à l’aide d’un déplacement optimisé.</span><span class="sxs-lookup"><span data-stu-id="78d60-278">**Scenario:** A file is moved from the file system to a namespace extension using an optimized move.</span></span>

<span data-ttu-id="78d60-279">Dans une opération de déplacement classique, la cible effectue une copie des données et la source supprime l’original.</span><span class="sxs-lookup"><span data-stu-id="78d60-279">In a conventional move operation, the target makes a copy of the data and the source deletes the original.</span></span> <span data-ttu-id="78d60-280">Cette procédure peut être inefficace car elle nécessite deux copies des données.</span><span class="sxs-lookup"><span data-stu-id="78d60-280">This procedure can be inefficient because it requires two copies of the data.</span></span> <span data-ttu-id="78d60-281">Avec les objets volumineux tels que les bases de données, une opération de déplacement classique peut même ne pas être pratique.</span><span class="sxs-lookup"><span data-stu-id="78d60-281">With large objects such as databases, a conventional move operation might not even be practical.</span></span>

<span data-ttu-id="78d60-282">Avec un déplacement optimisé, la cible utilise la compréhension de la façon dont les données sont stockées pour gérer l’ensemble de l’opération de déplacement.</span><span class="sxs-lookup"><span data-stu-id="78d60-282">With an optimized move, the target uses its understanding of how the data is stored to handle the entire move operation.</span></span> <span data-ttu-id="78d60-283">Il n’y a jamais de deuxième copie des données, et il n’est pas nécessaire que la source supprime les données d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-283">There is never a second copy of the data, and there is no need for the source to delete the original data.</span></span> <span data-ttu-id="78d60-284">Les données de l’interpréteur de commandes sont parfaitement adaptées aux déplacements optimisés, car la cible peut gérer l’ensemble de l’opération à l’aide de l’API Shell.</span><span class="sxs-lookup"><span data-stu-id="78d60-284">Shell data is well suited to optimized moves because the target can handle the entire operation using the Shell API.</span></span> <span data-ttu-id="78d60-285">Un exemple classique consiste à déplacer des fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-285">A typical example is moving files.</span></span> <span data-ttu-id="78d60-286">Une fois que la cible a le chemin d’un fichier à déplacer, elle peut utiliser [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) pour la déplacer.</span><span class="sxs-lookup"><span data-stu-id="78d60-286">Once the target has the path of a file to be moved, it can use [**SHFileOperation**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) to move it.</span></span> <span data-ttu-id="78d60-287">La source ne doit pas nécessairement supprimer le fichier d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-287">There is no need for the source to delete the original file.</span></span>

> [!Note]  
> <span data-ttu-id="78d60-288">L’interpréteur de commandes utilise normalement un déplacement optimisé pour déplacer des fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-288">The Shell normally uses an optimized move to move files.</span></span> <span data-ttu-id="78d60-289">Pour gérer correctement le transfert de données de Shell, votre application doit être en capacité de détecter et de gérer un déplacement optimisé.</span><span class="sxs-lookup"><span data-stu-id="78d60-289">To handle Shell data transfer properly, your application must be capable of detecting and handling an optimized move.</span></span>

 

<span data-ttu-id="78d60-290">Les déplacements optimisés sont traités de la manière suivante :</span><span class="sxs-lookup"><span data-stu-id="78d60-290">Optimized moves are handled in the following way:</span></span>

1.  <span data-ttu-id="78d60-291">La source appelle [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) avec le paramètre *DWEFFECT* défini sur DROPEFFECT \_ Move pour indiquer que les objets sources peuvent être déplacés.</span><span class="sxs-lookup"><span data-stu-id="78d60-291">The source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) with the *dwEffect* parameter set to DROPEFFECT\_MOVE to indicate that the source objects can be moved.</span></span>
2.  <span data-ttu-id="78d60-292">La cible reçoit la \_ valeur de déplacement DROPEFFECT via l’une de ses méthodes [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) , ce qui indique qu’un déplacement est autorisé.</span><span class="sxs-lookup"><span data-stu-id="78d60-292">The target receives the DROPEFFECT\_MOVE value through one of its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) methods, indicating that a move is allowed.</span></span>
3.  <span data-ttu-id="78d60-293">La cible copie l’objet (déplacement non optimisé) ou déplace l’objet (déplacement optimisé).</span><span class="sxs-lookup"><span data-stu-id="78d60-293">The target either copies the object (unoptimized move) or moves the object (optimized move).</span></span>
4.  <span data-ttu-id="78d60-294">La cible indique ensuite à la source s’il doit supprimer les données d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-294">The target then tells the source whether it needs to delete the original data.</span></span>

    <span data-ttu-id="78d60-295">Un déplacement optimisé est l’opération par défaut, avec les données supprimées par la cible.</span><span class="sxs-lookup"><span data-stu-id="78d60-295">An optimized move is the default operation, with the data deleted by the target.</span></span> <span data-ttu-id="78d60-296">Pour informer la source qu’un déplacement optimisé a été effectué :</span><span class="sxs-lookup"><span data-stu-id="78d60-296">To inform the source that an optimized move was performed:</span></span>

    -   -   <span data-ttu-id="78d60-297">La cible définit la valeur *pdwEffect* qu’elle a reçue par le biais de sa méthode [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) sur une valeur autre que DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-297">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to some value other than DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="78d60-298">Elle est généralement définie sur DROPEFFECT \_ None ou DROPEFFECT \_ Copy.</span><span class="sxs-lookup"><span data-stu-id="78d60-298">It is typically set to either DROPEFFECT\_NONE or DROPEFFECT\_COPY.</span></span> <span data-ttu-id="78d60-299">La valeur sera retournée à la source par [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="78d60-299">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="78d60-300">La cible appelle également la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) de l’objet de données et la transmet à un identificateur de format [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) défini sur DROPEFFECT \_ None.</span><span class="sxs-lookup"><span data-stu-id="78d60-300">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="78d60-301">Cet appel de méthode est nécessaire, car certaines cibles de déplacement peuvent ne pas définir correctement le paramètre *pdwEffect* de [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="78d60-301">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="78d60-302">Le format [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) est la méthode fiable pour indiquer qu’un déplacement optimisé a eu lieu.</span><span class="sxs-lookup"><span data-stu-id="78d60-302">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an optimized move has taken place.</span></span>

    <span data-ttu-id="78d60-303">Si la cible a été déplacée de manière non optimisée, les données doivent être supprimées par la source.</span><span class="sxs-lookup"><span data-stu-id="78d60-303">If the target did an unoptimized move, the data must be deleted by the source.</span></span> <span data-ttu-id="78d60-304">Pour informer la source qu’un déplacement non optimisé a été effectué :</span><span class="sxs-lookup"><span data-stu-id="78d60-304">To inform the source that an unoptimized move was performed:</span></span>

    -   -   <span data-ttu-id="78d60-305">La cible définit la valeur *pdwEffect* qu’elle a reçue par le biais de sa méthode [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) pour DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-305">The target sets the *pdwEffect* value it received through its [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="78d60-306">La valeur sera retournée à la source par [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="78d60-306">The value will be returned to the source by [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span>
        -   <span data-ttu-id="78d60-307">La cible appelle également la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) de l’objet de données et la transmet à un identificateur de format [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) défini sur DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-307">The target also calls the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method and passes it a [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format identifier set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="78d60-308">Cet appel de méthode est nécessaire, car certaines cibles de déplacement peuvent ne pas définir correctement le paramètre *pdwEffect* de [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="78d60-308">This method call is necessary because some drop targets might not set the *pdwEffect* parameter of [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) properly.</span></span> <span data-ttu-id="78d60-309">Le format [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) est la méthode fiable pour indiquer qu’un déplacement non optimisé a eu lieu.</span><span class="sxs-lookup"><span data-stu-id="78d60-309">The [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format is the reliable way to indicate that an unoptimized move has taken place.</span></span>

5.  <span data-ttu-id="78d60-310">La source inspecte les deux valeurs qui peuvent être retournées par la cible.</span><span class="sxs-lookup"><span data-stu-id="78d60-310">The source inspects the two values that can be returned by the target.</span></span> <span data-ttu-id="78d60-311">Si les deux sont définis sur DROPEFFECT Move, le déplacement n’est pas \_ optimisé en supprimant les données d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-311">If both are set to DROPEFFECT\_MOVE, it completes the unoptimized move by deleting the original data.</span></span> <span data-ttu-id="78d60-312">Dans le cas contraire, la cible faisait un déplacement optimisé et les données d’origine ont été supprimées.</span><span class="sxs-lookup"><span data-stu-id="78d60-312">Otherwise, the target did an optimized move and the original data has been deleted.</span></span>

## <a name="handling-delete-on-paste-operations"></a><span data-ttu-id="78d60-313">Gestion des opérations de suppression sur le collage</span><span class="sxs-lookup"><span data-stu-id="78d60-313">Handling Delete-on-Paste Operations</span></span>

<span data-ttu-id="78d60-314">**Scénario :** Un ou plusieurs fichiers sont coupés à partir d’un dossier dans l’Explorateur Windows et collés dans une extension d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="78d60-314">**Scenario:** One or more files are cut from a folder in Windows Explorer and pasted into a namespace extension.</span></span> <span data-ttu-id="78d60-315">L’Explorateur Windows laisse les fichiers en surbrillance jusqu’à ce qu’il reçoive des commentaires sur le résultat de l’opération de collage.</span><span class="sxs-lookup"><span data-stu-id="78d60-315">Windows Explorer leaves the files highlighted until it receives feedback on the outcome of the paste operation.</span></span>

<span data-ttu-id="78d60-316">Traditionnellement, lorsqu’un utilisateur coupe des données, il disparaît immédiatement de l’affichage.</span><span class="sxs-lookup"><span data-stu-id="78d60-316">Traditionally, when a user cuts data it immediately disappears from view.</span></span> <span data-ttu-id="78d60-317">Cela peut ne pas être efficace et peut entraîner des problèmes d’utilisation si l’utilisateur s’inquiète de ce qui est arrivé aux données.</span><span class="sxs-lookup"><span data-stu-id="78d60-317">This might not be efficient, and it can lead to usability problems if the user becomes concerned about what has happened to the data.</span></span> <span data-ttu-id="78d60-318">Une autre approche consiste à utiliser une opération de suppression sur collage.</span><span class="sxs-lookup"><span data-stu-id="78d60-318">An alternative approach is to use a delete-on-paste operation.</span></span>

<span data-ttu-id="78d60-319">Avec une opération de suppression sur collage, les données sélectionnées ne sont pas immédiatement supprimées de la vue.</span><span class="sxs-lookup"><span data-stu-id="78d60-319">With a delete-on-paste operation, the selected data is not immediately removed from view.</span></span> <span data-ttu-id="78d60-320">Au lieu de cela, l’application source la marque comme étant sélectionnée, peut-être en modifiant la police ou la couleur d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="78d60-320">Instead, the source application marks it as selected, perhaps by changing the font or background color.</span></span> <span data-ttu-id="78d60-321">Une fois que l’application cible a collé les données, elle notifie la source du résultat de l’opération.</span><span class="sxs-lookup"><span data-stu-id="78d60-321">After the target application has pasted the data, it notifies the source about the outcome of the operation.</span></span> <span data-ttu-id="78d60-322">Si la cible a effectué un [déplacement optimisé](#handling-optimized-move-operations), la source peut simplement mettre à jour son affichage.</span><span class="sxs-lookup"><span data-stu-id="78d60-322">If the target performed an [optimized move](#handling-optimized-move-operations), the source can simply update its display.</span></span> <span data-ttu-id="78d60-323">Si la cible a effectué un déplacement normal, la source doit également supprimer sa copie des données.</span><span class="sxs-lookup"><span data-stu-id="78d60-323">If the target performed a normal move, the source must also delete its copy of the data.</span></span> <span data-ttu-id="78d60-324">Si le collage échoue, l’application source restaure les données sélectionnées à leur apparence d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-324">If the paste fails, the source application restores the selected data to its original appearance.</span></span>

> [!Note]  
> <span data-ttu-id="78d60-325">L’interpréteur de commandes utilise normalement delete-on-Paste lorsqu’une opération couper/coller est utilisée pour déplacer des fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-325">The Shell normally uses delete-on-paste when a cut/paste operation is used to move files.</span></span> <span data-ttu-id="78d60-326">Les opérations de suppression sur le collage avec des objets Shell utilisent normalement un [déplacement optimisé](#handling-optimized-move-operations) pour déplacer les fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-326">Delete-on-paste operations with Shell objects normally use an [optimized move](#handling-optimized-move-operations) to move the files.</span></span> <span data-ttu-id="78d60-327">Pour gérer correctement le transfert de données de Shell, votre application doit être en capacité de détecter et de gérer les opérations de suppression sur collage.</span><span class="sxs-lookup"><span data-stu-id="78d60-327">To handle Shell data transfer properly, your application must be capable of detecting and handling delete-on-paste operations.</span></span>

 

<span data-ttu-id="78d60-328">La condition essentielle pour la suppression sur le collage est que la cible doit signaler le résultat de l’opération à la source.</span><span class="sxs-lookup"><span data-stu-id="78d60-328">The essential requirement for delete-on-paste is that the target must report the outcome of the operation to the source.</span></span> <span data-ttu-id="78d60-329">Toutefois, les techniques du presse-papiers standard ne peuvent pas être utilisées pour implémenter delete-on-Paste, car elles ne permettent pas à la cible de communiquer avec la source.</span><span class="sxs-lookup"><span data-stu-id="78d60-329">However, standard Clipboard techniques cannot be used to implement delete-on-paste because they do not provide a way for the target to communicate with the source.</span></span> <span data-ttu-id="78d60-330">Au lieu de cela, l’application cible utilise la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) de l’objet de données pour signaler le résultat à l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-330">Instead, the target application uses the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method to report the outcome to the data object.</span></span> <span data-ttu-id="78d60-331">L’objet de données peut ensuite communiquer avec la source par le biais d’une interface privée.</span><span class="sxs-lookup"><span data-stu-id="78d60-331">The data object can then communicate with the source through a private interface.</span></span>

<span data-ttu-id="78d60-332">La procédure de base pour une opération de suppression sur le collage est la suivante :</span><span class="sxs-lookup"><span data-stu-id="78d60-332">The basic procedure for a delete-on-paste operation is as follows:</span></span>

1.  <span data-ttu-id="78d60-333">La source marque l’affichage de l’écran des données sélectionnées.</span><span class="sxs-lookup"><span data-stu-id="78d60-333">The source marks the screen display of the selected data.</span></span>
2.  <span data-ttu-id="78d60-334">La source crée un objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-334">The source creates a data object.</span></span> <span data-ttu-id="78d60-335">Elle indique une opération de coupe en ajoutant le format [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) avec la valeur de données DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-335">It indicates a cut operation by adding the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) format with a data value of DROPEFFECT\_MOVE.</span></span>
3.  <span data-ttu-id="78d60-336">La source place l’objet de données dans le presse-papiers à l’aide de [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span><span class="sxs-lookup"><span data-stu-id="78d60-336">The source places the data object on the Clipboard using [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).</span></span>
4.  <span data-ttu-id="78d60-337">La cible récupère l’objet de données du presse-papiers à l’aide de [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="78d60-337">The target retrieves the data object from the Clipboard using [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span>
5.  <span data-ttu-id="78d60-338">La cible extrait les données [CFSTR \_ PREFERREDDROPEFFECT](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-338">The target extracts the [CFSTR\_PREFERREDDROPEFFECT](clipboard.md) data.</span></span> <span data-ttu-id="78d60-339">S’il est défini sur DROPEFFECT \_ Move, la cible peut soit effectuer un déplacement optimisé, soit simplement copier les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-339">If it is set to only DROPEFFECT\_MOVE, the target can either do an optimized move or simply copy the data.</span></span>
6.  <span data-ttu-id="78d60-340">Si la cible n’effectue pas de déplacement optimisé, elle appelle la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) avec le format [CFSTR \_ PERFORMEDDROPEFFECT](clipboard.md) défini sur DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-340">If the target does not do an optimized move, it calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
7.  <span data-ttu-id="78d60-341">Une fois le collage terminé, la cible appelle la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) avec le format [CFSTR \_ PASTESUCCEEDED](clipboard.md) défini sur DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-341">When the paste is complete, the target calls the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span>
8.  <span data-ttu-id="78d60-342">Lorsque la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) de la source est appelée avec le format [CFSTR \_ PASTESUCCEEDED](clipboard.md) défini sur DROPEFFECT \_ Move, elle doit vérifier si elle a également reçu le [format \_ PERFORMEDDROPEFFECT CFSTR](clipboard.md) défini sur DROPEFFECT \_ Move.</span><span class="sxs-lookup"><span data-stu-id="78d60-342">When the source's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is called with the [CFSTR\_PASTESUCCEEDED](clipboard.md) format set to DROPEFFECT\_MOVE, it must check to see if it also received the [CFSTR\_PERFORMEDDROPEFFECT](clipboard.md) format set to DROPEFFECT\_MOVE.</span></span> <span data-ttu-id="78d60-343">Si les deux formats sont envoyés par la cible, la source devra supprimer les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-343">If both formats are sent by the target, the source will have to delete the data.</span></span> <span data-ttu-id="78d60-344">Si seul le format [CFSTR \_ PASTESUCCEEDED](clipboard.md) est reçu, la source peut simplement supprimer les données de son affichage.</span><span class="sxs-lookup"><span data-stu-id="78d60-344">If only the [CFSTR\_PASTESUCCEEDED](clipboard.md) format is received, the source can simply remove the data from its display.</span></span> <span data-ttu-id="78d60-345">Si le transfert échoue, la source met à jour l’affichage à son apparence d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-345">If the transfer fails, the source updates the display to its original appearance.</span></span>

## <a name="transfering-data-to-and-from-virtual-folders"></a><span data-ttu-id="78d60-346">Transfert de données vers et à partir de dossiers virtuels</span><span class="sxs-lookup"><span data-stu-id="78d60-346">Transfering Data to and from Virtual Folders</span></span>

<span data-ttu-id="78d60-347">**Scénario :** Un utilisateur fait glisser un objet à partir de ou le supprime dans un dossier virtuel.</span><span class="sxs-lookup"><span data-stu-id="78d60-347">**Scenario:** A user drags an object from or drops it on a virtual folder.</span></span>

<span data-ttu-id="78d60-348">Les dossiers virtuels contiennent des objets qui ne font généralement pas partie du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-348">Virtual folders contain objects that are generally not part of the file system.</span></span> <span data-ttu-id="78d60-349">Certains dossiers virtuels, tels que la corbeille, peuvent représenter des données stockées sur le disque dur, mais pas en tant qu’objets de système de fichiers ordinaires.</span><span class="sxs-lookup"><span data-stu-id="78d60-349">Some virtual folders, such as the Recycle Bin, can represent data that is stored on the hard disk but not as ordinary file system objects.</span></span> <span data-ttu-id="78d60-350">Certains peuvent représenter des données stockées qui se trouvent sur un système distant, tel qu’un ordinateur de poche, ou un site FTP.</span><span class="sxs-lookup"><span data-stu-id="78d60-350">Some can represent stored data that is on a remote system, such as a handheld PC, or an FTP site.</span></span> <span data-ttu-id="78d60-351">D’autres, tels que le dossier Imprimantes, contiennent des objets qui ne représentent pas du tout des données stockées.</span><span class="sxs-lookup"><span data-stu-id="78d60-351">Others, such as the Printers folder, contain objects that do not represent stored data at all.</span></span> <span data-ttu-id="78d60-352">Bien que certains dossiers virtuels fassent partie du système, les développeurs peuvent également créer et installer des dossiers virtuels personnalisés en implémentant une extension d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="78d60-352">While some virtual folders are part of the system, developers can also create and install custom virtual folders by implementing a namespace extension.</span></span>

<span data-ttu-id="78d60-353">Quel que soit le type de données ou la manière dont il est stocké, les objets de dossier et de fichier contenus dans un dossier virtuel sont présentés par le Shell comme s’il s’agissait de fichiers et de dossiers normaux.</span><span class="sxs-lookup"><span data-stu-id="78d60-353">Regardless of the type of data or how it is stored, the folder and file objects that are contained by a virtual folder are presented by the Shell as if they were normal files and folders.</span></span> <span data-ttu-id="78d60-354">Il incombe au dossier virtuel de prendre toutes les données qu’il contient et de le présenter correctement à l’interpréteur de commandes.</span><span class="sxs-lookup"><span data-stu-id="78d60-354">It is the responsibility of the virtual folder to take whatever data it contains and present it to the Shell appropriately.</span></span> <span data-ttu-id="78d60-355">Cette exigence signifie que les dossiers virtuels prennent normalement en charge le glisser-déplacer et les transferts de données du presse-papiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-355">This requirement means that virtual folders normally support drag-and-drop and Clipboard data transfers.</span></span>

<span data-ttu-id="78d60-356">Il y a donc deux groupes de développeurs qui doivent se préoccuper du transfert de données vers et à partir de dossiers virtuels :</span><span class="sxs-lookup"><span data-stu-id="78d60-356">There are thus two groups of developers who need to be concerned with data transfer to and from virtual folders:</span></span>

-   <span data-ttu-id="78d60-357">Les développeurs dont les applications ont besoin d’accepter des données transférées à partir d’un dossier virtuel.</span><span class="sxs-lookup"><span data-stu-id="78d60-357">Developers whose applications need to accept data that is transferred from a virtual folder.</span></span>
-   <span data-ttu-id="78d60-358">Les développeurs dont les extensions d’espace de noms doivent prendre en charge le transfert de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-358">Developers whose namespace extensions need to properly support data transfer.</span></span>

### <a name="accepting-data-from-a-virtual-folder"></a><span data-ttu-id="78d60-359">Acceptation de données à partir d’un dossier virtuel</span><span class="sxs-lookup"><span data-stu-id="78d60-359">Accepting Data from a Virtual Folder</span></span>

<span data-ttu-id="78d60-360">Les dossiers virtuels peuvent représenter pratiquement n’importe quel type de données et peuvent stocker ces données de la manière qu’ils choisissent.</span><span class="sxs-lookup"><span data-stu-id="78d60-360">Virtual folders can represent virtually any type of data and can store that data in any way they choose.</span></span> <span data-ttu-id="78d60-361">Certains dossiers virtuels peuvent en fait contenir des fichiers et dossiers de système de fichiers normaux.</span><span class="sxs-lookup"><span data-stu-id="78d60-361">Some virtual folders might actually contain normal file system files and folders.</span></span> <span data-ttu-id="78d60-362">D’autres peuvent, par exemple, empaqueter tous leurs objets dans un document ou une base de données unique.</span><span class="sxs-lookup"><span data-stu-id="78d60-362">Others might, for instance, pack all their objects into a single document or database.</span></span>

<span data-ttu-id="78d60-363">Lorsqu’un objet de système de fichiers est transféré à une application, l’objet de données contient normalement un format [CF \_ HDROP](clipboard.md) avec le chemin d’accès complet de l’objet.</span><span class="sxs-lookup"><span data-stu-id="78d60-363">When a file system object is transferred to an application, the data object normally contains a [CF\_HDROP](clipboard.md) format with the object's fully qualified path.</span></span> <span data-ttu-id="78d60-364">Votre application peut extraire cette chaîne et utiliser les fonctions normales du système de fichiers pour ouvrir le fichier et extraire ses données.</span><span class="sxs-lookup"><span data-stu-id="78d60-364">Your application can extract this string and use the normal file system functions to open the file and extract its data.</span></span> <span data-ttu-id="78d60-365">Toutefois, étant donné que les dossiers virtuels ne contiennent généralement pas d’objets de système de fichiers normaux, ils n’utilisent généralement pas [CF \_ HDROP](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="78d60-365">However, because virtual folders typically do not contain normal file system objects, they generally do not use [CF\_HDROP](clipboard.md).</span></span>

<span data-ttu-id="78d60-366">Au lieu de [CF \_ HDROP](clipboard.md), les données sont normalement transférées à partir de dossiers virtuels avec les formats [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-366">Instead of [CF\_HDROP](clipboard.md), data is normally transferred from virtual folders with the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="78d60-367">Le format [CFSTR \_ FILECONTENTS](clipboard.md) présente deux avantages par rapport à [CF \_ HDROP](clipboard.md):</span><span class="sxs-lookup"><span data-stu-id="78d60-367">The [CFSTR\_FILECONTENTS](clipboard.md) format has two advantages over [CF\_HDROP](clipboard.md):</span></span>

-   <span data-ttu-id="78d60-368">Aucune méthode particulière n’est utilisée pour le stockage des données.</span><span class="sxs-lookup"><span data-stu-id="78d60-368">No particular method of data storage is assumed.</span></span>
-   <span data-ttu-id="78d60-369">Le format est plus souple.</span><span class="sxs-lookup"><span data-stu-id="78d60-369">The format is more flexible.</span></span> <span data-ttu-id="78d60-370">Il prend en charge trois mécanismes de transfert de données : un objet de mémoire globale, une interface [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) ou une interface [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="78d60-370">It supports three data transfer mechanisms: a global memory object, an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface, or an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="78d60-371">Les objets mémoire globaux sont rarement utilisés pour transférer des données vers ou depuis des objets virtuels, car les données doivent être copiées en mémoire dans leur intégralité.</span><span class="sxs-lookup"><span data-stu-id="78d60-371">Global memory objects are rarely used to transfer data to or from virtual objects because the data must be copied into memory in its entirety.</span></span> <span data-ttu-id="78d60-372">Le transfert d’un pointeur d’interface ne nécessite pratiquement aucune mémoire et est beaucoup plus efficace.</span><span class="sxs-lookup"><span data-stu-id="78d60-372">Transferring an interface pointer requires almost no memory and is much more efficient.</span></span> <span data-ttu-id="78d60-373">Avec des fichiers très volumineux, un pointeur d’interface peut être le seul mécanisme pratique de transfert de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-373">With very large files, an interface pointer might be the only practical data transfer mechanism.</span></span> <span data-ttu-id="78d60-374">En général, les données sont représentées par un pointeur [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) , car cette interface est un peu plus flexible que [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span><span class="sxs-lookup"><span data-stu-id="78d60-374">Typically, data is represented by an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) pointer, because that interface is somewhat more flexible than [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).</span></span> <span data-ttu-id="78d60-375">La cible extrait le pointeur de l’objet de données et utilise les méthodes d’interface pour extraire les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-375">The target extracts the pointer from the data object and uses the interface methods to extract the data.</span></span>

<span data-ttu-id="78d60-376">Pour plus d’informations sur la gestion des formats [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ filecontents](clipboard.md) , consultez [utilisation du \_ format CFSTR filecontents pour extraire des données d’un fichier](/windows).</span><span class="sxs-lookup"><span data-stu-id="78d60-376">For further discussion of how to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats, see [Using the CFSTR\_FILECONTENTS Format to Extract Data from a File](/windows).</span></span>

### <a name="transferring-data-to-and-from-a-namespace-extension"></a><span data-ttu-id="78d60-377">Transfert de données vers et à partir d’une extension d’espace de noms</span><span class="sxs-lookup"><span data-stu-id="78d60-377">Transferring Data to and from a NameSpace Extension</span></span>

<span data-ttu-id="78d60-378">Lorsque vous implémentez une extension d’espace de noms, vous devez normalement prendre en charge les fonctionnalités de glisser-déplacer.</span><span class="sxs-lookup"><span data-stu-id="78d60-378">When you implement a namespace extension, you will normally want to support drag-and-drop capabilities.</span></span> <span data-ttu-id="78d60-379">Suivez les recommandations relatives aux sources de dépôt et aux cibles présentées dans [instructions générales](#general-guidelines).</span><span class="sxs-lookup"><span data-stu-id="78d60-379">Follow the recommendations for drop sources and targets discussed in [General Guidelines](#general-guidelines).</span></span> <span data-ttu-id="78d60-380">En particulier, une extension d’espace de noms doit :</span><span class="sxs-lookup"><span data-stu-id="78d60-380">In particular, a namespace extension must:</span></span>

-   <span data-ttu-id="78d60-381">Être en mesure de gérer les formats [CFSTR \_ FILEDESCRIPTOR](clipboard.md) / [CFSTR \_ FILECONTENTS](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-381">Be able to handle the [CFSTR\_FILEDESCRIPTOR](clipboard.md)/[CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span> <span data-ttu-id="78d60-382">Ces deux formats sont généralement utilisés pour transférer des objets vers et à partir d’extensions d’espace de noms.</span><span class="sxs-lookup"><span data-stu-id="78d60-382">These two formats are normally used to transfer objects to and from namespace extensions.</span></span>
-   <span data-ttu-id="78d60-383">Pouvoir gérer les [déplacements optimisés](#handling-optimized-move-operations).</span><span class="sxs-lookup"><span data-stu-id="78d60-383">Be able to handle [optimized moves](#handling-optimized-move-operations).</span></span> <span data-ttu-id="78d60-384">L’interpréteur de commandes s’attend à ce que les objets Shell soient déplacés avec un déplacement optimisé.</span><span class="sxs-lookup"><span data-stu-id="78d60-384">The Shell expects that Shell objects will be moved with an optimized move.</span></span>
-   <span data-ttu-id="78d60-385">Pouvoir gérer une opération [de suppression sur collage](#handling-delete-on-paste-operations) .</span><span class="sxs-lookup"><span data-stu-id="78d60-385">Be able to handle a [delete-on-paste](#handling-delete-on-paste-operations) operation.</span></span> <span data-ttu-id="78d60-386">L’interpréteur de commandes utilise l’opération de suppression sur collage lorsque des objets sont déplacés de l’interpréteur de commandes à l’aide d’une opération couper/coller.</span><span class="sxs-lookup"><span data-stu-id="78d60-386">The Shell uses delete-on-paste when objects are moved from the Shell with a cut/paste operation.</span></span>
-   <span data-ttu-id="78d60-387">Pouvoir gérer le transfert de données via une interface [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) ou [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="78d60-387">Be able to handle data transfer through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="78d60-388">Le transfert de données vers ou à partir d’un dossier virtuel est normalement géré par le transfert de l’un de ces deux pointeurs d’interface, généralement un pointeur **IStream** .</span><span class="sxs-lookup"><span data-stu-id="78d60-388">Data transfer to or from a virtual folder is normally handled by transferring one of these two interface pointers, typically an **IStream** pointer.</span></span> <span data-ttu-id="78d60-389">La cible appelle ensuite les méthodes d’interface pour extraire les données :</span><span class="sxs-lookup"><span data-stu-id="78d60-389">The target then calls the interface methods to extract the data:</span></span>
    -   -   <span data-ttu-id="78d60-390">En tant que source de déplacement, l’extension de l’espace de noms doit extraire les données du stockage et les transmettre à la cible via cette interface.</span><span class="sxs-lookup"><span data-stu-id="78d60-390">As a drop source, the namespace extension must extract the data from storage and pass it through this interface to the target.</span></span>
        -   <span data-ttu-id="78d60-391">En tant que cible de déplacement, une extension d’espace de noms doit accepter les données provenant d’une source via cette interface et les stocker correctement.</span><span class="sxs-lookup"><span data-stu-id="78d60-391">As a drop target, a namespace extension must accept data from a source through this interface and store it properly.</span></span>

## <a name="dropping-files-on-the-recycle-bin"></a><span data-ttu-id="78d60-392">Suppression de fichiers dans la corbeille</span><span class="sxs-lookup"><span data-stu-id="78d60-392">Dropping Files on the Recycle Bin</span></span>

<span data-ttu-id="78d60-393">**Scénario :** L’utilisateur dépose un fichier dans la **Corbeille**.</span><span class="sxs-lookup"><span data-stu-id="78d60-393">**Scenario:** The user drops a file on the **Recycle Bin**.</span></span> <span data-ttu-id="78d60-394">Votre application ou extension d’espace de noms supprime le fichier d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-394">Your application or namespace extension deletes the original file.</span></span>

<span data-ttu-id="78d60-395">La corbeille est un dossier virtuel qui est utilisé comme référentiel pour les fichiers qui ne sont plus nécessaires.</span><span class="sxs-lookup"><span data-stu-id="78d60-395">The Recycle Bin is a virtual folder that is used as a repository for files that are no longer needed.</span></span> <span data-ttu-id="78d60-396">Tant que la Corbeille n’a pas été vidée, l’utilisateur peut récupérer ultérieurement le fichier et le renvoyer au système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-396">As long as the Recycle Bin has not been emptied, the user can later recover the file and return it to the file system.</span></span>

<span data-ttu-id="78d60-397">Dans la plupart des cas, le transfert d’objets Shell à la corbeille fonctionne comme n’importe quel autre dossier.</span><span class="sxs-lookup"><span data-stu-id="78d60-397">For the most part, transferring Shell objects to the Recycle Bin works much like any other folder.</span></span> <span data-ttu-id="78d60-398">Toutefois, lorsqu’un utilisateur dépose un fichier sur la **Corbeille**, la source doit supprimer l’original, même si les commentaires du dossier indiquent une opération de copie.</span><span class="sxs-lookup"><span data-stu-id="78d60-398">However, when a user drops a file on the **Recycle Bin**, the source needs to delete the original, even if the feedback from the folder indicates a copy operation.</span></span> <span data-ttu-id="78d60-399">Normalement, une source de déplacement n’a aucun moyen de savoir dans quel dossier son objet de données a été déposé.</span><span class="sxs-lookup"><span data-stu-id="78d60-399">Normally, a drop source has no way of knowing which folder its data object has been dropped on.</span></span> <span data-ttu-id="78d60-400">Toutefois, pour les systèmes Windows 2000 et versions ultérieures, lorsqu’un objet de données est déposé sur la **Corbeille**, l’interpréteur de commandes appelle la méthode [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) de l’objet de données avec un format [CFSTR \_ TARGETCLSID](clipboard.md) défini sur l’identificateur de classe (CLSID) de la Corbeille (CLSID \_ RecycleBin).</span><span class="sxs-lookup"><span data-stu-id="78d60-400">However, for Windows 2000 and later systems, when a data object is dropped on the **Recycle Bin**, the Shell will call the data object's [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method with a [CFSTR\_TARGETCLSID](clipboard.md) format set to the Recycle Bin's class identifier (CLSID) (CLSID\_RecycleBin).</span></span> <span data-ttu-id="78d60-401">Pour gérer correctement le cas de la corbeille, votre objet de données doit être en mesure de reconnaître ce format et de communiquer les informations à la source par le biais d’une interface privée.</span><span class="sxs-lookup"><span data-stu-id="78d60-401">To handle the Recycle Bin case properly, your data object should be able to recognize this format and communicate the information to the source through a private interface.</span></span>

> [!Note]  
> <span data-ttu-id="78d60-402">Quand [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) est appelé avec un format [CFSTR \_ TARGETCLSID](clipboard.md) défini sur CLSID \_ RecycleBin, la source de données doit fermer tous les descripteurs ouverts aux objets qui sont transférés avant de retourner à partir de la méthode.</span><span class="sxs-lookup"><span data-stu-id="78d60-402">When [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) is called with a [CFSTR\_TARGETCLSID](clipboard.md) format set to CLSID\_RecycleBin, the data source should close any open handles to the objects that are being transferred before returning from the method.</span></span> <span data-ttu-id="78d60-403">Dans le cas contraire, vous risquez de créer des violations de partage.</span><span class="sxs-lookup"><span data-stu-id="78d60-403">Otherwise, you might create sharing violations.</span></span>

 

## <a name="creating-and-importing-scrap-files"></a><span data-ttu-id="78d60-404">Création et importation de fichiers bribes</span><span class="sxs-lookup"><span data-stu-id="78d60-404">Creating and Importing Scrap Files</span></span>

<span data-ttu-id="78d60-405">**Scénario :** Un utilisateur fait glisser des données à partir d’un fichier de données de l’application OLE et le dépose sur le bureau ou l’Explorateur Windows.</span><span class="sxs-lookup"><span data-stu-id="78d60-405">**Scenario:** A user drags some data from an OLE application's data file and drops it on the desktop or Windows Explorer.</span></span>

<span data-ttu-id="78d60-406">Windows permet aux utilisateurs de faire glisser un objet à partir d’un fichier de données d’une application OLE et de le déposer sur le bureau ou sur un dossier du système de fichiers.</span><span class="sxs-lookup"><span data-stu-id="78d60-406">Windows allows users to drag an object from an OLE application's data file and drop it on the desktop or a file system folder.</span></span> <span data-ttu-id="78d60-407">Cette opération crée un *fichier bribe*, qui contient les données ou un lien vers les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-407">This operation creates a *scrap file*, which contains the data or a link to the data.</span></span> <span data-ttu-id="78d60-408">Le nom de fichier est extrait du nom abrégé inscrit pour le CLSID de l’objet et des données de [ \_ texte CF](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="78d60-408">The file name is taken from the short name registered for the CLSID of the object and the [CF\_TEXT](clipboard.md) data.</span></span> <span data-ttu-id="78d60-409">Pour que l’interpréteur de commandes crée un fichier bribe contenant des données, l’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) de l’application doit prendre en charge le \_ format de presse-papiers CF EMBEDSOURCE.</span><span class="sxs-lookup"><span data-stu-id="78d60-409">For the Shell to create a scrap file containing data, the application's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface must support the CF\_EMBEDSOURCE Clipboard format.</span></span> <span data-ttu-id="78d60-410">Pour créer un fichier contenant un lien, **IDataObject** doit prendre en charge le \_ format CF LINKSOURCE.</span><span class="sxs-lookup"><span data-stu-id="78d60-410">To create a file containing a link, **IDataObject** must support the CF\_LINKSOURCE format.</span></span>

<span data-ttu-id="78d60-411">Il existe également trois fonctionnalités facultatives qu’une application peut implémenter pour prendre en charge les fichiers bribes :</span><span class="sxs-lookup"><span data-stu-id="78d60-411">There are also three optional features that an application can implement to support scrap files:</span></span>

-   <span data-ttu-id="78d60-412">Prise en charge des allers-retours</span><span class="sxs-lookup"><span data-stu-id="78d60-412">Round-trip support</span></span>
-   <span data-ttu-id="78d60-413">Formats de données mis en cache</span><span class="sxs-lookup"><span data-stu-id="78d60-413">Cached data formats</span></span>
-   <span data-ttu-id="78d60-414">Rendu différé</span><span class="sxs-lookup"><span data-stu-id="78d60-414">Delayed rendering</span></span>

### <a name="round-trip-support"></a><span data-ttu-id="78d60-415">Prise en charge des allers-retours</span><span class="sxs-lookup"><span data-stu-id="78d60-415">Round-trip Support</span></span>

<span data-ttu-id="78d60-416">Un aller- *retour* implique le transfert d’un objet de données vers un autre conteneur, puis vers le document d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-416">A *round trip* involves transferring a data object to another container and then back to the original document.</span></span> <span data-ttu-id="78d60-417">Par exemple, un utilisateur peut transférer un groupe de cellules d’une feuille de calcul vers le bureau, en créant un fichier bribe contenant les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-417">For instance, a user could transfer a group of cells from a spreadsheet to the desktop, creating a scrap file with the data.</span></span> <span data-ttu-id="78d60-418">Si l’utilisateur transfère ensuite le rebut à la feuille de calcul, les données doivent être intégrées dans le document tel qu’il était avant le transfert d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-418">If the user then transfers the scrap back to the spreadsheet, the data needs to be integrated into the document as it was before the original transfer.</span></span>

<span data-ttu-id="78d60-419">Lorsque l’interpréteur de commandes crée le fichier bribe, il représente les données sous la forme d’un objet incorporé.</span><span class="sxs-lookup"><span data-stu-id="78d60-419">When the Shell creates the scrap file, it represents the data as an embedding object.</span></span> <span data-ttu-id="78d60-420">Lorsque le rebut est transféré vers un autre conteneur, il est transféré en tant qu’objet incorporé, même s’il est retourné au document d’origine.</span><span class="sxs-lookup"><span data-stu-id="78d60-420">When the scrap is transferred to another container, it is transferred as an embedding object, even if it is being returned to the original document.</span></span> <span data-ttu-id="78d60-421">Votre application est chargée de déterminer le format de données contenu dans le rebut et de replacer les données dans son format natif, si nécessaire.</span><span class="sxs-lookup"><span data-stu-id="78d60-421">Your application is responsible for determining the data format contained in the scrap and putting the data back into its native format if necessary.</span></span>

<span data-ttu-id="78d60-422">Pour définir le format de l’objet incorporé, déterminez son CLSID en extrayant le format CF OBJECTDESCRIPTOR de l’objet \_ .</span><span class="sxs-lookup"><span data-stu-id="78d60-422">To establish the format of the embedded object, determine its CLSID by retrieving the object's CF\_OBJECTDESCRIPTOR format.</span></span> <span data-ttu-id="78d60-423">Si le CLSID indique un format de données qui appartient à l’application, il doit transférer les données natives au lieu d’appeler [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span><span class="sxs-lookup"><span data-stu-id="78d60-423">If the CLSID indicates a data format that belongs to the application, it should transfer the native data instead of calling [**OleCreateFromData**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).</span></span>

### <a name="cached-data-formats"></a><span data-ttu-id="78d60-424">Formats de données mis en cache</span><span class="sxs-lookup"><span data-stu-id="78d60-424">Cached Data Formats</span></span>

<span data-ttu-id="78d60-425">Lorsque l’interpréteur de commandes crée un fichier bribe, il vérifie la liste des formats disponibles dans le registre.</span><span class="sxs-lookup"><span data-stu-id="78d60-425">When the Shell creates a scrap file, it checks the registry for the list of available formats.</span></span> <span data-ttu-id="78d60-426">Par défaut, deux formats sont disponibles : CF \_ EMBEDSOURCE et CF \_ LINKSOURCE.</span><span class="sxs-lookup"><span data-stu-id="78d60-426">By default, there are two formats available: CF\_EMBEDSOURCE and CF\_LINKSOURCE.</span></span> <span data-ttu-id="78d60-427">Toutefois, il existe plusieurs scénarios dans lesquels les applications peuvent avoir besoin de fichiers bribes dans différents formats :</span><span class="sxs-lookup"><span data-stu-id="78d60-427">However, there are a number of scenarios where applications might need to have scrap files in different formats:</span></span>

-   <span data-ttu-id="78d60-428">Pour autoriser le transfert de bribes vers des conteneurs non-OLE, qui ne peuvent pas accepter des formats d’objet incorporés.</span><span class="sxs-lookup"><span data-stu-id="78d60-428">To allow scraps to be transferred to non-OLE containers, which cannot accepted embedded object formats.</span></span>
-   <span data-ttu-id="78d60-429">Pour permettre aux suites d’applications de communiquer avec un format privé.</span><span class="sxs-lookup"><span data-stu-id="78d60-429">To allow suites of applications to communicate with a private format.</span></span>
-   <span data-ttu-id="78d60-430">Pour faciliter le traitement des allers-retours.</span><span class="sxs-lookup"><span data-stu-id="78d60-430">To make round trips easier to handle.</span></span>

<span data-ttu-id="78d60-431">Les applications peuvent ajouter des formats au rebut en les mettant en cache dans le registre.</span><span class="sxs-lookup"><span data-stu-id="78d60-431">Applications can add formats to the scrap by caching them in the registry.</span></span> <span data-ttu-id="78d60-432">Il existe deux types de formats mis en cache :</span><span class="sxs-lookup"><span data-stu-id="78d60-432">There are two types of cached formats:</span></span>

-   <span data-ttu-id="78d60-433">Formats de cache de priorité.</span><span class="sxs-lookup"><span data-stu-id="78d60-433">Priority cache formats.</span></span> <span data-ttu-id="78d60-434">Pour ces formats, les données sont copiées dans leur intégralité dans le rebut à partir de l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-434">For these formats, the data is copied in its entirety into the scrap from the data object.</span></span>
-   <span data-ttu-id="78d60-435">Formats avec rendu différé.</span><span class="sxs-lookup"><span data-stu-id="78d60-435">Delay-rendered formats.</span></span> <span data-ttu-id="78d60-436">Pour ces formats, l’objet de données n’est pas copié dans le rebut.</span><span class="sxs-lookup"><span data-stu-id="78d60-436">For these formats, the data object is not copied to the scrap.</span></span> <span data-ttu-id="78d60-437">Au lieu de cela, le rendu est retardé jusqu’à ce qu’une cible demande les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-437">Instead, rendering is delayed until a target requests the data.</span></span> <span data-ttu-id="78d60-438">Le rendu différé est abordé plus en détail dans la section suivante.</span><span class="sxs-lookup"><span data-stu-id="78d60-438">Delay-rendering is discussed in more detail in the next section.</span></span>

<span data-ttu-id="78d60-439">Pour ajouter un format de cache prioritaire ou de rendu différé, créez une sous-clé **DataFormat** sous la clé **CLSID** de l’application qui est la source des données.</span><span class="sxs-lookup"><span data-stu-id="78d60-439">To add a priority cache or delay-rendered format, create a **DataFormat** subkey under the **CLSID** key of the application that is the source of the data.</span></span> <span data-ttu-id="78d60-440">Sous cette sous-clé, créez une sous-clé **PriorityCacheFormats** ou **DelayRenderFormats** .</span><span class="sxs-lookup"><span data-stu-id="78d60-440">Under that subkey, create a **PriorityCacheFormats** or **DelayRenderFormats** subkey.</span></span> <span data-ttu-id="78d60-441">Pour chaque format de cache prioritaire ou de rendu différé, créez une sous-clé numérotée commençant par zéro.</span><span class="sxs-lookup"><span data-stu-id="78d60-441">For each priority cache or delay-rendered format, create a numbered subkey starting with zero.</span></span> <span data-ttu-id="78d60-442">Définissez la valeur de cette clé sur une chaîne avec le nom enregistré du format ou une \# valeur x, où X représente le numéro de format d’un format de presse-papiers standard.</span><span class="sxs-lookup"><span data-stu-id="78d60-442">Set the value of this key to either a string with the registered name of the format or a \#X value, where X represents the format number of a standard Clipboard format.</span></span>

<span data-ttu-id="78d60-443">L’exemple suivant montre des formats mis en cache pour deux applications.</span><span class="sxs-lookup"><span data-stu-id="78d60-443">The following sample shows cached formats for two applications.</span></span> <span data-ttu-id="78d60-444">L’application MyProg1 a le format de texte enrichi comme format de cache de priorité et un format privé « mon format » comme format de rendu différé.</span><span class="sxs-lookup"><span data-stu-id="78d60-444">The MyProg1 application has the rich-text format as a priority cache format, and a private format "My Format" as a delay-rendered format.</span></span> <span data-ttu-id="78d60-445">L’application MyProg2 a le \_ format de bitmap CF ( \# 8 ") comme format de cache de priorité.</span><span class="sxs-lookup"><span data-stu-id="78d60-445">The MyProg2 application has the CF\_BITMAP format (\#8") as a priority cache format.</span></span>

```
HKEY_CLASSES_ROOT
   CLSID
      {GUID}
         (Default) = MyProg1
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = Rich Text Format
            DelayRenderFormats
               0
                  (Default) = My Format
      {GUID}
         (Default) = MyProg2
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = #8
```

<span data-ttu-id="78d60-446">Vous pouvez ajouter des formats supplémentaires en créant des sous-clés numérotées supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="78d60-446">Additional formats can be added by creating additional numbered subkeys.</span></span>

### <a name="delayed-rendering"></a><span data-ttu-id="78d60-447">Rendu différé</span><span class="sxs-lookup"><span data-stu-id="78d60-447">Delayed Rendering</span></span>

<span data-ttu-id="78d60-448">Un format de rendu différé permet à une application de créer un fichier bribe, mais retarder le coût de rendu des données jusqu’à ce qu’elles soient demandées par une cible.</span><span class="sxs-lookup"><span data-stu-id="78d60-448">A delayed rendering format allows an application to create a scrap file but delay the expense of rendering the data until it is requested by a target.</span></span> <span data-ttu-id="78d60-449">L’interface [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) d’un rebut offre des formats de rendu différés à la cible, ainsi que des données natives et mises en cache.</span><span class="sxs-lookup"><span data-stu-id="78d60-449">The [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface of a scrap will offer the delayed rendering formats to the target along with native and cached data.</span></span> <span data-ttu-id="78d60-450">Si la cible demande un format de rendu retardé, le Shell exécute l’application et fournit les données à la cible à partir de l’objet actif.</span><span class="sxs-lookup"><span data-stu-id="78d60-450">If the target requests a delayed rendering format, the Shell will run the application and provide the data to the target from the active object.</span></span>

> [!Note]  
> <span data-ttu-id="78d60-451">Étant donné que le rendu différé est un peu risqué, il doit être utilisé avec précaution.</span><span class="sxs-lookup"><span data-stu-id="78d60-451">Because delayed rendering is somewhat risky, it should be used with caution.</span></span> <span data-ttu-id="78d60-452">Elle ne fonctionnera pas si le serveur n’est pas disponible ou sur des applications qui ne sont pas compatibles OLE.</span><span class="sxs-lookup"><span data-stu-id="78d60-452">It will not work if the server is not available, or on applications that are not OLE-enabled.</span></span>

 

## <a name="dragging-and-dropping-shell-objects-asynchronously"></a><span data-ttu-id="78d60-453">Glisser-déplacer des objets Shell de manière asynchrone</span><span class="sxs-lookup"><span data-stu-id="78d60-453">Dragging and Dropping Shell Objects Asynchronously</span></span>

<span data-ttu-id="78d60-454">**Scénario :** Un utilisateur transfère un grand bloc de données de la source vers la cible.</span><span class="sxs-lookup"><span data-stu-id="78d60-454">**Scenario:** A user transfers a large block of data from source to target.</span></span> <span data-ttu-id="78d60-455">Pour éviter de bloquer les deux applications pendant un laps de temps significatif, la cible extrait les données de manière asynchrone.</span><span class="sxs-lookup"><span data-stu-id="78d60-455">To avoid blocking both applications for a significant amount of time, the target extracts the data asynchronously.</span></span>

<span data-ttu-id="78d60-456">Normalement, le glisser-déplacer est une opération synchrone.</span><span class="sxs-lookup"><span data-stu-id="78d60-456">Normally, drag-and-drop is a synchronous operation.</span></span> <span data-ttu-id="78d60-457">En bref :</span><span class="sxs-lookup"><span data-stu-id="78d60-457">In brief:</span></span>

1.  <span data-ttu-id="78d60-458">La source de déplacement appelle [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) et bloque son thread principal jusqu’à ce que la fonction retourne.</span><span class="sxs-lookup"><span data-stu-id="78d60-458">The drop source calls [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) and blocks its primary thread until the function returns.</span></span> <span data-ttu-id="78d60-459">Le blocage du thread principal bloque normalement le traitement de l’interface utilisateur.</span><span class="sxs-lookup"><span data-stu-id="78d60-459">Blocking the primary thread normally blocks UI processing.</span></span>
2.  <span data-ttu-id="78d60-460">Après l’appel de la méthode [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) de la cible, la cible extrait les données de l’objet de données sur son thread principal.</span><span class="sxs-lookup"><span data-stu-id="78d60-460">After the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method is called, the target extracts the data from the data object on its primary thread.</span></span> <span data-ttu-id="78d60-461">Cette procédure bloque normalement le traitement de l’interface utilisateur de la cible pendant la durée du processus d’extraction.</span><span class="sxs-lookup"><span data-stu-id="78d60-461">This procedure normally blocks the target's UI processing for the duration of the extraction process.</span></span>
3.  <span data-ttu-id="78d60-462">Une fois que les données ont été extraites, la cible retourne l’appel d' [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , le système retourne [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop)et les deux threads peuvent continuer.</span><span class="sxs-lookup"><span data-stu-id="78d60-462">Once the data has been extracted, the target returns the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, the system returns [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), and both threads can proceed.</span></span>

<span data-ttu-id="78d60-463">En bref, le transfert de données synchrones peut bloquer les threads principaux des deux applications pendant un laps de temps significatif.</span><span class="sxs-lookup"><span data-stu-id="78d60-463">In short, synchronous data transfer can block the primary threads of both applications for a significant amount of time.</span></span> <span data-ttu-id="78d60-464">En particulier, les deux threads doivent attendre que la cible extraie les données.</span><span class="sxs-lookup"><span data-stu-id="78d60-464">In particular, both threads must wait while the target extracts the data.</span></span> <span data-ttu-id="78d60-465">Pour les petites quantités de données, le temps nécessaire à l’extraction des données est faible et les transferts de données synchrones fonctionnent très bien.</span><span class="sxs-lookup"><span data-stu-id="78d60-465">For small amounts of data, the time required to extract data is small and synchronous data transfer works quite well.</span></span> <span data-ttu-id="78d60-466">Toutefois, l’extraction synchrone de grandes quantités de données peut entraîner des retards de longue durée et perturber l’interface utilisateur de la cible et de la source.</span><span class="sxs-lookup"><span data-stu-id="78d60-466">However, synchronously extracting large amounts of data can cause lengthy delays and interfere with the UI of both target and source.</span></span>

<span data-ttu-id="78d60-467">L’interface [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) est une interface facultative qui peut être implémentée par un objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-467">The [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface is an optional interface that can be implemented by a data object.</span></span> <span data-ttu-id="78d60-468">Elle donne à la cible de déplacement la possibilité d’extraire des données de l’objet de données de façon asynchrone sur un thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="78d60-468">It gives the drop target the ability to extract data from the data object asynchronously on a background thread.</span></span> <span data-ttu-id="78d60-469">Une fois que l’extraction de données est transremise au thread d’arrière-plan, les threads principaux des deux applications sont libres de continuer.</span><span class="sxs-lookup"><span data-stu-id="78d60-469">Once data extraction is handed off to the background thread, the primary threads of both applications are free to proceed.</span></span>

### <a name="using-iasyncoperationidataobjectasynccapability"></a><span data-ttu-id="78d60-470">Utilisation de IASyncOperation/IDataObjectAsyncCapability</span><span class="sxs-lookup"><span data-stu-id="78d60-470">Using IASyncOperation/IDataObjectAsyncCapability</span></span>

> [!Note]  
> <span data-ttu-id="78d60-471">L’interface a été initialement nommée [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), mais elle a été remplacée par la valeur [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="78d60-471">The interface was originally named [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), but this was later changed to [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span> <span data-ttu-id="78d60-472">Dans le cas contraire, les deux interfaces sont identiques.</span><span class="sxs-lookup"><span data-stu-id="78d60-472">Otherwise, the two interfaces are identical.</span></span>

 

<span data-ttu-id="78d60-473">L’objectif de [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) est d’autoriser la source de déplacement et la cible de dépôt à négocier si les données peuvent être extraites de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="78d60-473">The purpose of [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) is to allow the drop source and drop target to negotiate whether data can be extracted asynchronously.</span></span> <span data-ttu-id="78d60-474">La procédure suivante décrit comment la source de déplacement utilise l’interface :</span><span class="sxs-lookup"><span data-stu-id="78d60-474">The following procedure outlines how the drop source uses the interface:</span></span>

1.  <span data-ttu-id="78d60-475">Créez un objet de données qui expose [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span><span class="sxs-lookup"><span data-stu-id="78d60-475">Create a data object that exposes [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).</span></span>
2.  <span data-ttu-id="78d60-476">Appelez [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) avec *FDoOpAsync* défini sur **Variant \_ true** pour indiquer qu’une opération asynchrone est prise en charge.</span><span class="sxs-lookup"><span data-stu-id="78d60-476">Call [**SetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) with *fDoOpAsync* set to **VARIANT\_TRUE** to indicate that an asynchronous operation is supported.</span></span>
3.  <span data-ttu-id="78d60-477">Après le retour de [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) , appelez [**INOPÉRATION**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span><span class="sxs-lookup"><span data-stu-id="78d60-477">After [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) returns, call [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation):</span></span>
    -   <span data-ttu-id="78d60-478">En cas d’échec de l' [**opération**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) ou de renvoi de la **\_ valeur false**, un transfert de données synchrone normal a eu lieu et le processus d’extraction des données est terminé.</span><span class="sxs-lookup"><span data-stu-id="78d60-478">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) fails or returns **VARIANT\_FALSE**, a normal synchronous data transfer has taken place and the data extraction process is finished.</span></span> <span data-ttu-id="78d60-479">La source doit effectuer tout nettoyage requis et continuer.</span><span class="sxs-lookup"><span data-stu-id="78d60-479">The source should do any cleanup that is required, and proceed.</span></span>
    -   <span data-ttu-id="78d60-480">Si [**inaction**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) retourne **la \_ valeur true**, les données sont extraites de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="78d60-480">If [**InOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) returns **VARIANT\_TRUE**, the data is being extracted asynchronously.</span></span> <span data-ttu-id="78d60-481">Les opérations de nettoyage doivent être gérées par [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="78d60-481">Cleanup operations should be handled by [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>
4.  <span data-ttu-id="78d60-482">Libère l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-482">Release the data object.</span></span>
5.  <span data-ttu-id="78d60-483">Lorsque le transfert de données asynchrone est terminé, l’objet de données avertit normalement la source par le biais d’une interface privée.</span><span class="sxs-lookup"><span data-stu-id="78d60-483">When the asynchronous data transfer is complete, the data object normally notifies the source through a private interface.</span></span>

<span data-ttu-id="78d60-484">La procédure suivante décrit comment la cible de déplacement utilise l’interface [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) pour extraire des données de façon asynchrone :</span><span class="sxs-lookup"><span data-stu-id="78d60-484">The following procedure outlines how the drop target uses the [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface to extract data asynchronously:</span></span>

1.  <span data-ttu-id="78d60-485">Lorsque le système appelle [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), appelez [**IDataObject :: QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) et demandez une interface [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) (IID \_ IAsyncOperation/IID \_ IDataObjectAsyncCapability) à partir de l’objet de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-485">When the system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), call [**IDataObject::QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) and request an [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85))/[**IDataObjectAsyncCapability**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) interface (IID\_IAsyncOperation/IID\_IDataObjectAsyncCapability) from the data object.</span></span>
2.  <span data-ttu-id="78d60-486">Appelez [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span><span class="sxs-lookup"><span data-stu-id="78d60-486">Call [**GetAsyncMode**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode).</span></span> <span data-ttu-id="78d60-487">Si la méthode retourne **la \_ valeur variant true**, l’objet de données prend en charge l’extraction de données asynchrone.</span><span class="sxs-lookup"><span data-stu-id="78d60-487">If the method returns **VARIANT\_TRUE**, the data object supports asynchronous data extraction.</span></span>
3.  <span data-ttu-id="78d60-488">Créez un thread distinct pour gérer l’extraction de données et appelez [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span><span class="sxs-lookup"><span data-stu-id="78d60-488">Create a separate thread to handle data extraction and call [**StartOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).</span></span>
4.  <span data-ttu-id="78d60-489">Retournez l’appel de la fonction [**IDropTarget ::D ROP**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , comme vous le feriez pour une opération normale de transfert de données.</span><span class="sxs-lookup"><span data-stu-id="78d60-489">Return the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) call, as you would for a normal data transfer operation.</span></span> <span data-ttu-id="78d60-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) renverra et débloquera la source de dépôt.</span><span class="sxs-lookup"><span data-stu-id="78d60-490">[**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) will return and unblock the drop source.</span></span> <span data-ttu-id="78d60-491">N’appelez pas [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) pour indiquer le résultat d’une opération de déplacement ou de suppression sur collage optimisée.</span><span class="sxs-lookup"><span data-stu-id="78d60-491">Do not call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome of an optimized move or delete-on-paste operation.</span></span> <span data-ttu-id="78d60-492">Attendez que l’opération soit terminée.</span><span class="sxs-lookup"><span data-stu-id="78d60-492">Wait until the operation is finished.</span></span>
5.  <span data-ttu-id="78d60-493">Extrayez les données sur le thread d’arrière-plan.</span><span class="sxs-lookup"><span data-stu-id="78d60-493">Extract the data on the background thread.</span></span> <span data-ttu-id="78d60-494">Le thread principal de la cible est débloqué et gratuit pour continuer.</span><span class="sxs-lookup"><span data-stu-id="78d60-494">The target's primary thread is unblocked and free to proceed.</span></span>
6.  <span data-ttu-id="78d60-495">Si le transfert de données était une opération de déplacement ou [de suppression sur collage](#handling-delete-on-paste-operations) [optimisée](#handling-optimized-move-operations) , appelez [**IDataObject :: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) pour indiquer le résultat.</span><span class="sxs-lookup"><span data-stu-id="78d60-495">If the data transfer was an [optimized move](#handling-optimized-move-operations) or [delete-on-paste](#handling-delete-on-paste-operations) operation, call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to indicate the outcome.</span></span>
7.  <span data-ttu-id="78d60-496">Informez l’objet de données que l’extraction est terminée en appelant [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span><span class="sxs-lookup"><span data-stu-id="78d60-496">Notify the data object that extraction is finished by calling [**EndOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).</span></span>

 

 
