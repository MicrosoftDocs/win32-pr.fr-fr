---
description: La procédure suivante décrit comment implémenter un MSP à l’aide d’ATL version 2,1 ou ATL version 3,0 et des classes de base MSP.
ms.assetid: 7485c34a-3c8a-412f-9cb9-8eb895084292
title: Utilisation des classes de base TAPI 3 MSP
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6131d44b6746075c43fc61c9d35decbe0564773db4746bba6d72b0da4697cabd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/11/2021
ms.locfileid: "119139712"
---
# <a name="using-the-tapi-3-msp-base-classes"></a>Utilisation des classes de base TAPI 3 MSP

La procédure suivante décrit comment implémenter un MSP à l’aide d’ATL version 2,1 ou ATL version 3,0 et des classes de base MSP. Pour plus d’informations et pour obtenir la liste des bibliothèques et en-têtes, consultez [classes de base TAPI 3 MSP](tapi-3-msp-base-classes.md). Le contenu de cette rubrique part du principe que le développeur a une bonne compréhension de ATL et COM, et qu’il a une expérience en matière d’implémentation des DLL COM à l’aide d’ATL.

**Pour implémenter et MSP en utilisant ATL 2,1 ou ATL 3,0**

1.  Créez un fichier IDL pour votre MSP. Ce fichier définit un CLSID pour votre MSP. Déclarez votre « coclasse » MSP comme implémentant l’interface [**ITMSPAddress**](/windows/desktop/api/msp/nn-msp-itmspaddress) , puis déclarez cette interface comme interface par défaut sur votre objet de classe. Pour la définition de **ITMSPAddress**, importez le fichier « MSP. idl ». Incluez votre « coclasse » MSP dans une bibliothèque de types pour votre MSP. Si votre MSP prend en charge les interfaces privées (personnalisées), définissez-les ici et incluez-les dans votre bibliothèque de types. L’exemple de code suivant est un fichier IDL comme décrit ci-dessus, sans interfaces personnalisées.

    ``` syntax
    import "msp.idl";
    [
          uuid(4DDB6D35-3BC1-11d2-86F2-006008B0E5D2),
          version(2.0),
          helpstring("Wave MSP 2.0 Type Library")
    ]
    library WAVEMSPLib
    {
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    [
    uuid(4DDB6D36-3BC1-11d2-86F2-006008B0E5D2),
    helpstring("Wave MSP Class")
    ]
    coclass WaveMSP
    {
    [default] interface ITMSPAddress;
    };
    };
    ```

2.  Modifiez votre TSP pour publier le CLSID de votre MSP lorsque Tapi3.dll le demande. Assurez-vous que (1) votre TSP peut négocier TAPI \_ VERSION3 \_ 0 ou une version ultérieure dans la fonction TSPI [**TSPI \_ lineNegotiateTSPIVersion**](/windows/win32/api/tspi/nf-tspi-tspi_linenegotiatetspiversion), (2) votre structure de [**LINEDEVCAPS**](/windows/win32/api/tapi/ns-tapi-linedevcaps) du PVC a l' \_ indicateur MSP LINEDEVCAPFLAGS défini dans le membre **DWDEVCAPFLAGS** et (3) votre TSP retourne votre CLSID msp dans la fonction TSPI TSPI [**\_ lineMSPIdentify**](/windows/win32/api/tspi/nf-tspi-tspi_linemspidentify). Il doit s’agir du même CLSID que celui spécifié dans votre fichier IDL ; par exemple, la deuxième ligne « UUID » dans l’exemple de fichier IDL à l’étape précédente.
3.  Compilez l’exemple d’application MSPBase, situé dans le kit de développement logiciel (SDK) de la plateforme, pour créer la bibliothèque MSPBaseSample. lib.
4.  Liez votre DLL MSP à la bibliothèque MSPBaseSample. lib.
5.  Incluez Mspbase. h dans le kit de développement logiciel (SDK) pour les définitions de classe de base MSP.
6.  Implémentez vos exportations de DLL (par exemple, DllMain). Microsoft Visual C++ les génère pour vous. Dans DllMain, sur \_ le processus dll \_ attacher et \_ \_ détacher le processus de dll, utilisez les macros **MSPLOGREGISTER** et **MSPLOGDEREGISTER** pour activer les fonctionnalités de journalisation pour votre dll. Spécifiez le nom de votre DLL dans l’appel **MSPLOGDEREGISTER** .
7.  Utilisez la macro LOG, définie dans Msplog. h, pour générer les messages de trace de la même manière que les classes de base. Définissez le symbole de préprocesseur MSPLOG pour inclure la journalisation dans votre DLL ; Laissez-le non défini pour générer une DLL qui n’a pas de journalisation.
8.  Dérivez une classe de CMSPAddress qui implémente des adresses pour votre MSP. Déclarez un mappage d’objet ATL global qui indique à ATL de créer une instance de votre classe d’adresses lorsque vous êtes invité à **cocréer** sur le CLSID que vous avez spécifié dans votre fichier IDL. En outre, dérivez votre classe Address du modèle ATL **CComCoClass** et incluez une \_ déclaration DECLARE Registry \_ ResourceId dans votre classe Address. Construisez un script de ressources et un fichier d’en-tête correspondants, comme pour toute autre DLL COM ATL.
9.  Implémentez les remplacements CMSPAddress requis pour votre classe Address. Pour [**MSPAddressAddRef**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressaddref) et [**MSPAddressRelease**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-mspaddressrelease), appelez les modèles de fonction d’assistance fournis. Pour [**GetCallMediaTypes**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-getcallmediatypes), il vous suffit de retourner une image bitmap **DWORD** avec l’ensemble de vos TAPIMEDIAMODEs pris en charge par le MSP. Pour [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) et [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall), retournez E \_ NOTIMPL et compilez et liez votre MSP à ce stade. À présent, vérifiez que vous pouvez inscrire et instancier votre MSP à partir d’applications TAPI 3, mais que vous n’avez pas réussi à créer des appels.
10. Dérivez une classe de CMSPCallMultiGraph pour implémenter vos objets d’appel MSP. Vous pouvez effectuer une dérivation à partir de [**CMSPCallBase**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallbase) au lieu de [**CMSPCallMultiGraph**](/windows/desktop/api/Mspcall/nl-mspcall-cmspcallmultigraph) si le modèle de filtre graphique par flux ne répond pas à vos besoins ; Cela augmente la complexité de la tâche (à la rédaction de cet article, tous les MSP dérivent les objets d’appel directement à partir de **CMSPCallMultiGraph**). Dans votre objet d’adresse, implémentez [**CreateMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-createmspcall) et [**ShutdownMSPCall**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdownmspcall) pour créer et arrêter votre type spécifique d’objet d’appel à l’aide des modèles de fonction d’assistance fournis. Dans votre objet d’appel, remplacez [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) pour retourner E \_ NOTIMPL. Remplacez [**MSPCallAddRef**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcalladdref) et [**MSPCallRelease**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-mspcallrelease) de manière identique aux méthodes d’adresse correspondantes. Là encore, vous devez être en mesure de compiler et lier votre MSP. il doit maintenant être en mesure de créer et d’arrêter des appels, mais les appels n’effectuent pas de diffusion utile.
11. Dérivez une classe de CMSPStream pour implémenter vos objets de flux MSP. Dans votre objet d’appel, implémentez [**CreateStreamObject**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-createstreamobject) pour créer et initialiser votre objet de flux (en général, en appelant la fonction ATL **CreateInstance** suivie de la **\_ InternalQueryInterface** ATL pour [**ITStream**](/windows/win32/api/tapi3if/nn-tapi3if-itstream) , puis en appelant **init** sur votre objet de flux). Pour prendre en charge un nombre fixe de flux (cela est courant pour les MSP qui ne prennent pas en charge la modification des configurations de flux par d’autres points de terminaison sur l’appel), remplacez **init**, [**CreateStream,**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-createstream)et [**RemoveStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstreamcontrol-removestream) sur votre objet d’appel. (L' **initialisation** d’appel crée tous vos flux initialement, et **CreateStream,** et **RemoveStream** retournent les codes d’erreur TAPI appropriés pour empêcher l’application de créer ou de supprimer des flux). Sinon, remplacez la méthode **init** de l’appel pour créer une configuration par défaut initiale des flux à l’aide des types de médias demandés pour l’appel. Quand vous créez des objets de flux par défaut dans la méthode **init** de votre appel, utilisez la méthode d’assistance [**InternalCreateStream**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-internalcreatestream) .
12. Implémentez votre objet de flux. La seule substitution obligatoire est la méthode [**de \_ nom d’extraction**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-get_name) , qui retourne simplement un nom convivial pour le flux. En outre, vous devrez remplacer plusieurs autres méthodes. Les méthodes à substituer varient en fonction de votre implémentation et lorsque vous décidez d’effectuer les différentes tâches impliquées dans la construction et la déconstruction de votre graphique de filtre. Ces tâches incluent la création des filtres de transport, des codecs et ainsi de suite, ainsi que l’insertion et la suppression des filtres dans les graphiques de filtres aux moments appropriés. Vous devez également utiliser l’interface [**ITTerminalControl**](/windows/desktop/api/Termmgr/nn-termmgr-itterminalcontrol) sur les objets terminaux pour connecter les terminaux sélectionnés à vos flux. Vous pouvez remplacer [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal) et [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) sur votre objet de flux pour limiter les configurations de terminal que vos flux accepteront. la limitation de chaque flux à un seul terminal simplifie en particulier la construction de vos graphiques de filtre, mais elle sacrifie les fonctionnalités de l’application telles que la préversion vidéo. Selon votre implémentation, vous allez placer votre code de construction de graphe, de déconstruction et de connexion de terminal dans les méthodes [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**Initialize**](/windows/desktop/api/msp/nf-msp-itmspaddress-initialize), [**Shutdown**](/windows/desktop/api/msp/nf-msp-itmspaddress-shutdown), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)et [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , ou dans vos propres méthodes basées sur la communication de TSP privée. Sachez qu’un flux sans terminal sélectionné doit suivre l’État graphique souhaité ; un appel **StartStream** suivi d’un appel **SelectTerminal** sur ce type de flux doit générer un flux de données. Substituez la plupart de ces méthodes pour vous assurer que la construction, la déconstruction, la connexion et la déconnexion appropriées se produisent dans chaque cas, en fonction de l’état du flux.
13. Implémentez votre communication sur le TSP. Remplacez [**CMSPAddress :: ReceiveTSPAddressData**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-receivetspaddressdata) et/ou [**CMSPCallBase :: ReceiveTSPCallData**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-receivetspcalldata), et/ou en appelant [**PostEvent**](/windows/desktop/api/Mspaddr/nf-mspaddr-cmspaddress-postevent) sur votre objet Address, ou [**HandleStreamEvent**](/windows/desktop/api/Mspcall/nf-mspcall-cmspcallbase-handlestreamevent) sur votre objet d’appel (à partir de votre appel ou de vos objets Stream).
14. Utilisez PostEvent sur votre objet Address, ou HandleStreamEvent sur votre objet d’appel (à partir de votre appel ou de Stream Objects) pour envoyer des événements de média d’appel à l’application via Tapi3.dll. En général, vous effectuez cette opération sur votre objet de flux, dans les méthodes substituées, notamment les méthodes [**ProcessGraphEvent**](/windows/desktop/api/Mspstrm/nf-mspstrm-cmspstream-processgraphevent), [**StopStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-stopstream), [**StartStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-startstream), [**PauseStream**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-pausestream), [**SelectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-selectterminal)et [**UnselectTerminal**](/windows/win32/api/tapi3if/nf-tapi3if-itstream-unselectterminal) , selon la manière dont vous implémentez vos flux.
15. Implémentez les interfaces ou sous-flux privés souhaités sur vos objets existants (adresse, appel et flux). En général, il n’y en a aucun. Sachez que lors de l’implémentation de vos interfaces privées, spécifiez le LIBID de votre bibliothèque de types à partir de votre fichier IDL. Autrement dit, les programmeurs d’applications doivent utiliser votre bibliothèque de types MSP lorsque vous utilisez vos interfaces personnalisées. Les interfaces MSP standard, implémentées dans les classes de base MSP, utilisent le LIBID Tapi3.dll et sont donc accessibles à toutes les applications TAPI 3.
16. Si vous implémentez des objets terminaux statiques ou dynamiques spécifiques à MSP ou des remplacements pour les terminaux statiques par défaut (non standard), vous pouvez utiliser les classes de base de terminal fournies. Vous devrez remplacer différentes méthodes sur votre objet d’adresse pour fournir des méthodes alternatives ou supplémentaires pour la création d’objets terminaux.
17. Implémentez l’interface IObjectSafety sur vos objets d’adresse, d’appel, de flux et de terminal. Pour utiliser le [Mappeur de dispatch](dispatch-mapper.md) pour interroger les interfaces sur vos objets MSP, marquez vos objets comme sécurisés pour les scripts sur ces interfaces. Pour ce faire, implémentez l’interface **IObjectSafety** sur votre objet. La dérivation à partir de **CMSPObjectSafetyImpl** (une classe d’assistance fournie dans Msputils. h) et l’ajout d' **IOBJECTSAFETY** au mappage COM ATL de votre classe \_ rend vos objets sécurisés pour les scripts sur toutes les interfaces qu’ils exposent. N’oubliez pas que l’utilisation du mappeur de répartition sur les objets MSP peut être implicite. L’adresse MSP et l’appel MSP sont agrégés par l’adresse TAPI et les objets d’appel TAPI. Si le mappeur de répartition est utilisé sur les objets TAPI pour interroger les interfaces exposées par les objets MSP agrégés, les objets MSP agrégés sont interrogés pour la sécurité des interfaces demandées.

 

 
