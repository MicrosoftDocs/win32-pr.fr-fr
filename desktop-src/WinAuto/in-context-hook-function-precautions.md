---
title: Précautions relatives à la fonction de raccordement In-Context
description: Pour des raisons de performances, les développeurs clients inscrivent les fonctions de raccordement dans le contexte.
ms.assetid: 14b48920-a291-4519-b005-e559263a0e83
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8c0e319037cb1295725548b3361bf076b4b1f760
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/20/2020
ms.locfileid: "106513726"
---
# <a name="in-context-hook-function-precautions"></a><span data-ttu-id="03583-103">Précautions relatives à la fonction de raccordement In-Context</span><span class="sxs-lookup"><span data-stu-id="03583-103">In-Context Hook Function Precautions</span></span>

<span data-ttu-id="03583-104">Pour des raisons de performances, les développeurs clients inscrivent les fonctions de raccordement dans le contexte.</span><span class="sxs-lookup"><span data-stu-id="03583-104">For performance reasons, client developers register in-context hook functions.</span></span> <span data-ttu-id="03583-105">Toutefois, étant donné que ces fonctions de raccordement sont mappées à l’espace d’adressage du serveur, les développeurs du client et du serveur doivent prendre des précautions pour garantir le bon déroulement du traitement des événements.</span><span class="sxs-lookup"><span data-stu-id="03583-105">However, because these hook functions are mapped into the server's address space, client and server developers must take precautions to ensure that the event processing goes smoothly.</span></span>

## <a name="precautions-for-client-developers"></a><span data-ttu-id="03583-106">Précautions pour les développeurs clients</span><span class="sxs-lookup"><span data-stu-id="03583-106">Precautions for Client Developers</span></span>

<span data-ttu-id="03583-107">Les développeurs clients doivent connaître les problèmes suivants :</span><span class="sxs-lookup"><span data-stu-id="03583-107">Client developers should be aware of the following issues:</span></span>

-   <span data-ttu-id="03583-108">Les fonctions de raccordement dans le contexte ne doivent pas utiliser beaucoup de temps processeur, car la fonction de raccordement doit retourner avant que l’application serveur continue.</span><span class="sxs-lookup"><span data-stu-id="03583-108">In-context hook functions should not use a lot of processor time, because the hook function must return before the server application continues.</span></span>
-   <span data-ttu-id="03583-109">Une fois qu’un événement est déclenché, il est possible que la fenêtre associée à un événement n’existe plus au moment de l’appel de la fonction de raccordement.</span><span class="sxs-lookup"><span data-stu-id="03583-109">After an event is triggered, it is possible that the window associated with an event no longer exists by the time the hook function is called.</span></span> <span data-ttu-id="03583-110">Les clients doivent vérifier que la fenêtre associée à un événement existe toujours avant d’effectuer toute autre action liée à l’événement.</span><span class="sxs-lookup"><span data-stu-id="03583-110">Clients must verify that the window associated with an event still exists before taking any other action related to the event.</span></span> <span data-ttu-id="03583-111">Pour vous assurer qu’une fenêtre existe toujours, les clients utilisent la fonction Microsoft Win32 [**IsWindow**](/windows/desktop/api/winuser/nf-winuser-iswindow) .</span><span class="sxs-lookup"><span data-stu-id="03583-111">To ensure that a window still exists, clients use the Microsoft Win32 [**IsWindow**](/windows/desktop/api/winuser/nf-winuser-iswindow) function.</span></span>
-   <span data-ttu-id="03583-112">Si la DLL dans laquelle la fonction de raccordement est définie est liée à une autre DLL, les développeurs clients doivent s’assurer que le système charge l’autre DLL.</span><span class="sxs-lookup"><span data-stu-id="03583-112">If the DLL in which the hook function is defined links to another DLL, client developers must ensure that the system loads the other DLL.</span></span> <span data-ttu-id="03583-113">En cas de liaison implicite (à l’aide des fichiers. def et des importations), la DLL supplémentaire doit se trouver dans le répertoire Windows ou dans l’un des répertoires système tels que Windows \\ System, Windows \\ system32 ou Windows \\ SysWOW64.</span><span class="sxs-lookup"><span data-stu-id="03583-113">If linking implicitly (using .def files and imports), the additional DLL must be in either the Windows directory or one of the system directories such as Windows\\System, Windows\\System32, or Windows\\SysWOW64.</span></span> <span data-ttu-id="03583-114">En cas de liaison explicite (à l’aide de [**LoadLibrary**](/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya)), le chemin d’accès complet au répertoire dans lequel réside la dll supplémentaire doit être spécifié dans l’appel à **LoadLibrary**.</span><span class="sxs-lookup"><span data-stu-id="03583-114">If linking explicitly (using [**LoadLibrary**](/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya)), the full path to the directory in which the additional DLL resides must be specified in the call to **LoadLibrary**.</span></span>
-   <span data-ttu-id="03583-115">Les fonctions de raccordement dans le contexte peuvent provoquer un dépassement de capacité de la pile lorsque la DLL qui contient la fonction de raccordement est chargée dans une application 16 bits.</span><span class="sxs-lookup"><span data-stu-id="03583-115">In-context hook functions may cause a stack overflow when the DLL that contains the hook function is loaded into a 16-bit application.</span></span> <span data-ttu-id="03583-116">Ce problème se produit parce que les applications 16 bits utilisent une taille de pile fixe qui n’est pas suffisamment grande pour accueillir la chaîne d’appels de fonction système qui entraînent un appel à la fonction de raccordement.</span><span class="sxs-lookup"><span data-stu-id="03583-116">This problem occurs because 16-bit applications use a fixed stack size that is not large enough to accommodate the chain of system function calls that result in a call to the hook function.</span></span>

## <a name="precautions-for-server-developers"></a><span data-ttu-id="03583-117">Précautions pour les développeurs de serveurs</span><span class="sxs-lookup"><span data-stu-id="03583-117">Precautions for Server Developers</span></span>

<span data-ttu-id="03583-118">Les développeurs de serveurs doivent savoir que les applications clientes peuvent inscrire des fonctions de raccordement dans le contexte.</span><span class="sxs-lookup"><span data-stu-id="03583-118">Server developers need to be aware that client applications might register in-context hook functions.</span></span> <span data-ttu-id="03583-119">Lorsqu’un serveur appelle [**NotifyWinEvent**](/windows/desktop/api/Winuser/nf-winuser-notifywinevent), il doit être préparé à gérer le [**WM \_ GETOBJECT**](wm-getobject.md) et d’autres méthodes [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) .</span><span class="sxs-lookup"><span data-stu-id="03583-119">When a server calls [**NotifyWinEvent**](/windows/desktop/api/Winuser/nf-winuser-notifywinevent), it must be prepared to handle [**WM\_GETOBJECT**](wm-getobject.md) and other [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) methods.</span></span>

## <a name="invalid-interface-pointers"></a><span data-ttu-id="03583-120">Pointeurs d’interface non valides</span><span class="sxs-lookup"><span data-stu-id="03583-120">Invalid Interface Pointers</span></span>

<span data-ttu-id="03583-121">Lorsqu’un client appelle [**AccessibleObjectFromEvent**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromevent) dans une fonction de raccordement dans le contexte, le pointeur d’interface [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) qui est retourné pointe directement vers le code dans l’espace d’adressage du serveur.</span><span class="sxs-lookup"><span data-stu-id="03583-121">When a client calls [**AccessibleObjectFromEvent**](/windows/desktop/api/Oleacc/nf-oleacc-accessibleobjectfromevent) within an in-context hook function, the [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) interface pointer that is returned points directly to code in the server's address space.</span></span> <span data-ttu-id="03583-122">Si le client appelle une propriété d’interface à l’aide de ce pointeur, la bibliothèque COM (Component Object Model) n’est pas impliquée dans le marshaling (empaquetage et envoi de paramètres d’interface au-delà des limites de processus) ou démarshaling (empaquetage des paramètres envoyés au-delà des limites de processus) et ne détecte pas si un objet est détruit</span><span class="sxs-lookup"><span data-stu-id="03583-122">If the client calls an interface property using this pointer, the Component Object Model (COM) library is not involved with marshaling (packaging and sending interface parameters across process boundaries) or unmarshaling (unpackaging parameters that have been sent across process boundaries) and does not detect if an object is destroyed.</span></span>

<span data-ttu-id="03583-123">Si le client appelle une propriété d’interface sur un objet qui est détruit, le pointeur d’interface non valide provoque une erreur de protection générale dans l’espace d’adressage du serveur, sauf si le serveur détecte cette situation.</span><span class="sxs-lookup"><span data-stu-id="03583-123">If the client calls an interface property to an object that is destroyed, the invalid interface pointer causes a General Protection fault in the server's address space unless the server detects this situation.</span></span>

<span data-ttu-id="03583-124">Pour vous protéger contre les pointeurs d’interface non valides, les serveurs [créent des objets proxy](creating-proxy-objects.md) qui encapsulent les objets accessibles et surveillent la durée de vie des objets accessibles.</span><span class="sxs-lookup"><span data-stu-id="03583-124">To protect against invalid interface pointers, servers [create proxy objects](creating-proxy-objects.md) that wrap accessible objects and monitor the life span of accessible objects.</span></span> <span data-ttu-id="03583-125">Par exemple, lorsqu’un client appelle une propriété [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) pour obtenir des informations sur un objet, le proxy vérifie si l’objet accessible est toujours disponible, et dans ce cas, transfère la demande du client à l’objet accessible.</span><span class="sxs-lookup"><span data-stu-id="03583-125">For instance, when a client calls an [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) property to get information about an object, the proxy checks whether the accessible object is still available, and if so, forwards the client's request to the accessible object.</span></span> <span data-ttu-id="03583-126">Si l’objet accessible est détruit, le proxy retourne une erreur au client.</span><span class="sxs-lookup"><span data-stu-id="03583-126">If the accessible object is destroyed, the proxy returns an error to the client.</span></span>

 

 