---
description: Cette rubrique montre comment créer et détruire des minuteries, et comment utiliser un minuteur pour intercepter l’entrée de la souris à des intervalles spécifiés.
ms.assetid: eee54078-759f-4fd4-9cf4-10a8bde888b7
title: Utilisation de minuteurs
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 440c6479aca9d5394c2ad9ade87dd77b1474f31f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "104320249"
---
# <a name="using-timers"></a><span data-ttu-id="47666-103">Utilisation de minuteurs</span><span class="sxs-lookup"><span data-stu-id="47666-103">Using Timers</span></span>

<span data-ttu-id="47666-104">Cette rubrique montre comment créer et détruire des minuteries, et comment utiliser un minuteur pour intercepter l’entrée de la souris à des intervalles spécifiés.</span><span class="sxs-lookup"><span data-stu-id="47666-104">This topic shows how to create and destroy timers, and how to use a timer to trap mouse input at specified intervals.</span></span>

<span data-ttu-id="47666-105">Cette rubrique contient les sections suivantes.</span><span class="sxs-lookup"><span data-stu-id="47666-105">This topic contains the following sections.</span></span>

-   [<span data-ttu-id="47666-106">Création d’un minuteur</span><span class="sxs-lookup"><span data-stu-id="47666-106">Creating a Timer</span></span>](#creating-a-timer)
-   [<span data-ttu-id="47666-107">Destruction d’un minuteur</span><span class="sxs-lookup"><span data-stu-id="47666-107">Destroying a Timer</span></span>](#destroying-a-timer)
-   [<span data-ttu-id="47666-108">Utilisation des fonctions de minuterie pour intercepter l’entrée de la souris</span><span class="sxs-lookup"><span data-stu-id="47666-108">Using Timer Functions to Trap Mouse Input</span></span>](#using-timer-functions-to-trap-mouse-input)
-   [<span data-ttu-id="47666-109">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="47666-109">Related topics</span></span>](#related-topics)

## <a name="creating-a-timer"></a><span data-ttu-id="47666-110">Création d’un minuteur</span><span class="sxs-lookup"><span data-stu-id="47666-110">Creating a Timer</span></span>

<span data-ttu-id="47666-111">L’exemple suivant utilise la fonction [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) pour créer deux minuteries.</span><span class="sxs-lookup"><span data-stu-id="47666-111">The following example uses the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) function to create two timers.</span></span> <span data-ttu-id="47666-112">La première minuterie est définie toutes les 10 secondes, la seconde pour toutes les cinq minutes.</span><span class="sxs-lookup"><span data-stu-id="47666-112">The first timer is set for every 10 seconds, the second for every five minutes.</span></span>


```
// Set two timers. 
 
SetTimer(hwnd,             // handle to main window 
    IDT_TIMER1,            // timer identifier 
    10000,                 // 10-second interval 
    (TIMERPROC) NULL);     // no timer callback 
 
SetTimer(hwnd,             // handle to main window 
    IDT_TIMER2,            // timer identifier 
    300000,                // five-minute interval 
    (TIMERPROC) NULL);     // no timer callback 
```



<span data-ttu-id="47666-113">Pour traiter les messages du [**\_ minuteur WM**](wm-timer.md) générés par ces minuteurs, ajoutez une instruction de cas de **\_ minuterie WM** à la procédure de fenêtre pour le paramètre *HWND* .</span><span class="sxs-lookup"><span data-stu-id="47666-113">To process the [**WM\_TIMER**](wm-timer.md) messages generated by these timers, add a **WM\_TIMER** case statement to the window procedure for the *hwnd* parameter.</span></span>


```
case WM_TIMER: 
 
    switch (wParam) 
    { 
        case IDT_TIMER1: 
            // process the 10-second timer 
 
             return 0; 
 
        case IDT_TIMER2: 
            // process the five-minute timer 

            return 0; 
    } 
```



<span data-ttu-id="47666-114">Une application peut également créer un minuteur dont les messages [**\_ du minuteur WM**](wm-timer.md) ne sont pas traités par la procédure de fenêtre principale, mais par une fonction de rappel définie par l’application, comme dans l’exemple de code suivant, qui crée un minuteur et utilise la fonction de rappel **MyTimerProc** pour traiter les messages du **\_ minuteur WM** de la minuterie.</span><span class="sxs-lookup"><span data-stu-id="47666-114">An application can also create a timer whose [**WM\_TIMER**](wm-timer.md) messages are processed not by the main window procedure but by an application-defined callback function, as in the following code sample, which creates a timer and uses the callback function **MyTimerProc** to process the timer's **WM\_TIMER** messages.</span></span>


```
// Set the timer. 
 
SetTimer(hwnd,                // handle to main window 
    IDT_TIMER3,               // timer identifier 
    5000,                     // 5-second interval 
    (TIMERPROC) MyTimerProc); // timer callback
```



<span data-ttu-id="47666-115">La Convention d’appel pour **MyTimerProc** doit être basée sur la fonction de rappel [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) .</span><span class="sxs-lookup"><span data-stu-id="47666-115">The calling convention for **MyTimerProc** must be based on the [*TimerProc*](/windows/win32/api/winuser/nc-winuser-timerproc) callback function.</span></span>

<span data-ttu-id="47666-116">Si votre application crée un minuteur sans spécifier de handle de fenêtre, votre application doit surveiller la file d’attente de messages pour les messages [**\_ du minuteur WM**](wm-timer.md) et les distribuer à la fenêtre appropriée.</span><span class="sxs-lookup"><span data-stu-id="47666-116">If your application creates a timer without specifying a window handle, your application must monitor the message queue for [**WM\_TIMER**](wm-timer.md) messages and dispatch them to the appropriate window.</span></span>


```
HWND hwndTimer;   // handle to window for timer messages 
MSG msg;          // message structure 
 
    while (GetMessage(&msg, // message structure 
            NULL,           // handle to window to receive the message 
               0,           // lowest message to examine 
               0))          // highest message to examine 
    { 
 
        // Post WM_TIMER messages to the hwndTimer procedure. 
 
        if (msg.message == WM_TIMER) 
        { 
            msg.hwnd = hwndTimer; 
        } 
 
        TranslateMessage(&msg); // translates virtual-key codes 
        DispatchMessage(&msg);  // dispatches message to window 
    } 
```



## <a name="destroying-a-timer"></a><span data-ttu-id="47666-117">Destruction d’un minuteur</span><span class="sxs-lookup"><span data-stu-id="47666-117">Destroying a Timer</span></span>

<span data-ttu-id="47666-118">Les applications doivent utiliser la fonction [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) pour détruire les minuteurs qui ne sont plus nécessaires.</span><span class="sxs-lookup"><span data-stu-id="47666-118">Applications should use the [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) function to destroy timers that are no longer necessary.</span></span> <span data-ttu-id="47666-119">L’exemple ci-dessous détruit les minuteries identifiées par les constantes IDT \_ Timer1, IDT \_ TIMER2 et IDT \_ TIMER3.</span><span class="sxs-lookup"><span data-stu-id="47666-119">The following example destroys the timers identified by the constants IDT\_TIMER1, IDT\_TIMER2, and IDT\_TIMER3.</span></span>


```
// Destroy the timers. 
 
KillTimer(hwnd, IDT_TIMER1); 
KillTimer(hwnd, IDT_TIMER2); 
KillTimer(hwnd, IDT_TIMER3); 
```



## <a name="using-timer-functions-to-trap-mouse-input"></a><span data-ttu-id="47666-120">Utilisation des fonctions de minuterie pour intercepter l’entrée de la souris</span><span class="sxs-lookup"><span data-stu-id="47666-120">Using Timer Functions to Trap Mouse Input</span></span>

<span data-ttu-id="47666-121">Il est parfois nécessaire d’éviter une entrée supplémentaire pendant que vous avez un pointeur de souris sur l’écran.</span><span class="sxs-lookup"><span data-stu-id="47666-121">Sometimes it is necessary to prevent more input while you have a mouse pointer on the screen.</span></span> <span data-ttu-id="47666-122">Une façon d’y parvenir consiste à créer une routine spéciale qui intercepte l’entrée de la souris jusqu’à ce qu’un événement spécifique se produise.</span><span class="sxs-lookup"><span data-stu-id="47666-122">One way to accomplish this is to create a special routine that traps mouse input until a specific event occurs.</span></span> <span data-ttu-id="47666-123">De nombreux développeurs font référence à cette routine en tant que « construction d’un Mousetrap ».</span><span class="sxs-lookup"><span data-stu-id="47666-123">Many developers refer to this routine as "building a mousetrap."</span></span>

<span data-ttu-id="47666-124">L’exemple suivant utilise les fonctions [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) et [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) pour intercepter l’entrée de la souris.</span><span class="sxs-lookup"><span data-stu-id="47666-124">The following example uses the [**SetTimer**](/windows/win32/api/winuser/nf-winuser-settimer) and [**KillTimer**](/windows/win32/api/winuser/nf-winuser-killtimer) functions to trap mouse input.</span></span> <span data-ttu-id="47666-125">**SetTimer** crée un minuteur qui envoie un message de [**\_ minuteur WM**](wm-timer.md) toutes les 10 secondes.</span><span class="sxs-lookup"><span data-stu-id="47666-125">**SetTimer** creates a timer that sends a [**WM\_TIMER**](wm-timer.md) message every 10 seconds.</span></span> <span data-ttu-id="47666-126">Chaque fois que l’application reçoit un message de **\_ minuteur WM** , il enregistre l’emplacement du pointeur de la souris.</span><span class="sxs-lookup"><span data-stu-id="47666-126">Each time the application receives a **WM\_TIMER** message, it records the mouse pointer location.</span></span> <span data-ttu-id="47666-127">Si l’emplacement actuel est le même que l’emplacement précédent et que la fenêtre principale de l’application est réduite, l’application déplace le pointeur de la souris sur l’icône.</span><span class="sxs-lookup"><span data-stu-id="47666-127">If the current location is the same as the previous location and the application's main window is minimized, the application moves the mouse pointer to the icon.</span></span> <span data-ttu-id="47666-128">Lorsque l’application se ferme, **KillTimer** arrête le minuteur.</span><span class="sxs-lookup"><span data-stu-id="47666-128">When the application closes, **KillTimer** stops the timer.</span></span>


```
HICON hIcon1;               // icon handle 
POINT ptOld;                // previous cursor location 
UINT uResult;               // SetTimer's return value 
HINSTANCE hinstance;        // handle to current instance 
 
//
// Perform application initialization here. 
//
 
wc.hIcon = LoadIcon(hinstance, MAKEINTRESOURCE(400)); 
wc.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(200)); 
 
// Record the initial cursor position. 
 
GetCursorPos(&ptOld); 
 
// Set the timer for the mousetrap. 
 
uResult = SetTimer(hwnd,             // handle to main window 
    IDT_MOUSETRAP,                   // timer identifier 
    10000,                           // 10-second interval 
    (TIMERPROC) NULL);               // no timer callback 
 
if (uResult == 0) 
{ 
    ErrorHandler("No timer is available."); 
} 
 
LONG APIENTRY MainWndProc( 
    HWND hwnd,          // handle to main window 
    UINT message,       // type of message 
    WPARAM  wParam,     // additional information 
    LPARAM  lParam)     // additional information 
{ 
 
    HDC hdc;        // handle to device context 
    POINT pt;       // current cursor location 
    RECT rc;        // location of minimized window 
 
    switch (message) 
    { 
        //
        // Process other messages. 
        // 
 
        case WM_TIMER: 
        // If the window is minimized, compare the current 
        // cursor position with the one from 10 seconds 
        // earlier. If the cursor position has not changed, 
        // move the cursor to the icon. 
 
            if (IsIconic(hwnd)) 
            { 
                GetCursorPos(&pt); 
 
                if ((pt.x == ptOld.x) && (pt.y == ptOld.y)) 
                { 
                    GetWindowRect(hwnd, &rc); 
                    SetCursorPos(rc.left, rc.top); 
                } 
                else 
                { 
                    ptOld.x = pt.x; 
                    ptOld.y = pt.y; 
                } 
            } 
 
            return 0; 
 
        case WM_DESTROY: 
 
        // Destroy the timer. 
 
            KillTimer(hwnd, IDT_MOUSETRAP); 
            PostQuitMessage(0); 
            break; 
 
        //
        // Process other messages. 
        // 
 
} 
```



<span data-ttu-id="47666-129">Bien que l’exemple suivant montre également comment intercepter l’entrée de la souris, il traite le message du [**\_ minuteur WM**](wm-timer.md) via la fonction de rappel définie par l’application **MyTimerProc**, plutôt que via la file d’attente de messages de l’application.</span><span class="sxs-lookup"><span data-stu-id="47666-129">Although the following example also shows you how to trap mouse input, it processes the [**WM\_TIMER**](wm-timer.md) message through the application-defined callback function **MyTimerProc**, rather than through the application's message queue.</span></span>


```
UINT uResult;               // SetTimer's return value 
HICON hIcon1;               // icon handle 
POINT ptOld;                // previous cursor location 
HINSTANCE hinstance;        // handle to current instance 
 
//
// Perform application initialization here. 
//
 
wc.hIcon = LoadIcon(hinstance, MAKEINTRESOURCE(400)); 
wc.hCursor = LoadCursor(hinstance, MAKEINTRESOURCE(200)); 
 
// Record the current cursor position. 
 
GetCursorPos(&ptOld); 
 
// Set the timer for the mousetrap. 
 
uResult = SetTimer(hwnd,      // handle to main window 
    IDT_MOUSETRAP,            // timer identifier 
    10000,                    // 10-second interval 
    (TIMERPROC) MyTimerProc); // timer callback 
 
if (uResult == 0) 
{ 
    ErrorHandler("No timer is available."); 
} 
 
LONG APIENTRY MainWndProc( 
    HWND hwnd,          // handle to main window 
    UINT message,       // type of message 
    WPARAM  wParam,     // additional information 
    LPARAM   lParam)    // additional information 
{ 
 
    HDC hdc;            // handle to device context 
 
    switch (message) 
    { 
    // 
    // Process other messages. 
    // 
 
        case WM_DESTROY: 
        // Destroy the timer. 
 
            KillTimer(hwnd, IDT_MOUSETRAP); 
            PostQuitMessage(0); 
            break; 
 
        //
        // Process other messages. 
        // 
 
} 
 
// MyTimerProc is an application-defined callback function that 
// processes WM_TIMER messages. 
 
VOID CALLBACK MyTimerProc( 
    HWND hwnd,        // handle to window for timer messages 
    UINT message,     // WM_TIMER message 
    UINT idTimer,     // timer identifier 
    DWORD dwTime)     // current system time 
{ 
 
    RECT rc; 
    POINT pt; 
 
    // If the window is minimized, compare the current 
    // cursor position with the one from 10 seconds earlier. 
    // If the cursor position has not changed, move the 
    // cursor to the icon. 
 
    if (IsIconic(hwnd)) 
    { 
        GetCursorPos(&pt); 
 
        if ((pt.x == ptOld.x) && (pt.y == ptOld.y)) 
        { 
            GetWindowRect(hwnd, &rc); 
            SetCursorPos(rc.left, rc.top); 
        } 
        else 
        { 
            ptOld.x = pt.x; 
            ptOld.y = pt.y; 
        } 
    } 
} 
```



## <a name="related-topics"></a><span data-ttu-id="47666-130">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="47666-130">Related topics</span></span>

<dl> <dt>

[<span data-ttu-id="47666-131">À propos des minuteries</span><span class="sxs-lookup"><span data-stu-id="47666-131">About Timers</span></span>](about-timers.md)
</dt> </dl>

 

 
