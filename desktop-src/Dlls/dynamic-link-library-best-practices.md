---
description: La création de dll présente un certain nombre de défis pour les développeurs.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Meilleures pratiques pour la bibliothèque Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 88aba0999f3d0825c6d2f4df3afe09d766a82232
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106540902"
---
# <a name="dynamic-link-library-best-practices"></a><span data-ttu-id="23681-103">Meilleures pratiques pour la bibliothèque Dynamic-Link</span><span class="sxs-lookup"><span data-stu-id="23681-103">Dynamic-Link Library Best Practices</span></span>

<span data-ttu-id="23681-104">\* \* Mis à jour : \* \*</span><span class="sxs-lookup"><span data-stu-id="23681-104">\*\*Updated: \*\*</span></span>

-   <span data-ttu-id="23681-105">17 mai, 2006</span><span class="sxs-lookup"><span data-stu-id="23681-105">May 17, 2006</span></span>

<span data-ttu-id="23681-106">**API importantes**</span><span class="sxs-lookup"><span data-stu-id="23681-106">**Important APIs**</span></span>

-   [<span data-ttu-id="23681-107">**DllMain**</span><span class="sxs-lookup"><span data-stu-id="23681-107">**DllMain**</span></span>](dllmain.md)
-   [<span data-ttu-id="23681-108">**LoadLibraryEx**</span><span class="sxs-lookup"><span data-stu-id="23681-108">**LoadLibraryEx**</span></span>](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [<span data-ttu-id="23681-109">**CreateProcess**</span><span class="sxs-lookup"><span data-stu-id="23681-109">**CreateProcess**</span></span>](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

<span data-ttu-id="23681-110">La création de dll présente un certain nombre de défis pour les développeurs.</span><span class="sxs-lookup"><span data-stu-id="23681-110">Creating DLLs presents a number of challenges for developers.</span></span> <span data-ttu-id="23681-111">Les dll n’ont pas de contrôle de version appliqué par le système.</span><span class="sxs-lookup"><span data-stu-id="23681-111">DLLs do not have system-enforced versioning.</span></span> <span data-ttu-id="23681-112">Lorsque plusieurs versions d’une DLL existent sur un système, la facilité de remplacement couplée à l’absence d’un schéma de contrôle de version crée des conflits d’API et de dépendances.</span><span class="sxs-lookup"><span data-stu-id="23681-112">When multiple versions of a DLL exist on a system, the ease of being overwritten coupled with the lack of a versioning schema creates dependency and API conflicts.</span></span> <span data-ttu-id="23681-113">La complexité de l’environnement de développement, l’implémentation du chargeur et les dépendances de DLL ont créé des fragilité dans l’ordre de chargement et le comportement de l’application.</span><span class="sxs-lookup"><span data-stu-id="23681-113">Complexity in the development environment, the loader implementation, and the DLL dependencies has created fragility in load order and application behavior.</span></span> <span data-ttu-id="23681-114">Enfin, de nombreuses applications reposent sur des dll et des ensembles complexes de dépendances qui doivent être respectées pour que les applications fonctionnent correctement.</span><span class="sxs-lookup"><span data-stu-id="23681-114">Lastly, many applications rely on DLLs and have complex sets of dependencies that must be honored for the applications to function properly.</span></span> <span data-ttu-id="23681-115">Ce document fournit des instructions pour les développeurs de DLL pour vous aider à créer des dll plus robustes, portables et extensibles.</span><span class="sxs-lookup"><span data-stu-id="23681-115">This document provides guidelines for DLL developers to help in building more robust, portable, and extensible DLLs.</span></span>

<span data-ttu-id="23681-116">Une synchronisation incorrecte dans [**DllMain**](dllmain.md) peut provoquer le blocage d’une application ou l’accès à des données ou du code dans une DLL non initialisée.</span><span class="sxs-lookup"><span data-stu-id="23681-116">Improper synchronization within [**DllMain**](dllmain.md) can cause an application to deadlock or access data or code in an uninitialized DLL.</span></span> <span data-ttu-id="23681-117">L’appel de certaines fonctions à partir de **DllMain** provoque de tels problèmes.</span><span class="sxs-lookup"><span data-stu-id="23681-117">Calling certain functions from within **DllMain** causes such problems.</span></span>

![que se passe-t-il quand une bibliothèque est chargée ?](images/fig1.png)

## <a name="general-best-practices"></a><span data-ttu-id="23681-119">Bonnes pratiques générales</span><span class="sxs-lookup"><span data-stu-id="23681-119">General Best Practices</span></span>

<span data-ttu-id="23681-120">[**DllMain**](dllmain.md) est appelé alors que le verrouillage du chargeur est maintenu.</span><span class="sxs-lookup"><span data-stu-id="23681-120">[**DllMain**](dllmain.md) is called while the loader-lock is held.</span></span> <span data-ttu-id="23681-121">Par conséquent, des restrictions significatives sont imposées sur les fonctions qui peuvent être appelées dans **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="23681-121">Therefore, significant restrictions are imposed on the functions that can be called within **DllMain**.</span></span> <span data-ttu-id="23681-122">Par conséquent, **DllMain** est conçu pour effectuer des tâches d’initialisation minimales, à l’aide d’un petit sous-ensemble de l’API Microsoft® Windows®.</span><span class="sxs-lookup"><span data-stu-id="23681-122">As such, **DllMain** is designed to perform minimal initialization tasks, by using a small subset of the Microsoft® Windows® API.</span></span> <span data-ttu-id="23681-123">Vous ne pouvez pas appeler une fonction dans **DllMain** qui tente directement ou indirectement d’acquérir le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="23681-123">You cannot call any function in **DllMain** that directly or indirectly tries to acquire the loader lock.</span></span> <span data-ttu-id="23681-124">Dans le cas contraire, vous présenterez la possibilité que votre application se bloque ou tombe en panne.</span><span class="sxs-lookup"><span data-stu-id="23681-124">Otherwise, you will introduce the possibility that your application deadlocks or crashes.</span></span> <span data-ttu-id="23681-125">Une erreur dans une implémentation de **DllMain** peut compromettre l’ensemble du processus et de tous ses threads.</span><span class="sxs-lookup"><span data-stu-id="23681-125">An error in a **DllMain** implementation can jeopardize the entire process and all of its threads.</span></span>

<span data-ttu-id="23681-126">La [**DllMain**](dllmain.md) idéale serait simplement un stub vide.</span><span class="sxs-lookup"><span data-stu-id="23681-126">The ideal [**DllMain**](dllmain.md) would be just an empty stub.</span></span> <span data-ttu-id="23681-127">Toutefois, étant donné la complexité de nombreuses applications, cela est généralement trop restrictif.</span><span class="sxs-lookup"><span data-stu-id="23681-127">However, given the complexity of many applications, this is generally too restrictive.</span></span> <span data-ttu-id="23681-128">Une bonne règle empirique pour **DllMain** consiste à différer le plus possible de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="23681-128">A good rule of thumb for **DllMain** is to postpone as much initialization as possible.</span></span> <span data-ttu-id="23681-129">L’initialisation tardive augmente la robustesse de l’application, car cette initialisation n’est pas effectuée tant que le verrouillage du chargeur est maintenu.</span><span class="sxs-lookup"><span data-stu-id="23681-129">Lazy initialization increases robustness of the application because this initialization is not performed while the loader lock is held.</span></span> <span data-ttu-id="23681-130">En outre, l’initialisation tardive vous permet d’utiliser en toute sécurité une plus grande partie de l’API Windows.</span><span class="sxs-lookup"><span data-stu-id="23681-130">Also, lazy initialization enables you to safely use much more of the Windows API.</span></span>

<span data-ttu-id="23681-131">Certaines tâches d’initialisation ne peuvent pas être reportées.</span><span class="sxs-lookup"><span data-stu-id="23681-131">Some initialization tasks cannot be postponed.</span></span> <span data-ttu-id="23681-132">Par exemple, une DLL qui dépend d’un fichier de configuration ne peut pas se charger si le fichier est incorrect ou contient des opérations garbage.</span><span class="sxs-lookup"><span data-stu-id="23681-132">For example, a DLL that depends on a configuration file should fail to load if the file is malformed or contains garbage.</span></span> <span data-ttu-id="23681-133">Pour ce type d’initialisation, la DLL doit essayer l’action et échouer rapidement plutôt que gaspiller des ressources en effectuant d’autres tâches.</span><span class="sxs-lookup"><span data-stu-id="23681-133">For this type of initialization, the DLL should attempt the action and fail quickly rather than waste resources by completing other work.</span></span>

<span data-ttu-id="23681-134">Vous ne devez jamais effectuer les tâches suivantes à partir de [**DllMain**](dllmain.md):</span><span class="sxs-lookup"><span data-stu-id="23681-134">You should never perform the following tasks from within [**DllMain**](dllmain.md):</span></span>

-   <span data-ttu-id="23681-135">Appelez [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) ou [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (directement ou indirectement).</span><span class="sxs-lookup"><span data-stu-id="23681-135">Call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) or [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (either directly or indirectly).</span></span> <span data-ttu-id="23681-136">Cela peut provoquer un blocage ou un incident.</span><span class="sxs-lookup"><span data-stu-id="23681-136">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="23681-137">Appelez [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)ou [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (directement ou indirectement).</span><span class="sxs-lookup"><span data-stu-id="23681-137">Call [**GetStringTypeA**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**GetStringTypeEx**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw), or [**GetStringTypeW**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (either directly or indirectly).</span></span> <span data-ttu-id="23681-138">Cela peut provoquer un blocage ou un incident.</span><span class="sxs-lookup"><span data-stu-id="23681-138">This can cause a deadlock or a crash.</span></span>
-   <span data-ttu-id="23681-139">Synchroniser avec d’autres threads.</span><span class="sxs-lookup"><span data-stu-id="23681-139">Synchronize with other threads.</span></span> <span data-ttu-id="23681-140">Cela peut provoquer un blocage.</span><span class="sxs-lookup"><span data-stu-id="23681-140">This can cause a deadlock.</span></span>
-   <span data-ttu-id="23681-141">Obtenez un objet de synchronisation détenu par du code qui attend pour acquérir le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="23681-141">Acquire a synchronization object that is owned by code that is waiting to acquire the loader lock.</span></span> <span data-ttu-id="23681-142">Cela peut provoquer un blocage.</span><span class="sxs-lookup"><span data-stu-id="23681-142">This can cause a deadlock.</span></span>
-   <span data-ttu-id="23681-143">Initialisez les threads COM à l’aide de [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span><span class="sxs-lookup"><span data-stu-id="23681-143">Initialize COM threads by using [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex).</span></span> <span data-ttu-id="23681-144">Dans certaines conditions, cette fonction peut appeler [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span><span class="sxs-lookup"><span data-stu-id="23681-144">Under certain conditions, this function can call [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).</span></span>
-   <span data-ttu-id="23681-145">Appelez les fonctions du Registre.</span><span class="sxs-lookup"><span data-stu-id="23681-145">Call the registry functions.</span></span> <span data-ttu-id="23681-146">Ces fonctions sont implémentées dans Advapi32.dll.</span><span class="sxs-lookup"><span data-stu-id="23681-146">These functions are implemented in Advapi32.dll.</span></span> <span data-ttu-id="23681-147">Si Advapi32.dll n’est pas initialisé avant votre DLL, la DLL peut accéder à la mémoire non initialisée et provoquer le blocage du processus.</span><span class="sxs-lookup"><span data-stu-id="23681-147">If Advapi32.dll is not initialized before your DLL, the DLL can access uninitialized memory and cause the process to crash.</span></span>
-   <span data-ttu-id="23681-148">Appelez [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span><span class="sxs-lookup"><span data-stu-id="23681-148">Call [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa).</span></span> <span data-ttu-id="23681-149">La création d’un processus peut charger une autre DLL.</span><span class="sxs-lookup"><span data-stu-id="23681-149">Creating a process can load another DLL.</span></span>
-   <span data-ttu-id="23681-150">Appelez [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span><span class="sxs-lookup"><span data-stu-id="23681-150">Call [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread).</span></span> <span data-ttu-id="23681-151">La sortie d’un thread pendant le détachement de la DLL peut entraîner une nouvelle acquisition du verrou du chargeur, provoquant un blocage ou un incident.</span><span class="sxs-lookup"><span data-stu-id="23681-151">Exiting a thread during DLL detach can cause the loader lock to be acquired again, causing a deadlock or a crash.</span></span>
-   <span data-ttu-id="23681-152">Appelez [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span><span class="sxs-lookup"><span data-stu-id="23681-152">Call [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread).</span></span> <span data-ttu-id="23681-153">La création d’un thread peut fonctionner si vous n’effectuez pas de synchronisation avec d’autres threads, mais cela est risqué.</span><span class="sxs-lookup"><span data-stu-id="23681-153">Creating a thread can work if you do not synchronize with other threads, but it is risky.</span></span>
-   <span data-ttu-id="23681-154">Créez un canal nommé ou un autre objet nommé (Windows 2000 uniquement).</span><span class="sxs-lookup"><span data-stu-id="23681-154">Create a named pipe or other named object (Windows 2000 only).</span></span> <span data-ttu-id="23681-155">Dans Windows 2000, les objets nommés sont fournis par la DLL des services Terminal Server.</span><span class="sxs-lookup"><span data-stu-id="23681-155">In Windows 2000, named objects are provided by the Terminal Services DLL.</span></span> <span data-ttu-id="23681-156">Si cette DLL n’est pas initialisée, les appels à la DLL peuvent entraîner le blocage du processus.</span><span class="sxs-lookup"><span data-stu-id="23681-156">If this DLL is not initialized, calls to the DLL can cause the process to crash.</span></span>
-   <span data-ttu-id="23681-157">Utilisez la fonction de gestion de la mémoire du Run-Time dynamique C (CRT).</span><span class="sxs-lookup"><span data-stu-id="23681-157">Use the memory management function from the dynamic C Run-Time (CRT).</span></span> <span data-ttu-id="23681-158">Si la DLL CRT n’est pas initialisée, les appels à ces fonctions peuvent provoquer le blocage du processus.</span><span class="sxs-lookup"><span data-stu-id="23681-158">If the CRT DLL is not initialized, calls to these functions can cause the process to crash.</span></span>
-   <span data-ttu-id="23681-159">Appeler des fonctions dans User32.dll ou Gdi32.dll.</span><span class="sxs-lookup"><span data-stu-id="23681-159">Call functions in User32.dll or Gdi32.dll.</span></span> <span data-ttu-id="23681-160">Certaines fonctions chargent une autre DLL, qui ne peut pas être initialisée.</span><span class="sxs-lookup"><span data-stu-id="23681-160">Some functions load another DLL, which may not be initialized.</span></span>
-   <span data-ttu-id="23681-161">Utilisez du code managé.</span><span class="sxs-lookup"><span data-stu-id="23681-161">Use managed code.</span></span>

<span data-ttu-id="23681-162">Les tâches suivantes peuvent être effectuées en toute sécurité dans **DllMain**:</span><span class="sxs-lookup"><span data-stu-id="23681-162">The following tasks are safe to perform within **DllMain**:</span></span>

-   <span data-ttu-id="23681-163">Initialiser des structures de données et des membres statiques au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="23681-163">Initialize static data structures and members at compile time.</span></span>
-   <span data-ttu-id="23681-164">Créer et initialiser des objets de synchronisation.</span><span class="sxs-lookup"><span data-stu-id="23681-164">Create and initialize synchronization objects.</span></span>
-   <span data-ttu-id="23681-165">Allouez de la mémoire et initialisez les structures de données dynamiques (en évitant les fonctions mentionnées ci-dessus).</span><span class="sxs-lookup"><span data-stu-id="23681-165">Allocate memory and initialize dynamic data structures (avoiding the functions listed above.)</span></span>
-   <span data-ttu-id="23681-166">Configurez le stockage local des threads (TLS).</span><span class="sxs-lookup"><span data-stu-id="23681-166">Set up thread local storage (TLS).</span></span>
-   <span data-ttu-id="23681-167">Ouvrir, lire et écrire dans des fichiers.</span><span class="sxs-lookup"><span data-stu-id="23681-167">Open, read from, and write to files.</span></span>
-   <span data-ttu-id="23681-168">Appeler des fonctions dans Kernel32.dll (à l’exception des fonctions répertoriées ci-dessus).</span><span class="sxs-lookup"><span data-stu-id="23681-168">Call functions in Kernel32.dll (except the functions that are listed above).</span></span>
-   <span data-ttu-id="23681-169">Affectez la valeur NULL aux pointeurs globaux, en déplaçant l’initialisation des membres dynamiques.</span><span class="sxs-lookup"><span data-stu-id="23681-169">Set global pointers to NULL, putting off the initialization of dynamic members.</span></span> <span data-ttu-id="23681-170">Dans Microsoft Windows Vista™, vous pouvez utiliser les fonctions d’initialisation unique pour garantir qu’un bloc de code n’est exécuté qu’une seule fois dans un environnement multithread.</span><span class="sxs-lookup"><span data-stu-id="23681-170">In Microsoft Windows Vista™, you can use the one-time initialization functions to ensure that a block of code is executed only once in a multithreaded environment.</span></span>

## <a name="deadlocks-caused-by-lock-order-inversion"></a><span data-ttu-id="23681-171">Interblocages dus à une inversion d’ordre de verrouillage</span><span class="sxs-lookup"><span data-stu-id="23681-171">Deadlocks Caused by Lock Order Inversion</span></span>

<span data-ttu-id="23681-172">Lorsque vous implémentez du code qui utilise plusieurs objets de synchronisation tels que des verrous, il est essentiel d’respecter l’ordre de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="23681-172">When you are implementing code that uses multiple synchronization objects such as locks, it is vital to respect lock order.</span></span> <span data-ttu-id="23681-173">Lorsqu’il est nécessaire d’acquérir plusieurs verrous à la fois, vous devez définir une priorité explicite appelée hiérarchie de verrouillage ou ordre de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="23681-173">When it is necessary to acquire more than one lock at a time, you must define an explicit precedence that is called a lock hierarchy or lock order.</span></span> <span data-ttu-id="23681-174">Par exemple, si le verrou A est acquis avant le verrou B quelque part dans le code, et que le verrou B est acquis avant le verrou C ailleurs dans le code, l’ordre de verrouillage est A, B, C et cet ordre doit être suivi dans l’ensemble du code.</span><span class="sxs-lookup"><span data-stu-id="23681-174">For example, if lock A is acquired before lock B somewhere in the code, and lock B is acquired before lock C elsewhere in the code, then the lock order is A, B, C and this order should be followed throughout the code.</span></span> <span data-ttu-id="23681-175">L’inversion d’ordre de verrouillage se produit lorsque l’ordre de verrouillage n’est pas suivi, par exemple, si le verrou B est acquis avant le verrouillage A. l’inversion d’ordre de verrou peut provoquer des blocages difficiles à déboguer.</span><span class="sxs-lookup"><span data-stu-id="23681-175">Lock order inversion occurs when the locking order is not followed—for example, if lock B is acquired before lock A. Lock order inversion can cause deadlocks that are difficult to debug.</span></span> <span data-ttu-id="23681-176">Pour éviter de tels problèmes, tous les threads doivent acquérir des verrous dans le même ordre.</span><span class="sxs-lookup"><span data-stu-id="23681-176">To avoid such problems, all threads must acquire locks in the same order.</span></span>

<span data-ttu-id="23681-177">Il est important de noter que le chargeur appelle [**DllMain**](dllmain.md) avec le verrou du chargeur déjà acquis, de sorte que le verrouillage du chargeur doit avoir la priorité la plus élevée dans la hiérarchie de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="23681-177">It is important to note that the loader calls [**DllMain**](dllmain.md) with the loader lock already acquired, so the loader lock should have the highest precedence in the locking hierarchy.</span></span> <span data-ttu-id="23681-178">Notez également que le code doit acquérir les verrous requis pour une synchronisation correcte ; Il n’est pas nécessaire d’acquérir chaque verrou unique défini dans la hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="23681-178">Also note that code only has to acquire the locks it requires for proper synchronization; it does not have to acquire every single lock that is defined in the hierarchy.</span></span> <span data-ttu-id="23681-179">Par exemple, si une section de code requiert uniquement les verrous A et C pour une synchronisation correcte, le code doit acquérir le verrou A avant d’acquérir le verrou C ; Il n’est pas nécessaire que le code acquière également le verrou B. En outre, le code DLL ne peut pas acquérir explicitement le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="23681-179">For example, if a section of code requires only locks A and C for proper synchronization, then the code should acquire lock A before it acquires lock C; it is not necessary for the code to also acquire lock B. Furthermore, DLL code cannot explicitly acquire the loader lock.</span></span> <span data-ttu-id="23681-180">Si le code doit appeler une API telle que [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) qui peut acquérir indirectement le verrou du chargeur et que le code doit également acquérir un verrou privé, le code doit appeler **GetModuleFileName** avant d’acquérir le verrou P, garantissant ainsi que l’ordre de chargement est respecté.</span><span class="sxs-lookup"><span data-stu-id="23681-180">If the code must call an API such as [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) that can indirectly acquire the loader lock and the code must also acquire a private lock, then the code should call **GetModuleFileName** before it acquires lock P, thus ensuring that load order is respected.</span></span>

<span data-ttu-id="23681-181">La figure 2 est un exemple qui illustre l’inversion de l’ordre de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="23681-181">Figure 2 is an example that illustrates lock order inversion.</span></span> <span data-ttu-id="23681-182">Prenons l’exemple d’une DLL dont le thread principal contient [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="23681-182">Consider a DLL whose main thread contains [**DllMain**](dllmain.md).</span></span> <span data-ttu-id="23681-183">Le chargeur de bibliothèque acquiert le verrou de chargeur L, puis appelle **DllMain**.</span><span class="sxs-lookup"><span data-stu-id="23681-183">The library loader acquires the loader lock L and then calls into **DllMain**.</span></span> <span data-ttu-id="23681-184">Le thread principal crée les objets de synchronisation A, B et G pour sérialiser l’accès à ses structures de données, puis tente d’acquérir le verrou G. Un thread de travail qui a déjà acquis le verrou G appelle ensuite une fonction telle que GetModuleHandle qui tente d’acquérir le verrou de chargeur L. Ainsi, le thread de travail est bloqué sur L et le thread principal est bloqué sur G, provoquant ainsi un blocage.</span><span class="sxs-lookup"><span data-stu-id="23681-184">The main thread creates synchronization objects A, B, and G to serialize access to its data structures and then tries to acquire lock G. A worker thread that has already successfully acquired lock G then calls a function such as GetModuleHandle that attempts to acquire the loader lock L. Thus, the worker thread is blocked on L and the main thread is blocked on G, resulting in a deadlock.</span></span>

![interblocage provoqué par une inversion d’ordre de verrouillage](images/fig2.png)

<span data-ttu-id="23681-186">Pour empêcher les blocages causés par l’inversion d’ordre de verrouillage, tous les threads doivent tenter d’acquérir des objets de synchronisation dans l’ordre de chargement défini à tout moment.</span><span class="sxs-lookup"><span data-stu-id="23681-186">To prevent deadlocks that are caused by lock order inversion, all threads should attempt to acquire synchronization objects in the defined load order at all times.</span></span>

## <a name="best-practices-for-synchronization"></a><span data-ttu-id="23681-187">Meilleures pratiques pour la synchronisation</span><span class="sxs-lookup"><span data-stu-id="23681-187">Best Practices for Synchronization</span></span>

<span data-ttu-id="23681-188">Prenons l’exemple d’une DLL qui crée des threads de travail dans le cadre de son initialisation.</span><span class="sxs-lookup"><span data-stu-id="23681-188">Consider a DLL that creates worker threads as part of its initialization.</span></span> <span data-ttu-id="23681-189">Lors du nettoyage des DLL, il est nécessaire de synchroniser avec tous les threads de travail pour vérifier que les structures de données sont dans un état cohérent, puis mettre fin aux threads de travail.</span><span class="sxs-lookup"><span data-stu-id="23681-189">Upon DLL cleanup, it is necessary to synchronize with all the worker threads to ensure that the data structures are in a consistent state and then terminate the worker threads.</span></span> <span data-ttu-id="23681-190">Aujourd’hui, il n’existe aucun moyen simple de résoudre complètement le problème de synchronisation et d’arrêt corrects des dll dans un environnement multithread.</span><span class="sxs-lookup"><span data-stu-id="23681-190">Today, there is no straightforward way to completely solve the problem of cleanly synchronizing and shutting down DLLs in a multithreaded environment.</span></span> <span data-ttu-id="23681-191">Cette section décrit les meilleures pratiques actuelles pour la synchronisation des threads lors de l’arrêt de la DLL.</span><span class="sxs-lookup"><span data-stu-id="23681-191">This section describes the current best practices for thread synchronizing during DLL shutdown.</span></span>

<span data-ttu-id="23681-192">Synchronisation des threads dans [**DllMain**](dllmain.md) pendant la sortie du processus</span><span class="sxs-lookup"><span data-stu-id="23681-192">Thread Synchronization in [**DllMain**](dllmain.md) during Process Exit</span></span>

-   <span data-ttu-id="23681-193">Au moment où [**DllMain**](dllmain.md) est appelé à la sortie du processus, tous les threads du processus ont été nettoyés de force et il y a un risque que l’espace d’adressage soit incohérent.</span><span class="sxs-lookup"><span data-stu-id="23681-193">By the time [**DllMain**](dllmain.md) is called at process exit, all the process’s threads have been forcibly cleaned up and there is a chance that the address space is inconsistent.</span></span> <span data-ttu-id="23681-194">La synchronisation n’est pas requise dans ce cas.</span><span class="sxs-lookup"><span data-stu-id="23681-194">Synchronization is not required in this case.</span></span> <span data-ttu-id="23681-195">En d’autres termes, le \_ Gestionnaire de détachement de processus de dll idéal \_ est vide.</span><span class="sxs-lookup"><span data-stu-id="23681-195">In other words, the ideal DLL\_PROCESS\_DETACH handler is empty.</span></span>
-   <span data-ttu-id="23681-196">Windows Vista garantit que les structures de données principales (variables d’environnement, répertoire actif, tas de processus, etc.) sont dans un état cohérent.</span><span class="sxs-lookup"><span data-stu-id="23681-196">Windows Vista ensures that core data structures (environment variables, current directory, process heap, and so on) are in a consistent state.</span></span> <span data-ttu-id="23681-197">Toutefois, d’autres structures de données peuvent être endommagées, de sorte que le nettoyage de la mémoire n’est pas sécurisé.</span><span class="sxs-lookup"><span data-stu-id="23681-197">However, other data structures can be corrupted, so cleaning memory is not safe.</span></span>
-   <span data-ttu-id="23681-198">L’état persistant qui doit être enregistré doit être vidé dans un stockage permanent.</span><span class="sxs-lookup"><span data-stu-id="23681-198">Persistent state that needs to be saved must be flushed to permanent storage.</span></span>

<span data-ttu-id="23681-199">Synchronisation de threads dans **DllMain** pour le \_ \_ détachement de thread dll pendant le DÉchargement de dll</span><span class="sxs-lookup"><span data-stu-id="23681-199">Thread Synchronization in **DllMain** for DLL\_THREAD\_DETACH during DLL Unload</span></span>

-   <span data-ttu-id="23681-200">Lorsque la DLL est déchargée, l’espace d’adressage n’est pas rejeté.</span><span class="sxs-lookup"><span data-stu-id="23681-200">When the DLL is unloaded, the address space is not thrown away.</span></span> <span data-ttu-id="23681-201">Par conséquent, la DLL est supposée effectuer un arrêt propre.</span><span class="sxs-lookup"><span data-stu-id="23681-201">Therefore, the DLL is expected to perform a clean shutdown.</span></span> <span data-ttu-id="23681-202">Cela comprend la synchronisation des threads, les handles ouverts, l’état persistant et les ressources allouées.</span><span class="sxs-lookup"><span data-stu-id="23681-202">This includes thread synchronization, open handles, persistent state, and allocated resources.</span></span>
-   <span data-ttu-id="23681-203">La synchronisation des threads est délicate car l’attente de la fermeture des threads dans [**DllMain**](dllmain.md) peut provoquer un blocage.</span><span class="sxs-lookup"><span data-stu-id="23681-203">Thread synchronization is tricky because waiting on threads to exit in [**DllMain**](dllmain.md) can cause a deadlock.</span></span> <span data-ttu-id="23681-204">Par exemple, la DLL A contient le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="23681-204">For example, DLL A holds the loader lock.</span></span> <span data-ttu-id="23681-205">Il signale le thread T pour quitter et attend que le thread se termine.</span><span class="sxs-lookup"><span data-stu-id="23681-205">It signals thread T to exit and waits for the thread to exit.</span></span> <span data-ttu-id="23681-206">Le thread T se termine et le chargeur tente d’acquérir le verrou du chargeur pour appeler le **DllMain** de la dll A avec le \_ \_ détachement de thread dll.</span><span class="sxs-lookup"><span data-stu-id="23681-206">Thread T exits and the loader tries to acquire the loader lock to call into DLL A’s **DllMain** with DLL\_THREAD\_DETACH.</span></span> <span data-ttu-id="23681-207">Cela provoque un interblocage.</span><span class="sxs-lookup"><span data-stu-id="23681-207">This causes a deadlock.</span></span> <span data-ttu-id="23681-208">Pour réduire le risque d’un blocage :</span><span class="sxs-lookup"><span data-stu-id="23681-208">To minimize the risk of a deadlock:</span></span>
    -   <span data-ttu-id="23681-209">DLL A obtient un \_ message de \_ détachement de thread dll dans son [**DllMain**](dllmain.md) et définit un événement pour le thread T, en lui signalant de quitter.</span><span class="sxs-lookup"><span data-stu-id="23681-209">DLL A gets a DLL\_THREAD\_DETACH message in its [**DllMain**](dllmain.md) and sets an event for thread T, signaling it to exit.</span></span>
    -   <span data-ttu-id="23681-210">Le thread T termine sa tâche actuelle, se met à un état cohérent, signale la DLL A et attend une attente infinie.</span><span class="sxs-lookup"><span data-stu-id="23681-210">Thread T finishes its current task, brings itself to a consistent state, signals DLL A, and waits infinitely.</span></span> <span data-ttu-id="23681-211">Notez que les routines de vérification de cohérence doivent respecter les mêmes restrictions que [**DllMain**](dllmain.md) pour éviter les interblocages.</span><span class="sxs-lookup"><span data-stu-id="23681-211">Note that the consistency-checking routines should follow the same restrictions as [**DllMain**](dllmain.md) to avoid deadlocking.</span></span>
    -   <span data-ttu-id="23681-212">La DLL A termine T, sachant qu’elle est dans un état cohérent.</span><span class="sxs-lookup"><span data-stu-id="23681-212">DLL A terminates T, knowing that it is in a consistent state.</span></span>

<span data-ttu-id="23681-213">Si une DLL est déchargée une fois que tous ses threads ont été créés, mais avant qu’ils ne commencent à s’exécuter, les threads peuvent se bloquer.</span><span class="sxs-lookup"><span data-stu-id="23681-213">If a DLL is unloaded after all its threads have been created, but before they begin executing, the threads may crash.</span></span> <span data-ttu-id="23681-214">Si la DLL crée des threads dans son **DllMain** dans le cadre de son initialisation, certains threads n’ont peut-être pas terminé l’initialisation et le \_ message d’attachement de thread dll \_ est toujours en attente de remise à la dll.</span><span class="sxs-lookup"><span data-stu-id="23681-214">If the DLL created threads in its **DllMain** as part of its initialization, some threads may not have finished initialization and their DLL\_THREAD\_ATTACH message is still waiting to be delivered to the DLL.</span></span> <span data-ttu-id="23681-215">Dans ce cas, si la DLL est déchargée, elle commence à mettre fin aux threads.</span><span class="sxs-lookup"><span data-stu-id="23681-215">In this situation, if the DLL is unloaded, it will begin terminating threads.</span></span> <span data-ttu-id="23681-216">Toutefois, certains threads peuvent être bloqués derrière le verrou du chargeur.</span><span class="sxs-lookup"><span data-stu-id="23681-216">However, some threads may be blocked behind the loader lock.</span></span> <span data-ttu-id="23681-217">Leurs \_ \_ messages d’attachement de thread dll sont traités après que la dll a été démappée, provoquant ainsi le blocage du processus.</span><span class="sxs-lookup"><span data-stu-id="23681-217">Their DLL\_THREAD\_ATTACH messages are processed after the DLL has been unmapped, causing the process to crash.</span></span>

## <a name="recommendations"></a><span data-ttu-id="23681-218">Recommandations</span><span class="sxs-lookup"><span data-stu-id="23681-218">Recommendations</span></span>

<span data-ttu-id="23681-219">Les recommandations suivantes sont recommandées :</span><span class="sxs-lookup"><span data-stu-id="23681-219">The following are recommended guidelines:</span></span>

-   <span data-ttu-id="23681-220">Utilisez Application Verifier pour intercepter les erreurs les plus courantes dans [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="23681-220">Use Application Verifier to catch the most common errors in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="23681-221">Si vous utilisez un verrou privé à l’intérieur de [**DllMain**](dllmain.md), définissez une hiérarchie de verrouillage et utilisez-la de manière cohérente.</span><span class="sxs-lookup"><span data-stu-id="23681-221">If using a private lock inside [**DllMain**](dllmain.md), define a locking hierarchy and use it consistently.</span></span> <span data-ttu-id="23681-222">Le verrouillage du chargeur doit être en bas de cette hiérarchie.</span><span class="sxs-lookup"><span data-stu-id="23681-222">The loader lock must be at the bottom of this hierarchy.</span></span>
-   <span data-ttu-id="23681-223">Vérifiez qu’aucun appel ne dépend d’une autre DLL qui n’a peut-être pas encore été entièrement chargée.</span><span class="sxs-lookup"><span data-stu-id="23681-223">Verify that no calls depend on another DLL that may not have been fully loaded yet.</span></span>
-   <span data-ttu-id="23681-224">Effectuez des initialisations simples statiques au moment de la compilation, plutôt que dans [**DllMain**](dllmain.md).</span><span class="sxs-lookup"><span data-stu-id="23681-224">Perform simple initializations statically at compile time, rather than in [**DllMain**](dllmain.md).</span></span>
-   <span data-ttu-id="23681-225">Différer tous les appels dans [**DllMain**](dllmain.md) qui peuvent attendre jusqu’à une date ultérieure.</span><span class="sxs-lookup"><span data-stu-id="23681-225">Defer any calls in [**DllMain**](dllmain.md) that can wait until later.</span></span>
-   <span data-ttu-id="23681-226">Différer les tâches d’initialisation qui peuvent attendre jusqu’à une date ultérieure.</span><span class="sxs-lookup"><span data-stu-id="23681-226">Defer initialization tasks that can wait until later.</span></span> <span data-ttu-id="23681-227">Certaines conditions d’erreur doivent être détectées tôt pour que l’application puisse gérer les erreurs correctement.</span><span class="sxs-lookup"><span data-stu-id="23681-227">Certain error conditions must be detected early so that the application can handle errors gracefully.</span></span> <span data-ttu-id="23681-228">Toutefois, il existe des compromis entre cette détection précoce et la perte de robustesse qui peut en résulter.</span><span class="sxs-lookup"><span data-stu-id="23681-228">However, there are tradeoffs between this early detection and the loss of robustness that can result from it.</span></span> <span data-ttu-id="23681-229">Le report de l’initialisation est souvent préférable.</span><span class="sxs-lookup"><span data-stu-id="23681-229">Deferring initialization is often best.</span></span>

 

 
