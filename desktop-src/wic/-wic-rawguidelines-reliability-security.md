---
description: Fiabilité et sécurité
ms.assetid: 1cbfabce-3d56-4e23-b9a7-02369c67e392
title: Fiabilité et sécurité
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a0f0e4a244de2c1463cdadb76162c18b041812b
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/08/2021
ms.locfileid: "106530890"
---
# <a name="reliability-and-security"></a><span data-ttu-id="70462-103">Fiabilité et sécurité</span><span class="sxs-lookup"><span data-stu-id="70462-103">Reliability and Security</span></span>

<span data-ttu-id="70462-104">Étant donné que les codecs du composant Windows Imaging Component (WIC) sont appelés à partir de l’interpréteur de commandes Windows et de la Galerie de photos, les auteurs de codec doivent faire tout leur possible pour garantir un haut niveau de fiabilité et de sécurité dans leurs codecs WIC.</span><span class="sxs-lookup"><span data-stu-id="70462-104">Because Windows Imaging Component (WIC) codecs will be invoked from within the Windows shell and Photo Gallery, codec authors should make every effort to ensure a high level of reliability and security in their WIC codecs.</span></span>

<span data-ttu-id="70462-105">L’écriture de code fiable dépend en grande partie des bonnes pratiques de codage, des revues de code efficaces et des tests d’unités rigoureux et des tests de scénario.</span><span class="sxs-lookup"><span data-stu-id="70462-105">Writing reliable code largely depends on good coding practices, effective code reviews, and thorough unit testing and scenario testing.</span></span> <span data-ttu-id="70462-106">En outre, les instructions suivantes permettent de s’assurer que le codec est conforme aux stratégies Windows Vista en matière de fiabilité.</span><span class="sxs-lookup"><span data-stu-id="70462-106">In addition, the following guidelines will help ensure that the codec complies with Windows Vista policies regarding reliability.</span></span>

-   <span data-ttu-id="70462-107">Activez l’annulation d’e/s.</span><span class="sxs-lookup"><span data-stu-id="70462-107">Enable I/O cancellation.</span></span>

    <span data-ttu-id="70462-108">Les auteurs de codec doivent permettre à l’utilisateur final d’annuler toute opération de longue durée.</span><span class="sxs-lookup"><span data-stu-id="70462-108">Codec authors should provide a way for the end user to cancel any long-running operation.</span></span> <span data-ttu-id="70462-109">Les codecs WIC le prennent en charge en implémentant IWICBitmapProgressNotification.</span><span class="sxs-lookup"><span data-stu-id="70462-109">WIC codecs support this by implementing IWICBitmapProgressNotification.</span></span> <span data-ttu-id="70462-110">Cela permet à une application appelante de spécifier une fonction de rappel que le codec doit appeler à des intervalles spécifiés pour notifier l’appelant de la progression de l’opération en cours.</span><span class="sxs-lookup"><span data-stu-id="70462-110">This allows a calling application to specify a callback function for the codec to call at specified intervals to notify the caller of the progress of the current operation.</span></span> <span data-ttu-id="70462-111">Lorsqu’une application retourne l’erreur \_ annulée à partir de la fonction de rappel, le codec doit annuler l’opération en cours et répartir le HRESULT vers l’appelant.</span><span class="sxs-lookup"><span data-stu-id="70462-111">When an application returns ERROR\_CANCELLED from the callback function, the codec must cancel whatever operation is in progress and propagate the HRESULT back to the caller.</span></span> <span data-ttu-id="70462-112">Ceci est particulièrement important pour les codecs BRUTs, car il peut s’avérer nécessaire de prendre plusieurs secondes pour décoder une image brute de taille réelle et les applications ont besoin d’un moyen d’abandonner ce traitement.</span><span class="sxs-lookup"><span data-stu-id="70462-112">This is especially important for RAW codecs, because it might take several seconds to decode a full-size RAW image and applications need a way to abort this processing.</span></span>

-   <span data-ttu-id="70462-113">Assurez-vous que le code s’exécute dans la plus petite portée requise pour exécuter sa fonction.</span><span class="sxs-lookup"><span data-stu-id="70462-113">Make sure that code runs in the smallest scope that is required to perform its function.</span></span>

    <span data-ttu-id="70462-114">Les auteurs de codec doivent s’assurer que le codec ne consomme pas plus de ressources que nécessaire, ou avoir une étendue supérieure à celle requise.</span><span class="sxs-lookup"><span data-stu-id="70462-114">Codec authors must ensure that the codec does not consume more resources than necessary or have a greater scope than is required.</span></span> <span data-ttu-id="70462-115">La portée d’un codec dans WIC est un fichier image unique. le codec est créé lors du chargement d’un fichier image et le codec est libéré lorsque l’image est fermée.</span><span class="sxs-lookup"><span data-stu-id="70462-115">The scope of a codec in WIC is a single image file; the codec is created when an image file is loaded, and the codec is released when the image is closed.</span></span> <span data-ttu-id="70462-116">Étant donné que WIC est une plateforme extensible basée sur des composants, les codecs WIC comportent des chargements et des déchargements qui se chevauchent, et démarrent et s’arrêtent, le tout dans le même processus.</span><span class="sxs-lookup"><span data-stu-id="70462-116">Because WIC is an extensible component-based platform, WIC codecs will have overlapping loads and unloads, and starts and stops, all within the same process.</span></span> <span data-ttu-id="70462-117">Si l’infrastructure sous-jacente d’un codec nécessite des opérations de démarrage et d’arrêt dans une étendue supérieure à une seule image, la fiabilité sera affectée.</span><span class="sxs-lookup"><span data-stu-id="70462-117">If the underlying infrastructure of a codec requires start and stop operations at a scope larger than a single image, reliability will be impacted.</span></span> <span data-ttu-id="70462-118">Les codecs compatibles WIC seront utilisés par l’Explorateur Windows, ainsi que par d’autres applications.</span><span class="sxs-lookup"><span data-stu-id="70462-118">WIC-enabled codecs will be used by the Windows Explorer, as well as other applications.</span></span> <span data-ttu-id="70462-119">Par conséquent, si un codec reste chargé pendant la durée de vie du processus, la mémoire n’est pas libérée efficacement et une défaillance du codec peut bloquer l’Explorateur Windows et éventuellement nécessiter le redémarrage de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="70462-119">Therefore, if a codec remains loaded for the lifetime of the process, memory will not be released efficiently and a failure of the codec could hang Windows Explorer and potentially require the machine to be rebooted.</span></span> <span data-ttu-id="70462-120">(Tenez compte du fait que le codec est appelé chaque fois qu’une image est miniature pour la première fois dans l’Explorateur Windows : il est essentiel qu’il s’agit d’une opération légère.)</span><span class="sxs-lookup"><span data-stu-id="70462-120">(Consider that the codec will be invoked every time an image is thumbnailed for the first time in Windows Explorer: it is essential that this be a lightweight operation.)</span></span>

-   <span data-ttu-id="70462-121">Utilisez les outils d’analyse du code statiques et dynamiques.</span><span class="sxs-lookup"><span data-stu-id="70462-121">Use static and dynamic code analysis tools.</span></span>

    -   <span data-ttu-id="70462-122">Outils d’analyse statique :</span><span class="sxs-lookup"><span data-stu-id="70462-122">Static analysis tools:</span></span>

        <span data-ttu-id="70462-123">PREfix : pour détecter les erreurs au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="70462-123">PREfix - for detecting errors at compile time.</span></span>

        <span data-ttu-id="70462-124">PREfast : pour l’analyse du code pour les bogues.</span><span class="sxs-lookup"><span data-stu-id="70462-124">PREfast - for analyzing code for bugs.</span></span>

    -   <span data-ttu-id="70462-125">Outils d’analyse dynamique :</span><span class="sxs-lookup"><span data-stu-id="70462-125">Dynamic analysis tools:</span></span>

        <span data-ttu-id="70462-126">AppVerifier-qui permet de rendre les applications plus résilientes en simulant des problèmes logiciels courants.</span><span class="sxs-lookup"><span data-stu-id="70462-126">AppVerifier - which helps make applications more resilient by simulating common real-world software issues.</span></span>

-   <span data-ttu-id="70462-127">Vérifiez toutes les entrées dans les révisions du code.</span><span class="sxs-lookup"><span data-stu-id="70462-127">Verify all inputs in code reviews.</span></span>

    <span data-ttu-id="70462-128">Tous les paramètres pour les méthodes exportées et toutes les données de fichier doivent être vérifiés avec soin pour la validité et rejetés de manière fiable en cas de défaillance, afin de se protéger contre les dépassements de mémoire tampon et les sous-exécutions, les dépassements arithmétiques et les dépassements de capacité et les types inattendus</span><span class="sxs-lookup"><span data-stu-id="70462-128">All parameters for exported methods and all file data must be carefully verified for validity and robustly rejected if faulty, in order to protect against buffer overruns and underruns, arithmetic overflows and underflows, and unexpected types.</span></span>

-   <span data-ttu-id="70462-129">Utilisez des techniques de fuzzing de fichiers pour détecter les blocages potentiels et les blocages.</span><span class="sxs-lookup"><span data-stu-id="70462-129">Use file fuzzing techniques to discover potential crashes and hangs.</span></span>

    <span data-ttu-id="70462-130">Le fuzzing de fichier est le processus de test du codec avec des entrées aléatoires.</span><span class="sxs-lookup"><span data-stu-id="70462-130">File fuzzing is the process of testing the codec with randomly permuted inputs.</span></span>

    <span data-ttu-id="70462-131">Il existe deux formes de fuzzing de fichiers : le fuzzing (aléatoire) et le fuzzing dirigé.</span><span class="sxs-lookup"><span data-stu-id="70462-131">There are two forms of file fuzzing: undirected (random) fuzzing and directed fuzzing.</span></span> <span data-ttu-id="70462-132">Le fuzzing non dirigé effectue un basculement binaire aléatoire pour voir si une entrée aléatoire peut bloquer le codec.</span><span class="sxs-lookup"><span data-stu-id="70462-132">Undirected fuzzing does some random bit flipping to see if random input can crash the codec.</span></span> <span data-ttu-id="70462-133">Le fuzzing dirigé permute l’entrée en fonction d’une connaissance du format de fichier.</span><span class="sxs-lookup"><span data-stu-id="70462-133">Directed fuzzing permutes the input based on some knowledge of the file format.</span></span> <span data-ttu-id="70462-134">Par exemple, s’il existe un contrôle de redondance cyclique (CRC) à l’offset d’octet 32, la modification des octets sans mettre à jour le CRC risque de ne pas exercer la plupart des chemins.</span><span class="sxs-lookup"><span data-stu-id="70462-134">For example, if there is a cycle redundancy check (CRC) at byte offset 32, then changing any bytes without updating the CRC will likely not exercise most of the codepaths.</span></span> <span data-ttu-id="70462-135">Dans cet exemple, un fuzzer dirigé doit corriger le CRC lorsque des octets sont modifiés.</span><span class="sxs-lookup"><span data-stu-id="70462-135">In this example, a directed fuzzer should fix the CRC when any bytes are modified.</span></span>

    <span data-ttu-id="70462-136">Le jeu d’images d’entrée pour le fuzzing de fichier doit être créé afin que chaque combinaison de paramètres prise en charge par le décodeur soit testée.</span><span class="sxs-lookup"><span data-stu-id="70462-136">The input set of images for file fuzzing should be created so that each parameter combination that the decoder supports is tested.</span></span> <span data-ttu-id="70462-137">Par exemple, si le décodeur prend en charge les fichiers Little-et Big-endian et trois paramètres de compression, le jeu d’images d’entrée doit être composé de fichiers Little endian de chaque paramètre de compression et de fichiers de poids fort (Big-endian) pour chaque paramètre de compression.</span><span class="sxs-lookup"><span data-stu-id="70462-137">For example, if the decoder supports little- and big-endian files and three compression settings, then the input set of image should consist of little-endian files of each compression setting and big-endian files for each compression setting.</span></span> <span data-ttu-id="70462-138">Cette approche produira un ensemble d’images d’entrée très robustes à tester.</span><span class="sxs-lookup"><span data-stu-id="70462-138">This approach will yield a large, but very robust set of input images to be tested.</span></span> <span data-ttu-id="70462-139">Même si aucune caméra ne produit chacune des combinaisons, mais que le décodeur prend en charge ces combinaisons théoriques, les auteurs de codec doivent fuzzer ces entrées.</span><span class="sxs-lookup"><span data-stu-id="70462-139">Even if no camera produces each of the combinations but the decoder supports these theoretical combinations, codec authors should fuzz these inputs.</span></span>

    <span data-ttu-id="70462-140">La sécurité peut être beaucoup améliorée en effectuant régulièrement un test Fuzz des fichiers image pendant le développement de codec.</span><span class="sxs-lookup"><span data-stu-id="70462-140">Security can be greatly enhanced by regularly performing fuzz testing of image files during codec development.</span></span> <span data-ttu-id="70462-141">Les codecs doivent toujours pouvoir détecter l’endommagement du fichier image et échouer correctement dans le cas d’une demande incorrecte ou de données incorrectes.</span><span class="sxs-lookup"><span data-stu-id="70462-141">Codecs should always be able to detect image file corruption and fail gracefully in the case of a malformed request or of malformed data.</span></span>

-   <span data-ttu-id="70462-142">Insistez sur le code.</span><span class="sxs-lookup"><span data-stu-id="70462-142">Stress the code.</span></span>

    <span data-ttu-id="70462-143">Stress-testez le codec en l’exécutant en continu dans plusieurs processus simultanés, en effectuant toutes les opérations prises en charge dans toutes les séquences possibles, sur des images de tailles différentes (y compris des images très volumineuses) à partir de chaque caméra prise en charge.</span><span class="sxs-lookup"><span data-stu-id="70462-143">Stress-test the codec by running it continually in multiple simultaneous processes, performing all supported operations in all possible sequences, on images of varying sizes (including very large images) from every supported camera.</span></span>

-   <span data-ttu-id="70462-144">Sécurité des threads.</span><span class="sxs-lookup"><span data-stu-id="70462-144">Thread safety.</span></span>

    <span data-ttu-id="70462-145">À compter de Windows 7, WIC exige que les CODECs BRUTs soient de type cloisonnement COM « both ».</span><span class="sxs-lookup"><span data-stu-id="70462-145">As of Windows 7, WIC requires that RAW CODECs be of COM apartment type "Both".</span></span> <span data-ttu-id="70462-146">Cela signifie que vous devez effectuer le verrouillage approprié pour gérer les appelants inter-cloisonnement et les appelants dans les scénarios multithread.</span><span class="sxs-lookup"><span data-stu-id="70462-146">This means that you must do the appropriate locking to handle cross-apartment callers and callers in multi-threaded scenarios.</span></span> <span data-ttu-id="70462-147">Les objets d’un cloisonnement multithread (MTA) peuvent être appelés simultanément par un nombre quelconque de threads dans le MTA, ce qui permet de meilleures performances sur les systèmes à plusieurs cœurs et certains scénarios de serveur.</span><span class="sxs-lookup"><span data-stu-id="70462-147">Objects within an Multi Threaded Apartment (MTA) may be called concurrently by any number of threads within the MTA, allowing for better performance on multi-core systems and certain server scenarios.</span></span> <span data-ttu-id="70462-148">En outre, les CODECs WIC qui résident dans un MTA peuvent appeler d’autres objets qui résident dans le MTA sans le coût de marshaling associé à l’appel entre les threads qui résident dans différents Apartments STA.</span><span class="sxs-lookup"><span data-stu-id="70462-148">In addition, WIC CODECs that live within an MTA can call other objects that live within the MTA without the marshalling cost associated of calling between threads that live in different STA apartments.</span></span> <span data-ttu-id="70462-149">Dans Windows 7, tous les CODECs WIC intégrés ont été mis à jour pour prendre en charge les MTA, y compris JPEG, TIFF, PNG, GIF, ICO et BMP.</span><span class="sxs-lookup"><span data-stu-id="70462-149">In Windows 7, all in-box WIC CODECs have been updated to support MTAs, including JPEG, TIFF, PNG, GIF, ICO, and BMP.</span></span> <span data-ttu-id="70462-150">les CODECs tiers qui ne prennent pas en charge les MTA entraînent des coûts de performances significatifs dans les applications multithread en raison du marshaling.</span><span class="sxs-lookup"><span data-stu-id="70462-150">3rd-party CODECs that do not to support MTAs will cause significant performance costs in multithreaded applications due to marshaling.</span></span> <span data-ttu-id="70462-151">L’activation de la prise en charge de MTA nécessite une synchronisation appropriée à implémenter dans le CODEC tiers.</span><span class="sxs-lookup"><span data-stu-id="70462-151">Enabling MTA support requires proper synchronization to be implemented in the 3rd-party CODEC.</span></span> <span data-ttu-id="70462-152">L’implémentation exacte de ces techniques de synchronisation dépasse le cadre de ce document.</span><span class="sxs-lookup"><span data-stu-id="70462-152">Exact implementation of these synchronization techniques is beyond the scope of this paper.</span></span> <span data-ttu-id="70462-153">Vous trouverez ci-dessous une référence générale pour la synchronisation des objets COM.</span><span class="sxs-lookup"><span data-stu-id="70462-153">A general reference for synchronizing COM objects is provided below.</span></span>

    https://msdn.microsoft.com/library/ms809971.aspx

## <a name="related-topics"></a><span data-ttu-id="70462-154">Rubriques connexes</span><span class="sxs-lookup"><span data-stu-id="70462-154">Related topics</span></span>

<dl> <dt>

<span data-ttu-id="70462-155">**Méthodologique**</span><span class="sxs-lookup"><span data-stu-id="70462-155">**Conceptual**</span></span>
</dt> <dt>

[<span data-ttu-id="70462-156">Vue d’ensemble du composant Windows Imaging</span><span class="sxs-lookup"><span data-stu-id="70462-156">Windows Imaging Component Overview</span></span>](-wic-about-windows-imaging-codec.md)
</dt> <dt>

[<span data-ttu-id="70462-157">Recommandations de WIC pour les formats d’image RAW Camera</span><span class="sxs-lookup"><span data-stu-id="70462-157">WIC Guidelines for Camera RAW Image Formats</span></span>](-wic-rawguidelines.md)
</dt> <dt>

[<span data-ttu-id="70462-158">Comment écrire un CODEC WIC-Enabled</span><span class="sxs-lookup"><span data-stu-id="70462-158">How to Write a WIC-Enabled CODEC</span></span>](-wic-howtowriteacodec.md)
</dt> </dl>

 

 



