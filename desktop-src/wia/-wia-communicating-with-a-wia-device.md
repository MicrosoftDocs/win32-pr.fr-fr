---
description: Quand un thread communique activement avec un périphérique WIA (Windows Image Acquisition) (par exemple, le transfert de données ou l’écriture de propriétés d’appareil) WIA &\# 0034 ; verrouille&\# 0034 ; l’appareil.
ms.assetid: 59533937-284a-4732-a73b-d2e0b5a9a370
title: Communication avec un appareil WIA dans plusieurs threads ou applications
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1a7a4b518093c3a0fc09534d67e22e5349d44d09
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/07/2021
ms.locfileid: "104202893"
---
# <a name="communicating-with-a-wia-device-in-multiple-threads-or-applications"></a><span data-ttu-id="e40b8-103">Communication avec un appareil WIA dans plusieurs threads ou applications</span><span class="sxs-lookup"><span data-stu-id="e40b8-103">Communicating with a WIA Device in Multiple Threads or Applications</span></span>

<span data-ttu-id="e40b8-104">Quand un thread communique activement avec un périphérique WIA (Windows Image Acquisition) (par exemple, en transférant des données ou en écrivant des propriétés d’appareil), WIA « verrouille » l’appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-104">When a thread is actively communicating with a Windows Image Acquisition (WIA) device (for example, transferring data or writing device properties) WIA "locks" the device.</span></span> <span data-ttu-id="e40b8-105">Quand un appareil est verrouillé, aucun autre thread ou processus ne peut communiquer activement avec cet appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-105">When a device is locked, no other threads or processes can actively communicate with that device.</span></span>

<span data-ttu-id="e40b8-106">WIA n’interdit pas à plusieurs threads ou processus de maintenir des connexions à un seul appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-106">WIA does not prohibit multiple threads or processes from maintaining connections to a single device.</span></span> <span data-ttu-id="e40b8-107">Autrement dit, un appareil est verrouillé uniquement pendant la communication réelle, et au moins deux applications peuvent avoir un seul appareil sélectionné simultanément.</span><span class="sxs-lookup"><span data-stu-id="e40b8-107">That is, a device is locked only during the actual communication, and two or more applications can simultaneously have a single device selected.</span></span>

<span data-ttu-id="e40b8-108">WIA crée une arborescence d’éléments distincte chaque fois qu’un thread ou une application appelle [**IWiaDevMgr :: CreateDevice**](/windows/desktop/api/wia_xp/nf-wia_xp-iwiadevmgr-createdevice) ou [**IWiaDevMgr2 :: CreateDevice**](-wia-iwiadevmgr2-createdevice.md) pour créer une instance de cet appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-108">WIA creates a separate item tree each time any thread or application calls [**IWiaDevMgr::CreateDevice**](/windows/desktop/api/wia_xp/nf-wia_xp-iwiadevmgr-createdevice) or [**IWiaDevMgr2::CreateDevice**](-wia-iwiadevmgr2-createdevice.md) to create an instance of that device.</span></span> <span data-ttu-id="e40b8-109">WIA gère des informations d’État distinctes pour chaque arborescence d’éléments.</span><span class="sxs-lookup"><span data-stu-id="e40b8-109">WIA maintains separate state information for each item tree.</span></span> <span data-ttu-id="e40b8-110">Par exemple, si un thread crée deux instances d’un scanneur particulier, il peut définir différentes résolutions d’analyse pour les deux instances.</span><span class="sxs-lookup"><span data-stu-id="e40b8-110">For example, if a thread creates two instances of a particular scanner, it can set different scan resolutions for the two instances.</span></span> <span data-ttu-id="e40b8-111">Quand [**IWiaDataTransfer :: idtGetData**](/windows/desktop/api/wia_xp/nf-wia_xp-iwiadatatransfer-idtgetdata) est appelé sur une instance particulière, WIA charge les propriétés associées à cette instance sur l’appareil avant que l’analyse proprement dite ait lieu.</span><span class="sxs-lookup"><span data-stu-id="e40b8-111">When [**IWiaDataTransfer::idtGetData**](/windows/desktop/api/wia_xp/nf-wia_xp-iwiadatatransfer-idtgetdata) is called on a particular instance, WIA loads the properties associated with that instance to the device before the actual scan takes place.</span></span> <span data-ttu-id="e40b8-112">Cela n’affecte pas l’état de l’autre instance de l’appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-112">This does not affect the state of the other instance of the device.</span></span>

<span data-ttu-id="e40b8-113">Si un thread a actuellement un appareil verrouillé (il communique activement avec cet appareil) et qu’un autre thread tente d’appeler une méthode qui communique activement avec l’appareil, la méthode retourne une erreur d’erreur d’erreur de l’WIA \_ \_ .</span><span class="sxs-lookup"><span data-stu-id="e40b8-113">If a thread currently has a device locked (it is actively communicating with that device) and another thread attempts to call a method that actively communicates with the device, the method returns a WIA\_ERROR\_BUSY error.</span></span>

<span data-ttu-id="e40b8-114">En général, la lecture et l’écriture des propriétés de l’appareil prend beaucoup de temps, car ces opérations provoquent rarement un conflit.</span><span class="sxs-lookup"><span data-stu-id="e40b8-114">Typically, reading and writing device properties takes so little time that these operations rarely cause a conflict.</span></span> <span data-ttu-id="e40b8-115">Toutefois, le transfert de données prend généralement plus de temps, et par conséquent, il est plus probable de créer des conflits d’accès à l’appareil.</span><span class="sxs-lookup"><span data-stu-id="e40b8-115">Transferring data, however, usually takes longer, and therefore is more likely to create device access conflicts.</span></span> <span data-ttu-id="e40b8-116">Il s’agit d’une programmation qui évite de longues opérations de périphérique (transferts de données) simultanément dans des threads distincts au sein d’une application.</span><span class="sxs-lookup"><span data-stu-id="e40b8-116">It is sound programming to avoid lengthy device operations (data transfers) concurrently in separate threads within an application.</span></span>

<span data-ttu-id="e40b8-117">Une application ne doit jamais supposer qu’il s’agit de la seule application qui communique avec un appareil WIA au démarrage.</span><span class="sxs-lookup"><span data-stu-id="e40b8-117">An application should never assume that it is the only application that is communicating with a WIA device when it starts.</span></span>

 

 



